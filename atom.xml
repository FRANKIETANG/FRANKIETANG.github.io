<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>付林恒的博客</title>
  
  <subtitle>要做最咸的鱼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-12T17:08:07.948Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Frankie Tang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Express</title>
    <link href="http://yoursite.com/2017/12/13/Express/"/>
    <id>http://yoursite.com/2017/12/13/Express/</id>
    <published>2017-12-12T17:04:24.000Z</published>
    <updated>2017-12-12T17:08:07.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>一个文档很完善的框架</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件是一种封装，对请求处理流程某一小块逻辑的封装。</p><pre><code>// express 版服务器const express = require(&#39;express&#39;)const http = require(&#39;http&#39;)const app = express()app.use((req, res, next) =&gt; {    console.log(&#39;this is middleware no.1&#39;)  // 1    next()})app.use((req, res) =&gt; {    console.log(&#39;this is middleware no.2&#39;)  // 2    res.end(&#39;hello world&#39;)})const server = http.createServer(app)server.listen(&#39;9292&#39;)// 这样子会打印出 1 2 而不是 2 1，是按顺序执行的</code></pre><p>当服务器接收到了请求之后一直没有返回（也就是 <code>app.use</code> 之后怎么都不做），会有超时错误。</p><h3 id="中间件的生命周期"><a href="#中间件的生命周期" class="headerlink" title="中间件的生命周期"></a>中间件的生命周期</h3><p>看下面这两段代码</p><pre><code>app.use((req, res, next) =&gt; {    req.number = 1    next()})app.use((req, res) =&gt; {    console.log(`req.number: ${req.number}`)    res.end(&#39;end&#39;)})</code></pre><pre><code>app.use((req, res, next) =&gt; {    console.log(`req.number: ${req.number}`)    next()})app.use((req, res) =&gt; {    req.number = 1    res.end(&#39;end&#39;)})</code></pre><p>第一段打印的是<code>req.number: 1</code>，第二段打印的是<code>req.number: undefined</code></p><p>他们的赋值也是有循序性的</p><p>也可以说互不影响吧，每个中间件只用处理复杂逻辑的一小块，通过 <code>next()</code> 把控制权交给下一个中间件，中间件不需要知道前一个中间件做了什么或者后一个中间件做了什么，只要处理好自己的逻辑就可以了。</p><h3 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h3><p>可以做个鉴权啥的</p><pre><code>// auth.jsmodule.exports =  function auth(req, res, next) {    console.log(req.query)    if (req.query.username === &#39;frankie&#39;) {  // req.query.username 一定要等于 frankie，要不然就go away        next()    } else {        res.end(&#39;please go away&#39;)    }}// index.jsapp.use(require(&#39;./middlewares/auth&#39;))  // 这里的 auth 可以理解为 OAuth 2</code></pre><p>不通过就停止执行下面的逻辑</p><p><img src="https://i.loli.net/2017/12/10/5a2d4f70bb5a9.gif" alt=""></p><pre><code>app.use(require(&#39;./middlewares/auth&#39;))app.use((req, res, next) =&gt; {    next(&#39;something wrong&#39;)  // next 里面如果有传东西就会当做错误处理掉，直接跑到下面的错误处理中间件})// 错误处理中间件app.use((err, req, res, next) =&gt; {    res.end(err)})// 注意传进去的四个参数一定要写全，如果只写 err, req, res 会被识别成 req, res, next</code></pre><h3 id="中间件的写法"><a href="#中间件的写法" class="headerlink" title="中间件的写法"></a>中间件的写法</h3><pre><code>function mw1(req, res, next) {    console.log(&#39;mw1&#39;)    next()}function mw2(req, res, next) {    console.log(&#39;mw2&#39;)    next()}function mw3(req, res, next) {    console.log(&#39;mw3&#39;)    res.end(&#39;done&#39;)}// 第一种app.use(mw1)app.use(mw2)app.use(mw3)// 第二种// app.use(mw1, mw2, mw3)// 第三种// app.use([mw1, mw2], mw3)app.use((err, req, res, next) =&gt; {    res.end(err)})</code></pre><h3 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h3><pre><code>// 另一种写法app.use(bodyParser.json())app.use(bodyParser.urlencoded({ extended: true }))// extended 是这样用的，如 users[0]=123&amp;users[1]=456 解析成数组，users[age]=18&amp;users[name]=frankie 解析成对象function mw0(options) {    return function (req, res, next) {        console.log(req.body)        next()    }}app.use(mw0())</code></pre><p>这个其实是解决 post 的处理，不过只能检测两种格式 <code>application/json</code> 和 <code>x-www-form-urlencoded</code></p><p><img src="https://i.loli.net/2017/12/11/5a2d5f3d9c67c.gif" alt=""></p><p>更多中间件模块 <a href="http://expressjs.com/en/resources/middleware.html" target="_blank" rel="noopener">http://expressjs.com/en/resources/middleware.html</a></p><h3 id="中间件的运行条件"><a href="#中间件的运行条件" class="headerlink" title="中间件的运行条件"></a>中间件的运行条件</h3><pre><code>app.use((req, res, next) =&gt; {    req.middlewares = []    next()})function mw1(options) {    return function (req, res, next) {        req.middlewares.push(&#39;mw1&#39;)        next()    }}function mw2(req, res, next) {    req.middlewares.push(&#39;mw2&#39;)    next()}function mw3(req, res, next) {    req.middlewares.push(&#39;mw3&#39;)    res.end(JSON.stringify(req.middlewares))}app.use(&#39;/&#39;, mw1())app.get(&#39;/article&#39;, mw2)app.post(&#39;/user&#39;, mw2)app.use(mw3)</code></pre><p><img src="https://i.loli.net/2017/12/11/5a2d636d08062.gif" alt=""></p><p>也就是说中间件可以通过路由、HTTP 请求的方法、body-parser、query 来做一些精细的控制</p><p>中间件不完全正则 <a href="http://expressjs.com/en/4x/api.html#path-examples" target="_blank" rel="noopener">http://expressjs.com/en/4x/api.html#path-examples</a></p><h2 id="Express-的其他细节"><a href="#Express-的其他细节" class="headerlink" title="Express 的其他细节"></a>Express 的其他细节</h2><p>用 express-generator 生成一个例子</p><pre><code>// Express 的 app.jsconst express = require(&#39;express&#39;);const path = require(&#39;path&#39;);// const favicon = require(&#39;serve-favicon&#39;);const logger = require(&#39;morgan&#39;);const cookieParser = require(&#39;cookie-parser&#39;);const bodyParser = require(&#39;body-parser&#39;);const index = require(&#39;./routes/index&#39;);const users = require(&#39;./routes/users&#39;);const app = express();// view engine setupapp.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); // 设置 views 文件夹为视图文件的目录，存放模板文件，__dirname 为全局变量，存储着当前正在执行脚本所在文件夹的绝对路径app.set(&#39;view engine&#39;, &#39;ejs&#39;); // 设置视图模版引擎为 ejs// uncomment after placing your favicon in /public// app.use(favicon(path.join(__dirname, &#39;public&#39;, &#39;favicon.ico&#39;)));/** *  Express 依赖于 connect，提供了大量的中间件，可以通过  app.use 启用 * *  app.use([path], function)：使用中间件 function，可选参数path默认为&#39;/&#39; *  app.use(express.favicon())：connect 内建的中间件，使用默认的 favicon 图标， *  如果想使用自己的图标，需改为app.use(express.favicon(__dirname + &#39;/public/images/favicon.ico&#39;)); *  这里我们把自定义的 favicon.ico 放到了 public/images 文件夹下。 */app.use(logger(&#39;dev&#39;));/** *  connect 内建的中间件，在开发环境下使用，在终端显示简单的不同颜色的日志，比如在启动 app.js 后访问 localhost:3000，终端会输出： *  Express server listening on port 3000 GET / 200 21ms - 206b GET /stylesheets/style.css 304 4ms *  数字200显示为绿色，304显示为蓝色。假如你去掉这一行代码，不管你怎么刷新网页，终端都只有一行 Express server listening on port 3000。 */app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false }));/** * bodyParser作用是对post请求的请求体进行解析 * bodyParser用于解析客户端请求的body中的内容,内部使用JSON编码处理,url编码处理以及对于文件的上传处理 */app.use(cookieParser());app.use(express.static(path.join(__dirname, &#39;public&#39;)));/** *  设置静态文件目录 *  express.static指定了静态页面的查找目录，如果定义express.static(&#39;/var/www&#39;)， *  当用户向node请求http://server/file.html，node将会自动查找/var/www下面找server/file.html *///  是一个路由控制器，用户如果访问“ / ”路径，则由 routes.index 来控制。app.use(&#39;/&#39;, index);app.use(&#39;/users&#39;, users);// catch 404 and forward to error handler// 上面全部走完没有结果就 404app.use((req, res, next) =&gt; {  const err = new Error(&#39;Not Found&#39;);  err.status = 404;  next(err);});// error handler// 错误信息会经过 error.ejs 渲染出来app.use((err, req, res) =&gt; {  // set locals, only providing error in development  res.locals.message = err.message;  res.locals.error = req.app.get(&#39;env&#39;) === &#39;development&#39; ? err : {};  // render the error page  res.status(err.status || 500);  res.render(&#39;error&#39;);});module.exports = app;</code></pre><p>入口看起来是 <code>bin/www</code>，但实际上真正的入口是 <code>app.js</code></p><p>接下来看看中断的例子</p><pre><code>router.use(&#39;/&#39;, (req, res, next) =&gt; {  console.log(&#39;mw1&#39;)  next(&#39;router&#39;)});router.use(&#39;/&#39;, (req, res, next) =&gt; {  console.log(&#39;mw2&#39;)  next()});// 这个只会打印 mw1// 如果在 next() 传一个字符串，就会中断代码</code></pre><h2 id="Express-中的-MVC"><a href="#Express-中的-MVC" class="headerlink" title="Express 中的 MVC"></a>Express 中的 MVC</h2><pre><code>// controllerconst express = require(&#39;express&#39;);const router = express.Router();const User = require(&#39;../models/in-demo/user&#39;);/* GET users listing. */router.get(&#39;/&#39;, (req, res) =&gt; {  const u = new User(req.query.firstName, req.query.lastName, req.query.age);  res.locals.user = u;  res.render(&#39;user&#39;);});module.exports = router;// modelclass User {  constructor(firstName, lastName, age) {    this.firstName = firstName;    this.lastName = lastName;    this.age = age;  }  getName() {    return `${this.firstName} ${this.lastName}`;  }}module.exports = User;// view&lt;h1&gt;&lt;%= user.lastName %&gt;&lt;/h1&gt;&lt;h1&gt;&lt;%= user.age %&gt;&lt;/h1&gt;</code></pre><p><img src="https://i.loli.net/2017/12/11/5a2e792b19f57.gif" alt=""></p><p>model -&gt; 保存变量</p><p>controller -&gt; 接收用户的请求，根据 model 来进行数据拼装</p><p>view -&gt; 显示给用户</p><pre><code>// 完善 modelconst users = [];class User {  constructor(firstName, lastName, age) {    this.firstName = firstName;    this.lastName = lastName;    this.age = age;  }  getName() {    return `${this.firstName} ${this.lastName}`;  }  static insert(firstName, lastName, age) {    const u = new User(firstName, lastName, age);    User.users.push(u);    return u;  }  static getOneByName(firstName, lastName) {    return User.users.find(element =&gt; element.firstName === firstName &amp;&amp; element.lastName === lastName);  }  static list(query) {    return User.users;  }  // 访问 User.users 的时候返回 users，等于 console.log(User.users)  static get [&#39;users&#39;]() {    return users;  }}module.exports = User;// 测试代码console.log(User.list());console.log(User.insert(&#39;kalun&#39;, &#39;tang&#39;, 21));console.log(User.list());console.log(User.insert(&#39;frankie&#39;, &#39;tang&#39;, 21));console.log(User.list());console.log(User.getOneByName(&#39;kalun&#39;, &#39;tang&#39;));</code></pre><p><img src="https://i.loli.net/2017/12/12/5a2fc8cd9f5cb.png" alt=""></p><p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/class</a></p><p>但是要考虑一个问题，每次重启 <code>users</code> 都是一个空数组，并没有持久化下来，因为是存在内存里。</p><pre><code>// controllerconst UserService = require(&#39;../services/user-service&#39;);router.get(&#39;/&#39;, (req, res) =&gt; {  const users = UserService.getAllUsers();  res.locals.users = users;  res.render(&#39;user&#39;);});router.post(&#39;/&#39;, (req, res) =&gt; {  const { firstName, lastName, age } = req.body;  const u = UserService.addNewUser(firstName, lastName, age);  res.json(u);});// modelconst User = require(&#39;../models/in-demo/user&#39;);  // 见上面的 usermodule.exports = {  getAllUsers() {    return User.list();  },  addNewUser(firstName, lastName, age) {    return User.insert(firstName, lastName, age);  },};// view&lt;% for(let i = 0; i &lt; users.length; i++){ %&gt;  &lt;h1&gt;&lt;%= users[i].firstName %&gt;&lt;/h1&gt;&lt;% } %&gt;</code></pre><p><img src="https://i.loli.net/2017/12/12/5a2fda4fdf08b.gif" alt=""></p><p>上面这个例子通过 post 数据储存到内存里，然后在通过 get 把数据渲染到页面上。</p><p>MVC 肯定也有发布订阅模式</p><p><a href="https://github.com/FRANKIETANG/express-demo/commit/b359514b3dbe998e35aac0a1af799f411abb1a74" target="_blank" rel="noopener">先给用户增加ID</a>（代码量太多不方便贴了）</p><p>用户发生一些行为，并且和数据进行交互</p><p><a href="https://github.com/FRANKIETANG/express-demo/commit/cca1519a3fb29de469a5cb9a98d6500ed93b6c73" target="_blank" rel="noopener">subscription</a>（代码量太多不方便贴了）</p><p><img src="https://i.loli.net/2017/12/13/5a3001a5cb36f.gif" alt=""></p><p>所以说，Express 的 MVC 的结构是</p><pre><code>routes/views/models/services/</code></pre><ul><li>其中，由于 express 的特点，根据设置，views 目录下的文件会被模板引擎在调用<code>res.render(&#39;view_name&#39;)</code>的时候自动渲染</li><li>view 层可以理解为模板引擎 + views 文件夹中的文件</li><li>而 routes 可以理解为 controller，负责根据用户的请求，调取相关的 service，最终得到 model 并用于渲染</li><li>models 则代表了 model 和相关逻辑</li><li>services 则有些特别，由于同层 model 之间解耦的需要，单个 model 往往不应该包含太多对其他 model 的操作，我们应该在 services 中对一系列逻辑上有关的 model 进行统一操作</li></ul><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><h3 id="如何设置-eslint-？"><a href="#如何设置-eslint-？" class="headerlink" title="如何设置 eslint ？"></a>如何设置 eslint ？</h3><p><a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="noopener">eslint-config-airbnb</a></p><pre><code>// 按着第一行命令走npm info &quot;eslint-config-airbnb@latest&quot; peerDependencies  // 显示的那一串是要你一个一个装的，太麻烦// 第二个方法（这个最好）(  export PKG=eslint-config-airbnb;  npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &#39;s/[\{\},]//g ; s/: /@/g&#39; | xargs npm install --save-dev &quot;$PKG@latest&quot;)// 安装完后开始配置npm install -g eslint  // 全局安装eslint --init  // 到目标文件夹初始化// 然后出现下面这个? How would you like to configure ESLint? (Use arrow keys)❯ Answer questions about your style   Use a popular style guide  // 选这个，然后选 airbub  Inspect your JavaScript file(s) // 接下来就要哪个选那个// 配置文件选 JSON// 配完后就跟着报错一个一个改</code></pre><p><a href="https://segmentfault.com/a/1190000009077086" target="_blank" rel="noopener">使用 VSCode + ESLint 实践前端编码规范</a></p><p><code>var</code> 改 <code>const</code>，用箭头函数，去掉没用的空格，要加分号，去掉没用的引用啊啥的，改到 0 报错就好。</p><p>其实就是为了统一代码格式</p><h3 id="query-里的冒号"><a href="#query-里的冒号" class="headerlink" title="query 里的冒号"></a>query 里的冒号</h3><pre><code>router.get(&#39;/:userId/subscription/:subscriptionId&#39;, (req, res, next) =&gt; { // 前面加一个冒号就代表这个是作为一个参数处理  res.json({    userId: req.params.userId,    subscriptionId: req.params.subscriptionId,  });});</code></pre><p><img src="https://i.loli.net/2017/12/13/5a300978c9cc4.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Express&quot;&gt;&lt;a href=&quot;#Express&quot; class=&quot;headerlink&quot; title=&quot;Express&quot;&gt;&lt;/a&gt;Express&lt;/h1&gt;&lt;p&gt;一个文档很完善的框架&lt;/p&gt;
&lt;h2 id=&quot;中间件&quot;&gt;&lt;a href=&quot;#中间件&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>补基础：JS 模块化</title>
    <link href="http://yoursite.com/2017/12/08/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9AJS%20%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://yoursite.com/2017/12/08/补基础：JS 模块化/</id>
    <published>2017-12-08T11:59:10.000Z</published>
    <updated>2017-12-11T08:51:35.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：JS-模块化"><a href="#补基础：JS-模块化" class="headerlink" title="补基础：JS 模块化"></a>补基础：JS 模块化</h1><p>为什么要用到模块化</p><ul><li>解耦</li><li>复用</li></ul><p>先举一个简单的例子</p><pre><code>// html&lt;body&gt;    &lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;// jsclass Person {    constructor(name) {        this.name = name    }    sayHi() {        console.log(`hello I&#39;m ${this.name}`)    }}class Employee extends Person {    constructor(name, salary) {        super(name)        this.salary = salary    }    work() {        console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)    }}function formatSalary(salary) {    return salary + &#39; RMB&#39;}let frankie = new Employee(&#39;frankie&#39;, 5000)frankie.sayHi() // hello I&#39;m frankiefrankie.work() // I&#39;m working, My salary is 5000 RMB</code></pre><p>如果像上面那么样引入会直接暴露所有接口，而且起名字也要很小心，如果使用模块化就可以解决这些问题。</p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>在没有 es6 的时代，用一种叫 namespace 的方法</p><p>解决暴露接口的问题可以用 namespace ，创造一个命名空间</p><pre><code>// html 注意顺序（JS 加载）&lt;script src=&quot;./js/person.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/util.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/employee.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt;// person.js(function (global) {    class Person {        constructor(name) {            this.name = name        }        sayHi() {            console.log(`hello I&#39;m ${this.name}`)        }    }    let namespace = global.MYAPP = global.MYAPP || {}  // 初始化    namespace.Person = Person  // 导出 Person})(window)// util.js(function (global) {    let namespace = global.MYAPP  // 因为 Person.js 是先引的所以页面上已经存在 global.MYAPP    namespace.UTILS = {  // 公有方法        formatSalary: function(salary) {            return salary + &#39; RMB&#39;        }    }})(window)// employee.js(function (global) {    let namespace = global.MYAPP  // 同理    let Person = namespace.Person  // 引入 Person    let formatSalary = namespace.UTILS.formatSalary    class Employee extends Person {        constructor(name, salary) {            super(name)            this.salary = salary        }        work() {            console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)        }    }    namespace.Employee = Employee  // 导出 Employee})(window)// main.js(function (global) {    let namespace = global.MYAPP    namespace.UTILS = {  // 公有方法        formatSalary: function(salary) {            return salary + &#39; RMB&#39;        }    }})(window)</code></pre><p>问题也是很明显的，JS 的执行顺序很让人头疼</p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>于是就有了新的规范 AMD -&gt; <a href="http://requirejs.org/" target="_blank" rel="noopener">requirejs</a> <a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">Javascript模块化编程（三）：require.js的用法</a></p><pre><code>// 举个例子// html 引入 requirejs&lt;script src=&quot;../node_modules/requirejs/require.js&quot; data-main=&quot;./js/main.js&quot;&gt;&lt;/script&gt;// person.jsdefine(function () {    class Person {        constructor(name) {            this.name = name        }        sayHi() {            console.log(`hello I&#39;m ${this.name}`)        }    }    return Person  // 导出 Person 模块})// util.jsdefine(function () {    return {  // 导出方法        formatSalary: function (salary) {            return salary + &#39; RMB&#39;        }    }})// employee.jsdefine([&#39;./person&#39;, &#39;./util&#39;], function (Person, UTILS) {  // 引入 Person 和 util 两个依赖，记住是异步加载    class Employee extends Person {        constructor(name, salary) {            super(name)            this.salary = salary        }        work() {            console.log(`I&#39;m working, My salary is ${UTILS.formatSalary(this.salary)}`)  // 使用 UTILS 的 formatSalary 方法        }    }    return Employee  // 导出 Employee 模块})// main.jsrequire([&#39;./employee&#39;], function (Employee) {  // 引入依赖 Employee    let frankie = new Employee(&#39;frankie&#39;, 5000)    frankie.sayHi() // hello I&#39;m frankie    frankie.work() // I&#39;m working, My salary is 5000 RMB})</code></pre><p>上面这个例子全部是依赖于 requirejs 来实现模块化，requirejs 定义了两个方法，define 和 require。他们都可以传两个参数，第一个是依赖，用数组表示，而且是异步加载，加载完后当做参数传给你要写逻辑的函数。</p><p>AMD -&gt; Asynchronous Module Definition（异步的模块定义）</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>是后端的模块化，主要是由 <code>require</code> 引入，<code>module.exports</code> 导出</p><pre><code>// person.jsclass Person {    constructor(name) {        this.name = name    }    sayHi() {        console.log(`hello I&#39;m ${this.name}`)    }}module.exports = Person  // 导出 Person// util.jsmodule.exports = {  // 导出方法    formatSalary: function (salary) {        return salary + &#39; RMB&#39;    }}// employee.jslet Person = require(&#39;./person.js&#39;)    UTILS = require(&#39;./util.js&#39;)  // 引入两个依赖class Employee extends Person {    constructor(name, salary) {        super(name)        this.salary = salary    }    work() {        console.log(`I&#39;m working, My salary is ${UTILS.formatSalary(this.salary)}`)    }}module.exports = Employee  // 导出 Employee// main.jslet Employee = require(&#39;./employee.js&#39;)  // 引入依赖let frankie = new Employee(&#39;frankie&#39;, 5000)frankie.sayHi() // hello I&#39;m frankiefrankie.work() // I&#39;m working, My salary is 5000 RMB</code></pre><p>CommonJS 这个规范不用把模块用 <code>function</code> 包起来，因为 node.js 定义就是每个文件就是模块</p><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>假如在 AMD 规范里加载 CommonJS 规范的模块肯定是不识别，在 CommonJS 规范里加载 AMD 规范也肯定不行</p><p>那怎么 AMD 和 CommonJS 都通吃呢？</p><pre><code>(function (gl) {    class Person {        constructor(name) {            this.name = name        }        sayHi() {            console.log(`hello I&#39;m ${this.name}`)        }    }    // 这里是通用方法    if (gl.hasOwnProperty(&#39;define&#39;)) {  // 看全局变量有没有 define，有执行 amd 规范        define(function () {            return Person        })    } else if (module != null &amp;&amp; typeof module.exports === &#39;object&#39;) {  // module 在不在 module.exports 在不在，在就执行 commonjs 规范        module.exports = Person    } else {        gl.Person = Person  // 如果都没有就挂到全局变量    }})(this)  // 传一个全局变量</code></pre><p><a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">vue-class-components</a> 也有这种判断规范的方法</p><p><img src="https://us1.myximage.com/2017/12/08/f296231a6848467fa1ad1c777079553c.png" alt=""></p><h2 id="es6-里的-import-和-export"><a href="#es6-里的-import-和-export" class="headerlink" title="es6 里的 import 和 export"></a>es6 里的 import 和 export</h2><pre><code>&lt;body&gt;    &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;// person.jsexport default class Person {    constructor(name) {        this.name = name    }    sayHi() {        console.log(`hello I&#39;m ${this.name}`)    }}// util.jsexport default function formatSalary(salary) {    return salary + &#39; RMB&#39;}// employee.jsimport Person from &#39;./person.js&#39;import formatSalary from &#39;./util.js&#39;export default class Employee extends Person {    constructor(name, salary) {        super(name)        this.salary = salary    }    work() {        console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)    }}// main.jsimport Employee from &#39;./employee.js&#39;let frankie = new Employee(&#39;frankie&#39;, 5000)frankie.sayHi() // hello I&#39;m frankiefrankie.work() // I&#39;m working, My salary is 5000 RMB// 设置好 webpack 打包</code></pre><p>值得一提的是，webpack 兼容所有模块规范的打包，各种规范混搭也可以。</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><h3 id="做一个-require"><a href="#做一个-require" class="headerlink" title="做一个 require"></a>做一个 require</h3><pre><code>// person.jsfunction Person(name) {    this.name = name}Person.prototype.sayHi = function () {    console.log(`hello I&#39;m ${this.name}`)}test.exports = Person  // 这里这个 test 要和下面一样// myrequire.jslet fs = require(&#39;fs&#39;)let modul = (function () {    let mod = {        exports: {}    }    function myrequire(filePath) {        let fnInText = fs.readFileSync(filePath, &#39;utf8&#39;)        let fn = new Function(&#39;test&#39;, fnInText)        fn(mod)    }    myrequire(&#39;./person.js&#39;)    return mod})()let Person = modul.exportslet frankie = new Person(&#39;frankie&#39;)frankie.sayHi()</code></pre><p><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="noopener">exports 和 module.exports 的区别</a></p><p><a href="https://github.com/FRANKIETANG/module" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：JS-模块化&quot;&gt;&lt;a href=&quot;#补基础：JS-模块化&quot; class=&quot;headerlink&quot; title=&quot;补基础：JS 模块化&quot;&gt;&lt;/a&gt;补基础：JS 模块化&lt;/h1&gt;&lt;p&gt;为什么要用到模块化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解耦&lt;/li&gt;
&lt;li&gt;复用&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MVC - MVVM 是什么</title>
    <link href="http://yoursite.com/2017/12/06/MVC%20-%20MVVM%20%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2017/12/06/MVC - MVVM 是什么/</id>
    <published>2017-12-05T17:19:34.000Z</published>
    <updated>2017-12-07T13:00:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC-MVVM-是什么"><a href="#MVC-MVVM-是什么" class="headerlink" title="MVC - MVVM 是什么"></a>MVC - MVVM 是什么</h1><p><a href="http://www.ruanyifeng.com/blog/2007/11/mvc.html" target="_blank" rel="noopener">谈谈MVC模式 - 阮一峰</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示 - 阮一峰</a></p><p><a href="http://javascript.ruanyifeng.com/advanced/backbonejs.html" target="_blank" rel="noopener">MVC框架与Backbone.js - JavaScript 标准参考教程（alpha） - 阮一峰</a></p><p>基于MVC的JavaScript Web富应用开发 - <a href="https://pan.baidu.com/s/1qY9hJmG" target="_blank" rel="noopener">网盘</a> 密码是 y9jv</p><p>以下例子代码的仓库在 <a href="https://github.com/FRANKIETANG/mvc-mvvm-example" target="_blank" rel="noopener">https://github.com/FRANKIETANG/mvc-mvvm-example</a> </p><p>代码变动看 <a href="https://github.com/FRANKIETANG/mvc-mvvm-example/commits/master" target="_blank" rel="noopener">commit</a></p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>如果要先实现一个 MVC ，首先要实现的是中间的那一层 Controller</p><p>对于 Controller 的作用，绑事件 / 调用方法可以用对象的形式 / 监听 DOM 并且更新 DOM / 操作数据</p><p>下面实现一个 MVC 的轮子吧</p><pre><code>// 举个例子// index.html 核心代码    &lt;div class=&quot;modules&quot;&gt;        &lt;div class=&quot;module1&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;number1&quot;&gt;            &lt;button name=&quot;button1&quot;&gt;点我&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;// index.jsimport &#39;./module1&#39;// Controller.jsimport $ from &#39;jquery&#39;class Controller {    constructor(options) {        this.$element = $(options.element)        this.events = options.events        this.bindEvents()    }    bindEvents() {        for (let key in this.events) {            let parts = key.split(&#39; &#39;)            let eventType = parts.shift()            let selector = parts.join(&#39; &#39;)            this.$element.on(eventType, selector, this.events[key])        }    }}export default Controller// module1.jsimport Controller from &#39;./Controller&#39;new Controller({    element: &#39;.module1&#39;,    events: {        &#39;change input&#39;: e =&gt; {            console.log(&#39;change1&#39;)        },        &#39;click button&#39;: e =&gt; {            console.log(&#39;click1&#39;)        }    }})</code></pre><p><img src="https://us1.myximage.com/2017/12/02/90db865271941bd9a64075d1a667d60e.gif" alt=""></p><p>比如上面这个例子就是当需要 Controller 的时候只需要写上你要绑的元素，要做的事件就好。至于实现方法全部交给 Controller 去处理。</p><p>但是上面的例子还是很简单，假如函数逻辑比较复杂该怎么做？可以用对象的形式调用方法。</p><pre><code>// 举个例子new Controller({    element: &#39;.module1&#39;,    events: {        &#39;change input&#39;: &#39;onChangeInput&#39;,            &#39;click button&#39;: &#39;addToCart&#39;    },    addToCart() {        let value = this.$element.find(&#39;input&#39;).val()        this.remoteAddCart(value).then(() =&gt; { // 假如发送到服务器让服务器知道你已经把什么放到购物车了，下次登录的时候就可以获取数据。            this.showAnimation() // 加入到购物车的动画        })      },    remoteAddCart() {        console.log(&#39;远程请求&#39;)        return Promise.resolve(1)    },    showAnimation(){        console.log(&#39;展示添加到购物车的动画&#39;)    }    onChangeInput(e) {        let input = e.currentTarget        console.log(input.value)    }    })// 修改一下 Controllerclass Controller {    constructor(options) {        for (let key in options) {            this[key] = options[key] // 把用户传的东西都放到 json        }        this.$element = $(this.element)        this.bindEvents()    }    bindEvents() {        for (let key in this.events) {            let parts = key.split(&#39; &#39;)            let eventType = parts.shift()            let selector = parts.join(&#39; &#39;)            if (typeof this.events[key] === &#39;function&#39;) {                this.$element.on(eventType, selector, this.events[key])            } else if (typeof this.events[key] === &#39;string&#39;) {                let methodName = this.events[key]                this.$element.on(eventType, selector, this[methodName].bind(this))            }        }    }}</code></pre><p><img src="https://us1.myximage.com/2017/12/02/9bee130d43526daa3c4794d75047aaa0.gif" alt=""></p><p>那监听 DOM 并且更新 DOM 呢？要怎么搞？（实际上早期的 MVC 更新 DOM 的确是要自己写，所以很麻烦）</p><pre><code>// 举个例子new Controller({    element: &#39;.module2&#39;,    events: {        &#39;change input&#39;: &#39;onChangeInput&#39;,        &#39;click button&#39;: &#39;onClickButton&#39;    },    onClickButton(e) {        let value = this.$element.find(&#39;input&#39;).val()        this.render(value)    },    onChangeInput(e) {        let input = e.currentTarget        console.log(input.value)    },    render(value) {        let $output = this.$element.find(&#39;.output&#39;)        if ($output.length === 0) {            $output = $(&#39;&lt;div class=&quot;output&quot;&gt;&lt;/div&gt;&#39;).text(value)            $output.appendTo(this.$element)        } else {            $output.text(value)        }    }})</code></pre><p><img src="https://us1.myximage.com/2017/12/02/53534b163c052c5f0b9a494c3a11f79c.gif" alt=""></p><p>然后过了一段时间之后就有了 template，在 JS 写模板。并且操作数据。<a href="http://handlebarsjs.com/" target="_blank" rel="noopener">http://handlebarsjs.com/</a></p><pre><code>// 举个例子// 先修改html&lt;div class=&quot;module2&quot;&gt;&lt;/div&gt;// 增加 template 和 datanew Controller({    element: &#39;.module2&#39;,    template: `        &lt;input type=&quot;text&quot; name=&quot;number2&quot; value=&quot;{{output}}&quot;&gt;        &lt;button name=&quot;button2&quot;&gt;点我&lt;/button&gt;          &lt;div class=&quot;output&quot;&gt;{{output}}&lt;/div&gt;      `,    data: {        output: &#39;&#39;  // 控制数据    },    events: {        &#39;change input&#39;: &#39;onChangeInput&#39;,        &#39;click button&#39;: &#39;onClickButton&#39;    },    onClickButton(e) {        let value = this.$element.find(&#39;input&#39;).val()        this.data.output = value        this.render()    },    onChangeInput(e) {        let input = e.currentTarget        console.log(input.value)    }})// Controllerclass Controller {    constructor(options) {        for (let key in options) {            this[key] = options[key]        }        this.$element = $(this.element)        if (this.template &amp;&amp; this.render) {  // 判断是否有 template            this.render()        }        this.bindEvents()    }    bindEvents() {        for (let key in this.events) {            let parts = key.split(&#39; &#39;)            let eventType = parts.shift()            let selector = parts.join(&#39; &#39;)            if (typeof this.events[key] === &#39;function&#39;) {                this.$element.on(eventType, selector, this.events[key])            } else if (typeof this.events[key] === &#39;string&#39;) {                let methodName = this.events[key]                this.$element.on(eventType, selector, this[methodName].bind(this))            }        }    }    render() {        let html = Handlebars.compile(this.template)(this.data)  // 渲染 template 和 data        this.$element.html(html)    }}</code></pre><p>和刚刚看起来效果变化不大，但实际上用上了 template 和 data 已经很接近 vue … 啊不是，是 MVC 了 </p><p><img src="https://us1.myximage.com/2017/12/03/5673db0242ef4494b3c9affc904f96a5.gif" alt=""></p><pre><code>// 再举个例子// index.html 加上模板    &lt;script id=&quot;module3Template&quot; type=&quot;text/x-handlerbars&quot;&gt;        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;        &lt;span&gt;{{number}}&lt;/span&gt;        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;        &lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;// module3.jsnew Controller({    element: &#39;.module3&#39;,    template: &#39;#module3Template&#39;,    data: {        number: 0    },    events: {        &#39;click button[name=increase]&#39;: &#39;increase&#39;,        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;    },    increase(){        this.data.number += 1        this.render()    },    decrease(){        this.data.number -= 1        this.render()    }    })// Controller.js 的 render 修改成    render() {        let template = (this.template[0] === &#39;#&#39;) ? $(this.template).html() : this.template        let html = Handlebars.compile(template)(this.data)        this.$element.html(html)    }</code></pre><p><img src="https://us1.myximage.com/2017/12/03/4bf9ab6f7e4d716f90c3b9e5684a710b.gif" alt=""></p><p>到这一步为止，已经实现 VC 了，视图层”（View）利用了 template 来实现，控制层”（Controller）就是 Controller.js，而数据层”（Model）就是 data，下面来举个例子</p><p>因为数据层”（Model）是从服务器来的，所以刚开始要初始化</p><pre><code>// 举个例子// 本地模拟数据 data.json{    &quot;number&quot;: 10000}// 用 promise 模拟数据更新new Controller({    element: &#39;.module4&#39;,    template: `        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;        &lt;span&gt;{{number}}&lt;/span&gt;        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;    `,    data: {        number: 0    },    init() {        $.get(&#39;/data.json&#39;).then((response) =&gt; {            this.data = response            this.render()        })    },    events: {        &#39;click button[name=increase]&#39;: &#39;increase&#39;,        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;    },    increase() {        this.remoteIncrease.then(() =&gt; {            this.data.number += 1            this.render()        })    },    decrease() {        this.remoteDecrease.then(() =&gt; {            this.data.number -= 1            this.render()        })    },    remoteIncrease() {        return new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                console.log(&#39;500ms&#39;)                resolve({                    number: this.number + 1                })            }, 500)        })    },    remoteDecrease() {        return new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                console.log(&#39;500ms&#39;)                resolve({                    number: this.number - 1                })            }, 500)        })    }})</code></pre><p><img src="https://us1.myximage.com/2017/12/03/7d92010a76b32fcc2c0d222194eec2fa.gif" alt=""></p><p>再优化一下代码把数据层”（Model）抽离出来</p><pre><code>let model = {    data: {        number: 0    },    get() {        return $.get(&#39;/data.json&#39;).then((response) =&gt; {            this.data = response            return this.data        })    },    increase() {        return new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                console.log(&#39;500ms&#39;)                this.data.number += 1                resolve(this.data)            }, 500)        })    },    decrease() {        return new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                console.log(&#39;500ms&#39;)                this.data.number -= 1                resolve(this.data)            }, 500)        })    }}new Controller({    element: &#39;.module4&#39;,    template: `        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;        &lt;span&gt;{{number}}&lt;/span&gt;        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;    `,    model: model,    events: {        &#39;click button[name=increase]&#39;: &#39;increase&#39;,        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;    },    init() {        this.model.get().then(() =&gt; {            this.render()        })    },    increase() {        this.model.increase().then(() =&gt; {            this.render()        })    },    decrease() {        this.model.decrease().then(() =&gt; {            this.render()        })    }})</code></pre><p>这样的好处就很明显了，操作永远只是数据，不会操作到 DOM，就是调一下 model 操作一下 view，以上，就实现了MVC 的全部功能 </p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>Object.defineProperty 可以对属性有读写的控制</p><pre><code>// 举个例子let frankie = {    _data: {        age: 18,        name: &#39;frankie&#39;    }}Object.defineProperty(frankie, &#39;age&#39;, {    get: () =&gt; {        console.log(&#39;frankie.age 被读取了&#39;)        return frankie._data.age    },    set: xxx =&gt; {        console.log(&#39;frankie.age 被设置了&#39;)        frankie._data.age = xxx    }})frankie.age = 19  // frankie.age 被设置了frankie.age = 20  // frankie.age 被设置了frankie.age = 21  // frankie.age 被设置了console.log(frankie.age)  // frankie.age 被读取了 21</code></pre><p>通过以上代码可以做到监听 input value 的变化去改内存里对象的变化，也可以改 <code>frankie.age</code> 来改页面上的数值</p><p>例子 =&gt; <a href="https://jsbin.com/zawapumihe/1/edit?html,js,output" target="_blank" rel="noopener">点击这里</a></p><h3 id="那-MVVM-到底是个啥玩意呢？"><a href="#那-MVVM-到底是个啥玩意呢？" class="headerlink" title="那 MVVM 到底是个啥玩意呢？"></a>那 MVVM 到底是个啥玩意呢？</h3><p>以上面这个例子为例：</p><ul><li>M -&gt; frankie (这个是 JS 内存里的)</li><li>VM -&gt; 能让 V 和 M 互相沟通的东西，当 M 变了就通知 V 变，当 V 变了就通知 M 变。（两头互相监听互相变）</li><li>V -&gt; HTML / CSS (内容 / 表现层)</li></ul><h3 id="MVVM-的缺点"><a href="#MVVM-的缺点" class="headerlink" title="MVVM 的缺点"></a>MVVM 的缺点</h3><p>第一点要注意的是 <code>Object.defineProperty</code> 里的 <code>get</code> 和 <code>set</code> 是同步还是异步（改了之后马上更新 input？改了之后在下一次任务的时候更新 input？）</p><p><img src="https://us1.myximage.com/2017/12/05/b34439946bad220c9faf564fdbe2f080.png" alt=""></p><p><img src="https://us1.myximage.com/2017/12/05/d8b5e5b60652215f6172f7e54a411110.png" alt="yin"></p><p>经过上面的测试是同步的</p><p>第二点是 DOM 的操作也是同步的（DOM 不存在异步过程）</p><p>这样会有一个问题，假如 view 层加了一个 input 就不能增加效果（以为因为新的 VM 没有 set 这个 input）。例子 =&gt; <a href="https://jsbin.com/cibunafuro/1/edit?html,js,output" target="_blank" rel="noopener">点击这里</a></p><p>所以 MVVM 的问题就在这里，只能监听已经存在的 key，新加的 key 没法监听</p><p>解决方法还是有的，提供一个 API 为新加的 key 服务。例子 =&gt; <a href="https://jsbin.com/zagacilade/edit?html,js,output" target="_blank" rel="noopener">点击这里</a></p><p>JS 操作 DOM 很慢，DOM 操作 JS 是很慢的</p><p>因为操作是同步的，所以有一个问题是，会很卡。但是 vue.js 很好的解决了这一个问题。（再也不用操作 DOM，从此     jQuery 退出历史舞台）</p><p><a href="https://jsbin.com/jeqaqoyeyi/2/edit?html,js,output" target="_blank" rel="noopener">vue.js 的 Hello world</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MVC-MVVM-是什么&quot;&gt;&lt;a href=&quot;#MVC-MVVM-是什么&quot; class=&quot;headerlink&quot; title=&quot;MVC - MVVM 是什么&quot;&gt;&lt;/a&gt;MVC - MVVM 是什么&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyi
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>用 Node 来搭建 HTTP 服务器</title>
    <link href="http://yoursite.com/2017/12/01/%E7%94%A8%20Node%20%E6%9D%A5%E6%90%AD%E5%BB%BA%20HTTP%20%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2017/12/01/用 Node 来搭建 HTTP 服务器/</id>
    <published>2017-12-01T15:03:36.000Z</published>
    <updated>2017-12-01T15:13:00.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用-Node-来搭建-HTTP-服务器"><a href="#用-Node-来搭建-HTTP-服务器" class="headerlink" title="用 Node 来搭建 HTTP 服务器"></a>用 Node 来搭建 HTTP 服务器</h1><p><a href="https://github.com/FRANKIETANG/simple-http-server" target="_blank" rel="noopener">https://github.com/FRANKIETANG/simple-http-server</a></p><p>可以点进去看 <a href="https://github.com/FRANKIETANG/simple-http-server/commits/master" target="_blank" rel="noopener">commit</a></p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>全称是 Uniform Resource Locator （唯一的资源定位器？），相当于一个地址。</p><p><code>Schema://Host:Port/Path?query#hash</code></p><blockquote><p>Schema =&gt; 协议</p><p>Host =&gt; 主姓名</p><p>Port =&gt; 端口号，比如 22 -&gt; ssh | 80 -&gt; http | 443 -&gt; https | mongodb -&gt; 27017</p><p>Path =&gt; 路径</p><p>query =&gt; 查询字符串</p><p>hash =&gt; 哈希</p></blockquote><pre><code>// 举个例子const url = `address://nanshan.shenzhen.china/shennandadao/10869`// 地址是://南山.深圳.中国/深南大道/10869号// Host:Port 可以写 IP 地址或者域名// 域名 -&gt; DNS (去 google)</code></pre><h3 id="举一个简单的例子"><a href="#举一个简单的例子" class="headerlink" title="举一个简单的例子"></a>举一个简单的例子</h3><p><a href="https://segmentfault.com/a/1190000009084576" target="_blank" rel="noopener">vscode 断点调试</a></p><p>最好用 <strong>postman</strong>，浏览器好像只支持 get 请求。</p><pre><code>const http = require(&#39;http&#39;) // http 模块是一定的const server = http.createServer()server.listen(8282)const querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 queryserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的    const url = request.url    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)    const query = querystring.parse(queryString)    console.log(query)    // console.log(url)    let responseStr // 定义返回字符串，收到 url 做出不同的返回值    if (url.indexOf(&#39;/hello&#39;) &gt; -1) { // 记得加前缀 /        responseStr = &#39;hi there&#39;        if (query.i_need_money === &#39;true&#39; &amp;&amp; Number(query.how_much) &gt; 500) {  // 这里做一个判断他是不是要钱，值得一提的是这里这个 &#39;true&#39;，因为这里是没有类型的所以要用这个 &#39;true&#39;            responseStr = &#39;go away&#39;        } else {            responseStr = &#39;ok, here you are&#39;        }    } else if (url.indexOf(&#39;/bye&#39;) &gt; -1) {  // 也可以用正则，不过如果写不好就会比 indexOf 要慢很多很多...        responseStr = &#39;see ya next time&#39;    } else {        responseStr = &#39;i cant understand what you are saying&#39;    }    response.statusCode = 200    response.end(responseStr)    // response.end(&#39;this is my first http server&#39;)})</code></pre><pre><code>// postman 的操作// 后台信息都是靠 console.loglocalhost:8282/hello  // GET hi there | 后台 /hellolocalhost:8282/bye  // GET see ya next time | 后台 /byelocalhost:8282/  // GET i cant understand what you are saying | 后台 /// 加上 querylocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 /hello?i_need_money=true// 引入 querystring 模块后再打印localhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 { i_need_money: &#39;true&#39; }localhost:8282/hello?i_need_money=true&amp;how_much=1000  // GET i cant understand what you are saying | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;1000&#39; }// hello 模块做好判断后localhost:8282/hello?i_need_money=true&amp;how_much=1000  // GET go away | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;1000&#39; }localhost:8282/hello?i_need_money=true&amp;how_much=300  // GET ok, here you are | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;300&#39; }</code></pre><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>以百度为例子</p><p><img src="https://us1.myximage.com/2017/11/30/10814fc32bca783917e30c6f8245b5e5.png" alt=""></p><blockquote><p>HTTP 请求第一部分（第一行）  <code>GET /index/ HTTP/1.1</code>  什么方法 | 什么路径 | 什么 HTTP 版本 </p><ul><li>HTTP 方法 =&gt; GET POST PATCH PUT DELETE OPTIONS HEAD</li><li>比如 <code>path: /user get:获取所有用户 | post:创建用户 | patch:修改用户信息 | put:创建 | delete:删除 | options:列举可进行的操作 | head:返回 head 信息</code></li></ul><p>HTTP 请求头 第二行到空行之前 重要的键值对有 Content-Type: 请求体的类型（编码、格式）Content-Length: 请求体的长度  Accept: 能够接收的返回体类型  Cookie: cookie 有多个键值对，中间有个等号，以分号为分隔符</p><p>HTTP 请求体和请求头以一个空行作为分隔符</p><p>HTTP 第三部分  请求体 http-request / response-body</p></blockquote><h3 id="举一个简单的例子-1"><a href="#举一个简单的例子-1" class="headerlink" title="举一个简单的例子"></a>举一个简单的例子</h3><p><a href="https://segmentfault.com/a/1190000009084576" target="_blank" rel="noopener">vscode 断点调试</a></p><p>最好用 <strong>postman</strong>，浏览器好像只支持 get 请求。</p><pre><code>const http = require(&#39;http&#39;) // http 模块是一定的const server = http.createServer()server.listen(8282)const querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 queryconst users = [];  // 做一个全局数组server.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的    const url = request.url    const path = url.substr(0, url.indexOf(&#39;?&#39;))    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)    const query = querystring.parse(queryString)    // console.log(query)    // console.log(url)    // console.log(path)    // 做一个请求例子    switch (path) {        case &#39;/user&#39;:            switch (request.method) {                case &#39;GET&#39;:                    response.statusCode = 200                    response.end(JSON.stringify(users))                    break;                case &#39;POST&#39;:                    break            }            break        default:            response.statusCode = 404            response.end(&#39;NOT_FOUND&#39;)            break    }})</code></pre><pre><code>// postman 的操作// 后台信息都是靠 console.loglocalhost:8282/user?frankie=1  // GET [] 因为是第一次请求所以user什么都没有// 文字太难表达了...看下面动图吧// 也就是通过post创建的用户</code></pre><p><img src="https://us1.myximage.com/2017/11/30/07c50f626d106f548a94d6a079a69ac6.gif" alt=""></p><pre><code>// 通过发送 json 定义用户const http = require(&#39;http&#39;) // http 模块是一定的const server = http.createServer()server.listen(8282)const querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 queryconst users = [];  // 做一个全局数组server.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的    const url = request.url    const path = url.substr(0, url.indexOf(&#39;?&#39;))    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)    const query = querystring.parse(queryString)    console.log(query)    console.log(url)    console.log(path)    // 做一个请求例子    // 其他方法也是一样的    switch (path) {        case &#39;/user&#39;:            switch (request.method) {                case &#39;GET&#39;:                    response.statusCode = 200                    response.end(JSON.stringify(users))                    break;                case &#39;POST&#39;:                    const contentType = request.headers[&#39;content-type&#39;]  // 看请求头的属性                    if (contentType !== &#39;application/json&#39;) {  // 不是json就400                        response.statusCode = 400                        response.end(&#39;error&#39;)                    }                    let requestBodyStr = &#39;&#39;                    request.on(&#39;data&#39;, (data) =&gt; {                        requestBodyStr += data.toString()  // 把json变成字符串                    })                    request.on(&#39;end&#39;, () =&gt; {                        const user = JSON.parse(requestBodyStr)  // 解析josn字符串                        users.push(user)                        response.statusCode = 200                        response.end(JSON.stringify(user))                    })                    // const user = { name: Math.floor(Math.random() * 100) }                    // users.push(user)                    // response.statusCode = 200                    // response.end(JSON.stringify(user))                    break            }            break        default:            response.statusCode = 404            response.end(&#39;NOT_FOUND&#39;)            break    }})</code></pre><p><img src="https://us1.myximage.com/2017/11/30/f0f0708a615d98816c5dfac1a6188a49.gif" alt=""></p><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>请求体的格式、编码通常由请求头里的 Content-type 指定，可能会很大（例如 form 格式可以请求 flie，分分钟 几十兆几百兆）（关键词 Buffer，一次吃不下我就一口一口吃）</p><pre><code>// 把上面那段代码改一下const http = require(&#39;http&#39;) // http 模块是一定的const server = http.createServer()server.listen(8282)const querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 queryconst users = []; // 做一个全局数组server.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的    const url = request.url    const path = url.substr(0, url.indexOf(&#39;?&#39;))    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)    const query = querystring.parse(queryString)    console.log(query)    console.log(url)    console.log(path)    // 做一个请求例子    // 其他方法也是一样的    switch (path) {        case &#39;/user&#39;:            switch (request.method) {                case &#39;GET&#39;:                    response.statusCode = 200                    response.end(JSON.stringify(users))                    break;                case &#39;POST&#39;:                    const contentType = request.headers[&#39;content-type&#39;] // 看请求头的属性                    if (contentType !== &#39;application/json&#39;) { // 不是json就400                        response.statusCode = 400                        response.end(&#39;error&#39;)                    }                    let requestBodyStr = &#39;&#39;                    request.on(&#39;data&#39;, (data) =&gt; { // 当这个请求收到数据的时候                        console.log(data) // 看看 data                     })                    request.on(&#39;end&#39;, () =&gt; { // 当发过来的这个请求体已经结束的时候                        response.end(&#39;done&#39;)                    })                    break            }            break        default:            response.statusCode = 404            response.end(&#39;NOT_FOUND&#39;)            break    }})</code></pre><p>然后发点数据</p><p><img src="https://us1.myximage.com/2017/12/01/e73caf3a3b4d360703165be09147afea.gif" alt=""></p><p>可以看到是一个 <code>&lt;Buffer&gt;</code> 这个其实相当于吃了一小口，那我试试传个大家伙</p><pre><code>// 再修改一下代码const http = require(&#39;http&#39;) // http 模块是一定的const server = http.createServer()server.listen(8282)const querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 queryconst users = []; // 做一个全局数组server.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的    const url = request.url    const path = url.substr(0, url.indexOf(&#39;?&#39;))    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)    const query = querystring.parse(queryString)    console.log(query)    console.log(url)    console.log(path)    // 做一个请求例子    // 其他方法也是一样的    switch (path) {        case &#39;/user&#39;:            switch (request.method) {                case &#39;GET&#39;:                    response.statusCode = 200                    response.end(JSON.stringify(users))                    break;                case &#39;POST&#39;:                    const contentType = request.headers[&#39;content-type&#39;] // 看请求头的属性                    // if (contentType !== &#39;application/json&#39;) { // 不是json就400                    //     response.statusCode = 400                    //     response.end(&#39;error&#39;)                    // }                    let dataCount = 0                    let requestBodyStr = &#39;&#39;                    request.on(&#39;data&#39;, (data) =&gt; { // 当这个请求收到数据的时候                        dataCount++                        console.log(data)                    })                    request.on(&#39;end&#39;, () =&gt; { // 当发过来的这个请求体已经结束的时候                        console.log(dataCount) // 看看一个文件要吃多少口                        response.end(dataCount + &#39;&#39;)                    })                    break            }            break        default:            response.statusCode = 404            response.end(&#39;NOT_FOUND&#39;)            break    }})</code></pre><p>然后发个算大的文件（48M）</p><p><img src="https://us1.myximage.com/2017/12/01/fcc0ec6f09967d75f4e2fdfdd6475138.gif" alt=""></p><p>也就是说这个大东西吃了 873 口</p><h2 id="假如用-Express-搭服务器"><a href="#假如用-Express-搭服务器" class="headerlink" title="假如用 Express 搭服务器"></a>假如用 Express 搭服务器</h2><p>先看看 bin/www 的代码</p><pre><code>// 7行和9行var app = require(&#39;../app&#39;);  // 定义各种路由var http = require(&#39;http&#39;);  // 引入http模块// 28行server.listen(port);  // 定义端口号</code></pre><p>怎么把刚刚我上面实现的效果用 Express 框架做出来呢？</p><pre><code>// app.js 26行改成app.use(&#39;/user&#39;, users);// 打开 routes 的 users.js，修改成var express = require(&#39;express&#39;)var router = express.Router()const users = []/* GET users listing. */router.route(&#39;/&#39;)  .get((req, res, next) =&gt; {    res.json(users)  })  .post((req, res)=&gt;{    const user = req.body    users.push(user)    res.json(user)  })module.exports = router</code></pre><p><img src="https://us1.myximage.com/2017/12/01/0eda1fdee399f2d5f16acd525d5f469a.gif" alt=""></p><p>其实框架还是解决了很多自己写东西的细节，像什么判断啊，转码啊啥的。那就可以不用管那么多直接写业务逻辑。</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><h3 id="命令行神器"><a href="#命令行神器" class="headerlink" title="命令行神器"></a>命令行神器</h3><p>又发现了个命令行神器..</p><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></p><h3 id="前端发送表单发送的数据-后端处理的方式"><a href="#前端发送表单发送的数据-后端处理的方式" class="headerlink" title="前端发送表单发送的数据-后端处理的方式"></a>前端发送表单发送的数据-后端处理的方式</h3><p><a href="https://github.com/FRANKIETANG/simple-http-server/commit/4366e9a1cc5506c7291b3550aa1ec2843644e817" target="_blank" rel="noopener">commit - form data</a></p><p><img src="https://us1.myximage.com/2017/12/01/ca7f44d9c3c761bca5d419204b5a5ff0.gif" alt=""></p><p>拿到数据了…（请忽略我的 JSON 报错）</p><p><a href="https://github.com/FRANKIETANG/simple-http-server/commit/1fdc106bf64cb242d53008b4f93b5c86b53af408" target="_blank" rel="noopener">commit - querystring replace JSON</a></p><p><img src="https://us1.myximage.com/2017/12/01/6a58999accae3fe5bcac42cb90ce1400.gif" alt=""></p><h3 id="如何做请求缓存"><a href="#如何做请求缓存" class="headerlink" title="如何做请求缓存"></a>如何做请求缓存</h3><p>就是收到第二次同样的请求返回一样的内容（先留个坑吧…）</p><ul><li>浏览器缓存</li><li>服务端缓存</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用-Node-来搭建-HTTP-服务器&quot;&gt;&lt;a href=&quot;#用-Node-来搭建-HTTP-服务器&quot; class=&quot;headerlink&quot; title=&quot;用 Node 来搭建 HTTP 服务器&quot;&gt;&lt;/a&gt;用 Node 来搭建 HTTP 服务器&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>补基础： node 各种知识点</title>
    <link href="http://yoursite.com/2017/11/29/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9Anode%20%E5%90%84%E7%A7%8D%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2017/11/29/补基础：node 各种知识点/</id>
    <published>2017-11-29T10:56:54.000Z</published>
    <updated>2017-11-29T11:00:26.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：node-各种知识点"><a href="#补基础：node-各种知识点" class="headerlink" title="补基础：node 各种知识点"></a>补基础：node 各种知识点</h1><p>简单带过所有开发环境</p><p>NVM:nvm是一个node.js版本管理器，我们将会使用nvm安装node.js的不同版本<br><a href="https://github.com/creationix/nvm#installation" target="_blank" rel="noopener">NVM安装指南</a></p><p>Node.js和npm: <a href="https://nodejs.org/dist/latest-v8.x/docs/api/" target="_blank" rel="noopener">Node.js官方文档</a> | <a href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwieh52Cgd_XAhUKrI8KHT9NBAoQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-tutorial.html&amp;usg=AOvVaw2jflp9kjA1IHdV5QL7UYRB" target="_blank" rel="noopener">Node.js 教程| 菜鸟教程</a></p><p>Git: <a href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjD3buFgd_XAhUJvo8KHem-BIIQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html&amp;usg=AOvVaw2SlbSmAVE814KUmXI236qx" target="_blank" rel="noopener">Git 教程| 菜鸟教程</a></p><p>MongoDB：MongoDB是时下最流行的NoSQL数据库，<a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB官网</a> | <a href="https://docs.mongodb.com/manual/introduction/" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="noopener">Ubuntu下安装MongoDB官方文档</a></p><p>Redis:运用最广的K-V数据库之一。在Ubuntu下使用 <code>sudo apt-get install redis-server</code> <a href="https://redis.io/" target="_blank" rel="noopener">官网</a></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">HTTP - MDN</a></p><p><a href="https://blog.zain.red/2017/11/23/http/" target="_blank" rel="noopener">HTTP</a></p><p><a href="http://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="noopener">关于HTTP协议，一篇就够了</a></p><h2 id="Git-和-Linux"><a href="#Git-和-Linux" class="headerlink" title="Git 和 Linux"></a>Git 和 Linux</h2><p>看我的旧文章 <a href="http://www.jianshu.com/p/82142a85df5d" target="_blank" rel="noopener">Linux 的基本命令行和 Git 的基本操作</a></p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>写一个脚本文件 show.js，满足以下需求：运行 node /path/to/show.js，输出当前目录下的所有文件。</p><pre><code>touch show.jsvi show.js#!/usr/bin/env node  // 告诉 bash 用 node 运行var fs = require(&quot;fs&quot;)console.log(&quot;查看当前目录&quot;)fs.readdir(process.cwd(),function(error, files){  if(error){    return console.error(error)  }  files.forEach(function(file){    console.log(file)  })})node show.js</code></pre><p>写一个脚本文件 view.js，满足以下需求：运行 node /path/to/view.js xxx，如果 xxx 文件存在，就输出 xxx 内容；如果 xxx 文件不存在，就输出「xxx 不存在」</p><pre><code>touch view.jsvi view.js#!/usr/bin/env node  // 告诉 bash 用 node 运行var file = process.argv[2]  // 获取输入命令行第三个参数var fs = require(&#39;fs&#39;)fs.stat(file, function(error, stat){  if(stat&amp;&amp;stat.isFile()) {    console.log(&#39;文件存在&#39;)    var data = fs.readFileSync(file, &quot;utf-8&quot;)  // 读取文件内容    console.log(data)  } else {    console.log(&#39;文件不存在或不是标准文件&#39;)  }})node view.js show.js</code></pre><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>把上面那两个代码上传</p><pre><code>npm adduser  // 一顿操作lsnpm init  // 一顿起名/*在 package.json 设置东西&quot;bin&quot;:{  &quot;view&quot;:&quot;view.js&quot;,  &quot;show&quot;:&quot;show.js&quot;}*/npm publishnpm i -g frankie-demo-2017-11-19/*新加了两行/usr/local/bin/show -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/show.js/usr/local/bin/view -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/view.js*/// 然后就可以全局使用 show 和 view 了npm uninstall -g frankie-demo-2017-11-19  // 卸载掉 demo</code></pre><p><a href="https://www.npmjs.com/package/frankie-demo-2017-11-19" target="_blank" rel="noopener">https://www.npmjs.com/package/frankie-demo-2017-11-19</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：node-各种知识点&quot;&gt;&lt;a href=&quot;#补基础：node-各种知识点&quot; class=&quot;headerlink&quot; title=&quot;补基础：node 各种知识点&quot;&gt;&lt;/a&gt;补基础：node 各种知识点&lt;/h1&gt;&lt;p&gt;简单带过所有开发环境&lt;/p&gt;
&lt;p&gt;NVM:
      
    
    </summary>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的基本命令行和 Git 的基本操作</title>
    <link href="http://yoursite.com/2017/11/27/Linux%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8C%20Git%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/11/27/Linux 的基本命令行和 Git 的基本操作/</id>
    <published>2017-11-27T08:28:16.000Z</published>
    <updated>2017-11-29T10:59:30.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-的基本命令行和-Git-的基本操作"><a href="#Linux-的基本命令行和-Git-的基本操作" class="headerlink" title="Linux 的基本命令行和 Git 的基本操作"></a>Linux 的基本命令行和 Git 的基本操作</h1><h2 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h2><pre><code>//进入目录cd//显示当前目录pwd//创建目录mkdir 目录名//创建目录mkdir -p 目录路径//查看路径ls 路径//查看路径ls -a 路径//查看路径ls -l 路径//查看路径 ls -al 路径//创建文件echo &#39;1&#39; &gt; 文件路径//创建文件echo &#39;1&#39; &gt;! 文件路径//创建文件echo &#39;1&#39; &gt;&gt; 文件路径//创建文件touch 文件名//改变文件更新时间touch 文件名//复制文件cp 源路径 目标路径//复制目录cp -r 源路径 目标路径//移动节点mv 源路径 目标路径//删除文件rm 文件路径//强制删除文件rm -f 文件路径//删除目录rm -r 目录路径//强制删除目录rm -rf 目录路径//查看目录结构tree//建立软链接ln -s 真实文件 链接</code></pre><h2 id="怎么把项目上传到-GitHub"><a href="#怎么把项目上传到-GitHub" class="headerlink" title="怎么把项目上传到 GitHub"></a>怎么把项目上传到 GitHub</h2><pre><code>//把项目先克隆到本地git clone git@github.com:FRANKIETANG/Remote-Mouse.git//把文件夹里的东西全部清除，然后运行以下命令git add *git commit -m ‘del’git push origin master//把新项目放在文件夹，再运行以下命令git add *git commit -m ‘intinal’git pull origin mastergit push origin master//这样，项目就可以在 GitHub 上看到啦哈哈哈</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">vim 的基本操作</a></p><p>自制命令行</p><pre><code>// ~/.bashrcvi ~/.bashrcalias xx = &quot;要干的事情&quot;source ~/.bashrcxx // ~/.zshrcvi ~/.zshrcalias xx = &quot;要干的事情&quot;source ~/.zshrcxx</code></pre><p>命令行小工具</p><ul><li>z: 方便实现快速目录跳转，<a href="https://github.com/rupa/z" target="_blank" rel="noopener">下载在此</a></li><li>fzf: 方便快速搜索文件或目录，<a href="https://github.com/junegunn/fzf#installation" target="_blank" rel="noopener">官网在此</a></li></ul><pre><code>curl -L https://raw.githubusercontent.com/rupa/z/master/z.sh &gt; z.shvi ~/.zshrcsource ~/z.shsource ~/.zshrcz // 看到你以前去过的所有目录z Desk // 去桌面</code></pre><pre><code>git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf~/.fzf/installsource ~/.zshrcfzf// 然后就可以在命令行搜索文件了</code></pre><pre><code>把 z 和 fzf 合在一起vi ~/.zshrcunalias z // 不要 z 命令// 以下为合并命令，理解就好。把 z 换成 j 和 jj 。jj 是上一次搜索的记录j() {     if [[ -z &quot;$*&quot; ]]; then         cd &quot;$(_z -l 2&gt;&amp;1 | fzf +s | sed &#39;s/^[0-9,.]* *//&#39;)&quot;     else         _last_z_args=&quot;$@&quot;         _z &quot;$@&quot;     fi } jj() {     cd &quot;$(_z -l 2&gt;&amp;1 | sed &#39;s/^[0-9,.]* *//&#39; | fzf -q $_last_z_args)&quot; } source ~/.zshrc</code></pre><pre><code>// 安装 yarnsudo apt-get update &amp;&amp; sudo apt-get install yarn</code></pre><pre><code>// 怎么看精简文档npm i -g tldr// tldr = too long; didn&#39;t read// 比如看 linux 下的 less 怎么使用man less// 太多了tldr less// 就会精简tldr npm</code></pre><pre><code>// git 操作脱离民工三连的方法git --version  // git 版本号git config --global user.name xxx  // 全局设置 user.namegit config --global user.email yyy  // 全局设置 user.emailgit config --global push.default simple// 这个 simple 可以换成 matching，通常默认为是 simple // 意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。// matching 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。git config --global core.quotepath false // 防止文件名变成数字，因为有可能你的文件是中文上传的是后变成中文git config --global push.editor &quot;vim&quot;  // 使用 vim 编辑提交信息// 以上这些都是在编辑 ~/.gitconfigmkdir git-democd git-demogit init  // 创建 .git 目录（本地仓库）touch 1.txt  // 打开写点东西git starus -sb  // ?? 1.txt  // 看文件处于什么状态// 这个 -sb 不是傻逼的意思，s 是 summary，b 是 branchgit add .  // 将多行文字（注意是 行 文字）纳入 git 控制 git starus -sb  // A 1.txt A 就是 ADD 的意思    M 就是改变的意思 git commit -v  // 进入 vim 编gaibain辑，在第一行写字相当于 git commit -m &quot;&quot; 引号里的文字git log  // 显示历史git show  // 后面加 commit 的 ID 可以看到哪行文字改变git remote add origin https://github.com/xxx/xxx.git  // 与仓库建立链接，名字叫 origin，地址叫后面那个像网址一样的东西（错的）git remote set-url origin git@github.com/xxx/xxx.git  // 更换地址git push -u origin master  // -u 是本地的分支和远程的分支建立链接，master 是远程的分支git clone  // 复制仓库并克隆，后面接仓库地址git pull  // 更新本地仓库（.git）和本地文件/*1. git push 之前必须 git pull2. git pull 之前必须 git commit3. git commit 之前必须 git add*/// 以下命令 Google 点击第一个git stash  // 不想提交进行了一半的工作git branch  // 分支的新建git checkout  // 切换分支git merge  // 分支的合并git reset  // 和 git checkout 差不多，细节 googlegit reflog  // 用来数据恢复的</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-的基本命令行和-Git-的基本操作&quot;&gt;&lt;a href=&quot;#Linux-的基本命令行和-Git-的基本操作&quot; class=&quot;headerlink&quot; title=&quot;Linux 的基本命令行和 Git 的基本操作&quot;&gt;&lt;/a&gt;Linux 的基本命令行和 Git
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>简单走一遍 node</title>
    <link href="http://yoursite.com/2017/11/26/%E7%AE%80%E5%8D%95%E8%B5%B0%E4%B8%80%E9%81%8D%20node/"/>
    <id>http://yoursite.com/2017/11/26/简单走一遍 node/</id>
    <published>2017-11-26T11:45:04.000Z</published>
    <updated>2017-11-29T10:58:05.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单走一遍-node"><a href="#简单走一遍-node" class="headerlink" title="简单走一遍 node"></a>简单走一遍 node</h1><p>一个 Express 便利贴项目 | 预览 <a href="http://tangkalun.top" target="_blank" rel="noopener">http://tangkalun.top</a> 源码 <a href="https://github.com/FRANKIETANG/Express-node" target="_blank" rel="noopener">https://github.com/FRANKIETANG/Express-node</a></p><p>详情代码看我 <a href="https://github.com/FRANKIETANG/Express-node/commits/master" target="_blank" rel="noopener">commit</a> </p><p><a href="http://expressjs.com" target="_blank" rel="noopener">http://expressjs.com</a></p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li>增删改查</li><li>便利贴可拖动</li><li>GitHub 登录</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h3><pre><code>npm init -ynpm install express --save</code></pre><p>老套路，先用 express 问候一下世界</p><pre><code>// app.jsconst express = require(&#39;express&#39;)const app = express()app.get(&#39;/&#39;, (req, res) =&gt; res.send(&#39;Hello World!&#39;))app.listen(3000, () =&gt; console.log(&#39;Example app listening on port 3000!&#39;))</code></pre><p>用 <code>node app.js</code> 成功的问候了世界</p><p>接下来安装 express-generator</p><pre><code>npm install express-generator --save-dev</code></pre><p><code>./node_modules/express-generator/bin/express-cli.js . -f -e</code> 自动生成</p><pre><code>// 看看目录tangkalun@tangkalun-PC:~/Desktop/Express-node$ lsapp.js  bin  node_modules  package.json  public  routes  views</code></pre><pre><code>// 根据提示npm inpm start</code></pre><p>换端口的方法是 <code>PORT=4000 node bin/www</code></p><h3 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h3><p>看以前写过的博客</p><h3 id="onchange"><a href="#onchange" class="headerlink" title="onchange"></a>onchange</h3><p><a href="https://www.npmjs.com/package/onchange" target="_blank" rel="noopener">https://www.npmjs.com/package/onchange</a> 查看当前文件状况</p><pre><code>&quot;build&quot;: &quot;webpack --config=src/webpack.config.js&quot;,&quot;watch&quot;: &quot;onchange &#39;src/**/*.js&#39; &#39;src/**/*.less&#39; -- npm run build&quot;</code></pre><h2 id="需要了解的内容有"><a href="#需要了解的内容有" class="headerlink" title="需要了解的内容有"></a><strong>需要了解的内容有</strong></h2><ul><li><a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">middleware</a></li><li><a href="http://expressjs.com/en/guide/using-template-engines.html" target="_blank" rel="noopener">template engines with Express</a></li><li><a href="http://expressjs.com/en/guide/routing.html" target="_blank" rel="noopener">Routing</a></li></ul><p>比如说一个简单的 middleware 可以这样子写</p><pre><code>app.use(&#39;/student&#39;, function (req, res, next) {  res.send(&#39;hello frankie&#39;)})</code></pre><p>我理解的话，大概是一个类似路由的东西</p><p>模板引擎：<a href="https://www.npmjs.com/package/ejs" target="_blank" rel="noopener">https://www.npmjs.com/package/ejs</a></p><p>有一句话是设置路径的，很重要。是用来设置是路由还是其他公共路径下的文件不会被当成路由加载</p><pre><code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>没什么好说的都是以前做的轮子变形</p><p>不过发布订阅的确写得简单了点…</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>crud</code> <code>restful</code></p><ul><li>获取所有的 note <code>GET /api/notes  req:{}  res:{stauts: 0, data: [{},{}]} {status:1,errorMsg: &#39;失败的原因&#39;}</code></li><li>创建一个 note <code>POST /api/note/create  req:{note: &#39;hello world&#39;}  res:{stauts: 0}  {status:1,errorMsg: &#39;失败的原因&#39;}</code></li><li>修改一个 note <code>POST /api/note/edit  req:{note: &#39;new note&#39;, id:100}</code></li><li>删除一个 note <code>POST /api/note/delete req:{id:100}</code></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="https://www.npmjs.com/package/sequelize" target="_blank" rel="noopener">https://www.npmjs.com/package/sequelize</a></p><p><a href="https://github.com/demopark/sequelize-docs-Zh-CN" target="_blank" rel="noopener">https://github.com/demopark/sequelize-docs-Zh-CN</a></p><pre><code>// 用 n 模块降级到 6.10.3$ npm install --save sequelize$ npm install --save sqlite3</code></pre><h2 id="登录登出功能"><a href="#登录登出功能" class="headerlink" title="登录登出功能"></a>登录登出功能</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a></p><p><a href="https://www.npmjs.com/package/passport" target="_blank" rel="noopener">https://www.npmjs.com/package/passport</a> 注意文档中的 Sessions 和 Middleware</p><p><a href="https://www.npmjs.com/package/passport-github" target="_blank" rel="noopener">https://www.npmjs.com/package/passport-github</a> 注意文档中的 Configure Strategy 和 Authenticate Requests</p><p><a href="http://www.cnblogs.com/gabrielchen/p/5800225.html" target="_blank" rel="noopener">http://www.cnblogs.com/gabrielchen/p/5800225.html</a></p><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p><p><a href="https://diamondfsd.com/article/7fc2b070-e238-4fbb-acaf-47f0e3fdaabc" target="_blank" rel="noopener">使用 GitHub OAuth 第三方验证登录</a></p><p><a href="http://www.open-open.com/lib/view/open1416812717570.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1416812717570.html</a></p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p><a href="https://github.com/FRANKIETANG/Express-node/commit/23e800fd0f76661225f5bae731cad4f22d302a6d" target="_blank" rel="noopener">permission - commit</a></p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>node 如何调试</p><pre><code>npm i -g node-inspectornode-inspector// 然后打开他指定的端口// 然后打开项目node --debug bin/www</code></pre><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>为了能让自己回想起自己的代码是啥意思，多看看自己的 commit</p><p>过一段时间想个更有难度的项目吧… 不应该老是做这种像 demo 一样的东西</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单走一遍-node&quot;&gt;&lt;a href=&quot;#简单走一遍-node&quot; class=&quot;headerlink&quot; title=&quot;简单走一遍 node&quot;&gt;&lt;/a&gt;简单走一遍 node&lt;/h1&gt;&lt;p&gt;一个 Express 便利贴项目 | 预览 &lt;a href=&quot;http://
      
    
    </summary>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>补基础：事件</title>
    <link href="http://yoursite.com/2017/11/19/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/11/19/补基础：事件/</id>
    <published>2017-11-19T05:43:09.000Z</published>
    <updated>2017-11-19T05:45:46.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：事件"><a href="#补基础：事件" class="headerlink" title="补基础：事件"></a>补基础：事件</h1><p>什么情况下会用到事件？</p><ul><li>DOM 操作</li><li>服务器的事件操作</li></ul><h2 id="node-events"><a href="#node-events" class="headerlink" title="node events"></a><a href="https://nodejs.org/api/events.html" target="_blank" rel="noopener">node events</a></h2><p><a href="https://nodejs.org/api/events.html#events_emitter_on_eventname_listener" target="_blank" rel="noopener">emitter.on(eventName, listener)</a> <a href="https://nodejs.org/api/events.html#events_emitter_emit_eventname_args" target="_blank" rel="noopener">emitter.emit(eventName[, …args])</a></p><pre><code>// example.jsconst EventEmitter = require(&#39;events&#39;);  // 这是 node 的一个内置模块，给 node 提供一个事件功能const emitter = new EventEmitter();emitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 这里这个 on 相当于 addEventListener  console.log(`an event occurred! with response ${arg}`)})emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)  // 用 emit 触发事件// node example.js// an event occurred! with response a,b</code></pre><p><a href="https://nodejs.org/api/events.html#events_emitter_eventnames" target="_blank" rel="noopener">emitter.eventNames()</a> <a href="https://nodejs.org/api/events.html#events_emitter_listenercount_eventname" target="_blank" rel="noopener">emitter.listenerCount(eventName)</a></p><pre><code>const EventEmitter = require(&#39;events&#39;);const emitter = new EventEmitter();emitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 1  console.log(`an event occurred! with response ${arg}`)});emitter.on(&#39;iEvent&#39;, () =&gt; {  // 2  console.log(`another event occurred!`);})emitter.on(&#39;newEvent&#39;, () =&gt; {  console.log(`another event occurred!`);})emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  //  同时触发 1 和 2let eNames = emitter.eventNames();console.log(eName);  // [&#39;iEvent&#39;, &#39;newEvent&#39;]  // 返回所有注册实例的名称let iEventListenerCount = emitter.listenerCount(&#39;iEvent&#39;);console.log(iEventListenerCount);  // 2  // 绑定了多少个 handler</code></pre><p><a href="https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener" target="_blank" rel="noopener">emitter.removeListener(eventName, listener)</a></p><pre><code>const EventEmitter = require(&#39;events&#39;);const emitter = new EventEmitter();emitter.on(&#39;iEvent&#39;, (...args) =&gt; {  console.log(`an event occurred! with response ${args}`);});let handler = function() {  console.log(`handler`);}emitter.on(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b   handler // 加一个 handleremitter.removeListener(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b/* 这样做不会 remove handler emitter.removeListener(&#39;iEvent&#39;, function() {  console.log(`handler`)  // an event occurred! with response a,b   handler})*/emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);</code></pre><p><a href="https://nodejs.org/api/events.html#events_emitter_once_eventname_listener" target="_blank" rel="noopener">emitter.once(eventName, listener)</a></p><pre><code>const EventEmitter = require(&#39;events&#39;);const emitter = new EventEmitter();/* 这样会打印两次emitter.on(&#39;iEvent&#39;, (...args) =&gt; {  console.log(`an event occurred! with response ${args}`);});emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,bemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,b*/emitter.once(&#39;onceEvent&#39;, (...args) =&gt; {  console.log(`an event occurred! with response ${args}`);})emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);// 只会触发一次// an event occurred! with response a,b</code></pre><h2 id="实现一个-Event"><a href="#实现一个-Event" class="headerlink" title="实现一个 Event"></a>实现一个 Event</h2><h3 id="on-和-emit"><a href="#on-和-emit" class="headerlink" title="on 和 emit"></a>on 和 emit</h3><pre><code>// on 可以想象成是一个订阅事件// emit 可以想象成一个发布事件// sub/pub(subscribe/publish)function Event() {    // todo...    this.eventToHandlers = {}  // 设置一个空对象}// todo...Event.prototype.on = function (eventName, callback) {    if (this.eventToHandlers[eventName]) {        this.eventToHandlers[eventName].push(callback);  // 如果已经有 callback 了就继续添加    } else {        this.eventToHandlers[eventName] = [callback];  // 没有的话就让 eventToHandlers[name] 变为 callback    }}Event.prototype.emit = function (eventName, ...args) {    let handlers = this.eventToHandlers[eventName] || [];  // 解决变量名字是 undefined 的问题    for (let fn of handlers) {  // 遍历 eventName 下面的数组        fn(...args)    }}let emitter = new Event();let handler1 = (...args) =&gt; {    console.log(`an event occurred! with response ${args}`);};emitter.on(&#39;iEvent&#39;, handler1)emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)let handler2 = () =&gt; { console.log(`another handler2`); };let handler3 = () =&gt; { console.log(`another handler3`); };emitter.on(&#39;iEvent2&#39;, handler2)emitter.on(&#39;iEvent2&#39;, handler3)emitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)// an event occurred! with response a,b// another handler2// another handler3// 保存的数据结构的格式最好是/*{  &quot;iEvent&quot;: [handler1]  &quot;iEvent2&quot;: [handler2, handler3]}*/</code></pre><h3 id="eventNames-和-listenerCount"><a href="#eventNames-和-listenerCount" class="headerlink" title="eventNames 和 listenerCount"></a>eventNames 和 listenerCount</h3><pre><code>function Event() {    this.eventToHandlers = {}}Event.prototype.on = function (eventName, callback) {    if (this.eventToHandlers[eventName]) {        this.eventToHandlers[eventName].push(callback);    } else {        this.eventToHandlers[eventName] = [callback];    }}Event.prototype.emit = function (eventName, ...args) {    let handlers = this.eventToHandlers[eventName] || [];    for (let fn of handlers) {        fn(...args)    }}// 实现 eventNames 和 listenerCountEvent.prototype.eventNames = function () {    // return array    return Object.keys(this.eventToHandlers);}Event.prototype.listenerCount = function (eventNames) {    // return number    // return (this.eventToHandlers[eventNames] || []).length  // 如果 this.eventToHandlers[eventNames] 没有就会取一个空数组    return this.eventToHandlers[eventNames] ? this.eventToHandlers[eventNames].length : 0;}let emitter = new Event();let handler1 = (...args) =&gt; {    console.log(`an event occurred! with response ${args}`);};emitter.on(&#39;iEvent&#39;, handler1)emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)let handler2 = () =&gt; { console.log(`another handler2`); };let handler3 = () =&gt; { console.log(`another handler3`); };emitter.on(&#39;iEvent2&#39;, handler2)emitter.on(&#39;iEvent2&#39;, handler3)emitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)console.log(emitter.eventNames());  // [&#39;iEvent&#39;, &#39;iEvent2&#39;]console.log(emitter.listenerCount(&#39;iEvent2&#39;));  // 2console.log(emitter.listenerCount(&#39;abc&#39;));  // 做一个处理 0</code></pre><h3 id="removeListener"><a href="#removeListener" class="headerlink" title="removeListener"></a>removeListener</h3><pre><code>function Event() {    this.eventToHandlers = {}}Event.prototype.on = function (eventName, callback) {    if (this.eventToHandlers[eventName]) {        this.eventToHandlers[eventName].push(callback);    } else {        this.eventToHandlers[eventName] = [callback];    }}Event.prototype.emit = function (eventName, ...args) {    let handlers = this.eventToHandlers[eventName] || [];    for (let fn of handlers) {        fn(...args)    }}// 实现一个 removeListenerEvent.prototype.removeListener = function (eventName, fn) {    let handlers = this.eventToHandlers[eventName];    let index = handlers.indexOf(fn);    if (index &gt; -1) {        handlers.splice(index, 1)    }}let emitter = new Event();let handler2 = () =&gt; { console.log(`another handler2`); };let handler3 = () =&gt; { console.log(`another handler3`); };emitter.on(&#39;iEvent2&#39;, handler2)emitter.on(&#39;iEvent2&#39;, handler3)emitter.removeListener(&#39;iEvent2&#39;, handler3)emitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)// another handler2</code></pre><h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><pre><code>function Event() {    this.eventToHandlers = {}}Event.prototype.on = function (eventName, callback) {    if (this.eventToHandlers[eventName]) {        this.eventToHandlers[eventName].push(callback);    } else {        this.eventToHandlers[eventName] = [callback];    }}Event.prototype.emit = function (eventName, ...args) {    let handlers = this.eventToHandlers[eventName] || [];    for (let fn of handlers) {        fn(...args)    }}Event.prototype.removeListener = function (eventName, fn) {    let handlers = this.eventToHandlers[eventName];    let index = handlers.indexOf(fn);    if (index &gt; -1) {        handlers.splice(index, 1)    }}// 实现一个 onceEvent.prototype.once = function (eventName, callback) {    // 触发之后删除掉    let handler = (...args) =&gt; {        callback(...args)        this.removeListener(eventName, handler)    }    this.on(eventName, handler)}let emitter = new Event();let handler4 = () =&gt; { console.log(`another handler4`); }emitter.once(&#39;iEvent4&#39;, handler4)emitter.emit(&#39;iEvent4&#39;)  // another handler4emitter.emit(&#39;iEvent4&#39;)  // 不打印</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：事件&quot;&gt;&lt;a href=&quot;#补基础：事件&quot; class=&quot;headerlink&quot; title=&quot;补基础：事件&quot;&gt;&lt;/a&gt;补基础：事件&lt;/h1&gt;&lt;p&gt;什么情况下会用到事件？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM 操作&lt;/li&gt;
&lt;li&gt;服务器的事件操作&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>看点面试题</title>
    <link href="http://yoursite.com/2017/11/15/%E7%9C%8B%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/15/看点面试题/</id>
    <published>2017-11-15T14:58:52.000Z</published>
    <updated>2017-11-15T15:00:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="看点面试题"><a href="#看点面试题" class="headerlink" title="看点面试题"></a>看点面试题</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南</a> — 解决状态码和请求方式</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>2xx成功</li><li>3xx重定向</li><li>4xx客户端错误</li><li>5xx服务器错误（流量大啥的）</li></ul><p>3xx 重定向：比如访问网站 A，结果重新打到网站 B 上。怎么从 A 导到 B。</p><p>比如输入一个 <a href="http://www.baidu.com，它会自动转到" target="_blank" rel="noopener">http://www.baidu.com，它会自动转到</a> <a href="https://www.baidu.com，状态码是" target="_blank" rel="noopener">https://www.baidu.com，状态码是</a> 307，因为在 Response Headers 有一个 Location</p><p>还有一些缓存相关的</p><blockquote><p>304：当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候,就会发送一个条件请求.在Fiddler中,你可以在<strong>Headers Inspector</strong>查找相关请求头,这样就可以辨别出一个请求是否是条件请求.</p><p>在进行条件请求时,客户端会提供给服务器一个<strong>If-Modified-Since</strong>请求头,其值为服务器上次返回的<strong>Last-Modified</strong>响应头中的日期值,还会提供一个<strong>If-None-Match</strong>请求头,值为服务器上次返回的<strong>ETag</strong>响应头的值:</p><p><img src="http://pic002.cnblogs.com/images/2012/116671/2012111610163856.jpg" alt="Fiddler Request Headers Inspector screenshot"></p><p>服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回<strong>HTTP/304 Not Modified</strong>响应,但没有响应体.客户端收到304响应后,就会从缓存中读取对应的资源.</p><p>另一种情况是,如果服务器认为客户端缓存的资源已经过期了,那么服务器就会返回<strong>HTTP/200 OK</strong>响应,响应体就是该资源当前最新的内容.客户端收到200响应后,就会用新的响应体覆盖掉旧的缓存资源.</p><p>只有在客户端缓存了对应资源且该资源的响应头中包含了<strong>Last-Modified</strong>或<strong>ETag</strong>的情况下,才可能发送条件请求.如果这两个头都不存在,则必须无条件(<strong>unconditionally</strong>)请求该资源,服务器也就必须返回完整的资源数据.</p></blockquote><p>4xx客户端错误：</p><ul><li>404 就是页面不存在</li><li>403 Forbidden 服务器上文件或目录的权限设置导致，就是登录了但是没有权限修改就会返回403</li><li>401 Unanthorized 完全没有登录，比如说进入了一个系统看系统里的东西但是没登录就会返回401</li></ul><p>Cache-Control Expires 其实是一个同样的功能</p><blockquote><p><strong>Expires</strong></p><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT</p><p>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。</p><p><strong>关于 Cache-Control: max-age=秒 和 Expires</strong></p><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</p><p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p><p><strong>Expires = max-age +   “每次下载时的当前的request时间”</strong></p><p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p></blockquote><p>不受系统时间的影响</p><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>比如一些常见的 get post delete put 这些</p><p>get 和 post 的区别是？<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">HTTP协议中GET和POST方法的区别</a></p><p>put 和 patch 的区别？<a href="https://ihower.tw/blog/archives/6483" target="_blank" rel="noopener">HTTP Verbs: 談 POST, PUT 和 PATCH 的應用</a></p><h3 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files" target="_blank" rel="noopener">XMLHttpRequest</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form" target="_blank" rel="noopener">form</a></li></ul><pre><code>// 假设发送的字符串里有 &amp; 和 = 怎么转译name: &#39;&amp;=xiaohong&#39;encodeURIComponent(&#39;&amp;=xiaohong&#39;)  // %26%3DxiaohongdecodeURIComponent(&#39;%26%3Dxiaohong&#39;)  // &amp;=xiaohong</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="noopener">FormData</a></p><p>application/json <code>JSON.parse(JSON.stringify(obj))</code></p><p>发数据的时候记得设置 content-type</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p><a href="https://segmentfault.com/a/1190000006689767" target="_blank" rel="noopener">HTTP 请求头与请求体</a></p><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p><a href="https://segmentfault.com/a/1190000006689786" target="_blank" rel="noopener">HTTP 响应头与状态码</a></p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="实参-Array-prototype-push"><a href="#实参-Array-prototype-push" class="headerlink" title="实参 - Array.prototype.push"></a>实参 - Array.prototype.push</h3><pre><code>// 实现一个 _push() 方法// 一顿操作Array.prototype._push = function() {  // todo..  for(let i = 0; i &lt; arguments.length; i++) {    this.splice(this.length, 0, arguments[i]);  }}var arr = [1,2,3]arr._push(4,5)console.log(arr)  // [1,2,3,4,5]arr._push([1,2], 6)console.log(arr)  // [1,2,3,4,5,[1,2],6]</code></pre><h3 id="call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组"><a href="#call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组" class="headerlink" title="call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组"></a>call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组</h3><pre><code>Array.prototype._concat = function () {    // todo...    let arr = this.slice(0);    arguments.length &amp;&amp; [].forEach.call(arguments, (value) =&gt; {        if (Array.isArray(value)) {            value.forEach(val =&gt; {                arr.push(val);            })        } else {            arr.push(value);        }    })    return arr;}let arr = [1, 2, 3]arr._concat([4, 5])console.log(arr) // [1,2,3,4,5]</code></pre><p>利用 <code>[].forEach.call</code> 调用数组的 <code>forEach</code> 方法（arguments 是类数组没有 forEach 方法）</p><h3 id="原型-extend-parentConstructor-childConstructor"><a href="#原型-extend-parentConstructor-childConstructor" class="headerlink" title="原型 - extend(parentConstructor, childConstructor)"></a>原型 - extend(parentConstructor, childConstructor)</h3><p>实现 extend 方法让子构造函数继承父构造函数的方法。</p><pre><code>function extend(parentConstructor, childConstructor) {  var prototype = Object.create(parentConstructor.prototype);  prototype.constructor = childConstructor;  childConstructor.prototype = prototype;}function Person(name) {  this.name = name;}Person.prototype.sayHi = function() {  console.log(`hi I&#39;m ${this.name}`);}var frankie = new Person(&#39;frankie&#39;);frankie.sayHi();function Student(name) {  Person.call(this, name);}// 实现 extend 方法让 xiaoming 有问候大家的技能extend(Person,Student);  //  extend 要挂在这里，如果挂在下面会有可能冲掉 student 的 prototype 属性Student.prototype.study = function() {  console.log(`hi I&#39;m ${this.name}. I&#39;m studying`);}var xiaoming = new Student(&#39;xiaoming&#39;);xiaoming.study()  // hi I&#39;m xiaoming. I&#39;m studyingxiaoming.sayHi()  // hi I&#39;m xiaoming</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;看点面试题&quot;&gt;&lt;a href=&quot;#看点面试题&quot; class=&quot;headerlink&quot; title=&quot;看点面试题&quot;&gt;&lt;/a&gt;看点面试题&lt;/h1&gt;&lt;h2 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;headerlink&quot; title=&quot;http&quot;
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://yoursite.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>补基础：JS 单元测试</title>
    <link href="http://yoursite.com/2017/11/13/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9AJS%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2017/11/13/补基础：JS 单元测试/</id>
    <published>2017-11-13T10:07:52.000Z</published>
    <updated>2017-11-13T10:09:48.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：JS-单元测试"><a href="#补基础：JS-单元测试" class="headerlink" title="补基础：JS 单元测试"></a>补基础：JS 单元测试</h1><h2 id="单元测试有啥用？"><a href="#单元测试有啥用？" class="headerlink" title="单元测试有啥用？"></a>单元测试有啥用？</h2><p>修改函数的实现方式难以保证输出的东西是自己想要的。</p><p>比如 GitHub 上较大的开源项目在别人贡献代码的时候要保证输出的东西和原来的一样。</p><p>单元测试就是保证这个。</p><p>而且单元测试也是一个文档，告诉别人怎么使用这个文档。</p><p><a href="https://github.com/n0ruSh/blogs/issues/2" target="_blank" rel="noopener">教练我要写单元测试</a></p><p><a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a></p><p><a href="http://shouldjs.github.io/" target="_blank" rel="noopener">Should</a></p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>现在做一个方法 <code>takeWhile</code> ，传一个数组和函数通过所有的 Mocha 测试</p><pre><code>/** * @param {Array} arr - base array * @param {Function} pred - predicate * @returns {Array} */function takeWhile(arr, pred) {    // todo...    /*    第一个测试    return []    */}module.exports = takeWhile;</code></pre><p>上面的 <code>@param</code> 看这个了解就好。<a href="http://www.css88.com/doc/jsdoc/tags-param.html" target="_blank" rel="noopener">@param</a></p><p>Mocha 的测试写法</p><pre><code>let takeWhile = require(&#39;../../src/array/takeWhile&#39;),    should = require(&#39;should&#39;);  // 比较库或者叫断言库，用来看输出后的东西是不是一样的。describe(&#39;array takeWhile&#39;, () =&gt; {  // describe 里面可以写一些小方法    it(&#39;should be okay with empty array&#39;, () =&gt; {  // it 接一些小的用例，后面最好就给一些描述啥的        let res = takeWhile([], (it) =&gt; {            return it &lt;= 8;        });        res.should.be.eql([]);  // 用 should 来比较是不是一个空数组    });    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {            return it &lt;= 8;        });        res.should.be.eql([1,2,3,8]);    });});</code></pre><p>运行 <code>mocha takeWhile.js</code> 实现第一个测试 <code>return []</code> </p><p><img src="http://upload-images.jianshu.io/upload_images/3191557-c3d18a2b8f498851.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>第一个通过了，第二个没有通过并且提示给了我们要输出 <code>[1,2,3,8]</code></p><p>事实上测试用例越多，则说明这个方法越全面。</p><pre><code>// 继续增加单元测试的用例let takeWhile = require(&#39;../../src/array/takeWhile&#39;),    should = require(&#39;should&#39;);describe(&#39;array takeWhile&#39;, () =&gt; {    it(&#39;should be okay with empty array&#39;, () =&gt; {        let res = takeWhile([], (it) =&gt; {            return it &lt;= 8;        });        res.should.be.eql([]);    });    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {            return it &lt;= 8;        });        res.should.be.eql([1,2,3,8]);    });    it(&#39;should be okay for normal array greater than 3&#39;, () =&gt; {        let res = takeWhile([1,2,6], (it) =&gt; {            return it &gt; 3;        });        res.should.be.eql([]);  // 第一个 1 就比 3 小直接返回空数组    });    it(&#39;should be okay for normal array greater than 3 with normal array&#39;, () =&gt; {        let res = takeWhile([4,2,6], (it) =&gt; {            return it &gt; 3;        });        res.should.be.eql([4]);  // 第一个 4 就比 3 大直接返回 [4]    });    it(&#39;should be okay for normal array with objects&#39;, () =&gt; {        let res = takeWhile([{a: 3}, {a: 4}, {a: 5}], (it) =&gt; {            return it.a &gt;= 3;        });        let obj = res[0];        obj.should.be.eql({a: 3});  // 看看第一个对象是不是 {a: 3}    });    it(&#39;should be okay for normal array with objects that has property a&#39;, () =&gt; {        let res = takeWhile([{a: 3}, {a: 4}, {c: 5}], (it) =&gt; {            return it.hasOwnProperty(&#39;a&#39;);        });        res.length.should.be.eql(2);  // 有 a 的数组是否长度是 2    });});</code></pre><p>那现在就实现方法 <code>takeWhile</code> 通过所有的单元实例</p><pre><code>/** * @param {Array} arr - base array * @param {Function} pred - predicate * @returns {Array} */function takeWhile(arr, pred) {    // todo...    let temp = [];    arr.some((it) =&gt; {        if(pred(it)) {            temp.push(it);        } else {            return true;        }    });    return temp;    /**     * let temp = [];     * for(let it of arr) {     *     if(pred(it)){     *         temp.push(it);     *     } else {     *         return temp;     *     }     * }     * return temp;     */    }module.exports = takeWhile;</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener">Array.prototype.some()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" rel="noopener">for…of</a></p><pre><code>// 彩蛋 --- some() 的用法let arr = [1,2,3]arr.some(function(it) {return it &lt; 4})  // truearr.some(function(it) {return it === 3})  // truearr.some(function(it) {return it &gt; 5})  // falsearr.some(function(it) {console.log(it); return it &lt; 4})  // 1 true// 只要有一个返回 true 就马上截止返回 true</code></pre><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>判断对象是不是空的对象（并不是指完全空的，原型上的东西还是要有的）</p><pre><code>let isEmptyObject = require(&#39;../../src/object/isEmptyObject&#39;),    should = require(&#39;should&#39;);describe(&#39;isEmptyObject&#39;, () =&gt; {    it(&#39;empty object&#39;, () =&gt; {        isEmptyObject({}).should.eql(true);    });    it(&#39;non-empty object&#39;, () =&gt; {        isEmptyObject({a: &#39;a&#39;}).should.eql(false);    });    it(&#39;should be okay for array&#39;, () =&gt; {        isEmptyObject([]).should.eql(false);    });    it(&#39;should be okay for number&#39;, () =&gt; {        isEmptyObject(1).should.eql(false);    });    it(&#39;should be okay for string&#39;, () =&gt; {        isEmptyObject(&quot;abc&quot;).should.eql(false);    });});</code></pre><pre><code>/** * @param {Any} obj * @returns {Boolean} */function isEmptyObject(obj) {    // todo...    // Object.prototype.toString.call(obj).toLowerCase() === &#39;[object object]&#39;    return obj.constructor === Object &amp;&amp; Object.keys(obj).length === 0;}module.exports = isEmptyObject;</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">Object.prototype.constructor</a></p><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>实现一个 trim 方法去掉前后空格（单词中间的空格不能省略）</p><pre><code>let trim = require(&#39;../../src/string/trim&#39;),    should = require(&#39;should&#39;);describe(&#39;string trim&#39;, () =&gt; {    it(&#39;trim string with no spaces at beginning and end&#39;, () =&gt; {        trim(&#39;hello world&#39;).should.eql(&#39;hello world&#39;);    });    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {        trim(&#39;  hello world&#39;).should.eql(&#39;hello world&#39;);    });    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {        trim(&#39;\thello world&#39;).should.eql(&#39;hello world&#39;);    });    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {        trim(&#39;\nhello world&#39;).should.eql(&#39;hello world&#39;);    });    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {        trim(&#39;hello world  &#39;).should.eql(&#39;hello world&#39;);    });    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {        trim(&#39;hello world\t&#39;).should.eql(&#39;hello world&#39;);    });    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {        trim(&#39;hello world\n&#39;).should.eql(&#39;hello world&#39;);    });    it(&#39;trim string with spaces/tabs/new lines at beginning and end&#39;, () =&gt; {        trim(&#39; \t\nhello world \t\n&#39;).should.eql(&#39;hello world&#39;);    });});</code></pre><pre><code>/** * @param {String} str * @returns {String} */function trim(str) {    return str.replace(/^\s+|\s+$/g, &quot;&quot;);}module.exports = trim;</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" target="_blank" rel="noopener">String.prototype.trim()</a> 的 Polyfill 是 </p><pre><code>if (!String.prototype.trim) {  String.prototype.trim = function () {    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, &#39;&#39;);  };}</code></pre><h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><p>变成小驼峰</p><pre><code>let toCamel = require(&#39;../../src/string/toCamel&#39;),    should = require(&#39;should&#39;);describe(&#39;string to camel case&#39;, () =&gt; {    it(&#39;empty string&#39;, () =&gt; {        toCamel(&#39;&#39;).should.eql(&#39;&#39;);    });    it(&#39;underscore string&#39;, () =&gt; {        toCamel(&#39;hello_world&#39;).should.eql(&#39;helloWorld&#39;);    });    it(&#39;underscore string&#39;, () =&gt; {        toCamel(&#39;hello_World&#39;).should.eql(&#39;helloWorld&#39;);    });    it(&#39;underscore string&#39;, () =&gt; {        toCamel(&#39;hello-world&#39;).should.eql(&#39;hello-world&#39;);    });    it(&#39;normal string&#39;, () =&gt; {        toCamel(&#39;helloWorld&#39;).should.eql(&#39;helloWorld&#39;);    });});</code></pre><pre><code>/** * @param {String} str * @returns {String} */function toCamel(str) {    return str.replace(/_(.)/,(whole, matched) =&gt; {  // whole 就是 _(.) matched 就是 (.) // 括号在正则表达式里就是一个捕获的关系        return matched.toUpperCase();    });}module.exports = toCamel;console.log(whole, matched)  // _w w _W W</code></pre><h2 id="怎么做集成"><a href="#怎么做集成" class="headerlink" title="怎么做集成"></a>怎么做集成</h2><p>相当于有中央服务器做集成，我提交代码，服务器自动帮我跑</p><p><a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a></p><p><a href="http://blog.csdn.net/buptgshengod/article/details/39578353" target="_blank" rel="noopener">Travis setup guide</a></p><p>可以在 github 上做一个仓库，我一提交代码就会自动帮忙跑。（这个了解就好，其实都差不多的，就是人工跑代码和机器跑代码的区别）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：JS-单元测试&quot;&gt;&lt;a href=&quot;#补基础：JS-单元测试&quot; class=&quot;headerlink&quot; title=&quot;补基础：JS 单元测试&quot;&gt;&lt;/a&gt;补基础：JS 单元测试&lt;/h1&gt;&lt;h2 id=&quot;单元测试有啥用？&quot;&gt;&lt;a href=&quot;#单元测试有啥用？&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>补基础：React-Redux-ES6-webpack-babel</title>
    <link href="http://yoursite.com/2017/11/05/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9AReact-Redux-ES6-webpack-babel/"/>
    <id>http://yoursite.com/2017/11/05/补基础：React-Redux-ES6-webpack-babel/</id>
    <published>2017-11-05T13:19:16.000Z</published>
    <updated>2017-11-12T16:18:40.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：React-Redux-ES6-webpack-babel"><a href="#补基础：React-Redux-ES6-webpack-babel" class="headerlink" title="补基础：React-Redux-ES6-webpack-babel"></a>补基础：React-Redux-ES6-webpack-babel</h1><p><a href="https://www.docschina.org/" target="_blank" rel="noopener">印记中文</a></p><p>先看一遍中文文档，第二遍中英文对着看，第三遍才看英文文档</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p><a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React 官方文档</a></p><pre><code>/** * JSX : xml in JavaScript * 1、tagName * 2、attributes(props) * 3、children *//** * 组件化:  * 1、函数式组件props =&gt; JSX ;  * 2、类组件:class A extends Component; */ /** * 数据源 : state  + props * 更新数据: setState * 方案: 当数据越来越复杂的时候，我们需要一个数据解决方案 ==&gt; redux * 发起数据变更(click etc.) ==&gt; action * 生成新的数据结构(state[store])  ==&gt; redux的reducer生成react的state * 渲染(render) ==&gt; react来做 */</code></pre><h3 id="DOM-对比"><a href="#DOM-对比" class="headerlink" title="DOM 对比"></a>DOM 对比</h3><pre><code>// 传统方式&lt;div data-id=&#39;1&#39;&gt;    hello world&lt;/div&gt;// vue &lt;div data-id={{id}}&gt;    {{name}}&lt;/div&gt;{      data: ()=&gt; {          return {              name: &#39;hello world&#39;,              id: 1          }      }}// 注意 vue 是一个 MVVM 框架// 特点就是数据和模板分离// 实际上 react 也可以认为是一个 MVVM 框架var JSX = &lt;div data-id=&#39;1&#39;&gt;    hello world&lt;/div&gt;;render(JSX,document.getElementById(&#39;root&#39;));// 数据和模板绑定在一起Virtual dom&lt;div width=&#39;100px&#39;&gt;a&lt;/div&gt;==&gt;tagname: divattributes:{width: &#39;100px&#39;}children: a==&gt; IOS / Androidtagname: UIButtonattributes:{display: flex}children: ...</code></pre><h3 id="用-react-问候世界"><a href="#用-react-问候世界" class="headerlink" title="用 react 问候世界"></a>用 react 问候世界</h3><pre><code>import react, { Component } from &#39;react&#39; // 基础库import { render } from &#39;react-dom&#39;  // 平台库 这是 web 库// 为什么要引两个库呢？// 为了跨平台// 比如在 ios/android 用上 react-native// import from &#39;react-natiev&#39;render(    &lt;h1&gt;Hello, world&lt;/h1&gt;              // 要塞的代码    document.getElementById(&#39;root&#39;)    // 容器)// 接下来看看用 webpack 编译后的代码_react2.default.createElement(  &#39;h1&#39;,  null,  &#39;Hello, world!&#39;/* 也就是说 react 会把 JSX 分成三个部分 * tagname * attributes * children*/</code></pre><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><pre><code>// 这种模板语法就叫做 JSXimport React, { Component } from &#39;react&#39;import { render } from &#39;react-dom&#39;const RootDom = document.getElementById(&#39;root&#39;)let JSX = &lt;div name=&quot;frankie&quot;&gt;    Hello world&lt;span&gt;你好&lt;/span&gt;&lt;/div&gt;render(JSX, RootDom)// 以下是编译出来的结果/*var JSX = _react2.default.createElement(  &#39;div&#39;,  { name: &#39;jirengu&#39; },  &#39;Hello world&#39;,  _react2.default.createElement(    &#39;span&#39;,    null,    &#39;\u4F60\u597D&#39;  ));*/// 结构就相当于这个/*tagname: &#39;div&#39;attributes: {      name: &#39;frankie&#39;}children: &#39;hello world&#39;,{      tagname: &#39;span&#39;      attributes: null      children: &#39;你好&#39;}*/</code></pre><pre><code>// 值得注意的地方// JSX 可以防止 XSS 漏洞// 比如写在 JSX 里会直接输出，写在 HTML 会把 &amp;gt; 转成 &gt;render() {  let b = &#39;First &amp;gt; Second&#39;  return (&lt;div&gt; {b} &lt;/div&gt;)} // 如果要不转译该怎么办？/*dangerouslySetInnerHTML函数dangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。一般而言，使用JS代码设置HTML文档的内容是危险的，因为这样很容易把你的用户信息暴露给跨站脚本攻击.所以，你虽然可以直接在React中设置html的内容，但你要使用 dangerouslySetInnerHTML 并向该函数传递一个含有__html键的对象，用来提醒你自己这样做很危险。例如：function createMarkup() {  return {__html: &#39;First &amp;middot; Second&#39;};}function MyComponent() {  return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;}*/// 实际上，JSX 里面输入 false ，null ，undefined 都是不渲染的render() {  return (&lt;div&gt; {false} {null} {undefined} {0} &lt;/div&gt;)} // 那如果有个空格在中间呢？render() {  let b = &#39;First         Second&#39;  // 这里这个空格会打印么？ 不会的  return (&lt;div&gt; {b} &lt;/div&gt;)} // 还有一些属性啊，比如 onChange onClick 都要用驼峰命名</code></pre><p><a href="https://zhuanlan.zhihu.com/p/22500730?refer=study-fe" target="_blank" rel="noopener">XSS是什么</a> <a href="https://zhuanlan.zhihu.com/p/22521378?refer=study-fe" target="_blank" rel="noopener">CSRF是什么</a></p><h3 id="JS-in-JSX（动态化）"><a href="#JS-in-JSX（动态化）" class="headerlink" title="JS-in-JSX（动态化）"></a>JS-in-JSX（动态化）</h3><pre><code>// 记住要用大括号来包裹变量import React,{Component} from &#39;react&#39;;import {render} from &#39;react-dom&#39;;const RootDom= document.getElementById(&#39;root&#39;);let a = 1;let jsx1 = &lt;div&gt;{a}&lt;/div&gt;;let b = { id : 2 };let jsx2 = &lt;div&gt;{b.id}&lt;/div&gt;;let jsx3 = [&#39;i&#39;,&#39;love&#39;,&#39;react&#39;].map((name) =&gt; {    return &lt;div&gt;{name}&lt;/div&gt;});render(&lt;div&gt;    {jsx1}{jsx2}{jsx3}    &lt;/div&gt;, RootDom);// 事实上 render 还有第三个参数 callback</code></pre><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><pre><code>import React,{Component} from &#39;react&#39;;import {render} from &#39;react-dom&#39;;const RootDom = document.getElementById(&#39;root&#39;);/* * pure functional components  * it must never modify its own props */const A = (props) =&gt; {    return &lt;div&gt;{ props.gender } + { props.name }&lt;/div&gt;};render(&lt;A gender=&#39;male name=&#39;frankie&#39;/&gt;,RootDom);// tagname  A, ==&gt; 不是传统的html标签，而是个函数// attributes {   ==&gt; 函数的情况下 attributes === props//     gender: &#39;male&#39;,//     name: &quot;frankie&quot;// }// children: null/* * class components * - Adding Local State to a Class * - Adding Lifecycle Methods to a Class */ class FisstComponent extends Component{        constructor() {            super()            this.state = {                b: 1            }        }        render() {            return(                 &lt;div&gt;                      I am a component                      {this.state.b}                 &lt;/div&gt;            )        } } render(&lt;FirstComponent /&gt;,RootDom); // class 组件必须有 render 方法 // class 组件必须继承 Component // 组件为什么要大写？区分 HTML 和 组件</code></pre><h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life-cycle"></a>life-cycle</h3><p><a href="https://facebook.github.io/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/state-and-lifecycle.html</a></p><pre><code>// 写代码的时候更具有控制力import React,{Component} from &#39;react&#39;;import {render} from &#39;react-dom&#39;;const RootDom= document.getElementById(&#39;root&#39;);class FirstComponent extends Component{    constructor(){        super();        this.state = {            b:1        }    }    // shouldComponentUpdate / componentWillReceiveProps / componentDidMount 用得比较多    shouldComponentUpdate(){   // 组件是不是应该被更新        console.log(&#39;shouldComponentUpdate&#39;);        return true;    }    componentWillUnmount(){   // 组件将会移除        console.log(&#39;componentWillUnmount&#39;)    }    componentDidUpdate(){   // 组件更新好了        console.log(&#39;componentDidUpdate&#39;)    }    componentWillUpdate(){   // 组件将会更新        console.log(&#39;componentWillUpdate&#39;)    }    componentWillReceiveProps(){   // 组件获得了新的 props        console.log(&#39;componentWillReceiveProps&#39;)    }    componentWillMount(){   // 组件将被加载        console.log(&#39;componentWillMount&#39;)    }    componentDidMount(){   // 组件加载完成        this.setState({b:1})        console.log(&#39;componentDidMount&#39;)    }    render(){   // 组件将被渲染        console.log(&#39;render&#39;)        let a = &#39;10/26&#39;        return &lt;div&gt;               I am a component                   {a }                {this.state.b}            &lt;/div&gt;    } };render(&lt;FirstComponent /&gt;,RootDom);// componentWillMount// render// componentDidMount// shouldComponentUpdate// componentWillUpdate// render// componentDidUpdate</code></pre><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><pre><code>// &lt;A a=&#39;1&#39;&gt; ==&gt; props = {a:&#39;1&#39;}import React,{Component} from &#39;react&#39;;import {render} from &#39;react-dom&#39;;const RootDom= document.getElementById(&#39;root&#39;);class Welcome extends Component {  render() {    return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt;  }}/** props.children * React uses this.props.children to access a component&#39;s children nodes. * ==== ! props should be pure === // 不应该做任何修改 */class ChildComponent extends Component{    render(){        return (        &lt;div&gt;            {this.props.children}   // 如果 render 写成传统的 html 标签，那“我是个孩子”就是 {this.props.children}            &lt;Welcome gender=&#39;male&#39; name=&#39;frankie&#39; /&gt;        &lt;/div&gt;        );    } };render(&lt;ChildComponent&gt;我是个孩子&lt;/ChildComponent&gt;,RootDom); // 设置默认值 defaultProps // 方法 1 Welcome.defaultProps = {      gender: &#39;male&#39;,      name: &#39;frankie&#39; } // 方法 2 class Welcome extends Component {    static defaultProps = {       gender: &#39;male&#39;,         name: &#39;frankie&#39;    } }</code></pre><pre><code> // 类型检测 import PropTypes from &#39;prop-types&#39;; class Welcome extends Component {    static defaultProps = {       gender: PropTypes.string,         name: PropTypes.string    }    render(){          return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt;     } } // 假设这里传了数字怎么办？ ReactDOM.render(&lt;Welcome gender=&#39;0234&#39; name=&#39;0234&#39;/&gt;,RootDom)</code></pre><p><a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://reactjs.org/docs/typechecking-with-proptypes.html</a></p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><pre><code>// setState 是一个异步的操作// 改变数据只有一种方法 setStateimport React,{Component} from &#39;react&#39;;import {render} from &#39;react-dom&#39;;const RootDom= document.getElementById(&#39;root&#39;);/** * 数据源: state + props * props: parent ==&gt; child 【pure不能修改】 * state: 自身维护的数据状态 */class PropState extends Component{    constructor(){        super();        this.state={a:&#39;I am state&#39;}    }    click(){        /**         * setState ==&gt; 本组件重新render         */        this.setState({            a:&#39;我更新啦 哈哈哈&#39;        })    }    render(){        return &lt;div onClick={()=&gt;this.click()}&gt;                {this.state.a}                &lt;A name= {this.state.a} /&gt;              &lt;/div&gt;    } };const A = (props) =&gt; {    return &lt;div&gt;{props.name}&lt;/div&gt;}render(&lt;PropState/&gt;,RootDom);</code></pre><pre><code>// 定时器// 记住在 numount 要取消定时器，要不然很容易会造成内存泄露class Timer extends Component {    constructor() {          super()          this.state = {              count: 0,              time: (new Date()).toLocaleTimeString()          }    }    tick() {        this.setState({            count: 1,            time: (new Date()).toLocaleTimeString()        })        console.log(this.state.count)  // 0,因为 setState() 是异步函数            }    componentWillMount() {        this.interval = setInterval(() =&gt; this.tick(),1000)    }    componentWillUnmount() {          clearInterval(this.interval)    }    shouldComponentUpate(nextProps, nextState) {          return true;    }    render() {          return (&lt;div&gt;the time is {this.state.time}&lt;/div&gt;)    }}ReactDOM.render(&lt;Timer /&gt;,RootDom)</code></pre><h3 id="值得注意的地方"><a href="#值得注意的地方" class="headerlink" title="值得注意的地方"></a>值得注意的地方</h3><pre><code>// 绑定 this 的方法// 箭头函数和 constructor 都可以class Name extends Component {    constructor() {          super()          this.state = {              name: &#39;frankie&#39;          }          // 构造函数绑 this          // this.handleClick = this.handleClick.bind(this)    }    // 箭头函数绑 this    handleClick = () =&gt; {          alert(this.state.name)    }    render() {          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)    }}// 最后一种 ReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)// 这种是不建议的，会触发 componentWillReceiveProps 和 shouldComponentUpdate，假如在定时器里，子组件就会一直 render// 也不能在 render 里用箭头函数ReactDOM.render(&lt;Name onClick={this.handleClick}/&gt;,RootDom)</code></pre><pre><code>// 阻止事件冒泡/*先考虑一个东西写在 React 的 div 和原生的 div 是不一样的那它们的 event 是一样的吗？// &lt;div onclick=&quot;&quot;&gt;&lt;/div&gt;function test(event){  return false}// reacthandleClick = (event) =&gt; {}其实是不一样的react 的 event 是被封装过的，叫做 SyntheticEvent 能实现百分之九十的 event 原生事件 通过 ev.nativeEvent === event 封装ev.nativeEvent.stopImmediatePropagation()handleClick = (event) =&gt; {  setTimeout(()=&gt; {    console.log(event.type)  })  console.log(event.type)}react 的 event 是不能异步执行的react 的 event 有一个事件值，触发完成之后就会销毁*/class Name extends Component {    constructor() {          super()          this.state = {              name: &#39;frankie&#39;          }    }    handleClick() {          alert(this.state.name)          // 可以直接调用        // event.stopPropagation()        // event.preventDefault()    }        render() {          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)    }}ReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)</code></pre><h3 id="ref-和-DOM"><a href="#ref-和-DOM" class="headerlink" title="ref 和 DOM"></a>ref 和 DOM</h3><p><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">https://reactjs.org/docs/refs-and-the-dom.html</a></p><pre><code>// 利用 ref 操作 DOM// react 不建议直接操作 DOM 元素，性能不好class Name extends Component {    constructor() {          super()          this.state = {              name: &#39;frankie&#39;          }    }    handleClick = (event) =&gt; {          // var el = document.getElementById(&#39;content&#39;)          // this.refs.style.color = &#39;red&#39;  这是旧的          this.contentRef.style.color = &#39;red&#39;    }        render() {          return (          // &lt;div ref=&quot;content&quot;&gt;  这是旧的          &lt;div onClick={this.handleClick}&gt;            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;            my name is {this.state.name}            &lt;/div&gt;          &lt;/div&gt;)    }}ReactDOM.render(&lt;Name /&gt;,RootDom)/*其实上面这种做法 React 是不推荐的class Name extends Component {    constructor() {          super()          this.state = {              color: &#39;&#39;,              name: &#39;frankie&#39;          }    }    handleClick(event){        this.setState({              color: &#39;red&#39;        })    }        render() {          return (          /*          直接在标签上使用style属性时，          要写成style={{}}是两个大括号，          外层大括号是告知jsx这里是js语法，          和真实DOM不同的是，属性值不能是字符串而必须为对象，          需要注意的是属性名同样需要驼峰命名法。即margin-top要写成marginTop。          */          &lt;div style={{color: this.state.color}} onClick={this.handleClick.bind(this)}&gt;            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;            my name is {this.state.name}            &lt;/div&gt;          &lt;/div&gt;)    }}ReactDOM.render(&lt;Name /&gt;,RootDom)*/</code></pre><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><pre><code>class Name extends Component {    constructor() {          super()          this.state = {             let arr = [{              id: &#39;1&#39;,              name: &#39;dalao1&#39;            }, {              id: &#39;2&#39;,              name: &#39;dalao2&#39;            }, {              id: &#39;3&#39;,              name: &#39;dalao3&#39;            }]                       }    }    render() {          return (          &lt;div onClick={this.handleClick}&gt;            &lt;ul&gt;                {arr.map((item, i) =&gt; {                    // return &lt;li key={i}&gt;{item.name}&lt;/li&gt;                    // 这个 key 的作用是见下面                      return &lt;li&gt;{item.name}&lt;/li&gt;                })}            &lt;/ul&gt;          &lt;/div&gt;)    }}ReactDOM.render(&lt;Name /&gt;,RootDom)/*key 的作用 react 做 diff 算法的时候使用如果 key 能保持稳定，DOM 内容不变就可以避免重新渲染key 不要用 index 不要用随机数class Name extends React.Component {    constructor() {          super()          this.state = {             people : [{              id: &#39;1&#39;,              name: &#39;dalao1&#39;            }, {              id: &#39;2&#39;,              name: &#39;dalao2&#39;            }, {              id: &#39;3&#39;,              name: &#39;dalao3&#39;            }]                       }    }    handleClick(event) {        // 这里要用深拷贝        let people = this.state.people        let newPeople = people.map((person =&gt; {              let newPerson = {...person}  // 这里相当于浅拷贝              if (newPerson.id == &#39;2&#39;) {                  newPerson.name += &#39;haha&#39;              }              return newPeople  // 返回了新的地址相当于深拷贝        }))        this.setState({            people : newPeople        })    }        render() {          return (          &lt;div onClick={this.handleClick.bind(this)}&gt;            &lt;ul&gt;                {this.state.people.map((item, i) =&gt; {                    // return &lt;Person key={Math.random() * 100} item={item}&gt;&lt;/Person&gt;                    // 如果像上面一样，因为 key 是不一样的，所以 react 以为这个组件没有使用过，要重新构造一份                    return &lt;Person key={i} item={item}&gt;&lt;/Person&gt;                })}            &lt;/ul&gt;          &lt;/div&gt;)    }}class Person extends React.Component{    shouldComponentUpdate(nextProps, nextState) {          return nextProps.item.name !== this.props.item.name          // 如果不用深拷贝，nextProps.item.name === this.props.item.name 是 true，相等的原因是因为 item 是引用类型    }      render(){          console.log(&#39;render&#39; + this.props.item.id)          /*           这里打印的是          render1          render2          render3          避免 1 3 渲染的方法是          key 值要稳定          深拷贝          */          return &lt;li&gt;{this.props.item.name}&lt;/li&gt;      }}ReactDOM.render(&lt;Name /&gt;,mountNode)*/</code></pre><p><a href="https://segmentfault.com/a/1190000006752076" target="_blank" rel="noopener">JavaScript 深入了解基本类型和引用类型的值</a></p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><pre><code>/*方法有：三元 if else 组件 方法 &amp;&amp;判断*/class Name extends React.Component{      render(){          let isLogin = this.props.isLogin          let comp = null          if(isLogin){          comp = &lt;Logout /&gt;          }else{          comp = &lt;Login /&gt;          }          return(&lt;div&gt;              {comp}              // {isLogin ? &lt;Logout /&gt; : &lt;Login /&gt;}  // 主要用三元运算          &lt;/div&gt;)      }}class Login extends React.Component{      render(){          return &lt;div&gt;login&lt;/div&gt;      }}class Logout extends React.Component{      render(){          return &lt;div&gt;logout&lt;/div&gt;      }}ReactDOM.render(&lt;Name isLogin={true}/&gt;,mountNode)/*可以封装成一个组件function SignIn(isLogin) {      if(isLogin){      return &lt;Logout/&gt;      }else{      return &lt;Login/&gt;      }}// 在 render 写render(){  return(&lt;SignIn isLogin={isLogin}/&gt;)}*//*也可以做成一个方法getLogIn(isLogin) {  if(isLogin){    return &lt;Logout /&gt;  }else{    return &lt;login/&gt;  }}render(){  return(&lt;div&gt;      {this.getLogin(isLogin)}  &lt;/div&gt;)}*//*还有一种用 &amp;&amp; 判断{isLogin &amp;&amp; &lt;Logout/&gt;}{isLogin &amp;&amp; &lt;LoginIn/&gt;}*/</code></pre><h3 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h3><pre><code>/*传一个组件出一个组件其实可以理解为一个给基础组件加方法的处理器比如说有两个组件 Ad1 Ad2 他们有 abc 三个方法Ad1Component{  a(){};b(){};c(){};}Ad2Component{  a(){};b(){};c(){};}那我们可以把方法抽离出一个 Basic 组件BasicComponent{  a(){};b(){};c(){};}然后写到 HOC 转换function wrapper(WrapperComponent){  return BasicComponent{    a(){};b(){};c(){};    render(){      return &lt;WrapperComponent /&gt;    }  }}*/// 写个例子// 在 input 组件的名字改变的时候加上一些日志的方法但是不能 input 组件上写（为什么会有这个需求？因为有可能这个组件不是你自己写的）/*想到一个方法用 prototype 但是会影响原型链 function logProps(InputComponent) {    InputComponent.prototype.componentWillReceiveProps = function(nextProps, nextState) {      console.log(&#39;============&#39;)      console.log(&#39;Current props: &#39;, this.props);      console.log(&#39;Next props: &#39;, nextProps);    };    return InputComponent;}*/// 正确的方法应该是利用 HOC 封装方法class InputComponent extends React.Component{    componentWillReceiveProps() {    }    render() {        return &lt;div&gt;{this.props.name}&lt;/div&gt;    }}function logProps(WrappedComponent) {    return class extends React.Component {  // 匿名组件，要实现的共有方法都在这里做      componentWillReceiveProps(nextProps) {            console.log(&#39;Current props: &#39;, this.props);        console.log(&#39;Next props: &#39;, nextProps);      }      render() {        return &lt;WrappedComponent {...this.props} /&gt;;      }    }}const EnhancedComponent = logProps(InputComponent); let name = &#39;dalao&#39;; setInterval(() =&gt; {    name += &#39; hah&#39;;    ReactDOM.render(&lt;EnhancedComponent name={name} /&gt;, document.getElementById(&#39;root&#39;)); }, 1000)</code></pre><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p><a href="http://www.redux.org.cn/" target="_blank" rel="noopener">Redux 官方文档</a></p><p><a href="https://github.com/slashhuang/redux-annotation" target="_blank" rel="noopener">https://github.com/slashhuang/redux-annotation</a></p><p><img src="https://ooo.0o0.ooo/2017/11/04/59fd9c6002509.jpg" alt=""></p><h3 id="第一个简单的例子"><a href="#第一个简单的例子" class="headerlink" title="第一个简单的例子"></a>第一个简单的例子</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()</a></p><pre><code>import { createStore } from &#39;redux&#39;const initState = {}const reducer = (state, action) =&gt; {    return action}const store = createStore(reducer, initState)store.dispatch({    type: &#39;init&#39;,    payload: &#39;hello world&#39;})console.log(store.getState())// redux 的整体架构// action (动作) ===&gt; 发起 AJAX// reducer (Handler处理器) ===&gt; JSON 处理// state (最后的状态) ===&gt; JSON 保存起来// 通常从后端拉数据的流程是这样的// AJAX ===&gt; JSON ===&gt; UI// 所以上面这个代码拆分开来就是const action = {      type: &#39;init&#39;,      payload: &#39;hello world&#39;,}const reducer = (state, action) =&gt; {  // state 是前一次保存的数据状态      return Object.assign({}, state, action);  // 生成下一个数据状态}const store = createStore(reducer, initState)store.dispatch(action)console.log(store.getState())</code></pre><h3 id="createStore-源码"><a href="#createStore-源码" class="headerlink" title="createStore 源码"></a>createStore 源码</h3><pre><code>// 需要注意的是第一个参数和第二个参数（reducer, 初始化的 state）export default function createStore(reducer, preloadedState, enhancer)/*判断...*/var currentReducer = reducer;  // 当前的处理器var currentState = preloadedState;   // 当前的state ===&gt; 初始化的 statevar currentListeners = []; var nextListeners = currentListeners;var isDispatching = false;  // 不执行/*往下看*/function getState() {    return currentState;  // 直接 return currentState}/*往下看*/  function dispatch(action) {    try {      isDispatching = true;      currentState = currentReducer(currentState, action);        // 用当前的 reducer 处理当前的 state 和 action      // 只要 dispatch(action) 就会处理一遍生成一个 state    } finally {      isDispatching = false;    }    var listeners = currentListeners = nextListeners;    for (var i = 0; i &lt; listeners.length; i++) {      var listener = listeners[i];      listener();    }    return action;  // 返回一个 action  }/*往下看*/  return _ref2 = {    dispatch: dispatch,    subscribe: subscribe,    getState: getState,    replaceReducer: replaceReducer  }, _ref2[$$observable] = observable, _ref2;  // 最后也是返回出来</code></pre><h3 id="回看例子分析-createStore-源码"><a href="#回看例子分析-createStore-源码" class="headerlink" title="回看例子分析 createStore 源码"></a>回看例子分析 createStore 源码</h3><pre><code>import { createStore } from &#39;redux&#39;const initState = {}const action = {      type: &#39;init&#39;,      payload: &#39;hello world&#39;,}const reducer = (state, action) =&gt; {   // currentState = currentReducer(currentState, action);        return Object.assign({}, state, action);  // 当前的数据状态}debuggerconst store = createStore(reducer, initState)  // reducer = (state, action) =&gt; {...}, initState = {}debuggerstore.dispatch(action)  // 所以 store 有 dispatch 方法console.log(store.getState())  // return currentState// Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}// debugger 看过程// var currentReducer = reducer;  // currentReducer = function reducer(state, action), reducer = function reducer(state, action)// var currentState = preloadedState;  // currentState = Object {}, preloadedState = Object {}/*跳到 dispatch return 一个 API 集合*//*下一个 debuggercurrentState = currentReducer(currentState, action); 进去看一下return Object.assign({}, state, action);  做一个覆盖currentState 变成了 Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}*//*看一下 console.log(store.getState())function getState() {    return currentState; // 返回 currentState}*/--------------------------------------------------------------------// 修改一下代码import { createStore } from &#39;redux&#39;const initState = {}const action = {      type: &#39;init&#39;,      payload: &#39;hello world&#39;,}const reducer = (state, action) =&gt; {      return Object.assign({}, state, action);}const store = createStore(reducer, initState)debuggerstore.subscribe(() =&gt; {      console.log(&#39;我注册啦&#39;)})store.dispatch(action)console.log(store.getState())// store.subscribe 进去看看/*  function subscribe(listener) {    //...    nextListeners.push(listener);    // nextListeners 是一个长度为零的数组，把 listener push 进去    return function unsubscribe() {        // ...    };  }*/// store.dispatch(action) 进去看看/*  function dispatch(action) {    //...    // 这里会读当前的观察者数组    var listeners = currentListeners = nextListeners;    for (var i = 0; i &lt; listeners.length; i++) {      var listener = listeners[i];      listener();    }    return action;  }  ---------------------  在 console 打 listeners 会打印出 [function]  listeners[0] 是  function () {      console.log(&#39;我注册啦&#39;);  }*//*需要注意的一点是  // When a store is created, an &quot;INIT&quot; action is dispatched so that every  // reducer returns their initial state. This effectively populates  // the initial state tree.  dispatch({ type: ActionTypes.INIT })  也就是说，每调用一遍 createStore 就会执行一遍 dispatch({ type: ActionTypes.INIT })  所以初始化的 action 是 type: &quot;@@redux/INIT&quot;*/</code></pre><h3 id="怎么改变-dom"><a href="#怎么改变-dom" class="headerlink" title="怎么改变 dom"></a>怎么改变 dom</h3><pre><code>// HTML    &lt;div id=&#39;root&#39;&gt;        1    &lt;/div&gt;// JSimport { createStore } from &#39;redux&#39;const ROOTDOM = document.getElementById(&#39;root&#39;)const initState = {}const action = {      type: &#39;init&#39;,      payload: &#39;hello world&#39;,}const reducer = (state, action) =&gt; {        return Object.assign({}, state, action); }const store = createStore(reducer, initState) store.subscribe(() =&gt; {      ROOTDOM.innerHTML = JSON.stringify(store.getState())})let counter = 0ROOTDOM.addEventListener(&#39;click&#39;, () =&gt; {      counter++      const action = {          type: &#39;click&#39;,          payload: counter      }      store.dispatch(action)})</code></pre><h3 id="实现一个MVVM"><a href="#实现一个MVVM" class="headerlink" title="实现一个MVVM"></a>实现一个MVVM</h3><pre><code>// HTML&lt;input id=&quot;name&quot;/&gt;数据预览区&lt;div id=&quot;preview&quot;&gt;&lt;/div&gt;&lt;div id=&#39;root&#39;&gt;1&lt;/div&gt;// JSimport { createStore } from &#39;redux&#39;;const initState = {};const action = {    type: &#39;init&#39;,    payload: &#39;hello world&#39;,};const reducer = (state, action) =&gt; {    return Object.assign({}, state, action);};const store = createStore(reducer, initState);const INPUTDOM = document.getElementById(&#39;name&#39;);const PREVIEWDOM = document.getElementById(&#39;preview&#39;);const digestUI = () =&gt; {    PREVIEWDOM.innerHTML = store.getState().payload;    if (PREVIEWDOM.innerHTML.length &gt; 20) {        alert(&#39;length is 20&#39;)    }};const inputChange = () =&gt;{    let val = INPUTDOM.value;    const action = {        type: &#39;input_change&#39;,        payload: val,    };    store.dispatch(action);};let counter = 0;INPUTDOM.addEventListener(&#39;input&#39;, inputChange)store.subscribe(digestUI);// 可以看出好处就是行为都是分离的</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><pre><code>// redux中的applyMiddleware中间件// Middleware makes it easier for software developers// to implement 【communication and input/output】,// so they can focus on the 【specific purpose of their application】.// 更专注 service 服务 input/output service 输入和输出// ajax ==&gt; json(乱得一笔) =service转换(中间件)=&gt; UI(整理成好的)// express/Koa// 前端// ajax ==http==&gt;// httpRequest(head,cookie,body)// middlewares(解析cookie, 拿到post请求的数据)// 数据就是好的一笔的数据// 后端(node.js)// 看一个例子// 注意下面这些很多箭头的叫做高阶函数// 例如 const highFunction = a =&gt; b =&gt; c =&gt; console.log(a+b+c); highFunction(1)(2)(3) // 6 // 一个函数执行完之后返回值是一个函数// 多参函数 ===&gt; 单参函数// 如果在 createStore 用上 enhancer 逻辑就会被 applyMiddleware 控制// return enhancer(createStore)(reducer, preloadedState)// 前一个 next 指向下一个 action=&gt; { next(action) }; 最后一个 next 指向 dispatch // 没有中间件 action ==&gt; ==dispatch==&gt; reducer ==&gt; nextState;// 有中间件 action ==middlewares==&gt; ==dispatch==&gt; reducer ==&gt; nextState;// applyMiddleware 的思想是把一堆函数封装成一个函数import { createStore, applyMiddleware } from &#39;redux&#39;;const logger1 = store =&gt; next =&gt; action =&gt; {    console.log(&#39;current dipatch&#39; + JSON.stringify(action));    next(action);};const logger2 = store =&gt; next =&gt; action=&gt; {    next(action);};const logger3 = store =&gt; next =&gt; action=&gt; {    next(action);};const enhancer = applyMiddleware(logger1, logger2, logger3);const reducer = (state, action) =&gt; state;const store = createStore(reducer, {}, enhancer);store.dispatch({type:1});store.dispatch({type:2});store.dispatch({type:3});</code></pre><p>action 的另一种写法 <a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="noopener">https://github.com/acdlite/flux-standard-action</a></p><p><a href="https://stackoverflow.com/questions/32646920/whats-the-at-symbol-in-the-redux-connect-decorator" target="_blank" rel="noopener">What’s the ‘@’ (at symbol) in the Redux @connect decorator?</a></p><p><a href="http://taobaofed.org/blog/2016/08/18/react-redux-connect/" target="_blank" rel="noopener">React 实践心得：react-redux 之 connect 方法详解</a></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6 教程</a></p><p><a href="https://frankietang.github.io/2017/10/14/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="noopener">摸到 ES6 的门把手</a></p><p>Stage 0 - Strawman（展示阶段）</p><ul><li>Stage 1 - Proposal（征求意见阶段）</li><li>Stage 2 - Draft（草案阶段）</li><li>Stage 3 - Candidate（候选人阶段）</li><li>Stage 4 - Finished（定案阶段）</li></ul><p>配 babel 的时候有用 </p><h3 id="Set-和-Map-的数据结构"><a href="#Set-和-Map-的数据结构" class="headerlink" title="Set 和 Map 的数据结构"></a>Set 和 Map 的数据结构</h3><p><a href="https://github.com/ruanyf/es6tutorial/blob/2ac6e76b38f117f2acf6c465ab70709275b4241a/docs/set-map.md" target="_blank" rel="noopener">set-map</a></p><pre><code>// 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。let s = new Set()s.size // 0s.add(1) // {1}s.size // 1s.add(1) // {1}s.size // 1s.add(&#39;1&#39;) // {1,&#39;1&#39;}s.size // 2// 如何快速去除数组里的重复元素[...new Set([1,2,3,4,5,4,3,2,1])]  // (5) [1, 2, 3, 4, 5]</code></pre><h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h3><pre><code>// 对类做一个封装// 懂了，大概就是在 class 上面绑定方法可以直接调用function divide(target){  target.prototype.divide = function(a,b) {return a/b}  return target}@divideclass Math{  add(a,b){    return a+b  }}let m = new Math()console.log(m.divide(6,3)) // 2// 再封装多一个判断function divide(needAdd){  return function(target){    if(needAdd){      target.prototype.divide = function(a,b) {return a/b}    }  }  return target}@divide(true)class Math{  add(a,b){    return a+b  }}let m = new Math()console.log(m.divide(6,3)) // 2</code></pre><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack 官方文档</a></p><h3 id="webpack-与-react"><a href="#webpack-与-react" class="headerlink" title="webpack 与 react"></a>webpack 与 react</h3><pre><code>// 主要是配 loaders{    test: /\.js[x]?$/,        // 符合 js 或者 jsx    loader: &quot;babel-loader&quot;,   // 运行 babel-loader    exclude: /node_modules/},</code></pre><p>说实话 webpack 这东西翻翻文档就好，不用死记硬背的。要什么功能直接 Google ，<code>npm i -D &lt;package&gt;</code></p><p><a href="https://juejin.im/post/59bb37fa6fb9a00a554f89d2" target="_blank" rel="noopener">webpack：从入门到真实项目配置</a></p><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p><a href="http://babeljs.io/" target="_blank" rel="noopener">babel 官方文档</a></p><h3 id="babel-1"><a href="#babel-1" class="headerlink" title="babel"></a>babel</h3><pre><code>// 因为 react 用的是 JSX 所以需要用到 babel// 不止 JSX 还有高阶组件(HOC) 要用到 es7 的 Decorator// 把这一堆代码转换成 JS// 以下是配法 {  &quot;presets&quot;: [     &quot;stage-0&quot;, // 草案 0     &quot;es2015&quot;,  // es6     &quot;react&quot;    // react  ],   &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]  // 翻译 Decorator}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：React-Redux-ES6-webpack-babel&quot;&gt;&lt;a href=&quot;#补基础：React-Redux-ES6-webpack-babel&quot; class=&quot;headerlink&quot; title=&quot;补基础：React-Redux-ES6-webpac
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>deepin shadowsocks-qt5 全局翻了个墙</title>
    <link href="http://yoursite.com/2017/10/25/deepin%20shadowsocks-qt5%20%E5%85%A8%E5%B1%80%E7%BF%BB%E4%BA%86%E4%B8%AA%E5%A2%99/"/>
    <id>http://yoursite.com/2017/10/25/deepin shadowsocks-qt5 全局翻了个墙/</id>
    <published>2017-10-24T16:58:53.000Z</published>
    <updated>2017-12-11T08:47:31.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deepin-shadowsocks-qt5-全局翻了个墙"><a href="#deepin-shadowsocks-qt5-全局翻了个墙" class="headerlink" title="deepin shadowsocks-qt5 全局翻了个墙"></a>deepin shadowsocks-qt5 全局翻了个墙</h1><p>最近真的是非常时期 <code>git push</code> <code>git pull</code> <code>git clone</code> 全部显示了</p><p>Connection closed by 192.30.255.113 port 22</p><p>以下是解决办法</p><pre><code>sudo apt-get install shadowsocks-qt5sudo apt-get install proxychains// 配置 /etc/proxychains.conf// 不要 socks4 127.0.0.1 9095 加上socks5 127.0.0.1 1080// 然后在每一条命令都加上proxychains</code></pre><p>关于怎么配 shadowsocks-qt5 网上一搜一大把，祝各位看到这篇文章能早日肉身翻墙吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deepin-shadowsocks-qt5-全局翻了个墙&quot;&gt;&lt;a href=&quot;#deepin-shadowsocks-qt5-全局翻了个墙&quot; class=&quot;headerlink&quot; title=&quot;deepin shadowsocks-qt5 全局翻了个墙&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="fq" scheme="http://yoursite.com/tags/fq/"/>
    
  </entry>
  
  <entry>
    <title>补基础：函数</title>
    <link href="http://yoursite.com/2017/10/24/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/10/24/补基础：函数/</id>
    <published>2017-10-23T17:19:56.000Z</published>
    <updated>2017-11-05T14:42:01.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：函数"><a href="#补基础：函数" class="headerlink" title="补基础：函数"></a>补基础：函数</h1><blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">函数</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments" target="_blank" rel="noopener">实参</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" target="_blank" rel="noopener">length</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">call</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">apply</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">Generator Function</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener">Generator</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" target="_blank" rel="noopener">迭代器协议</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" rel="noopener">for of</a></li></ul></blockquote><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><pre><code class="1">function fn() {      console.log(1)}fn() // 1// 传东西function fn(num, fn) {      console.log(fn(num))}fn(1, function(a){      return a + 1}) // 2</code></pre><pre><code>// whether fn is functionfunction fn() {}console.log(typeof fn === &#39;function&#39;)console.log(fn instanceof Function)console.log(Object.prototype.toString.call(fn) === &#39;[object Function]&#39;)</code></pre><pre><code>// 函数调用和没调用的区别function fn2() {      return 2}fn2()let obj = {      fn: fn2}console.log(obj.fn)     // 返回是一个函数console.log(obj.fn())   // 返回函数的结果</code></pre><pre><code>// 函数的借用let user = {      name: &#39;xiaohong&#39;,      sayHi: function() {          console.log(&#39;hello my name is &#39; + this.name)      }}uesr.sayHi()  // hello my name is xiaohong// 怎么借用方法let user2 = {name: &#39;xiaohei&#39;}// to-douser.sayHi.call(user2)// hello my name is xiaohongsetTimeout(function() {      console.log(&#39;hello&#39;)}, 1000)// 怎么写成一行呢？setTimeout(console.log.bind(null, &#39;hello&#39;), 1000)// 举个实用场景// var collection = document.getElementsByClassName(&#39;a&#39;)// 但是 collection 没有 forEach 方法// Array.prototype.forEach.call(collection)</code></pre><h2 id="形参-parameters-vs-实参-arguments"><a href="#形参-parameters-vs-实参-arguments" class="headerlink" title="形参(parameters) vs 实参(arguments)"></a>形参(parameters) vs 实参(arguments)</h2><p>实参是实际传进来的参数</p><p>形参是定义时候的参数</p><pre><code class="javascrip">// argumentsfunction fn(a, b) {    console.log(a, b)      console.log(arguments)      console.log(arguments.length)}function fn(a, b, ...args) {    console.log(a, b)      console.log(args)   // [3,4]      let args1 = Array.prototype.slice.call(arguments, 2)      console.log(args1)  // [3,4]}fn(1,2,3,4)// 1 2// { &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3, &#39;3&#39;: 4 }// 4let arr = [1,2,3]arr.push(1,2,3,4,5)console.log(arr)Array.prototype.push = function() {    // arguments      let args = Array.prototype.slice.call(arguments)}</code></pre><pre><code>// parametersfunction fn(a, b) {      console.log(arguments.length)}fn(1,2,3,4)console.log(fn.length) // 2 形参个数 = 函数名.length// 实现一个功能function sum(a, b, c) {      return a + b + c}console.log(sum(1,2,3))// fn 是一个函数function curry(fn) {    var len = fn.length      return function f1() {          let args = Array.prototype.slice.call(arguments)          if(args.length &lt; len) {              return function() {                  let args2 = Array.prototype.slice.call(arguments)                  return f1.apply(this, args.concat(args2))              }          } else {              return fn.apply(null,args)          }      }}let sumWithCurry = curry(sum) sumWithCurry(1,2,3)   // 6 len = 3, args.length = 3 sum.apply(null,[1,2,3])sumWithCurry(1)(2,3)  // 6// 先运行 sumWithCurry(1) 然后吃掉后面的函数 利用 concat sumWithCurry(1,2)(3)  // 6</code></pre><p><a href="https://github.com/n0ruSh/the-art-of-reading/issues/5" target="_blank" rel="noopener">柯里化</a></p><h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h2><pre><code>// 在 function 加一个 * 号就可以变成一个 Generator 函数function* fn() {      yield 3;      yield 4;      // console.log(&#39;hello&#39;)}console.log(typeof fn)     // functionconsole.log(fn())          // {}let iterator = fn()console.log(iterator.next())  // {value: 3, done: false}console.log(iterator.next())  // {value: 4, done: false}console.log(iterator.next())  // {value: undefined, done: true}// 3 -&gt; 4 -&gt; donefor(let i of fn()) {  // for of 遍历方法，可以遍历数组      console.log(i)}// 3// 4// 看看是怎么做到的let arr = [2,3,4]let iterator = arr[Symbol.iterator]()console.log(iterator.next()) // {value: 2, done: false}console.log(iterator.next()) // {value: 3, done: false}console.log(iterator.next()) // {value: 4, done: false}console.log(iterator.next()) // {value: undefined, done: true}// 只要符合迭代器 就可以用 for of 方法for(let j of iterator) {      console.log(j)}// 也可以遍历对象Object.defineProperty(Object.prototype, Symbol.iterator, {      enumerable: false,      writable: false,      configurable: false,      value: function() {          let self = this;          let keys = Object.keys(self); // [&#39;a&#39;, &#39;d&#39;]          let index = 0;          return {              next: function() {                  return {                      value: self[keys[index++]],  // 加点注释啥的 + &#39;suffix&#39;                      done: index &gt; keys.length                  }              }          }      }})let obj = {a: &#39;b&#39;, c: &#39;d&#39;}let iterator2 = obj[Symbol.iterator]()console.log(iterator2.next()) // {value: &#39;b&#39;, done: false}console.log(iterator2.next()) // {value: &#39;d&#39;, done: false}console.log(iterator2.next()) // {value: undefined, done: true}for(let val of obj) {      console.log(val)}let obj2 = {name: &#39;xiaohong&#39;, age: 20, sex: &#39;male&#39;}for(let j of obj2) {  // 只要支持迭代器协议就可以了      console.log(j)}</code></pre><pre><code>// 彩蛋 和 Promise 的比较// Promisenew Promise().then().then().then()// yield + generatorlet a = yield promise1let b = yield promise2let c = yield promise3// 看起来像是同步，实际上是异步</code></pre><pre><code>// 彩蛋2 为什么不支持 for of 遍历对象// 原因有可能是这样的// 数组不关心索引，对象关心let arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] = {      &#39;0&#39; : &#39;a&#39;,      &#39;1&#39; : &#39;b&#39;,      &#39;2&#39; : &#39;c&#39;,}let obj = {      &#39;a&#39;: &#39;b&#39;,      &#39;c&#39;: &#39;d&#39;}</code></pre><p>其实有两个新方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="noopener">Object.values()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener">Object.entries()</a> 可以遍历，Object.values() 只返回 value ，Object.entries() 返回全部</p><pre><code>// 彩蛋3 Symbol 是用来干嘛的？// 避免相等的值重复let a = &#39;a&#39;let b = &#39;a&#39;let obj = {}obj[a]obj[b]</code></pre><p><a href="http://www.infoq.com/cn/articles/es6-in-depth-symbols" target="_blank" rel="noopener">深入浅出ES6（八）：Symbols</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：函数&quot;&gt;&lt;a href=&quot;#补基础：函数&quot; class=&quot;headerlink&quot; title=&quot;补基础：函数&quot;&gt;&lt;/a&gt;补基础：函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>补基础：对象与数组的遍历方式</title>
    <link href="http://yoursite.com/2017/10/22/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/10/22/补基础：对象与数组的遍历方式/</id>
    <published>2017-10-22T13:40:50.000Z</published>
    <updated>2017-11-05T14:42:01.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：对象与数组的遍历方式"><a href="#补基础：对象与数组的遍历方式" class="headerlink" title="补基础：对象与数组的遍历方式"></a>补基础：对象与数组的遍历方式</h1><blockquote><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="noopener">Object.getOwnPropertyNames</a></li></ul><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a></li></ul><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener">Object.getOwnPropertyDescriptor</a></li></ul><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" target="_blank" rel="noopener">getOwnPropertyDescriptors</a></li></ul></blockquote><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><pre><code>let arr = [1, 2, 3]for(let i = 0, len = arr.length; i &lt; len; i++){      console.log(arr[i])}arr.forEach((it, index, self) =&gt; {      console.log(it, index, self)})// 1 0 [1,2,3]// 2 1 [1,2,3]// 3 2 [1,2,3]// 等于arr.forEach(console.log)</code></pre><h2 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h2><pre><code>let obj = {a: &#39;b&#39;, c: &#39;d&#39;}// 打印出// key a -&gt; b// key c -&gt; dfor(let key in obj) {      console.log(`key ${key} -&gt; ${obj[key]}`)}// 要注意的是，for in 会遍历原型链上的属性// 但是并没有打印到 console.log(obj.toString) 这个值// 没有打印 key toString -&gt; [Function: toString]Object.prototype.test = &#39;mytest&#39;// key a -&gt; b// key c -&gt; d// key test -&gt; mytest// 说明确实会遍历找到原型链上的属性// 那为什么 toString 没有打印出来？console.log(Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;))// {writable: true, enumerable: false, configurable: true, value: ƒ}// 通过 getOwnPropertyDescriptor 看到 enumerable 的确是 false ，说明了不可枚举。 // 所以说 Object.prototype 里面内置的方法大多数都是不可枚举的</code></pre><pre><code>// 那怎么可以只 for in 自身属性呢而不会遍历其他赋予到原型链上的属性呢？ （有的第三方库会在原型链上赋值）let obj = {a: &#39;b&#39;, c: &#39;d&#39;}Object.prototype.test = &#39;mytest&#39;for(let key in obj) {    // 只遍历自身属性 可以加一层判断    if(obj.hasOwnProperty(key)) {          console.log(`key ${key} -&gt; ${obj[key]}`)    }}</code></pre><pre><code>// 看一个使用场景function validUser(obj) {    // 同时具有name, age属性的为合法用户    return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp; obj.hasOwnProperty(&#39;age&#39;)}console.log(validUser({name: &#39;mike&#39;})); // false;console.log(validUser({age: 15})); // falseconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // true</code></pre><p>要注意不能用 <code>(!!obj.name &amp;&amp; !!obj.age)</code> 这种方法，要考虑到 <code>{age: 0}</code> 的可能性或者其他 如：<code>!!0 -&gt; false</code> <code>!!{} -&gt; true</code> <code>!![] -&gt; true</code> <code>!!&#39;&#39; -&gt; false</code></p><pre><code>// 多个属性function validUser(obj) {    // 同时具有 name, age, sex 属性的为合法用户    // 若是上面那种做法，会导致多属性很麻烦    // return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp;     //          obj.hasOwnProperty(&#39;age&#39;) &amp;&amp;    //          obj.hasOwnProperty(&#39;sex&#39;)    // 以下为解决方法    return requiredFields.every((it) =&gt; {          return obj.hasOwnProperty(it)    })}// 可以先配置成一个数组, 改变量就好let requiredFields = [&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;]console.log(validUser({name: &#39;mike&#39;})); // false;console.log(validUser({age: 15})); // falseconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // trueconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18, sex: &#39;ddd&#39;})); // true</code></pre><h2 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h2><pre><code>// 另外一种遍历方法 Object.keys(obj)let obj = {a: &#39;b&#39;, c: &#39;d&#39;}Object.prototype.test = &#39;myTest&#39;Object.keys(obj).forEach((key) =&gt; {      console.log(`key ${key} -&gt; ${obj[key]}`)})// 这个方法只能遍历到自身可枚举属性，那有没有办法可以遍历到不可枚举属性呢？// 打印所有自身属性，包含不可枚举console.log(Object.getOwnPropertyNames(obj)) // [&quot;a&quot;, &quot;c&quot;, &quot;nonEnumerable&quot;]Object.getOwnPropertyNames(obj).forEach((key) =&gt; {      console.log(`key ${key} -&gt; ${obj[key]}`)})// key a -&gt; b// key c -&gt; d// key nonEnumerable -&gt; static// 设置不可枚举的方法Object.defineProperty(obj, &#39;nonEnumerable&#39;, {    enumerable: false,    configurable: false,    writable: false,    value: &#39;static&#39;});console.log(obj.nonEnumerable) // &#39;static&#39;console.log(obj.hasOwnProperty(&#39;nonEnumerable&#39;)) // ture// 说明 obj 自身有 nonEnumerable ，设置为 static</code></pre><h2 id="get-set"><a href="#get-set" class="headerlink" title="get - set"></a>get - set</h2><p>数据双向绑定</p><pre><code>let obj = {a: &#39;b&#39;}// 可以这样Object.defineProperty(obj, &#39;c&#39;, {    get() {        // business logic 业务逻辑        // if(...) {        //      throw Error()        // }         // return 3           return 2    },    set() {           // 绑定逻辑 vue 的原理          console.log(&#39;setting value&#39;)    }});console.log(obj.c) // 在什么情况下会打印出 2 ？obj.c = 10         // 相当于运行了 set() 这个函数 打印出 setting valueconsole.log(obj.c) // 仍然是 2// 也就是说可以变成一个私有变量</code></pre><pre><code>// 如果要设置深层次的赋值obj = {    a: {        b: {            c: {                d: 3            }        }    }}console.log(obj.a.b.c.d); // 3// 用 definePropertyObject.defineProperty(obj, &#39;_deep&#39;, {    get: function(){        return obj.a.b.c.d;    }});console.log(obj._deep); //3</code></pre><h2 id="怎么大小通吃"><a href="#怎么大小通吃" class="headerlink" title="怎么大小通吃"></a>怎么大小通吃</h2><pre><code>// 对象和数组一起遍历function _each(objOrArray, callback) {    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){        objOrArray.forEach(callback);     }    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){        for(let key in objOrArray){            if(objOrArray.hasOwnProperty(key)){                callback(key,objOrArray[key]);            }        }    }      }_each([1,2,3], function(it, index) {    console.log(it + index);  }); // 1// 3// 5_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {    console.log(key + value);});// ab// cd</code></pre><pre><code>// 设置一个上下文function _each(objOrArray, callback, ctx){    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){        objOrArray.forEach(callback, ctx || this);     }    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){        for(let key in objOrArray){            if(objOrArray.hasOwnProperty(key)){                callback.call(ctx || this, key,objOrArray[key]);            }        }    }}_each([1,2,3], function(it, index) {    console.log(it + index + this.a);  }, {a: 3}); // 4// 6// 8_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {    console.log(key + value + this.a);}, {a: &#39;e&#39;});// abe// cde</code></pre><p>三板斧 <code>typeof</code> <code>Array.isArray([1,2])</code> <code>(Object.prototype.toString.call([1,2])</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：对象与数组的遍历方式&quot;&gt;&lt;a href=&quot;#补基础：对象与数组的遍历方式&quot; class=&quot;headerlink&quot; title=&quot;补基础：对象与数组的遍历方式&quot;&gt;&lt;/a&gt;补基础：对象与数组的遍历方式&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>补基础：this</title>
    <link href="http://yoursite.com/2017/10/19/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9Athis/"/>
    <id>http://yoursite.com/2017/10/19/补基础：this/</id>
    <published>2017-10-19T13:23:13.000Z</published>
    <updated>2017-11-05T14:42:01.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：this"><a href="#补基础：this" class="headerlink" title="补基础：this"></a>补基础：this</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/23804247?refer=study-fe" target="_blank" rel="noopener">this 的值到底是什么？一次说清楚</a></p><p><a href="https://zhuanlan.zhihu.com/p/25991271" target="_blank" rel="noopener">你怎么还没搞懂 this？</a></p><p>this的值是在函数调用的时候决定，而不是定义的时候决定</p></blockquote><h2 id="this-的四种绑定规则"><a href="#this-的四种绑定规则" class="headerlink" title="this 的四种绑定规则"></a>this 的四种绑定规则</h2><pre><code>// 默认绑定window.a = 3;function f() {    let a = 4;    console.log(this.a);}f(); // 3// 通过上面的文章我们得出其实是 f().call(undefined) 默认为 global</code></pre><pre><code>// 隐式绑定window.a = 3;let obj = {    a: 4,    f: function() {        console.log(this.a);    }};let obj1 = {    a: 4,    obj: {        a: 5,        f: function() {            console.log(this.a);        }    }};obj.f() // obj.f.call(obj) 所以是 4obj1.obj.f(); // obj1.obj.f.call(obj1.obj) 是 5let f = obj1.obj.f;f(); // f.call(undefined) 是 3</code></pre><pre><code>// 显式绑定window.a = 3;let obj = {    a: 4,    f: function() {        console.log(this.a);    }};obj.f.call({a: 6}); // 6let f = obj.f;f.call({a: 5}); // 5</code></pre><pre><code>// new绑定function Person(age) {    this.age = age;}let mike = Person(12); // Person.call(12) 如果在全局作用域写一个 12 那就会有 12 ,但是 mike.age 还是 undefinedconsole.log(mike.age); // undefined// 所以应该这样写// let mike = new Person(12)// 关于 new 这个方法，我在原型链实现过，内部应该会有一个 call() 的用法来调用 this</code></pre><h2 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach 方法"></a>forEach 方法</h2><pre><code>Array.prototype._forEach = function(fn) {    // 实现一个 forEach 方法    for(let i = 0; i &lt; this.length; i++) {        let it = this[i];        fn(it, i, this); // 看这里，调用的时候是这样的 fn.call(it,i,this) fn 没有绑定任何的上下文，所以是全局变量    }};function Person(age) {    this.age = age;    [3,5,10]._forEach(function(it){        // console.log(this) 这里其实会打印出 global 属性, 原因看上面        console.log(`${it} year later I&#39;m ${this.age + it} year old`);    });}let mike = new Person(12);// 3 year later I&#39;m 15 year old// 5 year later I&#39;m 17 year old// 10 year later I&#39;m 22 year old</code></pre><p>所以真正实现方法是：</p><pre><code>// 实际上原生的 forEach 可以传两个参数，一个是 callback ，还有一个其实是 this，所以其实 forEach 他本来就考虑到这种情况，所以可以直接传一个 this 进去Array.prototype._forEach = function(fn, ctx) {    // 实现一个 forEach 方法    for(let i = 0; i &lt; this.length; i++) {        let it = this[i];        fn.call(ctx || this, it, i, this); // 所以可以这样实现    }};/*Array.prototype._forEach = function(fn) {    for(let i = 0; i &lt; this.length; i++) {        let it = this[i];        fn(it, i, this);    }};*/function Person(age) {    this.age = age;    [3,5,10]._forEach(function(it){        console.log(`${it} year later I&#39;m ${this.age + it} year old`);    }, this);}/*function Person(age) {    this.age = age;    [3,5,10]._forEach(function(it){        console.log(`${it} year later I&#39;m ${this.age + it} year old`);    }.bind(this)); // bind(this) 会绑定成上下文的 this}*//*function Person(age) {    this.age = age;    let that = this    [3,5,10]._forEach(function(it){        console.log(`${it} year later I&#39;m ${that.age + it} year old`);    });  // 使 this 变成一个普通的变量，其实和 bind(this) 是一样的套路}*//*function Person(age) {    this.age = age;    [3,5,10]._forEach((it) =&gt; {        console.log(`${it} year later I&#39;m ${this.age + it} year old`);    }); // }*/let mike = new Person(12);// 3 year later I&#39;m 15 year old// 5 year later I&#39;m 17 year old// 10 year later I&#39;m 22 year old</code></pre><pre><code>// 这里说一下箭头函数的 thisArray.prototype._forEach = function(fn) {    for(let i = 0; i &lt; this.length; i++) {        let it = this[i];        fn(it, i, this);    }};function Person(age) {    [3,5,10]._forEach((it) =&gt; {        console.log(this);    });}Person.call({a: &#39;a&#39;}); // 绑定了 call 值 输出 =&gt; {a: &#39;a&#39;}Person(); // Person 的 this 输出 =&gt; globallet obj = {  b: 1,  f: Person}obj.f(); // 绑定了 obj 所以是 { b: 1, [Function: Person] }</code></pre><p>这里说一个很可能会出现的 bug ，在 <code>this.age = age</code> 这里如果不加分号会出现 bug ，变成了 <code>this.age = age[3,4,5]._forEach()</code> <code>age[3,4,5]</code> 返回是一个 <code>undefined</code></p><h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><pre><code>// 先看 _bind 的 this 值是什么/*Function.prototype._bind = function(ctx) {    console.log(this)};function Person(age) {    this.age = age;    (function(){})._bind(this)    console.log(this)}let mike = new Person(12);// Function 因为上下文的关系// Person { age: 12 } */Function.prototype._bind = function(ctx) {    // 实现一个 bind 方法    // return fn    // 注意不能用箭头函数，因为箭头函数没有 arguments    let that = this    let args = Array.prototype.slice.call(arguments, 1) // [1,3]    return function() {        let args2 = Array.prototype.slice.call(arguments) // [4,5]          let all = args.concat(args2);         return that.apply(ctx, all);    }};/*Function.prototype._bind = function(ctx) {    // 如果要用箭头函数，用 ... 取剩余的值    let args = Array.prototype.slice.call(arguments, 1)    return (...args2) {        console.log(args2)          let all = args.concat(args2);           cosole.log(all)        return that.apply(ctx, all);    }};*/function Person(age) {    this.age = age;    [3,5,10].forEach(function(it){        console.log(`${it} yeas later I&#39;m ${this.age + it} yeas old`);    }._bind(this, 1, 2));    // let fn = function(it) {    // }._bind(this, 1, 3);    // fn(4,5)    // 所以用了 _bind() 方法后就是等于 fn(this, 1, 3, 4, 5)    // let fn = function(it) {    // }    // let fn2 = fn._bind(this, 1, 2)    // fn2(4, 5, 6, 7, 8)    // 相当于 fn(1, 2, 4, 5, 6, 7, 8)}let mike = new Person(12);</code></pre><p>如何摊平数组?</p><pre><code>// 正常来说 数组 push 一个数组那就是数组内嵌数组let arr = [1,2]arr.push([3,4])arr // [1, 2, [3, 4]]arr.concat([3, 4]) // [1, 2, [3, 4], 3, 4]arr.push.apply(arr, [5, 6]) // [1, 2, [3, 4], 3, 4, 5, 6]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：this&quot;&gt;&lt;a href=&quot;#补基础：this&quot; class=&quot;headerlink&quot; title=&quot;补基础：this&quot;&gt;&lt;/a&gt;补基础：this&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.c
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>补基础：原型链和 prototype</title>
    <link href="http://yoursite.com/2017/10/17/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%20prototype/"/>
    <id>http://yoursite.com/2017/10/17/补基础：原型链和 prototype/</id>
    <published>2017-10-16T17:58:32.000Z</published>
    <updated>2017-11-05T14:42:01.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补基础：原型链和-prototype"><a href="#补基础：原型链和-prototype" class="headerlink" title="补基础：原型链和 prototype"></a>补基础：原型链和 prototype</h1><p>先搞清楚两个东西</p><ul><li><code>__proto__</code></li><li><code>prototype</code></li></ul><blockquote><p>实例化对象的原型(<code>__proto__</code>)指向了构造函数的prototype属性</p></blockquote><p>例如</p><pre><code>let arr = [1,2]let arr2 = new Array(3,4)arr.__proto__ === Array.prototype</code></pre><p>再举个例子</p><pre><code>// Array 实际是一个构造函数Array.__proto__ === Function.prototype// 我们经常用到的 Array.forEach Array.push 实际上是 Function 的方法Array.prototype.forEachArray.prototype.push// 举个例子let arr = [1,2]arr.push(3)console.log(arr) // [1,2,3]// 利用 hasOwnProperty 的方法看看console.log(arr.hasOwnProperty(&#39;push&#39;)) // falseconsole.log(Array.prototype.hasOwnProperty(&#39;push&#39;))</code></pre><p>所以说，本身 <code>arr</code> 是没有 <code>push</code> 这个方法的 ，于是就会从他的原型上找。先会找它的原型 (<code>arr.__proto__</code> 等价与在 <code>Array.prototype</code> 里面找) 。</p><p> 那 <code>arr.hasOwnProperty</code> 又是怎么来的呢？</p><pre><code>console.log(Object.prototype.hasOwnProperty.call(arr, &#39;hasOwnProperty&#39;)) //falseconsole.log(Object.prototype.hasOwnProperty.call(arr.__proto__, &#39;hasOwnProperty&#39;)) //falseconsole.log(Object.prototype.hasOwnProperty.call(Array.prototype, &#39;hasOwnProperty&#39;)) //false// 既然找不到，那我们可以往上一级找// arr.__proto__.__proto___ === Array.prototype.__proto__ === Object.prototype/*为什么 Array 是一个对象呢？因为是对象格式Array.prototype = {  push: function() {  }}*/console.log(Object.prototype.hasOwnProperty.call(Object.prototype, &#39;hasOwnProperty&#39;)) // true/*实际上是有尽头的一直往原型上找的话最后是一个 null*/</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>function Person(name) {    this.name = name;}Person.prototype.sayHi = function() {    console.log(`hello I&#39;m ${this.name}`);};let mike = new Person(&#39;mike&#39;);console.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // false</code></pre><pre><code>function Person(name) {    this.name = name;    this.sayHi = function() {        console.log(`hello I&#39;m ${this.name}`);    };}let mike = new Person(&#39;mike&#39;);console.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // true</code></pre><p>所以说，<code>prototype</code> 会给每个实例对象赋予一个新的 <code>sayHi()</code> </p><pre><code>function Person(name) {    this.name = name;    this.sayHi = function() {        console.log(`hello I&#39;m ${this.name}`);    };}let mike = new Person(&#39;mike&#39;);let mike2 = new Person(&#39;mike2&#39;);mike.sayHi();mike2.sayHi();console.log(mike.sayHi === mike2.sayHi) // false</code></pre><pre><code>function Person(name) {    this.name = name;}Person.prototype.sayHi = function() {    console.log(`hello I&#39;m ${this.name}`);};let mike = new Person(&#39;mike&#39;);let mike2 = new Person(&#39;mike2&#39;);mike.sayHi();mike2.sayHi();console.log(mike.sayHi === mike2.sayHi) // true</code></pre><pre><code>function Person(name) {    this.name = name;}Person.prototype.sayHi = function() {    console.log(`hello I&#39;m ${this.name}`);};let mike = new Person(&#39;mike&#39;);let mike2 = new Person(&#39;mike2&#39;);mike.sayHi();mike2.sayHi();Person.prototype.sayHi = function() {    console.log(`hi I&#39;m ${this.name}`);};mike.sayHi();mike2.sayHi();// hello I&#39;m mike// hello I&#39;m mike2// hi I&#39;m mike// hi I&#39;m mike2</code></pre><pre><code>function Person(name) {    this.name = name;}Person.prototype.sayHi = function() {    console.log(`hello I&#39;m ${this.name}`);};let mike = new Person(&#39;mike&#39;);let mike2 = new Person(&#39;mike2&#39;);mike.sayHi();mike2.sayHi();mike.sayHi = function() {    console.log(`hi I&#39;m ${this.name}`);};mike.sayHi();mike2.sayHi();// hello I&#39;m mike// hello I&#39;m mike2// hi I&#39;m mike// hello I&#39;m mike2</code></pre><p>所以，如果要找 a 里面有没有 b 这个玩意，就一直 <code>a.__proto__.__proto__</code> … 这个子子孙孙无穷尽也 </p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>判断自定义对象的类型</p></blockquote><pre><code>let arr = [1,2]console.log(arr instanceof Array)// 实际上就是 arr.__proto__ === Array.prototype</code></pre><pre><code>let arr = [1,2]// 实现一个 instanceof, in 是实例 fn 是构造函数function io(ins, fn) {    if(ins.__proto__){        if(ins.__proto__ === fn.prototype){            return true;        } else {            return io(ins.__proto__, fn);        }    }else {        return false;    }}/*function io(ins, fn) {    while(ins.__proto__ !== null){      if(ins.__proto__ === fn.prototype){        return true      }      ins = ins.__proto__    }    return false}*//*function io(ins, fn) {    if(ins.__proto__ === fn.prototype) return true    else if(ins.__proto__ === null){          return false    }    else return io(ins.__proto__, fn)}*/console.log(io(arr, Array)); //trueconsole.log(io(arr, Object)); //trueconsole.log(io(arr, Number)); //false</code></pre><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote><p>创建一个实例化对象，继承构造函数的一些实例和方法</p><ul><li>新生成一个对象</li><li>将构造函数的 this 指向这个新生成的对象</li><li>设置新生成对象的原型</li><li>执行构造函数</li><li>返回这个对象</li></ul></blockquote><pre><code>function Person(name,age) {    this.name = name;    this.age = age;}Person.prototype.sayHi = function() {    console.log(`hello I&#39;m ${this.name}`);};let mike = new Person(&#39;mike&#39;);mike.sayHi()// 实现一个 new 方法function myNewObject(f, ...arg) {    var obj, ret, proto;    proto = f.prototype;    obj = Object.create(proto);    ret = f.apply(obj, arg);    return obj;}// function myNewObject(fn, ...arg) {//     let obj = {}//     obj.__proto__ = fn.prototype//     fn.call(obj,arg)//     return obj// }let mike2 = myNewObject(Person, &#39;mike2&#39;, 12);console.log(mike2.name) // mike2mike2.sayHi(); // hello I&#39;m mike2console.log(mike2 instanceof Person); // true</code></pre><pre><code>function Person(name) {    // 看这里，因为 this 不是那个实例化对象了    if(!(this instanceof Person)) {        return new Person(name);    }    this.name = name;}Person.prototype.sayHi = function() {    console.log(`hello I&#39;m ${this.name}`);};let mike3 = Person(&#39;mike3&#39;);console.log(mike3) //undefined// 怎么让 mike3 也成为一个正常的实例化对象呢？// 看上面console.log(mike3.name); //mike3mike3.sayHi(); //hello I&#39;m mike3console.log(mike3 instanceof Person); //true</code></pre><h2 id="inheritance"><a href="#inheritance" class="headerlink" title="inheritance"></a>inheritance</h2><p>继承方法</p><pre><code>function Person(name) {    this.name = name;}Person.prototype.sayHi = function() {    console.log(`hello I&#39;m ${this.name}`);};function Student(name, grade) {    // to-do    Person.call(this,name);    this.grade = grade;}Student.prototype = Object.create(Person.prototype); //to-do// Student.prototype.__proto__ = Person.prototype// Student.prototype.constructor = Student;// 注意如果用以下这种方法// Student.prototype = new Person()// xiaohong.__proto__ === Student.prototype// xiaohong.__proto__.name === undefined // 多余的东西 // 需要的条件是// xiaohong.__proto__ // Student.prototype// xiaohong.__proto__.__proto__ // Person.protoypeStudent.prototype.study = function(){    console.log(&quot;I&#39;m studying&quot;);};let xiaohong = new Student(&#39;xiaohong&#39;, 6);xiaohong.sayHi(); //hello I&#39;m xiaohongxiaohong.study(); //I&#39;m studyingconsole.log(xiaohong.grade); //6console.log(xiaohong.name); //xiaohongconsole.log(xiaohong instanceof Person); //trueconsole.log(xiaohong instanceof Student); //trueconsole.log(xiaohong.constructor === Person); //true</code></pre><pre><code>// 彩蛋 做一个 Object.create()if(typeof Object.create !== &#39;function&#39;){      Object.create = function(obj){      function F(){}      F.prototype = obj      return new F()      }}</code></pre><p>注意 <code>__proto__</code> 不是规范里面的，是浏览器的规范 <code>Object.getPrototype(Array) === Array.__proto__</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补基础：原型链和-prototype&quot;&gt;&lt;a href=&quot;#补基础：原型链和-prototype&quot; class=&quot;headerlink&quot; title=&quot;补基础：原型链和 prototype&quot;&gt;&lt;/a&gt;补基础：原型链和 prototype&lt;/h1&gt;&lt;p&gt;先搞清楚两个
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>做一个音乐 Webapp 的流程</title>
    <link href="http://yoursite.com/2017/10/15/%E5%81%9A%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%20Webapp/"/>
    <id>http://yoursite.com/2017/10/15/做一个音乐 Webapp/</id>
    <published>2017-10-15T04:41:39.000Z</published>
    <updated>2017-12-07T12:57:55.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="做一个音乐-Webapp"><a href="#做一个音乐-Webapp" class="headerlink" title="做一个音乐 Webapp"></a>做一个音乐 Webapp</h1><p>超低仿 Vanilla JS 写的 QQ 音乐</p><p><a href="https://frankietang.github.io/qq-music/index.html" target="_blank" rel="noopener">预览</a> | <a href="https://github.com/FRANKIETANG/qq-music" target="_blank" rel="noopener">源码</a></p><p>那么乱的笔记估计就只有我才能看懂</p><ul><li>按需求制定一下接口</li><li>功能拆分成一个一个模块（首页 + 推荐 / 排行榜 / 搜索 / 播放器界面）</li><li>技术选型（CSS 预处理器 / JS 库）</li></ul><h2 id="怎么在网页抄数据"><a href="#怎么在网页抄数据" class="headerlink" title="怎么在网页抄数据"></a>怎么在网页抄数据</h2><p><img src="https://i.loli.net/2017/09/22/59c4990ac3f33.png" alt=""></p><h2 id="伪造请求"><a href="#伪造请求" class="headerlink" title="伪造请求"></a>伪造请求</h2><p><img src="https://i.loli.net/2017/09/23/59c5f31f6601d.png" alt=""></p><pre><code>curl &#39;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=1507564199109&#39; -H &#39;pragma: no-cache&#39; -H &#39;origin: https://m.y.qq.com&#39; -H &#39;accept-encoding: gzip, deflate, br&#39; -H &#39;accept-language: zh-CN,zh;q=0.8&#39; -H &#39;user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39; -H &#39;accept: application/json&#39; -H &#39;cache-control: no-cache&#39; -H &#39;authority: c.y.qq.com&#39; -H &#39;cookie: pgv_pvi=1576136704; pgv_si=s2924205056; RK=QfWPx2jbHN; tvfe_boss_uuid=bdd869ba21d19595; o_cookie=350558468; ts_refer=ADTAGmyqq; ptui_loginuin=350558468; ptisp=ctc; ptcz=bde020f9828475fc3e22f0fc78ba0024b7a615fad803b91694a069a02cefdb0b; pt2gguin=o0350558468; LW_sid=11S540S7L3v4m1k4L632K6r1m3; LW_uid=g1l53027M384N1y4K6Z2v6d1L4; eas_sid=H1Y5t0B7H3o461B4f692f682Y2; ts_uid=2559117424; qqmusic_fromtag=10; checkmask=3; yqq_stat=0; ts_refer=www.google.ca/; ts_uid=2559117424; pgv_info=ssid=s8871552255; pgv_pvid=2779555285&#39; -H &#39;referer: https://m.y.qq.com/&#39; --compressed</code></pre><p><code>npm install express --save</code> </p><p><code>npm install request --save</code> <code>npm install request-promise --save</code>（发请求的库）</p><p><a href="https://github.com/request/request-promise" target="_blank" rel="noopener">request-promise</a></p><p><img src="https://i.loli.net/2017/09/23/59c60819cabdf.png" alt=""></p><p><code>npm install -g nodemon</code></p><p><a href="https://nodemon.io/" target="_blank" rel="noopener">nodemon</a></p><p>我去…用 nodemon 不能用 <code>import XXX from &#39;XXX&#39;</code> 要用 <code>var XXX = require(&#39;XXX&#39;)</code></p><p><img src="https://i.loli.net/2017/09/23/59c60b0dcf706.png" alt=""></p><p>我去…原来还有 n 模块这玩意…</p><p><a href="https://www.npmjs.com/package/n" target="_blank" rel="noopener">n</a> 接受了这个设定还是挺不错的…</p><pre><code>//qq-server 代码const express = require(&#39;express&#39;)const request = require(&#39;request-promise&#39;)const app = express()app.get(&#39;/&#39;, async (req, res) =&gt; {    const url = `https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=${+ new Date()}`    try {        res.json(            await request({                uri: url,                json: true,                headers: {                    &#39;accept&#39;: &#39;application/json&#39;,                    &#39;authority&#39;: &#39;c.y.qq.com&#39;,                    &#39;origin&#39;: &#39;https://m.y.qq.com&#39;,                    &#39;referer&#39;: &#39;https://m.y.qq.com/&#39;,                    &#39;user-agent&#39;: &#39;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39;                }            })        )    } catch (e) {        res.json({ error: e.message })    }})app.listen(4000)</code></pre><p>运行 <code>nodemon qq-server.js</code> 打开 localhost:4000</p><p><img src="https://i.loli.net/2017/09/23/59c6163e42f5b.png" alt=""></p><p>开心 终于不用跨域请求了 也不用自己去抄数据了hhhh 新技能 get</p><p>再分析一个 API 接口</p><pre><code>https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=%E6%9D%8E%E8%8D%A3%E6%B5%A9&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=1&amp;remoteplace=txt.mqq.all&amp;_=1506154238572</code></pre><p><code>w=%E6%9D%8E%E8%8D%A3%E6%B5%A9</code> 这个是李荣浩</p><p><img src="https://i.loli.net/2017/09/23/59c618bbb79d2.png" alt=""></p><pre><code>//search部分的核心代码app.get(&#39;/search&#39;, async(req,res)=&gt;{    const { keyword, page = 1 } = req.query    const url=`https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=${encodeURIComponent(keyword)}&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=${page}&amp;remoteplace=txt.mqq.all&amp;_=${+ new Date()}`    try {        res.json(            await request({                uri: url,                json: true,                headers: HEADERS            })        )    } catch (e) {        res.json({ error: e.message })    }    })</code></pre><p><img src="https://i.loli.net/2017/09/23/59c6200b767cb.png" alt=""></p><p>所有参数都放在 ? 后面 用 &amp; 链接</p><p>你看真的成了</p><p>那就是说…我自己做了一个 API …</p><p>让这个 API 跨域 <code>npm install cors --save</code></p><p><a href="https://zeit.co/now" target="_blank" rel="noopener">https://zeit.co/now</a> 把做出来的 server.js 上传就可以用了</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>import export</p><h2 id="音乐歌词-API"><a href="#音乐歌词-API" class="headerlink" title="音乐歌词 API"></a>音乐歌词 API</h2><p><img src="https://i.loli.net/2017/09/25/59c8db302e050.png" alt=""></p><p>点击 network 看 JS</p><p>把这个地址复制，在 console 用 <code>fetch()</code> 跑一遍</p><p><img src="https://i.loli.net/2017/09/25/59c8dbc2a1f79.png" alt=""></p><p>再回到 network 看 XHR</p><p><img src="https://i.loli.net/2017/09/25/59c8dc2dd23db.png" alt=""></p><p>写一个正则，把 callback 去掉，括号去掉。</p><p><code>MusicJsonCallback({...}).replace(/MusicJsonCallback\((.*)\)/, &#39;$1&#39;)</code></p><p><code>let json = {...}</code></p><p><code>JSON.parse(json)</code></p><p><code>json.lyric</code></p><p><code>let div = document.createElement(&#39;div&#39;)</code></p><p><code>div.innerHTML = json.lyric</code></p><p><code>div.firstChild.nodeValue</code></p><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>单页面保存数据的方式</p><p>就是当你打开这个页面就可以直接转跳到那首歌的入口</p><p><code>href=&quot;#player?artist=${artist}&amp;songid=${song.songid}&amp;songname=${song.songname}&amp;albummid=${song.albummid}&amp;duration=${song.interval}&quot;</code></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>fetch / await async</p><p><code>[].slice.call()</code></p><p>IntersectionObserver</p><p><code>map</code> 和 <code>forEach</code> 的区别</p><p>懒加载 / 曝光加载</p><p>正则</p><pre><code>&#39;View frankietang on GitHub&#39;.match(/View (\w+) on GitHub/)[1]&#39;frankietang&#39;</code></pre><p>css 里面的 <code>filter:blur(15px)</code> 毛玻璃效果</p><p>进度条可以先移到最边边，然后慢慢的往右移。</p><p><code>max-height: calc(100% - 205px);</code></p><p><code>location.hash</code> 点击时 url 的变化</p><p><img src="https://ooo.0o0.ooo/2017/09/28/59ccf1d9533c4.png" alt=""></p><p>MVC – Model View Controller</p><p>autoprefixer-cli</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/NonDocumentTypeChildNode/previousElementSibling" target="_blank" rel="noopener">NonDocumentTypeChildNode.previousElementSibling</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;做一个音乐-Webapp&quot;&gt;&lt;a href=&quot;#做一个音乐-Webapp&quot; class=&quot;headerlink&quot; title=&quot;做一个音乐 Webapp&quot;&gt;&lt;/a&gt;做一个音乐 Webapp&lt;/h1&gt;&lt;p&gt;超低仿 Vanilla JS 写的 QQ 音乐&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>摸到 Vue.js 的门把手（3）</title>
    <link href="http://yoursite.com/2017/10/14/%E6%91%B8%E5%88%B0%20Vue.js%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2017/10/14/摸到 Vue.js 的门把手（3）/</id>
    <published>2017-10-13T16:13:11.000Z</published>
    <updated>2017-11-05T14:42:01.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摸到-Vue-js-的门把手（3）"><a href="#摸到-Vue-js-的门把手（3）" class="headerlink" title="摸到 Vue.js 的门把手（3）"></a>摸到 Vue.js 的门把手（3）</h1><p>回炉重造</p><h2 id="重看-vue-init-webpack-的选项"><a href="#重看-vue-init-webpack-的选项" class="headerlink" title="重看 vue init webpack 的选项"></a>重看 <code>vue init webpack</code> 的选项</h2><pre><code>? Generate project in current directory? Yes? Project name vue-resume? Project description A Vue.js project? Author FRANKIETANG &lt;350558468@qq.com&gt;? Vue build standalone//可以以后再装? Install vue-router? No//这东西很烦，不要? Use ESLint to lint your code? No//不需要单元测试? Setup unit tests with Karma + Mocha? No//不用管? Setup e2e tests with Nightwatch? No</code></pre><h2 id="升级了-NPM-之后居然装不了-SCSS-？"><a href="#升级了-NPM-之后居然装不了-SCSS-？" class="headerlink" title="升级了 NPM 之后居然装不了 SCSS ？"></a>升级了 NPM 之后居然装不了 SCSS ？</h2><p>会有一个奇怪的 <code>user &quot;root&quot; does not have permission to access the dev dir &quot;/home/tangkalun/Desktop/vue-resume/node_modules/node-sass/.node-gyp/6.3.1&quot;</code></p><p>那就用 <code>sudo SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install --save --unsafe-perm</code></p><p>不行就用 <code>export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;</code></p><p><code>npm install --save  sass-loader node-sass</code></p><p>又不行？</p><p><code>sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p><code>sudo cnpm install --save  sass-loader node-sass --unsafe-perm</code></p><p>不要加 <code>--unsafe-perm</code></p><p>在 linux 下有可能循环安装…</p><p>用这句 <code>rm -rf node_modules/ &amp;&amp; npm install &amp;&amp; npm rebuild</code></p><p>不用想那么多。人生苦短，能用就行。</p><h2 id="程序构想"><a href="#程序构想" class="headerlink" title="程序构想"></a>程序构想</h2><p>和之前一样分为导航栏，侧栏编写区，预览区</p><h2 id="iconfont-的善用"><a href="#iconfont-的善用" class="headerlink" title="iconfont 的善用"></a>iconfont 的善用</h2><p>生成 <code>&lt;script&gt;</code> 标签直接用…不用像之前写个脚本来搞一大堆</p><h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2><p><code>npm i element-ui -S</code></p><p><a href="http://element.eleme.io/#/zh-CN/component/installation" target="_blank" rel="noopener">文档</a></p><h2 id="数据绑定语法为-value-sync"><a href="#数据绑定语法为-value-sync" class="headerlink" title="数据绑定语法为:value.sync"></a>数据绑定语法为<code>:value.sync</code></h2><p><a href="https://vuxjs.gitbooks.io/vux/content/form/x-input.html" target="_blank" rel="noopener">点击这里</a></p><h2 id="slot-分發內容"><a href="#slot-分發內容" class="headerlink" title="slot 分發內容"></a>slot 分發內容</h2><p><a href="http://jsnwork.kiiuo.com/archives/2645/vue-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E3%80%8C%E4%BD%BF%E7%94%A8-slot-%E5%88%86%E7%99%BC%E5%85%A7%E5%AE%B9%E3%80%8D" target="_blank" rel="noopener">Vue – 如何理解「使用 slot 分發內容」</a></p><h2 id="完。"><a href="#完。" class="headerlink" title="完。"></a>完。</h2><p><a href="https://frankietang.github.io/vue-resume/dist/index.html" target="_blank" rel="noopener">预览</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摸到-Vue-js-的门把手（3）&quot;&gt;&lt;a href=&quot;#摸到-Vue-js-的门把手（3）&quot; class=&quot;headerlink&quot; title=&quot;摸到 Vue.js 的门把手（3）&quot;&gt;&lt;/a&gt;摸到 Vue.js 的门把手（3）&lt;/h1&gt;&lt;p&gt;回炉重造&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Black History" scheme="http://yoursite.com/tags/Black-History/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>摸到 Vue.js 的门把手（2）</title>
    <link href="http://yoursite.com/2017/10/14/%E6%91%B8%E5%88%B0%20Vue.js%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2017/10/14/摸到 Vue.js 的门把手（2）/</id>
    <published>2017-10-13T16:12:40.000Z</published>
    <updated>2017-11-05T14:42:01.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摸到-Vue-js-的门把手（2）"><a href="#摸到-Vue-js-的门把手（2）" class="headerlink" title="摸到 Vue.js 的门把手（2）"></a>摸到 Vue.js 的门把手（2）</h1><p>用 vue-cli 快速搭建</p><pre><code>npm init -ynpm install -g vue-clivue init webpack .//全部回车npm inpm run dev</code></pre><h2 id="项目分三组件"><a href="#项目分三组件" class="headerlink" title="项目分三组件"></a>项目分三组件</h2><p><code>&lt;Topbar/&gt;</code> / <code>&lt;ResumeEditor/&gt;</code> / <code>&lt;ResumePreview/&gt;</code></p><h2 id="禁用-ESLint"><a href="#禁用-ESLint" class="headerlink" title="禁用 ESLint"></a>禁用 ESLint</h2><pre><code>//build/webpack.base.conf.js  module: {    rules: [      //{        //test: /\.(js|vue)$/,        //loader: &#39;eslint-loader&#39;,        //enforce: &quot;pre&quot;,        //include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],        //options: {          //formatter: eslintFriendlyFormatter        //}      //},</code></pre><h2 id="GitHub-预览"><a href="#GitHub-预览" class="headerlink" title="GitHub 预览"></a>GitHub 预览</h2><pre><code>//config/index.jsassetsPublicPath: &#39;/vue-resume/dist&#39;,</code></pre><p><code>npm run build</code></p><p><code>https://frankietang.github.io/vue-resume/dist/#/</code></p><h2 id="使用-SCSS"><a href="#使用-SCSS" class="headerlink" title="使用 SCSS"></a>使用 SCSS</h2><p><code>npm install --save  sass-loader node-sass</code></p><h2 id="SVG-合并和使用方法"><a href="#SVG-合并和使用方法" class="headerlink" title="SVG 合并和使用方法"></a>SVG 合并和使用方法</h2><ul><li><a href="https://github.com/FRANKIETANG/vue-resume/commit/a112088f1c0bc772813f855139fcdd4cdeeea380" target="_blank" rel="noopener">使用脚本将所有 svg 拼成一个 svg，原来的多个 svg 变成了多个 symbol</a></li><li><a href="https://github.com/FRANKIETANG/vue-resume/commit/78556c0f7cb18d20e078f3abbbb85fd9b4c8ed43" target="_blank" rel="noopener">运行 node build/svg-symbol.js</a></li><li><a href="https://github.com/FRANKIETANG/vue-resume/commit/476cec015bbea1e7fc55bbfb33ba627c68353084" target="_blank" rel="noopener">将 SVG 插入 body 中</a></li></ul><pre><code>//任意地方&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><p><strong>值得注意的是，之前的 ResumeEditor 中的 data 是对象，对象是无序的，应该用数组让项目有一个完整的顺序</strong></p><h2 id="填写区核心代码"><a href="#填写区核心代码" class="headerlink" title="填写区核心代码"></a>填写区核心代码</h2><pre><code>        &lt;ol class=&quot;panels&quot;&gt;            &lt;li v-for=&quot;item in resume.config&quot;             v-show=&quot;item.field === selected&quot;&gt;                &lt;div v-if=&quot;resume[item.field] instanceof Array&quot;&gt;                    &lt;div class=&quot;subitem&quot; v-for=&quot;subitem in resume[item.field]&quot;&gt;                        &lt;div class=&quot;resumeField&quot; v-for=&quot;(value,key) in subitem&quot;&gt;                            &lt;label&gt;{{key}}&lt;/label&gt;                            &lt;input type=&quot;text&quot; :value=&quot;value&quot;&gt;                                                    &lt;/div&gt;                        &lt;hr&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div v-else class=&quot;resumeField&quot;                 v-for=&quot;(value,key) in resume[item.field]&quot;&gt;                    &lt;label&gt;{{key}}&lt;/label&gt;                    &lt;input type=&quot;text&quot;                     v-model=&quot;resume[item.field][key]&quot;&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ol&gt;</code></pre><h2 id="如何把填进去的数据放到预览页面呢？"><a href="#如何把填进去的数据放到预览页面呢？" class="headerlink" title="如何把填进去的数据放到预览页面呢？"></a>如何把填进去的数据放到预览页面呢？</h2><p>可以做一个公共数据储存区域</p><p>填写区填进去的数据先放到公共数据再传到预览区</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p><a href="https://jsfiddle.net/n9jmu5v7/1269/" target="_blank" rel="noopener">最基本的 Vuex 记数应用</a></p><h2 id="getter-与-setter"><a href="#getter-与-setter" class="headerlink" title="getter 与 setter"></a>getter 与 setter</h2><pre><code>computed: {  fullName: {    // getter    get: function () {      return this.firstName + &#39; &#39; + this.lastName    },    // setter    set: function (newValue) {      var names = newValue.split(&#39; &#39;)      this.firstName = names[0]      this.lastName = names[names.length - 1]    }  }}</code></pre><h2 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h2><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p><pre><code>// ...mutations: {  increment (state, n) {    state.count += n  }}store.commit(&#39;increment&#39;, 10)</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p><pre><code>// ...mutations: {  increment (state, payload) {    state.count += payload.amount  }}store.commit(&#39;increment&#39;, {  amount: 10})</code></pre><h2 id="store"><a href="#store" class="headerlink" title="$store"></a>$store</h2><p>这个 <code>$</code> 在 Vue 里是代表全局的意思</p><h2 id="多次-import-同一个文件"><a href="#多次-import-同一个文件" class="headerlink" title="多次 import 同一个文件"></a>多次 import 同一个文件</h2><p>Node对引入的模块都会进行缓存（缓存的是编译和执行后的对象），减少二次引入开销；<br>在Node的加载机制中，缓存的优先级是最高的；<br>这一点同时适用于不同的模块加载机制，无论ES2015的import还是CommonJS的require；</p><h2 id="CSS-white-space-pre-line"><a href="#CSS-white-space-pre-line" class="headerlink" title="CSS white-space: pre-line"></a>CSS white-space: pre-line</h2><p>去除一行文本中的空格，但是保留一行的换行符，作用是防止用户在输入框输入空格而产生对用户不友好显示效果</p><h2 id="Object-Path"><a href="#Object-Path" class="headerlink" title="Object-Path"></a>Object-Path</h2><p><a href="https://github.com/mariocasciaro/object-path" target="_blank" rel="noopener">object-path</a></p><p><a href="https://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/" target="_blank" rel="noopener">Object-Path 源码解读</a></p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p><code>Object.assign()</code> 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()</a></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><pre><code>//旧版本components: {  &#39;MyDialog&#39;: MyDialog}//ES6components: {  MyDialog}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摸到-Vue-js-的门把手（2）&quot;&gt;&lt;a href=&quot;#摸到-Vue-js-的门把手（2）&quot; class=&quot;headerlink&quot; title=&quot;摸到 Vue.js 的门把手（2）&quot;&gt;&lt;/a&gt;摸到 Vue.js 的门把手（2）&lt;/h1&gt;&lt;p&gt;用 vue-cli 
      
    
    </summary>
    
    
      <category term="Black History" scheme="http://yoursite.com/tags/Black-History/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>摸到 Vue.js 的门把手</title>
    <link href="http://yoursite.com/2017/10/14/%E6%91%B8%E5%88%B0%20Vue.js%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/"/>
    <id>http://yoursite.com/2017/10/14/摸到 Vue.js 的门把手/</id>
    <published>2017-10-13T16:11:47.000Z</published>
    <updated>2017-11-05T14:42:01.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摸到-Vue-js-的门把手"><a href="#摸到-Vue-js-的门把手" class="headerlink" title="摸到 Vue.js 的门把手"></a>摸到 Vue.js 的门把手</h1><p>文档那么多中文多和谐啊是不是？<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue.js</a></p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>先把 webpack 给配好。</p><p>接下来我们输入 Vue.js 测试代码给我们的代码</p><pre><code>//index.html      &lt;div id=&quot;app&quot;&gt;          {{ message }}      &lt;/div&gt; //index.jsimport Vue from &#39;vue&#39;var app = new Vue({    el: &#39;#app&#39;,    data: {      message: &#39;Hello Vue!&#39;    }  })</code></pre><p>真的是非常的和谐，很像 React </p><p><img src="http://upload-images.jianshu.io/upload_images/3191557-19472a5df4b492fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><pre><code>//index.html&lt;div class=&quot;newTask&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;&lt;/div&gt;//index.jsvar app = new Vue({    el: &#39;#app&#39;,    data: {        newTodo: &#39;&#39;,        todoList: []    },    created: function(){        let i = 0        setInterval(()=&gt;{            this.newTodo = i            i += 1        },1000)    }})</code></pre><p>只要 data.newTodo 被 JS 改了，input.value 就会变成一样的值。</p><pre><code>//index.html&lt;div class=&quot;newTask&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;&lt;/div&gt;//index.jsvar app = new Vue({    el: &#39;#app&#39;,    data: {        newTodo: &#39;&#39;,        todoList: []    },    created: function(){        let i = 0        setInterval(()=&gt;{            console.log(this.newTodo)            i += 1        },1000)    }})</code></pre><p>只要 input.value 被用户改了，data.newTodo 就会变成一样的值；</p><h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><pre><code>//index.html&lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot; @keypress.enter=&quot;addTodo&quot;&gt;//index.jsmethods: {    addTodo: function(){        this.todoList.push({            title: this.newTodo,            createdAt: new Date()        })        console.log(this.todoList)    }}</code></pre><h2 id="输入东西在页面展示"><a href="#输入东西在页面展示" class="headerlink" title="输入东西在页面展示"></a>输入东西在页面展示</h2><pre><code>&lt;li v-for=&quot;todo in todoList&quot;&gt;  {{ todo.title }}&lt;/li&gt;</code></pre><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><pre><code>//index.html&lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;{{ todo.title }}&lt;span v-if=&quot;todo.done&quot;&gt;已完成&lt;/span&gt;&lt;span v-else&gt;未完成&lt;/span&gt;//index.jsaddTodo: function(){    this.todoList.push({        title: this.newTodo,        createdAt: new Date(),        done: false    })    this.newTodo = &quot;&quot; //input 框变成空的}</code></pre><h2 id="localStorage-保存数据"><a href="#localStorage-保存数据" class="headerlink" title="localStorage 保存数据"></a>localStorage 保存数据</h2><pre><code>created: function() {  window.onbeforeunload = () =&gt;{    let dataString = JSON.stringify(this.todoList)    window.localStorage.setItem(&#39;myTodos&#39;, dataString)  }  let oldDataString = window.localStorage.getItem(&#39;myTodos&#39;)  let oldData = JSON.parse(oldDataString)  this.todoList = oldData || []},</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload" target="_blank" rel="noopener">onbeforeunload - MDN</a> 当窗口即将被<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload" target="_blank" rel="noopener"><code>卸载</code></a>时,会触发该事件.此时页面文档依然可见,且该事件的默认动作可以被<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault" target="_blank" rel="noopener"><code>取消</code></a>.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="noopener">JSON - MDN</a> 简单深拷贝</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage - MDN</a> <code>localStorage</code> 属性允许你访问一个 local <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener"><code>Storage</code></a> 对象。存储在 localStorage 里面的数据没有过期时间（expiration time）。</p><h2 id="数据存储选-leancloud"><a href="#数据存储选-leancloud" class="headerlink" title="数据存储选 leancloud"></a>数据存储选 leancloud</h2><p><a href="https://leancloud.cn/docs/start.html" target="_blank" rel="noopener">JavaScript SDK 安装指南</a></p><p><a href="https://leancloud.cn/docs/leanstorage_guide-js.html#数据存储开发指南___JavaScript" target="_blank" rel="noopener">数据存储开发指南 · JavaScript</a></p><p>之前有一个没有注意到的东西，就是利用这一段代码的时候打印出来的东西</p><pre><code>    signUp: function () {      let user = new AV.User();      user.setUsername(this.formData.username);      user.setPassword(this.formData.password);      user.signUp().then(function (loginedUser) {        console.log(loginedUser);      }, function (error) {      });    }</code></pre><blockquote><p>注意打印出来的三个属性：attributes, createdAt, id。</p><p>其中 attributes 就是我们传给数据库的 username（我们不是还传了一个 password 吗？服务器是不会把 password 传给前端的）</p><p>createdAt 是这个数据创建的时间，id 是用户的 id，也是我们区别用户的唯一凭据。</p></blockquote><h2 id="Vue-的切换-Tab"><a href="#Vue-的切换-Tab" class="headerlink" title="Vue 的切换 Tab"></a>Vue 的切换 Tab</h2><p>在 React 中是这样切换的</p><pre><code>{ this.state.selectedTab === &#39;signInOrSignUp&#39; ? &lt;SignIn /&gt;  : &lt;SignUp /&gt; }</code></pre><p>而 Vue 是这样</p><pre><code>&lt;div class=&quot;signUp&quot; v-if=&quot;actionType === &#39;signUp&#39;&quot;&gt;&lt;div class=&quot;logIn&quot; v-if=&quot;actionType === &#39;logIn&#39;&quot;&gt;</code></pre><h2 id="可注册-可登入-可登出-功能"><a href="#可注册-可登入-可登出-功能" class="headerlink" title="可注册 / 可登入 / 可登出 功能"></a>可注册 / 可登入 / 可登出 功能</h2><p>这个和我之前 React 没什么区别了</p><p>就是看 leancloud 的文档抄抄</p><p>注意 <code>v-if</code> 的使用技巧</p><h2 id="保存数据功能"><a href="#保存数据功能" class="headerlink" title="保存数据功能"></a>保存数据功能</h2><p><a href="https://leancloud.cn/docs/leanstorage_guide-js.html#保存对象" target="_blank" rel="noopener">保存数据</a></p><pre><code>  // 声明类型  var TodoFolder = AV.Object.extend(&#39;TodoFolder&#39;);  // 新建对象  var todoFolder = new TodoFolder();  // 设置名称  todoFolder.set(&#39;name&#39;,&#39;工作&#39;);  // 设置优先级  todoFolder.set(&#39;priority&#39;,1);  todoFolder.save().then(function (todo) {    console.log(&#39;objectId is &#39; + todo.id);  }, function (error) {    console.error(error);  });</code></pre><p>照着抄</p><p>注意不可以把代码放在 <code>window.onbeforeunload</code> 里，请求发出页面就刷新了</p><p><img src="http://upload-images.jianshu.io/upload_images/3191557-509e312e01c9434c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>从结果可以看到，AllTodos 保存请求失败了，被 <code>canceled</code> 了。</p><p>如果一个页面就要死了（刷新就表示不要当前页面了，当前页面可以死了），那么这个页面发出的请求其实就没有任何意义了。既然没有意义，浏览器为什么浪费时间去发这个页面里的请求呢？所以浏览器直接取消了这个请求。</p><p>简单来说，那就是：beforeunload 事件里面的所有请求都发不出去，会被取消！<br>我还从来没有在哪一本书里看到过这个知识点。所以说「实践」是非常重要的。</p></blockquote><p>这样就应该把上面那一段代码封装成一个函数调用。</p><h2 id="角色权限管理"><a href="#角色权限管理" class="headerlink" title="角色权限管理"></a>角色权限管理</h2><p><a href="https://leancloud.cn/docs/acl-guide.html#角色的创建" target="_blank" rel="noopener">角色的创建</a></p><pre><code>  // 创建一个针对 User 的查询  var query = new AV.Query(AV.User);  query.get(&#39;55f1572460b2ce30e8b7afde&#39;).then(function(otherUser) {    var post = new AV.Object(&#39;Post&#39;);    post.set(&#39;title&#39;, &#39;这是我的第二条发言，谢谢大家！&#39;);    post.set(&#39;content&#39;,&#39;我最近喜欢看足球和篮球了。&#39;);    // 新建一个 ACL 实例    var acl = new AV.ACL();    acl.setPublicReadAccess(true);    acl.setWriteAccess(AV.User.current(), true);    acl.setWriteAccess(otherUser, true);    // 将 ACL 实例赋予 Post 对象    post.setACL(acl);    // 保存到云端    return post.save();  }).then(function() {    // 保存成功  }).catch(function(error) {    // 错误信息    console.log(error);  });</code></pre><h2 id="居然有-React-一样的-BUG"><a href="#居然有-React-一样的-BUG" class="headerlink" title="居然有 React 一样的 BUG"></a>居然有 React 一样的 BUG</h2><p>就是 logout 之后 再 login 别的账号会没有数据</p><p>和 React 的解决方法一样封装成一个函数放在 <code>methods</code> 里。</p><h2 id="遇到奇怪的-BUG"><a href="#遇到奇怪的-BUG" class="headerlink" title="遇到奇怪的 BUG"></a>遇到奇怪的 BUG</h2><pre><code>rm -rf node_modules/npm install</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摸到-Vue-js-的门把手&quot;&gt;&lt;a href=&quot;#摸到-Vue-js-的门把手&quot; class=&quot;headerlink&quot; title=&quot;摸到 Vue.js 的门把手&quot;&gt;&lt;/a&gt;摸到 Vue.js 的门把手&lt;/h1&gt;&lt;p&gt;文档那么多中文多和谐啊是不是？&lt;a href
      
    
    </summary>
    
    
      <category term="Black History" scheme="http://yoursite.com/tags/Black-History/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
</feed>
