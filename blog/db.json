{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/material/source/css/disqus-proxy.css","path":"css/disqus-proxy.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/disqus-proxy.min.css","path":"css/disqus-proxy.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/duoshuo.css","path":"css/duoshuo.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/fontawesome.min.css","path":"css/fontawesome.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/material-icons.css","path":"css/material-icons.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify.css","path":"css/prettify.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify.min.css","path":"css/prettify.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/uc.css","path":"css/uc.css","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/material/source/img/26715825.jpg","path":"img/26715825.jpg","modified":0,"renderable":1},{"_id":"themes/material/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/bg.png","path":"img/bg.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/browserstack_logo.png","path":"img/browserstack_logo.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/upyun_logo.svg","path":"img/upyun_logo.svg","modified":0,"renderable":1},{"_id":"themes/material/source/js/MathJax.js","path":"js/MathJax.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/Valine.min.js","path":"js/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","path":"js/hanabi-browser-bundle.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lsloader.js","path":"js/lsloader.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/lsloader.min.js","path":"js/lsloader.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/nprogress.js","path":"js/nprogress.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/prettify.min.js","path":"js/prettify.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/queue.js","path":"js/queue.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/queue.min.js","path":"js/queue.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":0,"renderable":1},{"_id":"themes/material/source/css/material.css","path":"css/material.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/material.min.css","path":"css/material.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/material/source/img/daily_pic.png","path":"img/daily_pic.png","modified":0,"renderable":1},{"_id":"themes/material/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/js.js","path":"js/js.js","modified":0,"renderable":1},{"_id":"themes/material/source/js/js.min.js","path":"js/js.min.js","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","path":"css/prettify/atelier-cave-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","path":"css/prettify/atelier-cave-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","path":"css/prettify/atelier-dune-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","path":"css/prettify/atelier-dune-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","path":"css/prettify/atelier-estuary-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","path":"css/prettify/atelier-estuary-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","path":"css/prettify/atelier-forest-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","path":"css/prettify/atelier-forest-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","path":"css/prettify/atelier-heath-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","path":"css/prettify/atelier-heath-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","path":"css/prettify/atelier-lakeside-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","path":"css/prettify/atelier-lakeside-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","path":"css/prettify/atelier-plateau-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","path":"css/prettify/atelier-plateau-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","path":"css/prettify/atelier-savanna-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","path":"css/prettify/atelier-savanna-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","path":"css/prettify/atelier-seaside-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","path":"css/prettify/atelier-seaside-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","path":"css/prettify/atelier-sulphurpool-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","path":"css/prettify/atelier-sulphurpool-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/github-v2.min.css","path":"css/prettify/github-v2.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/github.min.css","path":"css/prettify/github.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","path":"css/prettify/hemisu-dark.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","path":"css/prettify/hemisu-light.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","path":"css/prettify/tomorrow-night-blue.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","path":"css/prettify/tomorrow-night-bright.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","path":"css/prettify/tomorrow-night-eighties.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","path":"css/prettify/tomorrow-night.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","path":"css/prettify/tomorrow.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","path":"css/prettify/tranquil-heart.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","path":"css/prettify/vibrant-ink.min.css","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","path":"img/footer/footer_ico-bilibili.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","path":"img/footer/footer_ico-facebook.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","path":"img/footer/footer_ico-github.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","path":"img/footer/footer_ico-gplus.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","path":"img/footer/footer_ico-instagram.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","path":"img/footer/footer_ico-linkedin.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","path":"img/footer/footer_ico-telegram.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","path":"img/footer/footer_ico-tumblr.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","path":"img/footer/footer_ico-twitter.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","path":"img/footer/footer_ico-v2ex.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","path":"img/footer/footer_ico-weibo.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","path":"img/footer/footer_ico-zhihu.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-10.png","path":"img/random/material-10.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-12.png","path":"img/random/material-12.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-17.png","path":"img/random/material-17.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-19.png","path":"img/random/material-19.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-3.png","path":"img/random/material-3.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-4.png","path":"img/random/material-4.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-6.png","path":"img/random/material-6.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-8.png","path":"img/random/material-8.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-9.png","path":"img/random/material-9.png","modified":0,"renderable":1},{"_id":"themes/material/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-1.png","path":"img/random/material-1.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-11.png","path":"img/random/material-11.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-13.png","path":"img/random/material-13.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-14.png","path":"img/random/material-14.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-15.png","path":"img/random/material-15.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-16.png","path":"img/random/material-16.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-18.png","path":"img/random/material-18.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-2.png","path":"img/random/material-2.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-5.png","path":"img/random/material-5.png","modified":0,"renderable":1},{"_id":"themes/material/source/img/random/material-7.png","path":"img/random/material-7.png","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"themes/material/.eslintrc.json","hash":"83ddc0cdc18f28b967795b8dac0421a52cdf7ece","modified":1513102714525},{"_id":"themes/material/.gitignore","hash":"dd9e9495fc7ce09c026f7fdcef45cf8ddfde40d8","modified":1513102714525},{"_id":"themes/material/.travis.yml","hash":"10a09fe2b341ccad5b97d4bd9cc2c1c03e1863a3","modified":1513102714525},{"_id":"themes/material/CONTRIBUTING.md","hash":"148f555e47d4725fe1faac775107a4d7b03f7136","modified":1513102714525},{"_id":"themes/material/CONTRIBUTING.zh-cn.md","hash":"ef3ccef0451d6ac616b3a35fbfedb6abd35e6b41","modified":1513102714525},{"_id":"themes/material/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1513102714529},{"_id":"themes/material/README.md","hash":"408e36745a8aeb187a25f309752c5e7da66f7e67","modified":1513102714529},{"_id":"themes/material/_config.template.yml","hash":"909c9b66c782311a0fe16bca4e75dc13e1b289ea","modified":1513102714529},{"_id":"themes/material/_config.yml","hash":"58628fe621851ccf194f02305edb1fd3c733194f","modified":1513149267356},{"_id":"themes/material/contributing.json","hash":"1bc0871b1c7822b82533b614090ac0ab7c55282c","modified":1513102714529},{"_id":"themes/material/lint.sh","hash":"49c3a65f8ca65754ec7fefcd2dcb6adc187f3856","modified":1513102714537},{"_id":"themes/material/package.json","hash":"e00885ee25ac548685af9869cf4cf895118a744c","modified":1513102714537},{"_id":"source/Search/index.md","hash":"a727b011fa52e9d420dd28362b0345a7e6c2e62f","modified":1513101517536},{"_id":"source/_posts/Express.md","hash":"f221a65fd1ca1cd675ec87ea77076a6e33cf513e","modified":1513319809612},{"_id":"source/_posts/Linux 的基本命令行和 Git 的基本操作.md","hash":"a9e1eedf533d445a4caaad0ac4eaa6b442aea49c","modified":1513101517536},{"_id":"source/_posts/MVC - MVVM 是什么.md","hash":"777840049c08aadbe5fc528d145e69bd7c6d7e6a","modified":1513101517536},{"_id":"source/_posts/deepin shadowsocks-qt5 全局翻了个墙.md","hash":"ac7c1e6158f578d138c4170b868f442b560d5237","modified":1513101517536},{"_id":"source/_posts/做一个音乐 Webapp.md","hash":"d1935f6302ce218eea88a3668102b24593e3eede","modified":1513101517536},{"_id":"source/_posts/摸到 ES6 的门把手.md","hash":"428fc178281f6fc4dbe828c5a005ad5630c6fb86","modified":1513160209973},{"_id":"source/_posts/摸到 Promise 的门把手.md","hash":"10d04c721edacdd3fa24c5d23d49487bd2617950","modified":1513101517536},{"_id":"source/_posts/摸到 React 的门把手 (2).md","hash":"551d104620a0b966a2e77854c2150644e495308d","modified":1513101517536},{"_id":"source/_posts/摸到 React 的门把手 (3).md","hash":"303f53bbb2e0c1efa6d88b4e53efb116f18fddb5","modified":1513101517536},{"_id":"source/_posts/摸到 React 的门把手 (4).md","hash":"6111ebc79501245b8222f17c389d37f6a033e284","modified":1513101517536},{"_id":"source/_posts/摸到 React 的门把手 (5).md","hash":"9a811c8a03f027151e02b83177c786bb1ef43c3f","modified":1513101517536},{"_id":"source/_posts/摸到 React 的门把手 (6).md","hash":"13ac02f2b97a6da70cd685afeebb678973461aa1","modified":1513101517536},{"_id":"source/_posts/摸到 React 的门把手 (完).md","hash":"595175a4c83e6854d643bec24f2af90d241cf0e8","modified":1513101517536},{"_id":"source/_posts/摸到 React 的门把手.md","hash":"4b4c6f573e651579605db2189be48339dfd098d3","modified":1513101517536},{"_id":"source/_posts/摸到 TypeScript 的门把手.md","hash":"3ddab8b1cf469335af1e6cd973d5a6ef4e4bf465","modified":1513101517536},{"_id":"source/_posts/摸到 Vue.js 的门把手.md","hash":"f2a690cfbbfd94566041a3683260af0136e4bab0","modified":1513101517536},{"_id":"source/_posts/摸到 Vue.js 的门把手（2）.md","hash":"7a0d2ed01b2f2b047bc15692fae0496d5ac16d22","modified":1513101517536},{"_id":"source/_posts/摸到 Vue.js 的门把手（3）.md","hash":"bf299f6609a0833bf87ec4c9bc75876d974170a1","modified":1513101517536},{"_id":"source/_posts/摸到 webpack 的门把手 (2).md","hash":"11972ffc792e74d835c8cf6e9f70faaea0021025","modified":1513101517536},{"_id":"source/_posts/摸到 webpack 的门把手.md","hash":"5fd28632263c4732aaf9c59ff30ead2c4081f5ac","modified":1513101517536},{"_id":"source/_posts/用 Node 来搭建 HTTP 服务器.md","hash":"d60457cf0afbf72d57b332c97762422e0c4ff1d0","modified":1513101517536},{"_id":"source/_posts/看点面试题.md","hash":"1ea8a2f1061287915a7aaed4094ddef336030bf6","modified":1513101517536},{"_id":"source/_posts/简单走一遍 node.md","hash":"530f566a29f46b87b61af601649019cfd733f5de","modified":1513101517536},{"_id":"source/_posts/补基础：JS 单元测试.md","hash":"6052fa37dec92f6eb3aedeed3a49d90c203a5aeb","modified":1513101517536},{"_id":"source/_posts/补基础：JS 模块化.md","hash":"20217a409601e8ea5431064bd0f8c5335992725a","modified":1513101517536},{"_id":"source/_posts/补基础：React-Redux-ES6-webpack-babel.md","hash":"c11193a706f239ed0775a095024f5b3ec1ed075f","modified":1513101517536},{"_id":"source/_posts/补基础：node 各种知识点.md","hash":"c32983b27e4c2e0f8770aa456e7c89334ee15bf1","modified":1513101517536},{"_id":"source/_posts/补基础：this.md","hash":"51a16f7973dc21fccdb02d4f8be6c73067c8b1dc","modified":1513101517536},{"_id":"source/_posts/补基础：事件.md","hash":"054e6a65ff74e54af23225c654820227003d39eb","modified":1513101517536},{"_id":"source/_posts/补基础：函数.md","hash":"28ed2c2376fec8af142fcc68c047b9e184c9a5c9","modified":1513101517536},{"_id":"source/_posts/补基础：原型链和 prototype.md","hash":"23a4e5ad74b6cadf278e337b78b094b9a3427b21","modified":1513101517536},{"_id":"source/_posts/补基础：对象与数组的遍历方式.md","hash":"f40ef3b3ad57b8072ea13471aa0e2b451e04eeef","modified":1513101517536},{"_id":"source/archives/index.md","hash":"b4c5a7e610aa67bc81b46aa772847122601b8dbb","modified":1513101517536},{"_id":"source/tags/index.md","hash":"c65dab88a1569a7e452d4fe346bb0e71437578cb","modified":1513101517536},{"_id":"themes/material/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1513102714505},{"_id":"themes/material/.git/config","hash":"25f809f40d4db61edb7a01aa9b2214c00a747153","modified":1513102714505},{"_id":"themes/material/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1513102555424},{"_id":"themes/material/.git/index","hash":"a5cd353d84832d65fd81f6922b48f596e6a70608","modified":1513102738102},{"_id":"themes/material/.git/packed-refs","hash":"d2e3908110890d67472e95dd60f1c2f6b5b70659","modified":1513102714505},{"_id":"themes/material/languages/de.yml","hash":"bce37d066ffa82f3e249d41d0ee883c913cc2c5f","modified":1513102714529},{"_id":"themes/material/languages/en.yml","hash":"b59136a1b4d0a77e550b0e7e2e430cac44230dd3","modified":1513102714529},{"_id":"themes/material/languages/es.yml","hash":"d35f5411bc87277cc2d3a58d9499ddb9cfd46f1b","modified":1513102714529},{"_id":"themes/material/languages/fr.yml","hash":"f456cf31a72d97f2f18e3bb6cf735285d2b9d2c5","modified":1513102714529},{"_id":"themes/material/languages/ja.yml","hash":"768b8330c9c73287efd475e68741ce4ebad29fd1","modified":1513102714529},{"_id":"themes/material/languages/ms.yml","hash":"237a39bbfcce33e7b918f6c5dc0f01bc79900262","modified":1513102714529},{"_id":"themes/material/languages/nl_NL.yml","hash":"b71e59807716185627d6b9b84e44a79401df639f","modified":1513102714529},{"_id":"themes/material/languages/pt-BR.yml","hash":"a070c2c4d0d3d54f8ca70513cff73c3f7c306db1","modified":1513102714529},{"_id":"themes/material/languages/ru.yml","hash":"fbff2cf48dbde45adcad781e2fd6c30b523a4ac1","modified":1513102714529},{"_id":"themes/material/languages/zh-CN.yml","hash":"c188cad1a16ab0651e2d2d03cb3fa79962cf65ff","modified":1513102714529},{"_id":"themes/material/languages/zh-TW.yml","hash":"ec55953f0330f81bf1ffb37ff34de258dfda642a","modified":1513102714529},{"_id":"themes/material/layout/index.ejs","hash":"aca1abb741f891776913c8ea2e6ff626a0ea5736","modified":1513102714537},{"_id":"themes/material/layout/layout.ejs","hash":"94f66850b815a262c0f8ff112a32a0a6f43066e3","modified":1513102714537},{"_id":"themes/material/layout/post.ejs","hash":"4dd572a9e84f3a6baa5e3f16d270e58e3cd31a23","modified":1513102714537},{"_id":"themes/material/scripts/helper.js","hash":"e7111a8b1f0ab5bf3466378c48c260a4f6e527d6","modified":1513102714537},{"_id":"themes/material/.github/PULL_REQUEST_TEMPLATE.md","hash":"f2a3a0b929c0909ab99c96fb82853c2c2d67961a","modified":1513102714525},{"_id":"themes/material/.github/ISSUE_TEMPLATE.md","hash":"52a733a4d2e21a9c4d719495a0353c6719484f9f","modified":1513102714525},{"_id":"themes/material/languages/ar.yml","hash":"472d71f052e08f3c03b15dd67d11ad41f2eee7bf","modified":1513102714529},{"_id":"themes/material/layout/_partial/Isolation-post-info.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513102714529},{"_id":"themes/material/scripts/lib/font_lsload.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513102714537},{"_id":"themes/material/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1513102555424},{"_id":"themes/material/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1513102555424},{"_id":"themes/material/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1513102555424},{"_id":"themes/material/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1513102555424},{"_id":"themes/material/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1513102555424},{"_id":"themes/material/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1513102555424},{"_id":"themes/material/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1513102555424},{"_id":"themes/material/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1513102555424},{"_id":"themes/material/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1513102555424},{"_id":"themes/material/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1513102555424},{"_id":"themes/material/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1513102555424},{"_id":"themes/material/.git/logs/HEAD","hash":"5bd8e943d1895a133f5d11e52d3336baa451762a","modified":1513102714505},{"_id":"themes/material/layout/_partial/Isolation-post_entry.ejs","hash":"134dc82320b7aed7d4d78960be63e16c5c4a30fb","modified":1513102714529},{"_id":"themes/material/layout/_partial/Paradox-post-info.ejs","hash":"125cfa5cd9e6e1ca5e958026fdd42f3c3141e34f","modified":1513102714529},{"_id":"themes/material/layout/_partial/Paradox-post-thumbnail.ejs","hash":"6f1e9a85c089ce98a36a2954839fb9ce3e53739e","modified":1513102714529},{"_id":"themes/material/layout/_partial/Paradox-post_entry-thumbnail.ejs","hash":"4d740eba338517d4e10d011a157cdefad45a8e1f","modified":1513102714529},{"_id":"themes/material/layout/_partial/Paradox-post_entry.ejs","hash":"5f4d67e5bd70f635203706cf344b036d891073e6","modified":1513102714529},{"_id":"themes/material/layout/_partial/Paradox-search.ejs","hash":"18a6971b04feccd124a096b8c7cecf1fd4bb914e","modified":1513102714529},{"_id":"themes/material/layout/_partial/blog_info.ejs","hash":"5e95796e6f9a81163554ca4198573860f7328d4e","modified":1513102714529},{"_id":"themes/material/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1513102714529},{"_id":"themes/material/layout/_partial/config_css.ejs","hash":"2b1e27faa0446a5e756e61ddf3e969e50948f1ce","modified":1513102714529},{"_id":"themes/material/layout/_partial/config_font.ejs","hash":"730abeb681758ce288d5541930c46bc4b041a0b1","modified":1513102714529},{"_id":"themes/material/layout/_partial/daily_pic.ejs","hash":"e780fbdb79b5e27091c408545cfd5b64892c9b01","modified":1513102714529},{"_id":"themes/material/layout/_partial/footer-left.ejs","hash":"372cdf718e01fea2736b8e427e57bfcfaa8a557f","modified":1513102714529},{"_id":"themes/material/layout/_partial/footer-option.ejs","hash":"be20394eaeaf2d20db28946b948962c839da6ea9","modified":1513102714529},{"_id":"themes/material/layout/_partial/footer.ejs","hash":"530626c347882579d09d71df68993e25076ca8e2","modified":1513102714529},{"_id":"themes/material/layout/_partial/footer_top.ejs","hash":"9eaace4feb951c96c0033e7271497f3f300d2476","modified":1513102714529},{"_id":"themes/material/layout/_partial/head.ejs","hash":"8167f995c7cc21a6a8ddbfbdd03f2f74a7bd904d","modified":1513102714529},{"_id":"themes/material/layout/_partial/import_js.ejs","hash":"961b8a0059875e4044fe80bbe91ca6a225f113e5","modified":1513102714533},{"_id":"themes/material/layout/_partial/isolate-sns_list.ejs","hash":"fc5f03ebb847f85975676a9dfee8870e7c908008","modified":1513102714533},{"_id":"themes/material/layout/_partial/isolate_info.ejs","hash":"b8ec76716bfa2e6513b4df6814fe8676536a94c1","modified":1513102714533},{"_id":"themes/material/layout/_partial/post-content.ejs","hash":"ad626e3b60bc4a17bacff02cf9b0a8beaba2ad1e","modified":1513102714533},{"_id":"themes/material/layout/_partial/post-header.ejs","hash":"b0b8973c48db6376a24d4b4b1d2eb15d18d6508c","modified":1513102714533},{"_id":"themes/material/layout/_partial/post-info-share.ejs","hash":"9f28d62bf728c2bd89411688426a65d7ee55400c","modified":1513102714533},{"_id":"themes/material/layout/_partial/post-nav.ejs","hash":"3b6d4568cc46f60c697ad9ec85a4aa5971f3eecc","modified":1513102714533},{"_id":"themes/material/layout/_partial/sidebar-footer.ejs","hash":"6c3486b846473e0d58666f7a8720f5bf4a14e030","modified":1513102714533},{"_id":"themes/material/layout/_partial/sidebar-footer_image.ejs","hash":"b9157d2072028a1db3c3419f76bde6637e85cf0e","modified":1513102714533},{"_id":"themes/material/layout/_partial/sidebar-header.ejs","hash":"06295e01092f55504d30a343c3fdc5091280e495","modified":1513102714533},{"_id":"themes/material/layout/_partial/sidebar-navigation.ejs","hash":"ff44901fdfdd952174b0d22e86df7163d7fba9ba","modified":1513102714533},{"_id":"themes/material/layout/_partial/sidebar.ejs","hash":"c5ce6136e82895cb80dab8a918a7cdf2fe820fea","modified":1513102714533},{"_id":"themes/material/layout/_partial/structured-data.ejs","hash":"e845df290185dc300cc4edcc08b50fddc5b6909b","modified":1513102714533},{"_id":"themes/material/layout/_partial/toc_button.ejs","hash":"688c3fc12e2548ff27fe60688f79dcce2881fd50","modified":1513102714533},{"_id":"themes/material/layout/_widget/dnsprefetch.ejs","hash":"5e4c5359d69a64042183db13f6dd771b1f7f6b31","modified":1513102714533},{"_id":"themes/material/layout/_widget/leancloud-like.ejs","hash":"e4780fe3bbb049db38d694fc18dee13d799bd51d","modified":1513102714533},{"_id":"themes/material/layout/_widget/leancloud-views_num.ejs","hash":"e27baba6a2de406463735d276606b15fb40f5eba","modified":1513102714533},{"_id":"themes/material/layout/_widget/leancloud-views.ejs","hash":"211dc183b8e84f71b2c25b3ac6659d162d81662b","modified":1513102714533},{"_id":"themes/material/layout/_widget/mathjax.ejs","hash":"b68befe1fea84739c8429c344e570a8bc0357401","modified":1513102714533},{"_id":"themes/material/layout/_widget/nprogress.ejs","hash":"901a64600854b312209287c702278183600e06b9","modified":1513102714533},{"_id":"themes/material/layout/_widget/page-gallery.ejs","hash":"81b9410deef7a83ef5bc7cd18ad042df70d70b94","modified":1513102714533},{"_id":"themes/material/layout/_widget/page-links.ejs","hash":"0ebe18e4326f921d6010df8479a08c2d403ba717","modified":1513102714533},{"_id":"themes/material/layout/_widget/page-tagcloud.ejs","hash":"e71de74e4067cc4e6aef1e09ac429c92bcd178b3","modified":1513102714533},{"_id":"themes/material/layout/_widget/page-timeline.ejs","hash":"9fa0195e08d9fd40aa0333e9279c98bc65acf604","modified":1513102714537},{"_id":"themes/material/layout/_widget/qrcode.ejs","hash":"3212e5d29fe8490c5d9a844ec9c2ce9925532de8","modified":1513102714537},{"_id":"themes/material/layout/_widget/search-local-js.ejs","hash":"f42cc040adf47fc7d74f64b0be3c3230e8a3339e","modified":1513102714537},{"_id":"themes/material/layout/_widget/search-swiftype-js.ejs","hash":"7ad1e843e620ccd9b3c041dccfdcee97921247a1","modified":1513102714537},{"_id":"themes/material/scripts/lib/css_lsload.js","hash":"179f5f5e3297a7fb7d90545ddd94eb468a11046e","modified":1513102714537},{"_id":"themes/material/scripts/lib/js_lsload.js","hash":"72f885b13fe0028a0e2acb7168dcc66e39ea1592","modified":1513102714537},{"_id":"themes/material/scripts/lib/path_for.js","hash":"f944e3b53a468962121aa3357cc0bc18ac27a34c","modified":1513102714537},{"_id":"themes/material/source/css/disqus-proxy.css","hash":"770776d8cec27cd5661bdfd59eff9af263439989","modified":1513102714537},{"_id":"themes/material/source/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1513102714537},{"_id":"themes/material/source/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1513102714537},{"_id":"themes/material/source/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1513102714537},{"_id":"themes/material/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1513102714537},{"_id":"themes/material/source/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1513102714537},{"_id":"themes/material/source/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1513102714541},{"_id":"themes/material/source/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1513102714537},{"_id":"themes/material/source/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1513102714541},{"_id":"themes/material/source/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1513102714541},{"_id":"themes/material/source/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1513102714541},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1513102714545},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1513102714545},{"_id":"themes/material/source/img/26715825.jpg","hash":"874943fa6cae02a72b6b609093499a9857bf0408","modified":1513103231957},{"_id":"themes/material/source/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1513102714569},{"_id":"themes/material/source/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1513102714569},{"_id":"themes/material/source/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1513102714569},{"_id":"themes/material/source/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1513102714569},{"_id":"themes/material/source/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1513102714569},{"_id":"themes/material/source/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1513102714577},{"_id":"themes/material/source/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1513102714577},{"_id":"themes/material/source/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1513102714577},{"_id":"themes/material/source/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1513102714577},{"_id":"themes/material/source/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1513102714577},{"_id":"themes/material/source/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1513102714577},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1513102714577},{"_id":"themes/material/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1513102714577},{"_id":"themes/material/source/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1513102714577},{"_id":"themes/material/source/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1513102714577},{"_id":"themes/material/source/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1513102714577},{"_id":"themes/material/source/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1513102714577},{"_id":"themes/material/source/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1513102714577},{"_id":"themes/material/source/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1513102714577},{"_id":"themes/material/source/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1513102714577},{"_id":"themes/material/scripts/lib/js_hex.js","hash":"2704583aa036d538544ce31c2e924c0c125309dd","modified":1513102714537},{"_id":"themes/material/scripts/lib/get_file_hex.js","hash":"eb3b9a45f8ca45ef40d5421baef7d4484023982c","modified":1513102714537},{"_id":"themes/material/source/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1513102714541},{"_id":"themes/material/source/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1513102714541},{"_id":"themes/material/source/css/style.css","hash":"a2f27c40f412dc24e1ed5f62a4117523a226eed0","modified":1513102714541},{"_id":"themes/material/source/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1513102714541},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1513102714545},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1513102714569},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1513102714569},{"_id":"themes/material/source/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1513102714569},{"_id":"themes/material/source/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1513102714577},{"_id":"themes/material/source/js/js.js","hash":"64b3f20e7138674ecf21e6e3982565ea63feae26","modified":1513102714577},{"_id":"themes/material/source/js/js.min.js","hash":"709d347d3be033b841de0493b7cf532b594bb1f6","modified":1513102714577},{"_id":"themes/material/.git/refs/heads/master","hash":"cddd42575fbd9b539274771d90a7e66b1b6b8945","modified":1513102714505},{"_id":"themes/material/layout/_widget/analytics/baidu-analytics.ejs","hash":"3866a7fead3c1f94a517f1f9d629f092670b1520","modified":1513102714533},{"_id":"themes/material/layout/_widget/analytics/cnzz-analytics.ejs","hash":"1765e3dcd92961292f40d1812e593186c77b17ef","modified":1513102714533},{"_id":"themes/material/layout/_widget/analytics/google-analytics.ejs","hash":"3b10ebf524baf0c24b22dcd110b39d15c5acb9b5","modified":1513102714533},{"_id":"themes/material/source/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1513102714541},{"_id":"themes/material/source/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1513102714541},{"_id":"themes/material/source/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1513102714541},{"_id":"themes/material/source/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1513102714541},{"_id":"themes/material/source/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1513102714541},{"_id":"themes/material/source/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1513102714541},{"_id":"themes/material/source/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1513102714541},{"_id":"themes/material/source/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1513102714541},{"_id":"themes/material/source/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1513102714541},{"_id":"themes/material/source/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1513102714541},{"_id":"themes/material/source/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1513102714541},{"_id":"themes/material/source/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1513102714541},{"_id":"themes/material/source/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1513102714541},{"_id":"themes/material/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1513102714545},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1513102714545},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1513102714565},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1513102714569},{"_id":"themes/material/source/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1513102714569},{"_id":"themes/material/source/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1513102714569},{"_id":"themes/material/source/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1513102714569},{"_id":"themes/material/source/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1513102714569},{"_id":"themes/material/source/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1513102714569},{"_id":"themes/material/source/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1513102714569},{"_id":"themes/material/source/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1513102714573},{"_id":"themes/material/source/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1513102714573},{"_id":"themes/material/source/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1513102714573},{"_id":"themes/material/source/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1513102714573},{"_id":"themes/material/source/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1513102714573},{"_id":"themes/material/source/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1513102714573},{"_id":"themes/material/source/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1513102714573},{"_id":"themes/material/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1513102714577},{"_id":"themes/material/layout/_widget/comment/livere/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/valine/common.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513102714533},{"_id":"themes/material/source/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1513102714569},{"_id":"themes/material/source/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1513102714569},{"_id":"themes/material/source/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1513102714573},{"_id":"themes/material/source/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1513102714573},{"_id":"themes/material/source/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1513102714573},{"_id":"themes/material/source/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1513102714573},{"_id":"themes/material/source/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1513102714573},{"_id":"themes/material/source/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1513102714573},{"_id":"themes/material/source/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1513102714573},{"_id":"themes/material/source/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1513102714573},{"_id":"themes/material/.git/logs/refs/heads/master","hash":"5bd8e943d1895a133f5d11e52d3336baa451762a","modified":1513102714505},{"_id":"themes/material/.git/objects/pack/pack-d594bcac686e983c0ce836393735357c65aeaee7.idx","hash":"28f42fd954642e6b3cc3250dbe0fb5dd30a87e55","modified":1513102714397},{"_id":"themes/material/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1513102714505},{"_id":"themes/material/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/disqus/enter.ejs","hash":"39192034766349e47967da63184f9104fdded2ab","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/disqus/main.ejs","hash":"21e0eeff664191b818d7a0071ae7edcdfc270442","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/disqus_click/main.ejs","hash":"f53de208ca46c669a868a1922488e39509c6fe3b","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/gitalk/common.ejs","hash":"f739897518011e1b3de7807c8c5d734984711282","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/gitalk/enter.ejs","hash":"4d70d76465469a57def29a221962a5520fb34ebe","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/gitalk/main.ejs","hash":"1ee7a7b2b9b5ae8c4fa8c4b09c7973b9e085bdf2","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/gitment/common.ejs","hash":"9c6c8d1b448c32afb01c2d0351e87f4d4a17ec3c","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/gitment/enter.ejs","hash":"46d904fde9233694b95c6a3d91b9a2b7a6805850","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/livere/enter.ejs","hash":"194b7bb581a3b8608a7ab135b6953d7908f51cc8","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/livere/main.ejs","hash":"1c4be9ba104a8cbcc11d45f11bf8cfe7704b93a5","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/valine/enter.ejs","hash":"ab528aad46237d9e7f1c5b4b2b310dd628b2de63","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/valine/main.ejs","hash":"3d5d8559e6ad4ffb58a61d96439b2718eb9999b6","modified":1513102714533},{"_id":"themes/material/layout/_widget/comment/gitment/main.ejs","hash":"e622660eda38cda05847aadc2a3e31a228fc519b","modified":1513102714533},{"_id":"themes/material/.git/logs/refs/remotes/origin/HEAD","hash":"5bd8e943d1895a133f5d11e52d3336baa451762a","modified":1513102714505},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1513102714565},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1513102714549},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1513102714553},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1513102714557},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1513102714561},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1513102714565},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1513102714553},{"_id":"themes/material/.git/objects/pack/pack-d594bcac686e983c0ce836393735357c65aeaee7.pack","hash":"a6b67da588d4bed783e4c836259097f905d62b61","modified":1513102714393},{"_id":"public/atom.xml","hash":"a4e08091c262cb89896a78ab13070942a6bcc8ab","modified":1513319822235},{"_id":"public/search.xml","hash":"212c24d9cbe5de010529df1b792ea843c6574aa6","modified":1513319822908},{"_id":"public/sitemap.xml","hash":"d1b7ccb7e99f830c5fbe54324886e95870e57d5d","modified":1513319822925},{"_id":"public/Search/index.html","hash":"613377e83984fd0a6a119674d10ceb88fe2bb473","modified":1513149278027},{"_id":"public/archives/index.html","hash":"ea73d5b00425a916a0aaa7b0d421cf007ddcbb01","modified":1513149278134},{"_id":"public/tags/index.html","hash":"27429f9c3835eb4cc655d8575934b108a2b7c102","modified":1513149278136},{"_id":"public/2017/12/13/Express/index.html","hash":"e1affa3821002bfa46ed116787f5a8e77bf238fd","modified":1513319822931},{"_id":"public/2017/12/08/补基础：JS 模块化/index.html","hash":"a51334ddfcc211d55b2db2ac042dfd0bb500b029","modified":1513149278136},{"_id":"public/2017/12/06/MVC - MVVM 是什么/index.html","hash":"5b1bd0e6544f0290daf22e363fb34f966fe76422","modified":1513149278136},{"_id":"public/2017/12/01/用 Node 来搭建 HTTP 服务器/index.html","hash":"5558a356297c59198b5f33c45c5cc87c205cad1f","modified":1513149278137},{"_id":"public/2017/11/29/补基础：node 各种知识点/index.html","hash":"8549f44b923f52ab22b3bb3b9878e6ef265962f0","modified":1513149278137},{"_id":"public/2017/11/27/Linux 的基本命令行和 Git 的基本操作/index.html","hash":"5576ca21f90aa5dc64077ac9d8ffe8a3cd9d5b03","modified":1513149278137},{"_id":"public/2017/11/26/简单走一遍 node/index.html","hash":"dfce0054ff4ba3b665a778af347c2f202b6b69ae","modified":1513149278137},{"_id":"public/2017/11/19/补基础：事件/index.html","hash":"bb87b1d1f95f5dbbabe826a0242b3908c135ba98","modified":1513149278137},{"_id":"public/2017/11/15/看点面试题/index.html","hash":"585ecd3a59c1045039109df8c28ab6765eb1e91a","modified":1513149278137},{"_id":"public/2017/11/13/补基础：JS 单元测试/index.html","hash":"74966792909789d0e9ff205a187f4cfc4ebe0f5e","modified":1513149278137},{"_id":"public/2017/11/05/补基础：React-Redux-ES6-webpack-babel/index.html","hash":"069a4e44701330014ea694735baa4ac6d9f5eaec","modified":1513149278137},{"_id":"public/2017/10/25/deepin shadowsocks-qt5 全局翻了个墙/index.html","hash":"fe0f08926c1a21ae41ce39f1f64abb3745aae03b","modified":1513149278137},{"_id":"public/2017/10/24/补基础：函数/index.html","hash":"85097fc30b04535494a208b6fc14fc0b356aefa7","modified":1513149278137},{"_id":"public/2017/10/22/补基础：对象与数组的遍历方式/index.html","hash":"ea31930464c58a0cc5b672b8081f18cf11778eaf","modified":1513149278137},{"_id":"public/2017/10/19/补基础：this/index.html","hash":"862af492e30474db1e444da45e026c556d62de5e","modified":1513149278138},{"_id":"public/2017/10/17/补基础：原型链和 prototype/index.html","hash":"4937cc251b17a2d9c85ca28c0149c46de804c77e","modified":1513149278138},{"_id":"public/2017/10/15/做一个音乐 Webapp/index.html","hash":"3525cc967ea1473e65cb0920e27528da2e5c221b","modified":1513149278138},{"_id":"public/2017/10/14/摸到 Vue.js 的门把手（3）/index.html","hash":"0005c800ae1eab33fe80213fa08ce0ba985d7afe","modified":1513149278138},{"_id":"public/2017/10/14/摸到 Vue.js 的门把手（2）/index.html","hash":"6acb5e34335ae132e9aa29c3333e87382a887b3c","modified":1513149278138},{"_id":"public/2017/10/14/摸到 Vue.js 的门把手/index.html","hash":"d5d39ac7d5aadb165af58c148216ad25185fe4f8","modified":1513149278138},{"_id":"public/2017/10/14/摸到 React 的门把手 (完)/index.html","hash":"9ce93e959244acd7ee2ba7eeb9a4e5e9092849a9","modified":1513149278138},{"_id":"public/2017/10/14/摸到 React 的门把手 (6)/index.html","hash":"d8bdd5383d0ffa3323fa163b309ff4d4335b8d87","modified":1513149278138},{"_id":"public/2017/10/14/摸到 React 的门把手 (5)/index.html","hash":"6dff029a36c182d9b220a781d21f59e8ac9cfde6","modified":1513149278138},{"_id":"public/2017/10/14/摸到 React 的门把手 (4)/index.html","hash":"66e0db9788c037df631fe8d6a9f1c2f4f2a6518f","modified":1513149278138},{"_id":"public/2017/10/14/摸到 React 的门把手 (3)/index.html","hash":"973bd97d882def34eec1e93ce5d90f28aa6b016a","modified":1513149278138},{"_id":"public/2017/10/14/摸到 React 的门把手 (2)/index.html","hash":"b689f417378e995d81f4a506697dbb860eaf5319","modified":1513149278139},{"_id":"public/2017/10/14/摸到 React 的门把手/index.html","hash":"cd178e5ffaff61451ddcbf15852790364063e3cd","modified":1513149278139},{"_id":"public/2017/10/14/摸到 TypeScript 的门把手/index.html","hash":"6ec250510cf1b56bdc8da7fe292044ffa18a4a0e","modified":1513149278139},{"_id":"public/2017/10/14/摸到 webpack 的门把手 (2)/index.html","hash":"e944d04931a2f7bec21644b5ec19ea28772ddf60","modified":1513149278139},{"_id":"public/2017/10/14/摸到 webpack 的门把手/index.html","hash":"ec69d0a37662389e8737b3b47b94ef56919953a7","modified":1513149278139},{"_id":"public/2017/10/14/摸到 Promise 的门把手/index.html","hash":"4d9f562a02f0246ed205c1df20b026071839aefb","modified":1513149278139},{"_id":"public/2017/10/14/摸到 ES6 的门把手/index.html","hash":"0c80b03c689510b993cd03b8e2d328b01b0b3c9a","modified":1513160241870},{"_id":"public/archives/2017/index.html","hash":"6baf5baa2390738ed5e965bd3b4cf1f0e5ad1a0a","modified":1513149278139},{"_id":"public/archives/2017/10/index.html","hash":"e75a7a17a7705538fc19bedb6066360100536063","modified":1513149278139},{"_id":"public/archives/2017/11/index.html","hash":"e48d653ef235ad8eadd7d031e1af9db01cded8dc","modified":1513149278139},{"_id":"public/archives/2017/12/index.html","hash":"307c8d86f491e7f58d10fc603616b461640a3017","modified":1513149278139},{"_id":"public/index.html","hash":"e58b8454125f0dab206ba8f662c9df28bf043db4","modified":1513149278139},{"_id":"public/tags/Node/index.html","hash":"320c1cb3a51f42517128e075edd48b00cb4d38ad","modified":1513149278140},{"_id":"public/tags/Linux/index.html","hash":"a15f0fca182ee74fa2335647d13cf41af467e95d","modified":1513149278140},{"_id":"public/tags/Git/index.html","hash":"daac823b60f58d9374ac59c0c6e5dab84aa1b931","modified":1513149278140},{"_id":"public/tags/JavaScript/index.html","hash":"5c138cd9f7accc39683d2fe7814b8101a43fb194","modified":1513149278140},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"d8a69723da1addd4eabbff16ec98882e6a11b221","modified":1513149278140},{"_id":"public/tags/fq/index.html","hash":"0afb565ab7a10a50add10b190f23150690ce3c9e","modified":1513149278140},{"_id":"public/tags/ES6/index.html","hash":"9f8a2d8e1f2947d56c3fce8f3f1b70b3a6812c82","modified":1513149278140},{"_id":"public/tags/Black-History/index.html","hash":"3454fa44eeb0d67acb3ead7c21c1f659bf5f252f","modified":1513149278140},{"_id":"public/tags/Black-History/page/2/index.html","hash":"84642a9ee570ff2f352a0d234fa504ae02393ca6","modified":1513149278155},{"_id":"public/tags/React/index.html","hash":"b0f39a06641d44d1478a9e5f7c367ee4488c8402","modified":1513149278155},{"_id":"public/tags/TypeScript/index.html","hash":"7c8b7c7fcc44337bda4c17c8efe56d36a098e046","modified":1513149278155},{"_id":"public/tags/Vue/index.html","hash":"f08dec8b1b649336ddff6a39b241076aaf28a4a3","modified":1513149278155},{"_id":"public/tags/webpack/index.html","hash":"15f92b2317df6d8e17395d8a1cf3aee85b6b89e8","modified":1513149278155},{"_id":"public/tags/HTTP/index.html","hash":"0c5930c39d41be9a15c12b628067d796341fd046","modified":1513149278155},{"_id":"public/tags/Interview/index.html","hash":"3cf6fb2cfcc826ef16f97b0adceea8b2afc493c9","modified":1513149278155},{"_id":"public/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1513149278155},{"_id":"public/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1513149278156},{"_id":"public/img/26715825.jpg","hash":"874943fa6cae02a72b6b609093499a9857bf0408","modified":1513149278156},{"_id":"public/img/avatar.png","hash":"bf483b0d495dbbcfb308348a945818e1c1cc9696","modified":1513149278156},{"_id":"public/img/bg.png","hash":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1513149278156},{"_id":"public/img/favicon.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1513149278156},{"_id":"public/img/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1513149278156},{"_id":"public/img/logo.png","hash":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1513149278156},{"_id":"public/img/sidebar_header.png","hash":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1513149278156},{"_id":"public/img/upyun_logo.svg","hash":"1f118b2b9c54f431d5e731ccf316ceefe605ba67","modified":1513149278156},{"_id":"public/img/footer/footer_ico-bilibili.svg","hash":"1a007ae30d69aa597f589edb4ee0638a9814c988","modified":1513149278156},{"_id":"public/img/footer/footer_ico-facebook.svg","hash":"74b3b3c6bd1d76b7eaaf75d36ac929b11a5a3e82","modified":1513149278156},{"_id":"public/img/footer/footer_ico-github.svg","hash":"5f1f9f53e6a87ad674108c6bd16e424a1e888c61","modified":1513149278156},{"_id":"public/img/footer/footer_ico-gplus.svg","hash":"b50274133ab263bcacdf729871d0446b615ac984","modified":1513149278157},{"_id":"public/img/footer/footer_ico-instagram.svg","hash":"294c511e62063ea49f61e23958ab27d643ba0228","modified":1513149278157},{"_id":"public/img/footer/footer_ico-linkedin.svg","hash":"9831c86352ec5ff283a3277d033120f86388c277","modified":1513149278157},{"_id":"public/img/footer/footer_ico-telegram.svg","hash":"413d66e40ca476deeb49364935d49d2f7839cdfd","modified":1513149278157},{"_id":"public/img/footer/footer_ico-tumblr.svg","hash":"11daf4fa4220787306fc21a879429e98b7db8d03","modified":1513149278157},{"_id":"public/img/footer/footer_ico-twitter.svg","hash":"58df7777d6fcee8fa3c42453c091714bb3f97c95","modified":1513149278157},{"_id":"public/img/footer/footer_ico-v2ex.svg","hash":"c5ffaf67a97e534c266d1585a9a3b56f1bfe3052","modified":1513149278157},{"_id":"public/img/footer/footer_ico-weibo.svg","hash":"26d0cdb77f0c4afd60111176167eacfa222bc4c1","modified":1513149278157},{"_id":"public/img/footer/footer_ico-zhihu.svg","hash":"d3f8da320fffefc5144822665dfe17d25af4061c","modified":1513149278157},{"_id":"public/img/gallery/arrow.svg","hash":"144d73877e52acc5068bc0c9d1e69ef450e69f26","modified":1513149278157},{"_id":"public/img/gallery/close.svg","hash":"2690088060811f01c9360df75be80070156ff176","modified":1513149278157},{"_id":"public/img/gallery/spinner.svg","hash":"fc9d1cd1118ac896d4f5326e110a653f3ea32b11","modified":1513149278157},{"_id":"public/img/random/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1513149278157},{"_id":"public/img/random/material-12.png","hash":"d020b3d42542715c7ae95b3d8603fe3180bfe8f3","modified":1513149278157},{"_id":"public/img/random/material-17.png","hash":"ece82810e31f711576db598c845c3d97bd49fe67","modified":1513149278158},{"_id":"public/img/random/material-19.png","hash":"768ed1a4966e2e418cb00f6b36d2fc9058328eb3","modified":1513149278158},{"_id":"public/img/random/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1513149278158},{"_id":"public/img/random/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1513149278158},{"_id":"public/img/random/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1513149278158},{"_id":"public/img/random/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1513149278158},{"_id":"public/img/random/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1513149278158},{"_id":"public/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1513149278212},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1513149278217},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1513149278222},{"_id":"public/img/daily_pic.png","hash":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1513149278222},{"_id":"public/img/random/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1513149278223},{"_id":"public/img/random/material-11.png","hash":"ce20b0ad08a248c036115374f2edb7301ff60b72","modified":1513149278223},{"_id":"public/img/random/material-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1513149278223},{"_id":"public/img/random/material-14.png","hash":"b4f65b601960138c69f57171b0ddd55895483f45","modified":1513149278223},{"_id":"public/img/random/material-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1513149278223},{"_id":"public/img/random/material-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1513149278223},{"_id":"public/img/random/material-18.png","hash":"4b98204abe36ecd3f30678d2c22059130e0db328","modified":1513149278223},{"_id":"public/img/random/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1513149278224},{"_id":"public/img/random/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1513149278224},{"_id":"public/img/random/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1513149278224},{"_id":"public/css/disqus-proxy.min.css","hash":"3f8f99f71d361302288b0ba11fd36072564b08c2","modified":1513149278242},{"_id":"public/css/duoshuo.css","hash":"32a02eaa01ff7b66fd9df307b0d33d52810096be","modified":1513149278242},{"_id":"public/css/ie-blocker.css","hash":"dddce7e6250a449291888ae7865697282a213b14","modified":1513149278243},{"_id":"public/css/duoshuo.min.css","hash":"89a30544b8b01d061da51c40f2af702a7969de5e","modified":1513149278243},{"_id":"public/css/prettify.css","hash":"c395f20ee64e80c2b6b15c7dade02f9aaaeab2c8","modified":1513149278243},{"_id":"public/css/prettify.min.css","hash":"62edd8f08656463b0e077dcf893faa3cc8eb5fe4","modified":1513149278243},{"_id":"public/css/uc.css","hash":"1e0977a2c9bdf721cc05654dfc025dd250655852","modified":1513149278243},{"_id":"public/js/hanabi-browser-bundle.js","hash":"d646647bda386140c8315d60e3ff4ddbdb15c1ea","modified":1513149278243},{"_id":"public/js/ie-blocker.en.js","hash":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1513149278243},{"_id":"public/js/ie-blocker.zhCN.js","hash":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1513149278243},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1513149278243},{"_id":"public/js/lsloader.js","hash":"2b14e57784fb6b5f58d71584189c61af45f393e8","modified":1513149278244},{"_id":"public/js/lsloader.min.js","hash":"1a68a8d267948ea8475245b7d365a1a1bd8f732e","modified":1513149278244},{"_id":"public/js/nprogress.js","hash":"a3058d4b6afb5d7a14e5afcbb88f778de35864f0","modified":1513149278244},{"_id":"public/js/prettify.min.js","hash":"69908fe0a09cee107c25cb5d769b861723e7b7bb","modified":1513149278244},{"_id":"public/js/queue.js","hash":"dd252616b568b71c222d9cfc859bfe52738e576a","modified":1513149278244},{"_id":"public/js/queue.min.js","hash":"21aab782ca33efbb1386cc960b6be0a02106760d","modified":1513149278244},{"_id":"public/js/smoothscroll.js","hash":"df56a1c84191a62750ae820943377b6775fca0e2","modified":1513149278244},{"_id":"public/css/prettify/atelier-cave-dark.min.css","hash":"cb0156cdc36500a26b232ae1c81fdc880eba85e7","modified":1513149278244},{"_id":"public/css/prettify/atelier-cave-light.min.css","hash":"4b62dc45aa351b071d6a434dc54fe8c2e15c85cc","modified":1513149278245},{"_id":"public/css/prettify/atelier-dune-dark.min.css","hash":"c5094d99ca0e619d97860c88211bf908fdf830b1","modified":1513149278245},{"_id":"public/css/prettify/atelier-dune-light.min.css","hash":"b3ad98483e4d5bde72d52a15423d98e0d086db09","modified":1513149278245},{"_id":"public/css/prettify/atelier-estuary-dark.min.css","hash":"7e3a065cafeb3acc1d7178f64ef4265f5d5ad2b9","modified":1513149278245},{"_id":"public/css/prettify/atelier-estuary-light.min.css","hash":"1d12d8f7fa9c122a186ee76fdf681c191a68f104","modified":1513149278245},{"_id":"public/css/prettify/atelier-forest-dark.min.css","hash":"9296b851a5b66785a60afa5da5fe9080bda96bf5","modified":1513149278245},{"_id":"public/css/prettify/atelier-forest-light.min.css","hash":"3532f6e86bf4afbba05f7a074b791b73174f9622","modified":1513149278245},{"_id":"public/css/prettify/atelier-heath-dark.min.css","hash":"954309acd7918422382a3ff2f9c2988aec0ff956","modified":1513149278246},{"_id":"public/css/prettify/atelier-heath-light.min.css","hash":"a67199fa580b3aa2df031e5d2028929d29ca3b45","modified":1513149278246},{"_id":"public/css/prettify/atelier-lakeside-dark.min.css","hash":"18575fc6dff855e395a39d0383d2f18807091f0d","modified":1513149278246},{"_id":"public/css/prettify/atelier-lakeside-light.min.css","hash":"e20e8ac64432fa1aa6f74792b58196af7cf79c12","modified":1513149278246},{"_id":"public/css/prettify/atelier-plateau-dark.min.css","hash":"137e3c499a720da3c1d57b4dc53264b1d623e1c5","modified":1513149278246},{"_id":"public/css/prettify/atelier-plateau-light.min.css","hash":"153801640fdcbb74c0de3f15345110f2210eb991","modified":1513149278247},{"_id":"public/css/prettify/atelier-savanna-dark.min.css","hash":"fba92c652fd6704422b8f2bbc11706805a6faed0","modified":1513149278247},{"_id":"public/css/prettify/atelier-savanna-light.min.css","hash":"d9425ffb7c60d646190c22b9a5f72091ee5f9ace","modified":1513149278247},{"_id":"public/css/prettify/atelier-seaside-dark.min.css","hash":"e0e6bbacc75a349b1e49c236d374b0e42f1fd485","modified":1513149278248},{"_id":"public/css/prettify/atelier-seaside-light.min.css","hash":"732750b75389c1c49204f37705e6abeee40ce64f","modified":1513149278248},{"_id":"public/css/prettify/atelier-sulphurpool-dark.min.css","hash":"015a35dddaee153fa8bb71d7f3818a6ba4d120d8","modified":1513149278248},{"_id":"public/css/prettify/atelier-sulphurpool-light.min.css","hash":"ab1a6200eab648cab443c3df77fde9b237ef27b6","modified":1513149278248},{"_id":"public/css/prettify/github-v2.min.css","hash":"57630621d20842a529bdea7b17fc90f520e562ef","modified":1513149278248},{"_id":"public/css/prettify/github.min.css","hash":"19cf828225288fa5c006f1d8f66c39d11f4ef7f2","modified":1513149278248},{"_id":"public/css/prettify/hemisu-dark.min.css","hash":"a671248cfd573292026d2174817e82e593691052","modified":1513149278249},{"_id":"public/css/prettify/hemisu-light.min.css","hash":"b2556ff41e513fd13d032ec84a37ee260a905815","modified":1513149278249},{"_id":"public/css/prettify/tomorrow-night-blue.min.css","hash":"c442728d96485bcf816151fe6bd96993aae09852","modified":1513149278249},{"_id":"public/css/prettify/tomorrow-night-bright.min.css","hash":"cf251fd3edfd736695272a0f1b41d509b7bb1fb9","modified":1513149278250},{"_id":"public/css/prettify/tomorrow-night-eighties.min.css","hash":"6ce259d674bb4edda23eea32b2379be17d0e0e6e","modified":1513149278250},{"_id":"public/css/prettify/tomorrow-night.min.css","hash":"d989206d124035494acb4b0cdc7fbc89f3b7d108","modified":1513149278251},{"_id":"public/css/prettify/tomorrow.min.css","hash":"b2c6d610b77f0273fefab5aa4ad26a7f58956f87","modified":1513149278251},{"_id":"public/css/prettify/tranquil-heart.min.css","hash":"0f6eefbdda8e410832e9c516a5dd19899217ef06","modified":1513149278251},{"_id":"public/css/prettify/vibrant-ink.min.css","hash":"c265bac6c31cf622b536b29c8a6bc46955d6fe63","modified":1513149278251},{"_id":"public/css/disqus-proxy.css","hash":"d5086cda8aaae20b8d3f9dd50f0be5ccb717e42a","modified":1513149278251},{"_id":"public/css/fontawesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1513149278252},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1513149278252},{"_id":"public/css/material-icons.css","hash":"f6f95fe5190f3c65931847246621fb83754eb00c","modified":1513149278252},{"_id":"public/js/MathJax.js","hash":"a21703b5848325a902c9b39bbf3ca6490d3e1b1b","modified":1513149278252},{"_id":"public/js/Valine.min.js","hash":"6a287a99a772a0ea8f98b133523429c9250cc67f","modified":1513149278252},{"_id":"public/css/material.css","hash":"068e2b00f686157b6e8b78b9b808112adbedf4de","modified":1513149278252},{"_id":"public/css/material.min.css","hash":"1a19febb9214ab689b02f5bb8ccb23579e6c1181","modified":1513149278252},{"_id":"public/css/style.css","hash":"a2f27c40f412dc24e1ed5f62a4117523a226eed0","modified":1513149278253},{"_id":"public/css/style.min.css","hash":"a9e9b33e1fcf818f08a04b909c86f2460a05f060","modified":1513149278253},{"_id":"public/js/jquery.min.js","hash":"00073d6597d2760b81387274a9ec56b9d5cb1552","modified":1513149278253},{"_id":"public/js/js.js","hash":"64b3f20e7138674ecf21e6e3982565ea63feae26","modified":1513149278253},{"_id":"public/js/js.min.js","hash":"709d347d3be033b841de0493b7cf532b594bb1f6","modified":1513149278253},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1513149278253},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1513149278253},{"_id":"public/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1513149278253},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1513149278254},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1513149278254},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1513149278297},{"_id":"public/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1513149278306},{"_id":"public/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1513149278306},{"_id":"public/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1513149278306},{"_id":"public/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1513149278307},{"_id":"public/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1513149278307},{"_id":"public/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1513149278307}],"Category":[],"Data":[],"Page":[{"title":"Search","date":"2017-11-12T05:18:44.000Z","_content":"","source":"Search/index.md","raw":"---\ntitle: Search\ndate: 2017-11-12 13:18:44\n---\n","updated":"2017-12-12T17:58:37.536Z","path":"Search/index.html","comments":1,"layout":"page","_id":"cjb4q0d730000f1xh31ena6dp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"archives","date":"2017-11-12T04:41:15.000Z","type":"Writing","layout":"Writing","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2017-11-12 12:41:15\ntype: \"Writing\"\nlayout: Writing\n---\n","updated":"2017-12-12T17:58:37.536Z","path":"archives/index.html","comments":1,"_id":"cjb4q0d7g0002f1xh73drn4xo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-10-17T12:39:11.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-10-17 20:39:11\ntype: \"tags\"\nlayout: tags\n---\n","updated":"2017-12-12T17:58:37.536Z","path":"tags/index.html","comments":1,"_id":"cjb4q0d7p0005f1xhjieu40tb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Express","date":"2017-12-12T17:04:24.000Z","_content":"# Express\n\n一个文档很完善的框架\n\n## 中间件\n\n中间件是一种封装，对请求处理流程某一小块逻辑的封装。\n\n```\n// express 版服务器\nconst express = require('express')\nconst http = require('http')\nconst app = express()\n\napp.use((req, res, next) => {\n    console.log('this is middleware no.1')  // 1\n    next()\n})\n\napp.use((req, res) => {\n    console.log('this is middleware no.2')  // 2\n    res.end('hello world')\n})\n\nconst server = http.createServer(app)\n\nserver.listen('9292')\n\n// 这样子会打印出 1 2 而不是 2 1，是按顺序执行的\n```\n\n当服务器接收到了请求之后一直没有返回（也就是 `app.use` 之后怎么都不做），会有超时错误。\n\n### 中间件的生命周期\n\n看下面这两段代码\n\n```\napp.use((req, res, next) => {\n    req.number = 1\n    next()\n})\n\napp.use((req, res) => {\n    console.log(`req.number: ${req.number}`)\n    res.end('end')\n})\n```\n\n```\napp.use((req, res, next) => {\n    console.log(`req.number: ${req.number}`)\n    next()\n})\n\napp.use((req, res) => {\n    req.number = 1\n    res.end('end')\n})\n```\n\n第一段打印的是`req.number: 1`，第二段打印的是`req.number: undefined`\n\n他们的赋值也是有循序性的\n\n也可以说互不影响吧，每个中间件只用处理复杂逻辑的一小块，通过 `next()` 把控制权交给下一个中间件，中间件不需要知道前一个中间件做了什么或者后一个中间件做了什么，只要处理好自己的逻辑就可以了。\n\n### 中间件的作用\n\n可以做个鉴权啥的\n\n```\n// auth.js\nmodule.exports =  function auth(req, res, next) {\n    console.log(req.query)\n    if (req.query.username === 'frankie') {  // req.query.username 一定要等于 frankie，要不然就go away\n        next()\n    } else {\n        res.end('please go away')\n    }\n}\n\n// index.js\napp.use(require('./middlewares/auth'))  // 这里的 auth 可以理解为 OAuth 2\n```\n\n不通过就停止执行下面的逻辑\n\n![](https://i.loli.net/2017/12/10/5a2d4f70bb5a9.gif)\n\n```\napp.use(require('./middlewares/auth'))\n\napp.use((req, res, next) => {\n    next('something wrong')  // next 里面如果有传东西就会当做错误处理掉，直接跑到下面的错误处理中间件\n})\n\n// 错误处理中间件\napp.use((err, req, res, next) => {\n    res.end(err)\n})\n\n// 注意传进去的四个参数一定要写全，如果只写 err, req, res 会被识别成 req, res, next\n```\n\n### 中间件的写法\n\n```\nfunction mw1(req, res, next) {\n    console.log('mw1')\n    next()\n}\n\nfunction mw2(req, res, next) {\n    console.log('mw2')\n    next()\n}\n\nfunction mw3(req, res, next) {\n    console.log('mw3')\n    res.end('done')\n}\n\n// 第一种\napp.use(mw1)\napp.use(mw2)\napp.use(mw3)\n\n// 第二种\n// app.use(mw1, mw2, mw3)\n\n// 第三种\n// app.use([mw1, mw2], mw3)\n\napp.use((err, req, res, next) => {\n    res.end(err)\n})\n```\n\n### body-parser\n\n```\n// 另一种写法\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\n\n// extended 是这样用的，如 users[0]=123&users[1]=456 解析成数组，users[age]=18&users[name]=frankie 解析成对象\n\nfunction mw0(options) {\n    return function (req, res, next) {\n        console.log(req.body)\n        next()\n    }\n}\n\napp.use(mw0())\n```\n\n这个其实是解决 post 的处理，不过只能检测两种格式 `application/json` 和 `x-www-form-urlencoded`\n\n![](https://i.loli.net/2017/12/11/5a2d5f3d9c67c.gif)\n\n更多中间件模块 http://expressjs.com/en/resources/middleware.html\n\n### 中间件的运行条件\n\n```\napp.use((req, res, next) => {\n    req.middlewares = []\n    next()\n})\n\nfunction mw1(options) {\n    return function (req, res, next) {\n        req.middlewares.push('mw1')\n        next()\n    }\n}\n\nfunction mw2(req, res, next) {\n    req.middlewares.push('mw2')\n    next()\n}\n\nfunction mw3(req, res, next) {\n    req.middlewares.push('mw3')\n    res.end(JSON.stringify(req.middlewares))\n}\n\napp.use('/', mw1())\napp.get('/article', mw2)\napp.post('/user', mw2)\napp.use(mw3)\n```\n\n![](https://i.loli.net/2017/12/11/5a2d636d08062.gif)\n\n也就是说中间件可以通过路由、HTTP 请求的方法、body-parser、query 来做一些精细的控制\n\n中间件不完全正则 http://expressjs.com/en/4x/api.html#path-examples\n\n## Express 的其他细节\n\n用 express-generator 生成一个例子\n\n```\n// Express 的 app.js\nconst express = require('express');\nconst path = require('path');\n// const favicon = require('serve-favicon');\nconst logger = require('morgan');\nconst cookieParser = require('cookie-parser');\nconst bodyParser = require('body-parser');\n\nconst index = require('./routes/index');\nconst users = require('./routes/users');\n\nconst app = express();\n\n// view engine setup\napp.set('views', path.join(__dirname, 'views')); // 设置 views 文件夹为视图文件的目录，存放模板文件，__dirname 为全局变量，存储着当前正在执行脚本所在文件夹的绝对路径\napp.set('view engine', 'ejs'); // 设置视图模版引擎为 ejs\n\n// uncomment after placing your favicon in /public\n// app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\n/**\n *  Express 依赖于 connect，提供了大量的中间件，可以通过  app.use 启用\n *\n *  app.use([path], function)：使用中间件 function，可选参数path默认为'/'\n *  app.use(express.favicon())：connect 内建的中间件，使用默认的 favicon 图标，\n *  如果想使用自己的图标，需改为app.use(express.favicon(__dirname + '/public/images/favicon.ico'));\n *  这里我们把自定义的 favicon.ico 放到了 public/images 文件夹下。\n */\napp.use(logger('dev'));\n/**\n *  connect 内建的中间件，在开发环境下使用，在终端显示简单的不同颜色的日志，比如在启动 app.js 后访问 localhost:3000，终端会输出：\n *  Express server listening on port 3000 GET / 200 21ms - 206b GET /stylesheets/style.css 304 4ms\n *  数字200显示为绿色，304显示为蓝色。假如你去掉这一行代码，不管你怎么刷新网页，终端都只有一行 Express server listening on port 3000。\n */\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n/**\n * bodyParser作用是对post请求的请求体进行解析\n * bodyParser用于解析客户端请求的body中的内容,内部使用JSON编码处理,url编码处理以及对于文件的上传处理\n */\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n/**\n *  设置静态文件目录\n *  express.static指定了静态页面的查找目录，如果定义express.static('/var/www')，\n *  当用户向node请求http://server/file.html，node将会自动查找/var/www下面找server/file.html\n */\n\n//  是一个路由控制器，用户如果访问“ / ”路径，则由 routes.index 来控制。\napp.use('/', index);\napp.use('/users', users);\n\n// catch 404 and forward to error handler\n// 上面全部走完没有结果就 404\napp.use((req, res, next) => {\n  const err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\n\n// error handler\n// 错误信息会经过 error.ejs 渲染出来\napp.use((err, req, res) => {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render('error');\n});\n\nmodule.exports = app;\n```\n\n入口看起来是 `bin/www`，但实际上真正的入口是 `app.js`\n\n接下来看看中断的例子\n\n```\nrouter.use('/', (req, res, next) => {\n  console.log('mw1')\n  next('router')\n});\n\nrouter.use('/', (req, res, next) => {\n  console.log('mw2')\n  next()\n});\n\n// 这个只会打印 mw1\n// 如果在 next() 传一个字符串，就会中断代码\n```\n\n## Express 中的 MVC\n\n```\n// controller\nconst express = require('express');\n\nconst router = express.Router();\nconst User = require('../models/in-demo/user');\n\n/* GET users listing. */\nrouter.get('/', (req, res) => {\n  const u = new User(req.query.firstName, req.query.lastName, req.query.age);\n  res.locals.user = u;\n  res.render('user');\n});\n\nmodule.exports = router;\n\n// model\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\nmodule.exports = User;\n\n// view\n<h1><%= user.lastName %></h1>\n<h1><%= user.age %></h1>\n```\n\n![](https://i.loli.net/2017/12/11/5a2e792b19f57.gif)\n\nmodel -> 保存变量\n\ncontroller -> 接收用户的请求，根据 model 来进行数据拼装\n\nview -> 显示给用户\n\n```\n// 完善 model\nconst users = [];\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  static insert(firstName, lastName, age) {\n    const u = new User(firstName, lastName, age);\n    User.users.push(u);\n    return u;\n  }\n  static getOneByName(firstName, lastName) {\n    return User.users.find(element => element.firstName === firstName && element.lastName === lastName);\n  }\n\n  static list(query) {\n    return User.users;\n  }\n\n  // 访问 User.users 的时候返回 users，等于 console.log(User.users)\n  static get ['users']() {\n    return users;\n  }\n}\n\nmodule.exports = User;\n\n// 测试代码\nconsole.log(User.list());\nconsole.log(User.insert('kalun', 'tang', 21));\nconsole.log(User.list());\nconsole.log(User.insert('frankie', 'tang', 21));\nconsole.log(User.list());\nconsole.log(User.getOneByName('kalun', 'tang'));\n```\n\n![](https://i.loli.net/2017/12/12/5a2fc8cd9f5cb.png)\n\nhttp://es6.ruanyifeng.com/#docs/class\n\n但是要考虑一个问题，每次重启 `users` 都是一个空数组，并没有持久化下来，因为是存在内存里。\n\n```\n// controller\nconst UserService = require('../services/user-service');\nrouter.get('/', (req, res) => {\n  const users = UserService.getAllUsers();\n  res.locals.users = users;\n  res.render('user');\n});\n\nrouter.post('/', (req, res) => {\n  const { firstName, lastName, age } = req.body;\n  const u = UserService.addNewUser(firstName, lastName, age);\n  res.json(u);\n});\n\n// model\nconst User = require('../models/in-demo/user');  // 见上面的 user\n\nmodule.exports = {\n  getAllUsers() {\n    return User.list();\n  },\n  addNewUser(firstName, lastName, age) {\n    return User.insert(firstName, lastName, age);\n  },\n};\n\n// view\n<% for(let i = 0; i < users.length; i++){ %>\n  <h1><%= users[i].firstName %></h1>\n<% } %>\n```\n\n![](https://i.loli.net/2017/12/12/5a2fda4fdf08b.gif)\n\n上面这个例子通过 post 数据储存到内存里，然后在通过 get 把数据渲染到页面上。\n\nMVC 肯定也有发布订阅模式\n\n[先给用户增加ID](https://github.com/FRANKIETANG/express-demo/commit/b359514b3dbe998e35aac0a1af799f411abb1a74)（代码量太多不方便贴了）\n\n用户发生一些行为，并且和数据进行交互\n\n[subscription](https://github.com/FRANKIETANG/express-demo/commit/cca1519a3fb29de469a5cb9a98d6500ed93b6c73)（代码量太多不方便贴了）\n\n![](https://i.loli.net/2017/12/13/5a3001a5cb36f.gif)\n\n所以说，Express 的 MVC 的结构是\n\n```\nroutes/\nviews/\nmodels/\nservices/\n```\n\n- 其中，由于 express 的特点，根据设置，views 目录下的文件会被模板引擎在调用`res.render('view_name')`的时候自动渲染\n- view 层可以理解为模板引擎 + views 文件夹中的文件\n- 而 routes 可以理解为 controller，负责根据用户的请求，调取相关的 service，最终得到 model 并用于渲染\n- models 则代表了 model 和相关逻辑\n- services 则有些特别，由于同层 model 之间解耦的需要，单个 model 往往不应该包含太多对其他 model 的操作，我们应该在 services 中对一系列逻辑上有关的 model 进行统一操作\n\n## 彩蛋\n\n### 如何设置 eslint ？\n\n[eslint-config-airbnb](https://www.npmjs.com/package/eslint-config-airbnb)\n\n```\n// 按着第一行命令走\nnpm info \"eslint-config-airbnb@latest\" peerDependencies  // 显示的那一串是要你一个一个装的，太麻烦\n\n// 第二个方法（这个最好）\n(\n  export PKG=eslint-config-airbnb;\n  npm info \"$PKG@latest\" peerDependencies --json | command sed 's/[\\{\\},]//g ; s/: /@/g' | xargs npm install --save-dev \"$PKG@latest\"\n)\n\n// 安装完后开始配置\nnpm install -g eslint  // 全局安装\neslint --init  // 到目标文件夹初始化\n// 然后出现下面这个\n? How would you like to configure ESLint? (Use arrow keys)\n❯ Answer questions about your style \n  Use a popular style guide  // 选这个，然后选 airbub\n  Inspect your JavaScript file(s) \n// 接下来就要哪个选那个\n// 配置文件选 JSON\n\n// 配完后就跟着报错一个一个改\n```\n\n[使用 VSCode + ESLint 实践前端编码规范](https://segmentfault.com/a/1190000009077086)\n\n`var` 改 `const`，用箭头函数，去掉没用的空格，要加分号，去掉没用的引用啊啥的，改到 0 报错就好。\n\n其实就是为了统一代码格式\n\n### query 里的冒号\n\n```\nrouter.get('/:userId/subscription/:subscriptionId', (req, res, next) => { // 前面加一个冒号就代表这个是作为一个参数处理\n  res.json({\n    userId: req.params.userId,\n    subscriptionId: req.params.subscriptionId,\n  });\n});\n```\n\n![](https://i.loli.net/2017/12/15/5a336d474c910.png)","source":"_posts/Express.md","raw":"---\ntitle: Express\ndate: 2017-12-13 01:04:24\ntags: [Node]\n---\n# Express\n\n一个文档很完善的框架\n\n## 中间件\n\n中间件是一种封装，对请求处理流程某一小块逻辑的封装。\n\n```\n// express 版服务器\nconst express = require('express')\nconst http = require('http')\nconst app = express()\n\napp.use((req, res, next) => {\n    console.log('this is middleware no.1')  // 1\n    next()\n})\n\napp.use((req, res) => {\n    console.log('this is middleware no.2')  // 2\n    res.end('hello world')\n})\n\nconst server = http.createServer(app)\n\nserver.listen('9292')\n\n// 这样子会打印出 1 2 而不是 2 1，是按顺序执行的\n```\n\n当服务器接收到了请求之后一直没有返回（也就是 `app.use` 之后怎么都不做），会有超时错误。\n\n### 中间件的生命周期\n\n看下面这两段代码\n\n```\napp.use((req, res, next) => {\n    req.number = 1\n    next()\n})\n\napp.use((req, res) => {\n    console.log(`req.number: ${req.number}`)\n    res.end('end')\n})\n```\n\n```\napp.use((req, res, next) => {\n    console.log(`req.number: ${req.number}`)\n    next()\n})\n\napp.use((req, res) => {\n    req.number = 1\n    res.end('end')\n})\n```\n\n第一段打印的是`req.number: 1`，第二段打印的是`req.number: undefined`\n\n他们的赋值也是有循序性的\n\n也可以说互不影响吧，每个中间件只用处理复杂逻辑的一小块，通过 `next()` 把控制权交给下一个中间件，中间件不需要知道前一个中间件做了什么或者后一个中间件做了什么，只要处理好自己的逻辑就可以了。\n\n### 中间件的作用\n\n可以做个鉴权啥的\n\n```\n// auth.js\nmodule.exports =  function auth(req, res, next) {\n    console.log(req.query)\n    if (req.query.username === 'frankie') {  // req.query.username 一定要等于 frankie，要不然就go away\n        next()\n    } else {\n        res.end('please go away')\n    }\n}\n\n// index.js\napp.use(require('./middlewares/auth'))  // 这里的 auth 可以理解为 OAuth 2\n```\n\n不通过就停止执行下面的逻辑\n\n![](https://i.loli.net/2017/12/10/5a2d4f70bb5a9.gif)\n\n```\napp.use(require('./middlewares/auth'))\n\napp.use((req, res, next) => {\n    next('something wrong')  // next 里面如果有传东西就会当做错误处理掉，直接跑到下面的错误处理中间件\n})\n\n// 错误处理中间件\napp.use((err, req, res, next) => {\n    res.end(err)\n})\n\n// 注意传进去的四个参数一定要写全，如果只写 err, req, res 会被识别成 req, res, next\n```\n\n### 中间件的写法\n\n```\nfunction mw1(req, res, next) {\n    console.log('mw1')\n    next()\n}\n\nfunction mw2(req, res, next) {\n    console.log('mw2')\n    next()\n}\n\nfunction mw3(req, res, next) {\n    console.log('mw3')\n    res.end('done')\n}\n\n// 第一种\napp.use(mw1)\napp.use(mw2)\napp.use(mw3)\n\n// 第二种\n// app.use(mw1, mw2, mw3)\n\n// 第三种\n// app.use([mw1, mw2], mw3)\n\napp.use((err, req, res, next) => {\n    res.end(err)\n})\n```\n\n### body-parser\n\n```\n// 另一种写法\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\n\n// extended 是这样用的，如 users[0]=123&users[1]=456 解析成数组，users[age]=18&users[name]=frankie 解析成对象\n\nfunction mw0(options) {\n    return function (req, res, next) {\n        console.log(req.body)\n        next()\n    }\n}\n\napp.use(mw0())\n```\n\n这个其实是解决 post 的处理，不过只能检测两种格式 `application/json` 和 `x-www-form-urlencoded`\n\n![](https://i.loli.net/2017/12/11/5a2d5f3d9c67c.gif)\n\n更多中间件模块 http://expressjs.com/en/resources/middleware.html\n\n### 中间件的运行条件\n\n```\napp.use((req, res, next) => {\n    req.middlewares = []\n    next()\n})\n\nfunction mw1(options) {\n    return function (req, res, next) {\n        req.middlewares.push('mw1')\n        next()\n    }\n}\n\nfunction mw2(req, res, next) {\n    req.middlewares.push('mw2')\n    next()\n}\n\nfunction mw3(req, res, next) {\n    req.middlewares.push('mw3')\n    res.end(JSON.stringify(req.middlewares))\n}\n\napp.use('/', mw1())\napp.get('/article', mw2)\napp.post('/user', mw2)\napp.use(mw3)\n```\n\n![](https://i.loli.net/2017/12/11/5a2d636d08062.gif)\n\n也就是说中间件可以通过路由、HTTP 请求的方法、body-parser、query 来做一些精细的控制\n\n中间件不完全正则 http://expressjs.com/en/4x/api.html#path-examples\n\n## Express 的其他细节\n\n用 express-generator 生成一个例子\n\n```\n// Express 的 app.js\nconst express = require('express');\nconst path = require('path');\n// const favicon = require('serve-favicon');\nconst logger = require('morgan');\nconst cookieParser = require('cookie-parser');\nconst bodyParser = require('body-parser');\n\nconst index = require('./routes/index');\nconst users = require('./routes/users');\n\nconst app = express();\n\n// view engine setup\napp.set('views', path.join(__dirname, 'views')); // 设置 views 文件夹为视图文件的目录，存放模板文件，__dirname 为全局变量，存储着当前正在执行脚本所在文件夹的绝对路径\napp.set('view engine', 'ejs'); // 设置视图模版引擎为 ejs\n\n// uncomment after placing your favicon in /public\n// app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\n/**\n *  Express 依赖于 connect，提供了大量的中间件，可以通过  app.use 启用\n *\n *  app.use([path], function)：使用中间件 function，可选参数path默认为'/'\n *  app.use(express.favicon())：connect 内建的中间件，使用默认的 favicon 图标，\n *  如果想使用自己的图标，需改为app.use(express.favicon(__dirname + '/public/images/favicon.ico'));\n *  这里我们把自定义的 favicon.ico 放到了 public/images 文件夹下。\n */\napp.use(logger('dev'));\n/**\n *  connect 内建的中间件，在开发环境下使用，在终端显示简单的不同颜色的日志，比如在启动 app.js 后访问 localhost:3000，终端会输出：\n *  Express server listening on port 3000 GET / 200 21ms - 206b GET /stylesheets/style.css 304 4ms\n *  数字200显示为绿色，304显示为蓝色。假如你去掉这一行代码，不管你怎么刷新网页，终端都只有一行 Express server listening on port 3000。\n */\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n/**\n * bodyParser作用是对post请求的请求体进行解析\n * bodyParser用于解析客户端请求的body中的内容,内部使用JSON编码处理,url编码处理以及对于文件的上传处理\n */\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n/**\n *  设置静态文件目录\n *  express.static指定了静态页面的查找目录，如果定义express.static('/var/www')，\n *  当用户向node请求http://server/file.html，node将会自动查找/var/www下面找server/file.html\n */\n\n//  是一个路由控制器，用户如果访问“ / ”路径，则由 routes.index 来控制。\napp.use('/', index);\napp.use('/users', users);\n\n// catch 404 and forward to error handler\n// 上面全部走完没有结果就 404\napp.use((req, res, next) => {\n  const err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\n\n// error handler\n// 错误信息会经过 error.ejs 渲染出来\napp.use((err, req, res) => {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render('error');\n});\n\nmodule.exports = app;\n```\n\n入口看起来是 `bin/www`，但实际上真正的入口是 `app.js`\n\n接下来看看中断的例子\n\n```\nrouter.use('/', (req, res, next) => {\n  console.log('mw1')\n  next('router')\n});\n\nrouter.use('/', (req, res, next) => {\n  console.log('mw2')\n  next()\n});\n\n// 这个只会打印 mw1\n// 如果在 next() 传一个字符串，就会中断代码\n```\n\n## Express 中的 MVC\n\n```\n// controller\nconst express = require('express');\n\nconst router = express.Router();\nconst User = require('../models/in-demo/user');\n\n/* GET users listing. */\nrouter.get('/', (req, res) => {\n  const u = new User(req.query.firstName, req.query.lastName, req.query.age);\n  res.locals.user = u;\n  res.render('user');\n});\n\nmodule.exports = router;\n\n// model\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\nmodule.exports = User;\n\n// view\n<h1><%= user.lastName %></h1>\n<h1><%= user.age %></h1>\n```\n\n![](https://i.loli.net/2017/12/11/5a2e792b19f57.gif)\n\nmodel -> 保存变量\n\ncontroller -> 接收用户的请求，根据 model 来进行数据拼装\n\nview -> 显示给用户\n\n```\n// 完善 model\nconst users = [];\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  static insert(firstName, lastName, age) {\n    const u = new User(firstName, lastName, age);\n    User.users.push(u);\n    return u;\n  }\n  static getOneByName(firstName, lastName) {\n    return User.users.find(element => element.firstName === firstName && element.lastName === lastName);\n  }\n\n  static list(query) {\n    return User.users;\n  }\n\n  // 访问 User.users 的时候返回 users，等于 console.log(User.users)\n  static get ['users']() {\n    return users;\n  }\n}\n\nmodule.exports = User;\n\n// 测试代码\nconsole.log(User.list());\nconsole.log(User.insert('kalun', 'tang', 21));\nconsole.log(User.list());\nconsole.log(User.insert('frankie', 'tang', 21));\nconsole.log(User.list());\nconsole.log(User.getOneByName('kalun', 'tang'));\n```\n\n![](https://i.loli.net/2017/12/12/5a2fc8cd9f5cb.png)\n\nhttp://es6.ruanyifeng.com/#docs/class\n\n但是要考虑一个问题，每次重启 `users` 都是一个空数组，并没有持久化下来，因为是存在内存里。\n\n```\n// controller\nconst UserService = require('../services/user-service');\nrouter.get('/', (req, res) => {\n  const users = UserService.getAllUsers();\n  res.locals.users = users;\n  res.render('user');\n});\n\nrouter.post('/', (req, res) => {\n  const { firstName, lastName, age } = req.body;\n  const u = UserService.addNewUser(firstName, lastName, age);\n  res.json(u);\n});\n\n// model\nconst User = require('../models/in-demo/user');  // 见上面的 user\n\nmodule.exports = {\n  getAllUsers() {\n    return User.list();\n  },\n  addNewUser(firstName, lastName, age) {\n    return User.insert(firstName, lastName, age);\n  },\n};\n\n// view\n<% for(let i = 0; i < users.length; i++){ %>\n  <h1><%= users[i].firstName %></h1>\n<% } %>\n```\n\n![](https://i.loli.net/2017/12/12/5a2fda4fdf08b.gif)\n\n上面这个例子通过 post 数据储存到内存里，然后在通过 get 把数据渲染到页面上。\n\nMVC 肯定也有发布订阅模式\n\n[先给用户增加ID](https://github.com/FRANKIETANG/express-demo/commit/b359514b3dbe998e35aac0a1af799f411abb1a74)（代码量太多不方便贴了）\n\n用户发生一些行为，并且和数据进行交互\n\n[subscription](https://github.com/FRANKIETANG/express-demo/commit/cca1519a3fb29de469a5cb9a98d6500ed93b6c73)（代码量太多不方便贴了）\n\n![](https://i.loli.net/2017/12/13/5a3001a5cb36f.gif)\n\n所以说，Express 的 MVC 的结构是\n\n```\nroutes/\nviews/\nmodels/\nservices/\n```\n\n- 其中，由于 express 的特点，根据设置，views 目录下的文件会被模板引擎在调用`res.render('view_name')`的时候自动渲染\n- view 层可以理解为模板引擎 + views 文件夹中的文件\n- 而 routes 可以理解为 controller，负责根据用户的请求，调取相关的 service，最终得到 model 并用于渲染\n- models 则代表了 model 和相关逻辑\n- services 则有些特别，由于同层 model 之间解耦的需要，单个 model 往往不应该包含太多对其他 model 的操作，我们应该在 services 中对一系列逻辑上有关的 model 进行统一操作\n\n## 彩蛋\n\n### 如何设置 eslint ？\n\n[eslint-config-airbnb](https://www.npmjs.com/package/eslint-config-airbnb)\n\n```\n// 按着第一行命令走\nnpm info \"eslint-config-airbnb@latest\" peerDependencies  // 显示的那一串是要你一个一个装的，太麻烦\n\n// 第二个方法（这个最好）\n(\n  export PKG=eslint-config-airbnb;\n  npm info \"$PKG@latest\" peerDependencies --json | command sed 's/[\\{\\},]//g ; s/: /@/g' | xargs npm install --save-dev \"$PKG@latest\"\n)\n\n// 安装完后开始配置\nnpm install -g eslint  // 全局安装\neslint --init  // 到目标文件夹初始化\n// 然后出现下面这个\n? How would you like to configure ESLint? (Use arrow keys)\n❯ Answer questions about your style \n  Use a popular style guide  // 选这个，然后选 airbub\n  Inspect your JavaScript file(s) \n// 接下来就要哪个选那个\n// 配置文件选 JSON\n\n// 配完后就跟着报错一个一个改\n```\n\n[使用 VSCode + ESLint 实践前端编码规范](https://segmentfault.com/a/1190000009077086)\n\n`var` 改 `const`，用箭头函数，去掉没用的空格，要加分号，去掉没用的引用啊啥的，改到 0 报错就好。\n\n其实就是为了统一代码格式\n\n### query 里的冒号\n\n```\nrouter.get('/:userId/subscription/:subscriptionId', (req, res, next) => { // 前面加一个冒号就代表这个是作为一个参数处理\n  res.json({\n    userId: req.params.userId,\n    subscriptionId: req.params.subscriptionId,\n  });\n});\n```\n\n![](https://i.loli.net/2017/12/15/5a336d474c910.png)","slug":"Express","published":1,"updated":"2017-12-15T06:36:49.612Z","_id":"cjb4q0d770001f1xhc1sveuyy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h1><p>一个文档很完善的框架</p>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>中间件是一种封装，对请求处理流程某一小块逻辑的封装。</p>\n<pre><code>// express 版服务器\nconst express = require(&#39;express&#39;)\nconst http = require(&#39;http&#39;)\nconst app = express()\n\napp.use((req, res, next) =&gt; {\n    console.log(&#39;this is middleware no.1&#39;)  // 1\n    next()\n})\n\napp.use((req, res) =&gt; {\n    console.log(&#39;this is middleware no.2&#39;)  // 2\n    res.end(&#39;hello world&#39;)\n})\n\nconst server = http.createServer(app)\n\nserver.listen(&#39;9292&#39;)\n\n// 这样子会打印出 1 2 而不是 2 1，是按顺序执行的\n</code></pre><p>当服务器接收到了请求之后一直没有返回（也就是 <code>app.use</code> 之后怎么都不做），会有超时错误。</p>\n<h3 id=\"中间件的生命周期\"><a href=\"#中间件的生命周期\" class=\"headerlink\" title=\"中间件的生命周期\"></a>中间件的生命周期</h3><p>看下面这两段代码</p>\n<pre><code>app.use((req, res, next) =&gt; {\n    req.number = 1\n    next()\n})\n\napp.use((req, res) =&gt; {\n    console.log(`req.number: ${req.number}`)\n    res.end(&#39;end&#39;)\n})\n</code></pre><pre><code>app.use((req, res, next) =&gt; {\n    console.log(`req.number: ${req.number}`)\n    next()\n})\n\napp.use((req, res) =&gt; {\n    req.number = 1\n    res.end(&#39;end&#39;)\n})\n</code></pre><p>第一段打印的是<code>req.number: 1</code>，第二段打印的是<code>req.number: undefined</code></p>\n<p>他们的赋值也是有循序性的</p>\n<p>也可以说互不影响吧，每个中间件只用处理复杂逻辑的一小块，通过 <code>next()</code> 把控制权交给下一个中间件，中间件不需要知道前一个中间件做了什么或者后一个中间件做了什么，只要处理好自己的逻辑就可以了。</p>\n<h3 id=\"中间件的作用\"><a href=\"#中间件的作用\" class=\"headerlink\" title=\"中间件的作用\"></a>中间件的作用</h3><p>可以做个鉴权啥的</p>\n<pre><code>// auth.js\nmodule.exports =  function auth(req, res, next) {\n    console.log(req.query)\n    if (req.query.username === &#39;frankie&#39;) {  // req.query.username 一定要等于 frankie，要不然就go away\n        next()\n    } else {\n        res.end(&#39;please go away&#39;)\n    }\n}\n\n// index.js\napp.use(require(&#39;./middlewares/auth&#39;))  // 这里的 auth 可以理解为 OAuth 2\n</code></pre><p>不通过就停止执行下面的逻辑</p>\n<p><img src=\"https://i.loli.net/2017/12/10/5a2d4f70bb5a9.gif\" alt=\"\"></p>\n<pre><code>app.use(require(&#39;./middlewares/auth&#39;))\n\napp.use((req, res, next) =&gt; {\n    next(&#39;something wrong&#39;)  // next 里面如果有传东西就会当做错误处理掉，直接跑到下面的错误处理中间件\n})\n\n// 错误处理中间件\napp.use((err, req, res, next) =&gt; {\n    res.end(err)\n})\n\n// 注意传进去的四个参数一定要写全，如果只写 err, req, res 会被识别成 req, res, next\n</code></pre><h3 id=\"中间件的写法\"><a href=\"#中间件的写法\" class=\"headerlink\" title=\"中间件的写法\"></a>中间件的写法</h3><pre><code>function mw1(req, res, next) {\n    console.log(&#39;mw1&#39;)\n    next()\n}\n\nfunction mw2(req, res, next) {\n    console.log(&#39;mw2&#39;)\n    next()\n}\n\nfunction mw3(req, res, next) {\n    console.log(&#39;mw3&#39;)\n    res.end(&#39;done&#39;)\n}\n\n// 第一种\napp.use(mw1)\napp.use(mw2)\napp.use(mw3)\n\n// 第二种\n// app.use(mw1, mw2, mw3)\n\n// 第三种\n// app.use([mw1, mw2], mw3)\n\napp.use((err, req, res, next) =&gt; {\n    res.end(err)\n})\n</code></pre><h3 id=\"body-parser\"><a href=\"#body-parser\" class=\"headerlink\" title=\"body-parser\"></a>body-parser</h3><pre><code>// 另一种写法\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\n\n// extended 是这样用的，如 users[0]=123&amp;users[1]=456 解析成数组，users[age]=18&amp;users[name]=frankie 解析成对象\n\nfunction mw0(options) {\n    return function (req, res, next) {\n        console.log(req.body)\n        next()\n    }\n}\n\napp.use(mw0())\n</code></pre><p>这个其实是解决 post 的处理，不过只能检测两种格式 <code>application/json</code> 和 <code>x-www-form-urlencoded</code></p>\n<p><img src=\"https://i.loli.net/2017/12/11/5a2d5f3d9c67c.gif\" alt=\"\"></p>\n<p>更多中间件模块 <a href=\"http://expressjs.com/en/resources/middleware.html\" target=\"_blank\" rel=\"noopener\">http://expressjs.com/en/resources/middleware.html</a></p>\n<h3 id=\"中间件的运行条件\"><a href=\"#中间件的运行条件\" class=\"headerlink\" title=\"中间件的运行条件\"></a>中间件的运行条件</h3><pre><code>app.use((req, res, next) =&gt; {\n    req.middlewares = []\n    next()\n})\n\nfunction mw1(options) {\n    return function (req, res, next) {\n        req.middlewares.push(&#39;mw1&#39;)\n        next()\n    }\n}\n\nfunction mw2(req, res, next) {\n    req.middlewares.push(&#39;mw2&#39;)\n    next()\n}\n\nfunction mw3(req, res, next) {\n    req.middlewares.push(&#39;mw3&#39;)\n    res.end(JSON.stringify(req.middlewares))\n}\n\napp.use(&#39;/&#39;, mw1())\napp.get(&#39;/article&#39;, mw2)\napp.post(&#39;/user&#39;, mw2)\napp.use(mw3)\n</code></pre><p><img src=\"https://i.loli.net/2017/12/11/5a2d636d08062.gif\" alt=\"\"></p>\n<p>也就是说中间件可以通过路由、HTTP 请求的方法、body-parser、query 来做一些精细的控制</p>\n<p>中间件不完全正则 <a href=\"http://expressjs.com/en/4x/api.html#path-examples\" target=\"_blank\" rel=\"noopener\">http://expressjs.com/en/4x/api.html#path-examples</a></p>\n<h2 id=\"Express-的其他细节\"><a href=\"#Express-的其他细节\" class=\"headerlink\" title=\"Express 的其他细节\"></a>Express 的其他细节</h2><p>用 express-generator 生成一个例子</p>\n<pre><code>// Express 的 app.js\nconst express = require(&#39;express&#39;);\nconst path = require(&#39;path&#39;);\n// const favicon = require(&#39;serve-favicon&#39;);\nconst logger = require(&#39;morgan&#39;);\nconst cookieParser = require(&#39;cookie-parser&#39;);\nconst bodyParser = require(&#39;body-parser&#39;);\n\nconst index = require(&#39;./routes/index&#39;);\nconst users = require(&#39;./routes/users&#39;);\n\nconst app = express();\n\n// view engine setup\napp.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); // 设置 views 文件夹为视图文件的目录，存放模板文件，__dirname 为全局变量，存储着当前正在执行脚本所在文件夹的绝对路径\napp.set(&#39;view engine&#39;, &#39;ejs&#39;); // 设置视图模版引擎为 ejs\n\n// uncomment after placing your favicon in /public\n// app.use(favicon(path.join(__dirname, &#39;public&#39;, &#39;favicon.ico&#39;)));\n/**\n *  Express 依赖于 connect，提供了大量的中间件，可以通过  app.use 启用\n *\n *  app.use([path], function)：使用中间件 function，可选参数path默认为&#39;/&#39;\n *  app.use(express.favicon())：connect 内建的中间件，使用默认的 favicon 图标，\n *  如果想使用自己的图标，需改为app.use(express.favicon(__dirname + &#39;/public/images/favicon.ico&#39;));\n *  这里我们把自定义的 favicon.ico 放到了 public/images 文件夹下。\n */\napp.use(logger(&#39;dev&#39;));\n/**\n *  connect 内建的中间件，在开发环境下使用，在终端显示简单的不同颜色的日志，比如在启动 app.js 后访问 localhost:3000，终端会输出：\n *  Express server listening on port 3000 GET / 200 21ms - 206b GET /stylesheets/style.css 304 4ms\n *  数字200显示为绿色，304显示为蓝色。假如你去掉这一行代码，不管你怎么刷新网页，终端都只有一行 Express server listening on port 3000。\n */\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n/**\n * bodyParser作用是对post请求的请求体进行解析\n * bodyParser用于解析客户端请求的body中的内容,内部使用JSON编码处理,url编码处理以及对于文件的上传处理\n */\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, &#39;public&#39;)));\n/**\n *  设置静态文件目录\n *  express.static指定了静态页面的查找目录，如果定义express.static(&#39;/var/www&#39;)，\n *  当用户向node请求http://server/file.html，node将会自动查找/var/www下面找server/file.html\n */\n\n//  是一个路由控制器，用户如果访问“ / ”路径，则由 routes.index 来控制。\napp.use(&#39;/&#39;, index);\napp.use(&#39;/users&#39;, users);\n\n// catch 404 and forward to error handler\n// 上面全部走完没有结果就 404\napp.use((req, res, next) =&gt; {\n  const err = new Error(&#39;Not Found&#39;);\n  err.status = 404;\n  next(err);\n});\n\n// error handler\n// 错误信息会经过 error.ejs 渲染出来\napp.use((err, req, res) =&gt; {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get(&#39;env&#39;) === &#39;development&#39; ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render(&#39;error&#39;);\n});\n\nmodule.exports = app;\n</code></pre><p>入口看起来是 <code>bin/www</code>，但实际上真正的入口是 <code>app.js</code></p>\n<p>接下来看看中断的例子</p>\n<pre><code>router.use(&#39;/&#39;, (req, res, next) =&gt; {\n  console.log(&#39;mw1&#39;)\n  next(&#39;router&#39;)\n});\n\nrouter.use(&#39;/&#39;, (req, res, next) =&gt; {\n  console.log(&#39;mw2&#39;)\n  next()\n});\n\n// 这个只会打印 mw1\n// 如果在 next() 传一个字符串，就会中断代码\n</code></pre><h2 id=\"Express-中的-MVC\"><a href=\"#Express-中的-MVC\" class=\"headerlink\" title=\"Express 中的 MVC\"></a>Express 中的 MVC</h2><pre><code>// controller\nconst express = require(&#39;express&#39;);\n\nconst router = express.Router();\nconst User = require(&#39;../models/in-demo/user&#39;);\n\n/* GET users listing. */\nrouter.get(&#39;/&#39;, (req, res) =&gt; {\n  const u = new User(req.query.firstName, req.query.lastName, req.query.age);\n  res.locals.user = u;\n  res.render(&#39;user&#39;);\n});\n\nmodule.exports = router;\n\n// model\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\nmodule.exports = User;\n\n// view\n&lt;h1&gt;&lt;%= user.lastName %&gt;&lt;/h1&gt;\n&lt;h1&gt;&lt;%= user.age %&gt;&lt;/h1&gt;\n</code></pre><p><img src=\"https://i.loli.net/2017/12/11/5a2e792b19f57.gif\" alt=\"\"></p>\n<p>model -&gt; 保存变量</p>\n<p>controller -&gt; 接收用户的请求，根据 model 来进行数据拼装</p>\n<p>view -&gt; 显示给用户</p>\n<pre><code>// 完善 model\nconst users = [];\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  static insert(firstName, lastName, age) {\n    const u = new User(firstName, lastName, age);\n    User.users.push(u);\n    return u;\n  }\n  static getOneByName(firstName, lastName) {\n    return User.users.find(element =&gt; element.firstName === firstName &amp;&amp; element.lastName === lastName);\n  }\n\n  static list(query) {\n    return User.users;\n  }\n\n  // 访问 User.users 的时候返回 users，等于 console.log(User.users)\n  static get [&#39;users&#39;]() {\n    return users;\n  }\n}\n\nmodule.exports = User;\n\n// 测试代码\nconsole.log(User.list());\nconsole.log(User.insert(&#39;kalun&#39;, &#39;tang&#39;, 21));\nconsole.log(User.list());\nconsole.log(User.insert(&#39;frankie&#39;, &#39;tang&#39;, 21));\nconsole.log(User.list());\nconsole.log(User.getOneByName(&#39;kalun&#39;, &#39;tang&#39;));\n</code></pre><p><img src=\"https://i.loli.net/2017/12/12/5a2fc8cd9f5cb.png\" alt=\"\"></p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/class</a></p>\n<p>但是要考虑一个问题，每次重启 <code>users</code> 都是一个空数组，并没有持久化下来，因为是存在内存里。</p>\n<pre><code>// controller\nconst UserService = require(&#39;../services/user-service&#39;);\nrouter.get(&#39;/&#39;, (req, res) =&gt; {\n  const users = UserService.getAllUsers();\n  res.locals.users = users;\n  res.render(&#39;user&#39;);\n});\n\nrouter.post(&#39;/&#39;, (req, res) =&gt; {\n  const { firstName, lastName, age } = req.body;\n  const u = UserService.addNewUser(firstName, lastName, age);\n  res.json(u);\n});\n\n// model\nconst User = require(&#39;../models/in-demo/user&#39;);  // 见上面的 user\n\nmodule.exports = {\n  getAllUsers() {\n    return User.list();\n  },\n  addNewUser(firstName, lastName, age) {\n    return User.insert(firstName, lastName, age);\n  },\n};\n\n// view\n&lt;% for(let i = 0; i &lt; users.length; i++){ %&gt;\n  &lt;h1&gt;&lt;%= users[i].firstName %&gt;&lt;/h1&gt;\n&lt;% } %&gt;\n</code></pre><p><img src=\"https://i.loli.net/2017/12/12/5a2fda4fdf08b.gif\" alt=\"\"></p>\n<p>上面这个例子通过 post 数据储存到内存里，然后在通过 get 把数据渲染到页面上。</p>\n<p>MVC 肯定也有发布订阅模式</p>\n<p><a href=\"https://github.com/FRANKIETANG/express-demo/commit/b359514b3dbe998e35aac0a1af799f411abb1a74\" target=\"_blank\" rel=\"noopener\">先给用户增加ID</a>（代码量太多不方便贴了）</p>\n<p>用户发生一些行为，并且和数据进行交互</p>\n<p><a href=\"https://github.com/FRANKIETANG/express-demo/commit/cca1519a3fb29de469a5cb9a98d6500ed93b6c73\" target=\"_blank\" rel=\"noopener\">subscription</a>（代码量太多不方便贴了）</p>\n<p><img src=\"https://i.loli.net/2017/12/13/5a3001a5cb36f.gif\" alt=\"\"></p>\n<p>所以说，Express 的 MVC 的结构是</p>\n<pre><code>routes/\nviews/\nmodels/\nservices/\n</code></pre><ul>\n<li>其中，由于 express 的特点，根据设置，views 目录下的文件会被模板引擎在调用<code>res.render(&#39;view_name&#39;)</code>的时候自动渲染</li>\n<li>view 层可以理解为模板引擎 + views 文件夹中的文件</li>\n<li>而 routes 可以理解为 controller，负责根据用户的请求，调取相关的 service，最终得到 model 并用于渲染</li>\n<li>models 则代表了 model 和相关逻辑</li>\n<li>services 则有些特别，由于同层 model 之间解耦的需要，单个 model 往往不应该包含太多对其他 model 的操作，我们应该在 services 中对一系列逻辑上有关的 model 进行统一操作</li>\n</ul>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><h3 id=\"如何设置-eslint-？\"><a href=\"#如何设置-eslint-？\" class=\"headerlink\" title=\"如何设置 eslint ？\"></a>如何设置 eslint ？</h3><p><a href=\"https://www.npmjs.com/package/eslint-config-airbnb\" target=\"_blank\" rel=\"noopener\">eslint-config-airbnb</a></p>\n<pre><code>// 按着第一行命令走\nnpm info &quot;eslint-config-airbnb@latest&quot; peerDependencies  // 显示的那一串是要你一个一个装的，太麻烦\n\n// 第二个方法（这个最好）\n(\n  export PKG=eslint-config-airbnb;\n  npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &#39;s/[\\{\\},]//g ; s/: /@/g&#39; | xargs npm install --save-dev &quot;$PKG@latest&quot;\n)\n\n// 安装完后开始配置\nnpm install -g eslint  // 全局安装\neslint --init  // 到目标文件夹初始化\n// 然后出现下面这个\n? How would you like to configure ESLint? (Use arrow keys)\n❯ Answer questions about your style \n  Use a popular style guide  // 选这个，然后选 airbub\n  Inspect your JavaScript file(s) \n// 接下来就要哪个选那个\n// 配置文件选 JSON\n\n// 配完后就跟着报错一个一个改\n</code></pre><p><a href=\"https://segmentfault.com/a/1190000009077086\" target=\"_blank\" rel=\"noopener\">使用 VSCode + ESLint 实践前端编码规范</a></p>\n<p><code>var</code> 改 <code>const</code>，用箭头函数，去掉没用的空格，要加分号，去掉没用的引用啊啥的，改到 0 报错就好。</p>\n<p>其实就是为了统一代码格式</p>\n<h3 id=\"query-里的冒号\"><a href=\"#query-里的冒号\" class=\"headerlink\" title=\"query 里的冒号\"></a>query 里的冒号</h3><pre><code>router.get(&#39;/:userId/subscription/:subscriptionId&#39;, (req, res, next) =&gt; { // 前面加一个冒号就代表这个是作为一个参数处理\n  res.json({\n    userId: req.params.userId,\n    subscriptionId: req.params.subscriptionId,\n  });\n});\n</code></pre><p><img src=\"https://i.loli.net/2017/12/15/5a336d474c910.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h1><p>一个文档很完善的框架</p>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>中间件是一种封装，对请求处理流程某一小块逻辑的封装。</p>\n<pre><code>// express 版服务器\nconst express = require(&#39;express&#39;)\nconst http = require(&#39;http&#39;)\nconst app = express()\n\napp.use((req, res, next) =&gt; {\n    console.log(&#39;this is middleware no.1&#39;)  // 1\n    next()\n})\n\napp.use((req, res) =&gt; {\n    console.log(&#39;this is middleware no.2&#39;)  // 2\n    res.end(&#39;hello world&#39;)\n})\n\nconst server = http.createServer(app)\n\nserver.listen(&#39;9292&#39;)\n\n// 这样子会打印出 1 2 而不是 2 1，是按顺序执行的\n</code></pre><p>当服务器接收到了请求之后一直没有返回（也就是 <code>app.use</code> 之后怎么都不做），会有超时错误。</p>\n<h3 id=\"中间件的生命周期\"><a href=\"#中间件的生命周期\" class=\"headerlink\" title=\"中间件的生命周期\"></a>中间件的生命周期</h3><p>看下面这两段代码</p>\n<pre><code>app.use((req, res, next) =&gt; {\n    req.number = 1\n    next()\n})\n\napp.use((req, res) =&gt; {\n    console.log(`req.number: ${req.number}`)\n    res.end(&#39;end&#39;)\n})\n</code></pre><pre><code>app.use((req, res, next) =&gt; {\n    console.log(`req.number: ${req.number}`)\n    next()\n})\n\napp.use((req, res) =&gt; {\n    req.number = 1\n    res.end(&#39;end&#39;)\n})\n</code></pre><p>第一段打印的是<code>req.number: 1</code>，第二段打印的是<code>req.number: undefined</code></p>\n<p>他们的赋值也是有循序性的</p>\n<p>也可以说互不影响吧，每个中间件只用处理复杂逻辑的一小块，通过 <code>next()</code> 把控制权交给下一个中间件，中间件不需要知道前一个中间件做了什么或者后一个中间件做了什么，只要处理好自己的逻辑就可以了。</p>\n<h3 id=\"中间件的作用\"><a href=\"#中间件的作用\" class=\"headerlink\" title=\"中间件的作用\"></a>中间件的作用</h3><p>可以做个鉴权啥的</p>\n<pre><code>// auth.js\nmodule.exports =  function auth(req, res, next) {\n    console.log(req.query)\n    if (req.query.username === &#39;frankie&#39;) {  // req.query.username 一定要等于 frankie，要不然就go away\n        next()\n    } else {\n        res.end(&#39;please go away&#39;)\n    }\n}\n\n// index.js\napp.use(require(&#39;./middlewares/auth&#39;))  // 这里的 auth 可以理解为 OAuth 2\n</code></pre><p>不通过就停止执行下面的逻辑</p>\n<p><img src=\"https://i.loli.net/2017/12/10/5a2d4f70bb5a9.gif\" alt=\"\"></p>\n<pre><code>app.use(require(&#39;./middlewares/auth&#39;))\n\napp.use((req, res, next) =&gt; {\n    next(&#39;something wrong&#39;)  // next 里面如果有传东西就会当做错误处理掉，直接跑到下面的错误处理中间件\n})\n\n// 错误处理中间件\napp.use((err, req, res, next) =&gt; {\n    res.end(err)\n})\n\n// 注意传进去的四个参数一定要写全，如果只写 err, req, res 会被识别成 req, res, next\n</code></pre><h3 id=\"中间件的写法\"><a href=\"#中间件的写法\" class=\"headerlink\" title=\"中间件的写法\"></a>中间件的写法</h3><pre><code>function mw1(req, res, next) {\n    console.log(&#39;mw1&#39;)\n    next()\n}\n\nfunction mw2(req, res, next) {\n    console.log(&#39;mw2&#39;)\n    next()\n}\n\nfunction mw3(req, res, next) {\n    console.log(&#39;mw3&#39;)\n    res.end(&#39;done&#39;)\n}\n\n// 第一种\napp.use(mw1)\napp.use(mw2)\napp.use(mw3)\n\n// 第二种\n// app.use(mw1, mw2, mw3)\n\n// 第三种\n// app.use([mw1, mw2], mw3)\n\napp.use((err, req, res, next) =&gt; {\n    res.end(err)\n})\n</code></pre><h3 id=\"body-parser\"><a href=\"#body-parser\" class=\"headerlink\" title=\"body-parser\"></a>body-parser</h3><pre><code>// 另一种写法\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\n\n// extended 是这样用的，如 users[0]=123&amp;users[1]=456 解析成数组，users[age]=18&amp;users[name]=frankie 解析成对象\n\nfunction mw0(options) {\n    return function (req, res, next) {\n        console.log(req.body)\n        next()\n    }\n}\n\napp.use(mw0())\n</code></pre><p>这个其实是解决 post 的处理，不过只能检测两种格式 <code>application/json</code> 和 <code>x-www-form-urlencoded</code></p>\n<p><img src=\"https://i.loli.net/2017/12/11/5a2d5f3d9c67c.gif\" alt=\"\"></p>\n<p>更多中间件模块 <a href=\"http://expressjs.com/en/resources/middleware.html\" target=\"_blank\" rel=\"noopener\">http://expressjs.com/en/resources/middleware.html</a></p>\n<h3 id=\"中间件的运行条件\"><a href=\"#中间件的运行条件\" class=\"headerlink\" title=\"中间件的运行条件\"></a>中间件的运行条件</h3><pre><code>app.use((req, res, next) =&gt; {\n    req.middlewares = []\n    next()\n})\n\nfunction mw1(options) {\n    return function (req, res, next) {\n        req.middlewares.push(&#39;mw1&#39;)\n        next()\n    }\n}\n\nfunction mw2(req, res, next) {\n    req.middlewares.push(&#39;mw2&#39;)\n    next()\n}\n\nfunction mw3(req, res, next) {\n    req.middlewares.push(&#39;mw3&#39;)\n    res.end(JSON.stringify(req.middlewares))\n}\n\napp.use(&#39;/&#39;, mw1())\napp.get(&#39;/article&#39;, mw2)\napp.post(&#39;/user&#39;, mw2)\napp.use(mw3)\n</code></pre><p><img src=\"https://i.loli.net/2017/12/11/5a2d636d08062.gif\" alt=\"\"></p>\n<p>也就是说中间件可以通过路由、HTTP 请求的方法、body-parser、query 来做一些精细的控制</p>\n<p>中间件不完全正则 <a href=\"http://expressjs.com/en/4x/api.html#path-examples\" target=\"_blank\" rel=\"noopener\">http://expressjs.com/en/4x/api.html#path-examples</a></p>\n<h2 id=\"Express-的其他细节\"><a href=\"#Express-的其他细节\" class=\"headerlink\" title=\"Express 的其他细节\"></a>Express 的其他细节</h2><p>用 express-generator 生成一个例子</p>\n<pre><code>// Express 的 app.js\nconst express = require(&#39;express&#39;);\nconst path = require(&#39;path&#39;);\n// const favicon = require(&#39;serve-favicon&#39;);\nconst logger = require(&#39;morgan&#39;);\nconst cookieParser = require(&#39;cookie-parser&#39;);\nconst bodyParser = require(&#39;body-parser&#39;);\n\nconst index = require(&#39;./routes/index&#39;);\nconst users = require(&#39;./routes/users&#39;);\n\nconst app = express();\n\n// view engine setup\napp.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); // 设置 views 文件夹为视图文件的目录，存放模板文件，__dirname 为全局变量，存储着当前正在执行脚本所在文件夹的绝对路径\napp.set(&#39;view engine&#39;, &#39;ejs&#39;); // 设置视图模版引擎为 ejs\n\n// uncomment after placing your favicon in /public\n// app.use(favicon(path.join(__dirname, &#39;public&#39;, &#39;favicon.ico&#39;)));\n/**\n *  Express 依赖于 connect，提供了大量的中间件，可以通过  app.use 启用\n *\n *  app.use([path], function)：使用中间件 function，可选参数path默认为&#39;/&#39;\n *  app.use(express.favicon())：connect 内建的中间件，使用默认的 favicon 图标，\n *  如果想使用自己的图标，需改为app.use(express.favicon(__dirname + &#39;/public/images/favicon.ico&#39;));\n *  这里我们把自定义的 favicon.ico 放到了 public/images 文件夹下。\n */\napp.use(logger(&#39;dev&#39;));\n/**\n *  connect 内建的中间件，在开发环境下使用，在终端显示简单的不同颜色的日志，比如在启动 app.js 后访问 localhost:3000，终端会输出：\n *  Express server listening on port 3000 GET / 200 21ms - 206b GET /stylesheets/style.css 304 4ms\n *  数字200显示为绿色，304显示为蓝色。假如你去掉这一行代码，不管你怎么刷新网页，终端都只有一行 Express server listening on port 3000。\n */\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n/**\n * bodyParser作用是对post请求的请求体进行解析\n * bodyParser用于解析客户端请求的body中的内容,内部使用JSON编码处理,url编码处理以及对于文件的上传处理\n */\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, &#39;public&#39;)));\n/**\n *  设置静态文件目录\n *  express.static指定了静态页面的查找目录，如果定义express.static(&#39;/var/www&#39;)，\n *  当用户向node请求http://server/file.html，node将会自动查找/var/www下面找server/file.html\n */\n\n//  是一个路由控制器，用户如果访问“ / ”路径，则由 routes.index 来控制。\napp.use(&#39;/&#39;, index);\napp.use(&#39;/users&#39;, users);\n\n// catch 404 and forward to error handler\n// 上面全部走完没有结果就 404\napp.use((req, res, next) =&gt; {\n  const err = new Error(&#39;Not Found&#39;);\n  err.status = 404;\n  next(err);\n});\n\n// error handler\n// 错误信息会经过 error.ejs 渲染出来\napp.use((err, req, res) =&gt; {\n  // set locals, only providing error in development\n  res.locals.message = err.message;\n  res.locals.error = req.app.get(&#39;env&#39;) === &#39;development&#39; ? err : {};\n\n  // render the error page\n  res.status(err.status || 500);\n  res.render(&#39;error&#39;);\n});\n\nmodule.exports = app;\n</code></pre><p>入口看起来是 <code>bin/www</code>，但实际上真正的入口是 <code>app.js</code></p>\n<p>接下来看看中断的例子</p>\n<pre><code>router.use(&#39;/&#39;, (req, res, next) =&gt; {\n  console.log(&#39;mw1&#39;)\n  next(&#39;router&#39;)\n});\n\nrouter.use(&#39;/&#39;, (req, res, next) =&gt; {\n  console.log(&#39;mw2&#39;)\n  next()\n});\n\n// 这个只会打印 mw1\n// 如果在 next() 传一个字符串，就会中断代码\n</code></pre><h2 id=\"Express-中的-MVC\"><a href=\"#Express-中的-MVC\" class=\"headerlink\" title=\"Express 中的 MVC\"></a>Express 中的 MVC</h2><pre><code>// controller\nconst express = require(&#39;express&#39;);\n\nconst router = express.Router();\nconst User = require(&#39;../models/in-demo/user&#39;);\n\n/* GET users listing. */\nrouter.get(&#39;/&#39;, (req, res) =&gt; {\n  const u = new User(req.query.firstName, req.query.lastName, req.query.age);\n  res.locals.user = u;\n  res.render(&#39;user&#39;);\n});\n\nmodule.exports = router;\n\n// model\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\nmodule.exports = User;\n\n// view\n&lt;h1&gt;&lt;%= user.lastName %&gt;&lt;/h1&gt;\n&lt;h1&gt;&lt;%= user.age %&gt;&lt;/h1&gt;\n</code></pre><p><img src=\"https://i.loli.net/2017/12/11/5a2e792b19f57.gif\" alt=\"\"></p>\n<p>model -&gt; 保存变量</p>\n<p>controller -&gt; 接收用户的请求，根据 model 来进行数据拼装</p>\n<p>view -&gt; 显示给用户</p>\n<pre><code>// 完善 model\nconst users = [];\nclass User {\n  constructor(firstName, lastName, age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n  }\n  getName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  static insert(firstName, lastName, age) {\n    const u = new User(firstName, lastName, age);\n    User.users.push(u);\n    return u;\n  }\n  static getOneByName(firstName, lastName) {\n    return User.users.find(element =&gt; element.firstName === firstName &amp;&amp; element.lastName === lastName);\n  }\n\n  static list(query) {\n    return User.users;\n  }\n\n  // 访问 User.users 的时候返回 users，等于 console.log(User.users)\n  static get [&#39;users&#39;]() {\n    return users;\n  }\n}\n\nmodule.exports = User;\n\n// 测试代码\nconsole.log(User.list());\nconsole.log(User.insert(&#39;kalun&#39;, &#39;tang&#39;, 21));\nconsole.log(User.list());\nconsole.log(User.insert(&#39;frankie&#39;, &#39;tang&#39;, 21));\nconsole.log(User.list());\nconsole.log(User.getOneByName(&#39;kalun&#39;, &#39;tang&#39;));\n</code></pre><p><img src=\"https://i.loli.net/2017/12/12/5a2fc8cd9f5cb.png\" alt=\"\"></p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/class</a></p>\n<p>但是要考虑一个问题，每次重启 <code>users</code> 都是一个空数组，并没有持久化下来，因为是存在内存里。</p>\n<pre><code>// controller\nconst UserService = require(&#39;../services/user-service&#39;);\nrouter.get(&#39;/&#39;, (req, res) =&gt; {\n  const users = UserService.getAllUsers();\n  res.locals.users = users;\n  res.render(&#39;user&#39;);\n});\n\nrouter.post(&#39;/&#39;, (req, res) =&gt; {\n  const { firstName, lastName, age } = req.body;\n  const u = UserService.addNewUser(firstName, lastName, age);\n  res.json(u);\n});\n\n// model\nconst User = require(&#39;../models/in-demo/user&#39;);  // 见上面的 user\n\nmodule.exports = {\n  getAllUsers() {\n    return User.list();\n  },\n  addNewUser(firstName, lastName, age) {\n    return User.insert(firstName, lastName, age);\n  },\n};\n\n// view\n&lt;% for(let i = 0; i &lt; users.length; i++){ %&gt;\n  &lt;h1&gt;&lt;%= users[i].firstName %&gt;&lt;/h1&gt;\n&lt;% } %&gt;\n</code></pre><p><img src=\"https://i.loli.net/2017/12/12/5a2fda4fdf08b.gif\" alt=\"\"></p>\n<p>上面这个例子通过 post 数据储存到内存里，然后在通过 get 把数据渲染到页面上。</p>\n<p>MVC 肯定也有发布订阅模式</p>\n<p><a href=\"https://github.com/FRANKIETANG/express-demo/commit/b359514b3dbe998e35aac0a1af799f411abb1a74\" target=\"_blank\" rel=\"noopener\">先给用户增加ID</a>（代码量太多不方便贴了）</p>\n<p>用户发生一些行为，并且和数据进行交互</p>\n<p><a href=\"https://github.com/FRANKIETANG/express-demo/commit/cca1519a3fb29de469a5cb9a98d6500ed93b6c73\" target=\"_blank\" rel=\"noopener\">subscription</a>（代码量太多不方便贴了）</p>\n<p><img src=\"https://i.loli.net/2017/12/13/5a3001a5cb36f.gif\" alt=\"\"></p>\n<p>所以说，Express 的 MVC 的结构是</p>\n<pre><code>routes/\nviews/\nmodels/\nservices/\n</code></pre><ul>\n<li>其中，由于 express 的特点，根据设置，views 目录下的文件会被模板引擎在调用<code>res.render(&#39;view_name&#39;)</code>的时候自动渲染</li>\n<li>view 层可以理解为模板引擎 + views 文件夹中的文件</li>\n<li>而 routes 可以理解为 controller，负责根据用户的请求，调取相关的 service，最终得到 model 并用于渲染</li>\n<li>models 则代表了 model 和相关逻辑</li>\n<li>services 则有些特别，由于同层 model 之间解耦的需要，单个 model 往往不应该包含太多对其他 model 的操作，我们应该在 services 中对一系列逻辑上有关的 model 进行统一操作</li>\n</ul>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><h3 id=\"如何设置-eslint-？\"><a href=\"#如何设置-eslint-？\" class=\"headerlink\" title=\"如何设置 eslint ？\"></a>如何设置 eslint ？</h3><p><a href=\"https://www.npmjs.com/package/eslint-config-airbnb\" target=\"_blank\" rel=\"noopener\">eslint-config-airbnb</a></p>\n<pre><code>// 按着第一行命令走\nnpm info &quot;eslint-config-airbnb@latest&quot; peerDependencies  // 显示的那一串是要你一个一个装的，太麻烦\n\n// 第二个方法（这个最好）\n(\n  export PKG=eslint-config-airbnb;\n  npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &#39;s/[\\{\\},]//g ; s/: /@/g&#39; | xargs npm install --save-dev &quot;$PKG@latest&quot;\n)\n\n// 安装完后开始配置\nnpm install -g eslint  // 全局安装\neslint --init  // 到目标文件夹初始化\n// 然后出现下面这个\n? How would you like to configure ESLint? (Use arrow keys)\n❯ Answer questions about your style \n  Use a popular style guide  // 选这个，然后选 airbub\n  Inspect your JavaScript file(s) \n// 接下来就要哪个选那个\n// 配置文件选 JSON\n\n// 配完后就跟着报错一个一个改\n</code></pre><p><a href=\"https://segmentfault.com/a/1190000009077086\" target=\"_blank\" rel=\"noopener\">使用 VSCode + ESLint 实践前端编码规范</a></p>\n<p><code>var</code> 改 <code>const</code>，用箭头函数，去掉没用的空格，要加分号，去掉没用的引用啊啥的，改到 0 报错就好。</p>\n<p>其实就是为了统一代码格式</p>\n<h3 id=\"query-里的冒号\"><a href=\"#query-里的冒号\" class=\"headerlink\" title=\"query 里的冒号\"></a>query 里的冒号</h3><pre><code>router.get(&#39;/:userId/subscription/:subscriptionId&#39;, (req, res, next) =&gt; { // 前面加一个冒号就代表这个是作为一个参数处理\n  res.json({\n    userId: req.params.userId,\n    subscriptionId: req.params.subscriptionId,\n  });\n});\n</code></pre><p><img src=\"https://i.loli.net/2017/12/15/5a336d474c910.png\" alt=\"\"></p>\n"},{"title":"Linux 的基本命令行和 Git 的基本操作","date":"2017-11-27T08:28:16.000Z","_content":"# Linux 的基本命令行和 Git 的基本操作\n\n## Linux 命令行\n```\n//进入目录\ncd\n//显示当前目录\npwd\n//创建目录\nmkdir 目录名\n//创建目录\nmkdir -p 目录路径\n//查看路径\nls 路径\n//查看路径\nls -a 路径\n//查看路径\nls -l 路径\n//查看路径 \nls -al 路径\n//创建文件\necho '1' > 文件路径\n//创建文件\necho '1' >! 文件路径\n//创建文件\necho '1' >> 文件路径\n//创建文件\ntouch 文件名\n//改变文件更新时间\ntouch 文件名\n//复制文件\ncp 源路径 目标路径\n//复制目录\ncp -r 源路径 目标路径\n//移动节点\nmv 源路径 目标路径\n//删除文件\nrm 文件路径\n//强制删除文件\nrm -f 文件路径\n//删除目录\nrm -r 目录路径\n//强制删除目录\nrm -rf 目录路径\n//查看目录结构\ntree\n//建立软链接\nln -s 真实文件 链接\n```\n## 怎么把项目上传到 GitHub\n```\n//把项目先克隆到本地\ngit clone git@github.com:FRANKIETANG/Remote-Mouse.git\n//把文件夹里的东西全部清除，然后运行以下命令\ngit add *\ngit commit -m ‘del’\ngit push origin master\n//把新项目放在文件夹，再运行以下命令\ngit add *\ngit commit -m ‘intinal’\ngit pull origin master\ngit push origin master\n//这样，项目就可以在 GitHub 上看到啦哈哈哈\n```\n## 补充\n\n[vim 的基本操作](https://coolshell.cn/articles/5426.html)\n\n自制命令行\n\n```\n// ~/.bashrc\n\nvi ~/.bashrc\nalias xx = \"要干的事情\"\nsource ~/.bashrc\nxx \n\n// ~/.zshrc\n\nvi ~/.zshrc\nalias xx = \"要干的事情\"\nsource ~/.zshrc\nxx \n```\n\n命令行小工具\n\n- z: 方便实现快速目录跳转，[下载在此](https://github.com/rupa/z)\n- fzf: 方便快速搜索文件或目录，[官网在此](https://github.com/junegunn/fzf#installation)\n\n```\ncurl -L https://raw.githubusercontent.com/rupa/z/master/z.sh > z.sh\nvi ~/.zshrc\nsource ~/z.sh\nsource ~/.zshrc\nz // 看到你以前去过的所有目录\nz Desk // 去桌面\n```\n\n```\ngit clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf\n~/.fzf/install\n\nsource ~/.zshrc\nfzf\n// 然后就可以在命令行搜索文件了\n```\n\n```\n把 z 和 fzf 合在一起\nvi ~/.zshrc\n\nunalias z // 不要 z 命令\n// 以下为合并命令，理解就好。把 z 换成 j 和 jj 。jj 是上一次搜索的记录\nj() {\n     if [[ -z \"$*\" ]]; then\n         cd \"$(_z -l 2>&1 | fzf +s | sed 's/^[0-9,.]* *//')\"\n     else\n         _last_z_args=\"$@\"\n         _z \"$@\"\n     fi\n }\n\n jj() {\n     cd \"$(_z -l 2>&1 | sed 's/^[0-9,.]* *//' | fzf -q $_last_z_args)\"\n }\n \n source ~/.zshrc\n```\n\n```\n// 安装 yarn\nsudo apt-get update && sudo apt-get install yarn\n```\n\n```\n// 怎么看精简文档\nnpm i -g tldr\n// tldr = too long; didn't read\n// 比如看 linux 下的 less 怎么使用\nman less\n// 太多了\ntldr less\n// 就会精简\ntldr npm\n```\n```\n// git 操作脱离民工三连的方法\n\ngit --version  // git 版本号\n\n\ngit config --global user.name xxx  // 全局设置 user.name\ngit config --global user.email yyy  // 全局设置 user.email\ngit config --global push.default simple\n// 这个 simple 可以换成 matching，通常默认为是 simple \n// 意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。\n// matching 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。\ngit config --global core.quotepath false // 防止文件名变成数字，因为有可能你的文件是中文上传的是后变成中文\ngit config --global push.editor \"vim\"  // 使用 vim 编辑提交信息\n// 以上这些都是在编辑 ~/.gitconfig\n\n\nmkdir git-demo\ncd git-demo\ngit init  // 创建 .git 目录（本地仓库）\ntouch 1.txt  // 打开写点东西\ngit starus -sb  // ?? 1.txt  // 看文件处于什么状态\n// 这个 -sb 不是傻逼的意思，s 是 summary，b 是 branch\ngit add .  // 将多行文字（注意是 行 文字）纳入 git 控制 \ngit starus -sb  // A 1.txt A 就是 ADD 的意思\tM 就是改变的意思 \ngit commit -v  // 进入 vim 编gaibain辑，在第一行写字相当于 git commit -m \"\" 引号里的文字\ngit log  // 显示历史\ngit show  // 后面加 commit 的 ID 可以看到哪行文字改变\ngit remote add origin https://github.com/xxx/xxx.git  \n// 与仓库建立链接，名字叫 origin，地址叫后面那个像网址一样的东西（错的）\ngit remote set-url origin git@github.com/xxx/xxx.git  // 更换地址\ngit push -u origin master  // -u 是本地的分支和远程的分支建立链接，master 是远程的分支\ngit clone  // 复制仓库并克隆，后面接仓库地址\ngit pull  // 更新本地仓库（.git）和本地文件\n/*\n1. git push 之前必须 git pull\n2. git pull 之前必须 git commit\n3. git commit 之前必须 git add\n*/\n\n\n// 以下命令 Google 点击第一个\ngit stash  // 不想提交进行了一半的工作\ngit branch  // 分支的新建\ngit checkout  // 切换分支\ngit merge  // 分支的合并\ngit reset  // 和 git checkout 差不多，细节 google\ngit reflog  // 用来数据恢复的\n```\n","source":"_posts/Linux 的基本命令行和 Git 的基本操作.md","raw":"---\ntitle: Linux 的基本命令行和 Git 的基本操作\ndate: 2017-11-27 16:28:16\ntags: [Linux,Git]\n---\n# Linux 的基本命令行和 Git 的基本操作\n\n## Linux 命令行\n```\n//进入目录\ncd\n//显示当前目录\npwd\n//创建目录\nmkdir 目录名\n//创建目录\nmkdir -p 目录路径\n//查看路径\nls 路径\n//查看路径\nls -a 路径\n//查看路径\nls -l 路径\n//查看路径 \nls -al 路径\n//创建文件\necho '1' > 文件路径\n//创建文件\necho '1' >! 文件路径\n//创建文件\necho '1' >> 文件路径\n//创建文件\ntouch 文件名\n//改变文件更新时间\ntouch 文件名\n//复制文件\ncp 源路径 目标路径\n//复制目录\ncp -r 源路径 目标路径\n//移动节点\nmv 源路径 目标路径\n//删除文件\nrm 文件路径\n//强制删除文件\nrm -f 文件路径\n//删除目录\nrm -r 目录路径\n//强制删除目录\nrm -rf 目录路径\n//查看目录结构\ntree\n//建立软链接\nln -s 真实文件 链接\n```\n## 怎么把项目上传到 GitHub\n```\n//把项目先克隆到本地\ngit clone git@github.com:FRANKIETANG/Remote-Mouse.git\n//把文件夹里的东西全部清除，然后运行以下命令\ngit add *\ngit commit -m ‘del’\ngit push origin master\n//把新项目放在文件夹，再运行以下命令\ngit add *\ngit commit -m ‘intinal’\ngit pull origin master\ngit push origin master\n//这样，项目就可以在 GitHub 上看到啦哈哈哈\n```\n## 补充\n\n[vim 的基本操作](https://coolshell.cn/articles/5426.html)\n\n自制命令行\n\n```\n// ~/.bashrc\n\nvi ~/.bashrc\nalias xx = \"要干的事情\"\nsource ~/.bashrc\nxx \n\n// ~/.zshrc\n\nvi ~/.zshrc\nalias xx = \"要干的事情\"\nsource ~/.zshrc\nxx \n```\n\n命令行小工具\n\n- z: 方便实现快速目录跳转，[下载在此](https://github.com/rupa/z)\n- fzf: 方便快速搜索文件或目录，[官网在此](https://github.com/junegunn/fzf#installation)\n\n```\ncurl -L https://raw.githubusercontent.com/rupa/z/master/z.sh > z.sh\nvi ~/.zshrc\nsource ~/z.sh\nsource ~/.zshrc\nz // 看到你以前去过的所有目录\nz Desk // 去桌面\n```\n\n```\ngit clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf\n~/.fzf/install\n\nsource ~/.zshrc\nfzf\n// 然后就可以在命令行搜索文件了\n```\n\n```\n把 z 和 fzf 合在一起\nvi ~/.zshrc\n\nunalias z // 不要 z 命令\n// 以下为合并命令，理解就好。把 z 换成 j 和 jj 。jj 是上一次搜索的记录\nj() {\n     if [[ -z \"$*\" ]]; then\n         cd \"$(_z -l 2>&1 | fzf +s | sed 's/^[0-9,.]* *//')\"\n     else\n         _last_z_args=\"$@\"\n         _z \"$@\"\n     fi\n }\n\n jj() {\n     cd \"$(_z -l 2>&1 | sed 's/^[0-9,.]* *//' | fzf -q $_last_z_args)\"\n }\n \n source ~/.zshrc\n```\n\n```\n// 安装 yarn\nsudo apt-get update && sudo apt-get install yarn\n```\n\n```\n// 怎么看精简文档\nnpm i -g tldr\n// tldr = too long; didn't read\n// 比如看 linux 下的 less 怎么使用\nman less\n// 太多了\ntldr less\n// 就会精简\ntldr npm\n```\n```\n// git 操作脱离民工三连的方法\n\ngit --version  // git 版本号\n\n\ngit config --global user.name xxx  // 全局设置 user.name\ngit config --global user.email yyy  // 全局设置 user.email\ngit config --global push.default simple\n// 这个 simple 可以换成 matching，通常默认为是 simple \n// 意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。\n// matching 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。\ngit config --global core.quotepath false // 防止文件名变成数字，因为有可能你的文件是中文上传的是后变成中文\ngit config --global push.editor \"vim\"  // 使用 vim 编辑提交信息\n// 以上这些都是在编辑 ~/.gitconfig\n\n\nmkdir git-demo\ncd git-demo\ngit init  // 创建 .git 目录（本地仓库）\ntouch 1.txt  // 打开写点东西\ngit starus -sb  // ?? 1.txt  // 看文件处于什么状态\n// 这个 -sb 不是傻逼的意思，s 是 summary，b 是 branch\ngit add .  // 将多行文字（注意是 行 文字）纳入 git 控制 \ngit starus -sb  // A 1.txt A 就是 ADD 的意思\tM 就是改变的意思 \ngit commit -v  // 进入 vim 编gaibain辑，在第一行写字相当于 git commit -m \"\" 引号里的文字\ngit log  // 显示历史\ngit show  // 后面加 commit 的 ID 可以看到哪行文字改变\ngit remote add origin https://github.com/xxx/xxx.git  \n// 与仓库建立链接，名字叫 origin，地址叫后面那个像网址一样的东西（错的）\ngit remote set-url origin git@github.com/xxx/xxx.git  // 更换地址\ngit push -u origin master  // -u 是本地的分支和远程的分支建立链接，master 是远程的分支\ngit clone  // 复制仓库并克隆，后面接仓库地址\ngit pull  // 更新本地仓库（.git）和本地文件\n/*\n1. git push 之前必须 git pull\n2. git pull 之前必须 git commit\n3. git commit 之前必须 git add\n*/\n\n\n// 以下命令 Google 点击第一个\ngit stash  // 不想提交进行了一半的工作\ngit branch  // 分支的新建\ngit checkout  // 切换分支\ngit merge  // 分支的合并\ngit reset  // 和 git checkout 差不多，细节 google\ngit reflog  // 用来数据恢复的\n```\n","slug":"Linux 的基本命令行和 Git 的基本操作","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d7h0003f1xh6ansculi","content":"<h1 id=\"Linux-的基本命令行和-Git-的基本操作\"><a href=\"#Linux-的基本命令行和-Git-的基本操作\" class=\"headerlink\" title=\"Linux 的基本命令行和 Git 的基本操作\"></a>Linux 的基本命令行和 Git 的基本操作</h1><h2 id=\"Linux-命令行\"><a href=\"#Linux-命令行\" class=\"headerlink\" title=\"Linux 命令行\"></a>Linux 命令行</h2><pre><code>//进入目录\ncd\n//显示当前目录\npwd\n//创建目录\nmkdir 目录名\n//创建目录\nmkdir -p 目录路径\n//查看路径\nls 路径\n//查看路径\nls -a 路径\n//查看路径\nls -l 路径\n//查看路径 \nls -al 路径\n//创建文件\necho &#39;1&#39; &gt; 文件路径\n//创建文件\necho &#39;1&#39; &gt;! 文件路径\n//创建文件\necho &#39;1&#39; &gt;&gt; 文件路径\n//创建文件\ntouch 文件名\n//改变文件更新时间\ntouch 文件名\n//复制文件\ncp 源路径 目标路径\n//复制目录\ncp -r 源路径 目标路径\n//移动节点\nmv 源路径 目标路径\n//删除文件\nrm 文件路径\n//强制删除文件\nrm -f 文件路径\n//删除目录\nrm -r 目录路径\n//强制删除目录\nrm -rf 目录路径\n//查看目录结构\ntree\n//建立软链接\nln -s 真实文件 链接\n</code></pre><h2 id=\"怎么把项目上传到-GitHub\"><a href=\"#怎么把项目上传到-GitHub\" class=\"headerlink\" title=\"怎么把项目上传到 GitHub\"></a>怎么把项目上传到 GitHub</h2><pre><code>//把项目先克隆到本地\ngit clone git@github.com:FRANKIETANG/Remote-Mouse.git\n//把文件夹里的东西全部清除，然后运行以下命令\ngit add *\ngit commit -m ‘del’\ngit push origin master\n//把新项目放在文件夹，再运行以下命令\ngit add *\ngit commit -m ‘intinal’\ngit pull origin master\ngit push origin master\n//这样，项目就可以在 GitHub 上看到啦哈哈哈\n</code></pre><h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p><a href=\"https://coolshell.cn/articles/5426.html\" target=\"_blank\" rel=\"noopener\">vim 的基本操作</a></p>\n<p>自制命令行</p>\n<pre><code>// ~/.bashrc\n\nvi ~/.bashrc\nalias xx = &quot;要干的事情&quot;\nsource ~/.bashrc\nxx \n\n// ~/.zshrc\n\nvi ~/.zshrc\nalias xx = &quot;要干的事情&quot;\nsource ~/.zshrc\nxx\n</code></pre><p>命令行小工具</p>\n<ul>\n<li>z: 方便实现快速目录跳转，<a href=\"https://github.com/rupa/z\" target=\"_blank\" rel=\"noopener\">下载在此</a></li>\n<li>fzf: 方便快速搜索文件或目录，<a href=\"https://github.com/junegunn/fzf#installation\" target=\"_blank\" rel=\"noopener\">官网在此</a></li>\n</ul>\n<pre><code>curl -L https://raw.githubusercontent.com/rupa/z/master/z.sh &gt; z.sh\nvi ~/.zshrc\nsource ~/z.sh\nsource ~/.zshrc\nz // 看到你以前去过的所有目录\nz Desk // 去桌面\n</code></pre><pre><code>git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf\n~/.fzf/install\n\nsource ~/.zshrc\nfzf\n// 然后就可以在命令行搜索文件了\n</code></pre><pre><code>把 z 和 fzf 合在一起\nvi ~/.zshrc\n\nunalias z // 不要 z 命令\n// 以下为合并命令，理解就好。把 z 换成 j 和 jj 。jj 是上一次搜索的记录\nj() {\n     if [[ -z &quot;$*&quot; ]]; then\n         cd &quot;$(_z -l 2&gt;&amp;1 | fzf +s | sed &#39;s/^[0-9,.]* *//&#39;)&quot;\n     else\n         _last_z_args=&quot;$@&quot;\n         _z &quot;$@&quot;\n     fi\n }\n\n jj() {\n     cd &quot;$(_z -l 2&gt;&amp;1 | sed &#39;s/^[0-9,.]* *//&#39; | fzf -q $_last_z_args)&quot;\n }\n\n source ~/.zshrc\n</code></pre><pre><code>// 安装 yarn\nsudo apt-get update &amp;&amp; sudo apt-get install yarn\n</code></pre><pre><code>// 怎么看精简文档\nnpm i -g tldr\n// tldr = too long; didn&#39;t read\n// 比如看 linux 下的 less 怎么使用\nman less\n// 太多了\ntldr less\n// 就会精简\ntldr npm\n</code></pre><pre><code>// git 操作脱离民工三连的方法\n\ngit --version  // git 版本号\n\n\ngit config --global user.name xxx  // 全局设置 user.name\ngit config --global user.email yyy  // 全局设置 user.email\ngit config --global push.default simple\n// 这个 simple 可以换成 matching，通常默认为是 simple \n// 意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。\n// matching 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。\ngit config --global core.quotepath false // 防止文件名变成数字，因为有可能你的文件是中文上传的是后变成中文\ngit config --global push.editor &quot;vim&quot;  // 使用 vim 编辑提交信息\n// 以上这些都是在编辑 ~/.gitconfig\n\n\nmkdir git-demo\ncd git-demo\ngit init  // 创建 .git 目录（本地仓库）\ntouch 1.txt  // 打开写点东西\ngit starus -sb  // ?? 1.txt  // 看文件处于什么状态\n// 这个 -sb 不是傻逼的意思，s 是 summary，b 是 branch\ngit add .  // 将多行文字（注意是 行 文字）纳入 git 控制 \ngit starus -sb  // A 1.txt A 就是 ADD 的意思    M 就是改变的意思 \ngit commit -v  // 进入 vim 编gaibain辑，在第一行写字相当于 git commit -m &quot;&quot; 引号里的文字\ngit log  // 显示历史\ngit show  // 后面加 commit 的 ID 可以看到哪行文字改变\ngit remote add origin https://github.com/xxx/xxx.git  \n// 与仓库建立链接，名字叫 origin，地址叫后面那个像网址一样的东西（错的）\ngit remote set-url origin git@github.com/xxx/xxx.git  // 更换地址\ngit push -u origin master  // -u 是本地的分支和远程的分支建立链接，master 是远程的分支\ngit clone  // 复制仓库并克隆，后面接仓库地址\ngit pull  // 更新本地仓库（.git）和本地文件\n/*\n1. git push 之前必须 git pull\n2. git pull 之前必须 git commit\n3. git commit 之前必须 git add\n*/\n\n\n// 以下命令 Google 点击第一个\ngit stash  // 不想提交进行了一半的工作\ngit branch  // 分支的新建\ngit checkout  // 切换分支\ngit merge  // 分支的合并\ngit reset  // 和 git checkout 差不多，细节 google\ngit reflog  // 用来数据恢复的\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linux-的基本命令行和-Git-的基本操作\"><a href=\"#Linux-的基本命令行和-Git-的基本操作\" class=\"headerlink\" title=\"Linux 的基本命令行和 Git 的基本操作\"></a>Linux 的基本命令行和 Git 的基本操作</h1><h2 id=\"Linux-命令行\"><a href=\"#Linux-命令行\" class=\"headerlink\" title=\"Linux 命令行\"></a>Linux 命令行</h2><pre><code>//进入目录\ncd\n//显示当前目录\npwd\n//创建目录\nmkdir 目录名\n//创建目录\nmkdir -p 目录路径\n//查看路径\nls 路径\n//查看路径\nls -a 路径\n//查看路径\nls -l 路径\n//查看路径 \nls -al 路径\n//创建文件\necho &#39;1&#39; &gt; 文件路径\n//创建文件\necho &#39;1&#39; &gt;! 文件路径\n//创建文件\necho &#39;1&#39; &gt;&gt; 文件路径\n//创建文件\ntouch 文件名\n//改变文件更新时间\ntouch 文件名\n//复制文件\ncp 源路径 目标路径\n//复制目录\ncp -r 源路径 目标路径\n//移动节点\nmv 源路径 目标路径\n//删除文件\nrm 文件路径\n//强制删除文件\nrm -f 文件路径\n//删除目录\nrm -r 目录路径\n//强制删除目录\nrm -rf 目录路径\n//查看目录结构\ntree\n//建立软链接\nln -s 真实文件 链接\n</code></pre><h2 id=\"怎么把项目上传到-GitHub\"><a href=\"#怎么把项目上传到-GitHub\" class=\"headerlink\" title=\"怎么把项目上传到 GitHub\"></a>怎么把项目上传到 GitHub</h2><pre><code>//把项目先克隆到本地\ngit clone git@github.com:FRANKIETANG/Remote-Mouse.git\n//把文件夹里的东西全部清除，然后运行以下命令\ngit add *\ngit commit -m ‘del’\ngit push origin master\n//把新项目放在文件夹，再运行以下命令\ngit add *\ngit commit -m ‘intinal’\ngit pull origin master\ngit push origin master\n//这样，项目就可以在 GitHub 上看到啦哈哈哈\n</code></pre><h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p><a href=\"https://coolshell.cn/articles/5426.html\" target=\"_blank\" rel=\"noopener\">vim 的基本操作</a></p>\n<p>自制命令行</p>\n<pre><code>// ~/.bashrc\n\nvi ~/.bashrc\nalias xx = &quot;要干的事情&quot;\nsource ~/.bashrc\nxx \n\n// ~/.zshrc\n\nvi ~/.zshrc\nalias xx = &quot;要干的事情&quot;\nsource ~/.zshrc\nxx\n</code></pre><p>命令行小工具</p>\n<ul>\n<li>z: 方便实现快速目录跳转，<a href=\"https://github.com/rupa/z\" target=\"_blank\" rel=\"noopener\">下载在此</a></li>\n<li>fzf: 方便快速搜索文件或目录，<a href=\"https://github.com/junegunn/fzf#installation\" target=\"_blank\" rel=\"noopener\">官网在此</a></li>\n</ul>\n<pre><code>curl -L https://raw.githubusercontent.com/rupa/z/master/z.sh &gt; z.sh\nvi ~/.zshrc\nsource ~/z.sh\nsource ~/.zshrc\nz // 看到你以前去过的所有目录\nz Desk // 去桌面\n</code></pre><pre><code>git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf\n~/.fzf/install\n\nsource ~/.zshrc\nfzf\n// 然后就可以在命令行搜索文件了\n</code></pre><pre><code>把 z 和 fzf 合在一起\nvi ~/.zshrc\n\nunalias z // 不要 z 命令\n// 以下为合并命令，理解就好。把 z 换成 j 和 jj 。jj 是上一次搜索的记录\nj() {\n     if [[ -z &quot;$*&quot; ]]; then\n         cd &quot;$(_z -l 2&gt;&amp;1 | fzf +s | sed &#39;s/^[0-9,.]* *//&#39;)&quot;\n     else\n         _last_z_args=&quot;$@&quot;\n         _z &quot;$@&quot;\n     fi\n }\n\n jj() {\n     cd &quot;$(_z -l 2&gt;&amp;1 | sed &#39;s/^[0-9,.]* *//&#39; | fzf -q $_last_z_args)&quot;\n }\n\n source ~/.zshrc\n</code></pre><pre><code>// 安装 yarn\nsudo apt-get update &amp;&amp; sudo apt-get install yarn\n</code></pre><pre><code>// 怎么看精简文档\nnpm i -g tldr\n// tldr = too long; didn&#39;t read\n// 比如看 linux 下的 less 怎么使用\nman less\n// 太多了\ntldr less\n// 就会精简\ntldr npm\n</code></pre><pre><code>// git 操作脱离民工三连的方法\n\ngit --version  // git 版本号\n\n\ngit config --global user.name xxx  // 全局设置 user.name\ngit config --global user.email yyy  // 全局设置 user.email\ngit config --global push.default simple\n// 这个 simple 可以换成 matching，通常默认为是 simple \n// 意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。\n// matching 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。\ngit config --global core.quotepath false // 防止文件名变成数字，因为有可能你的文件是中文上传的是后变成中文\ngit config --global push.editor &quot;vim&quot;  // 使用 vim 编辑提交信息\n// 以上这些都是在编辑 ~/.gitconfig\n\n\nmkdir git-demo\ncd git-demo\ngit init  // 创建 .git 目录（本地仓库）\ntouch 1.txt  // 打开写点东西\ngit starus -sb  // ?? 1.txt  // 看文件处于什么状态\n// 这个 -sb 不是傻逼的意思，s 是 summary，b 是 branch\ngit add .  // 将多行文字（注意是 行 文字）纳入 git 控制 \ngit starus -sb  // A 1.txt A 就是 ADD 的意思    M 就是改变的意思 \ngit commit -v  // 进入 vim 编gaibain辑，在第一行写字相当于 git commit -m &quot;&quot; 引号里的文字\ngit log  // 显示历史\ngit show  // 后面加 commit 的 ID 可以看到哪行文字改变\ngit remote add origin https://github.com/xxx/xxx.git  \n// 与仓库建立链接，名字叫 origin，地址叫后面那个像网址一样的东西（错的）\ngit remote set-url origin git@github.com/xxx/xxx.git  // 更换地址\ngit push -u origin master  // -u 是本地的分支和远程的分支建立链接，master 是远程的分支\ngit clone  // 复制仓库并克隆，后面接仓库地址\ngit pull  // 更新本地仓库（.git）和本地文件\n/*\n1. git push 之前必须 git pull\n2. git pull 之前必须 git commit\n3. git commit 之前必须 git add\n*/\n\n\n// 以下命令 Google 点击第一个\ngit stash  // 不想提交进行了一半的工作\ngit branch  // 分支的新建\ngit checkout  // 切换分支\ngit merge  // 分支的合并\ngit reset  // 和 git checkout 差不多，细节 google\ngit reflog  // 用来数据恢复的\n</code></pre>"},{"title":"MVC - MVVM 是什么","date":"2017-12-05T17:19:34.000Z","_content":"# MVC - MVVM 是什么\n\n[谈谈MVC模式 - 阮一峰](http://www.ruanyifeng.com/blog/2007/11/mvc.html)\n\n[MVC，MVP 和 MVVM 的图示 - 阮一峰](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)\n\n[MVC框架与Backbone.js - JavaScript 标准参考教程（alpha） - 阮一峰](http://javascript.ruanyifeng.com/advanced/backbonejs.html)\n\n基于MVC的JavaScript Web富应用开发 - [网盘](https://pan.baidu.com/s/1qY9hJmG) 密码是 y9jv\n\n以下例子代码的仓库在 https://github.com/FRANKIETANG/mvc-mvvm-example \n\n代码变动看 [commit](https://github.com/FRANKIETANG/mvc-mvvm-example/commits/master)\n\n## MVC\n\n如果要先实现一个 MVC ，首先要实现的是中间的那一层 Controller\n\n对于 Controller 的作用，绑事件 / 调用方法可以用对象的形式 / 监听 DOM 并且更新 DOM / 操作数据\n\n下面实现一个 MVC 的轮子吧\n\n```\n// 举个例子\n\n// index.html 核心代码\n    <div class=\"modules\">\n        <div class=\"module1\">\n            <input type=\"text\" name=\"number1\">\n            <button name=\"button1\">点我</button>\n        </div>\n    </div>\n\n// index.js\nimport './module1'\n\n// Controller.js\nimport $ from 'jquery'\n\nclass Controller {\n    constructor(options) {\n        this.$element = $(options.element)\n        this.events = options.events\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(' ')\n            let eventType = parts.shift()\n            let selector = parts.join(' ')\n            this.$element.on(eventType, selector, this.events[key])\n        }\n    }\n}\n\nexport default Controller\n\n// module1.js\nimport Controller from './Controller'\n\nnew Controller({\n    element: '.module1',\n    events: {\n        'change input': e => {\n            console.log('change1')\n        },\n        'click button': e => {\n            console.log('click1')\n        }\n    }\n})\n```\n\n![](https://us1.myximage.com/2017/12/02/90db865271941bd9a64075d1a667d60e.gif)\n\n比如上面这个例子就是当需要 Controller 的时候只需要写上你要绑的元素，要做的事件就好。至于实现方法全部交给 Controller 去处理。\n\n但是上面的例子还是很简单，假如函数逻辑比较复杂该怎么做？可以用对象的形式调用方法。\n\n```\n// 举个例子\n\nnew Controller({\n    element: '.module1',\n    events: {\n        'change input': 'onChangeInput',    \n        'click button': 'addToCart'\n    },\n    addToCart() {\n        let value = this.$element.find('input').val()\n        this.remoteAddCart(value).then(() => { // 假如发送到服务器让服务器知道你已经把什么放到购物车了，下次登录的时候就可以获取数据。\n            this.showAnimation() // 加入到购物车的动画\n        })  \n    },\n    remoteAddCart() {\n        console.log('远程请求')\n        return Promise.resolve(1)\n    },\n    showAnimation(){\n        console.log('展示添加到购物车的动画')\n    }\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }    \n})\n\n// 修改一下 Controller\n\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key] // 把用户传的东西都放到 json\n        }\n        this.$element = $(this.element)\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(' ')\n            let eventType = parts.shift()\n            let selector = parts.join(' ')\n            if (typeof this.events[key] === 'function') {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === 'string') {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n}\n```\n\n![](https://us1.myximage.com/2017/12/02/9bee130d43526daa3c4794d75047aaa0.gif)\n\n那监听 DOM 并且更新 DOM 呢？要怎么搞？（实际上早期的 MVC 更新 DOM 的确是要自己写，所以很麻烦）\n\n```\n// 举个例子\n\nnew Controller({\n    element: '.module2',\n    events: {\n        'change input': 'onChangeInput',\n        'click button': 'onClickButton'\n    },\n    onClickButton(e) {\n        let value = this.$element.find('input').val()\n        this.render(value)\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    },\n    render(value) {\n        let $output = this.$element.find('.output')\n        if ($output.length === 0) {\n            $output = $('<div class=\"output\"></div>').text(value)\n            $output.appendTo(this.$element)\n        } else {\n            $output.text(value)\n        }\n    }\n})\n```\n\n![](https://us1.myximage.com/2017/12/02/53534b163c052c5f0b9a494c3a11f79c.gif)\n\n然后过了一段时间之后就有了 template，在 JS 写模板。并且操作数据。http://handlebarsjs.com/\n\n```\n// 举个例子\n// 先修改html\n<div class=\"module2\"></div>\n\n// 增加 template 和 data\nnew Controller({\n    element: '.module2',\n    template: `\n        <input type=\"text\" name=\"number2\" value=\"{{output}}\">\n        <button name=\"button2\">点我</button>  \n        <div class=\"output\">{{output}}</div>  \n    `,\n    data: {\n        output: ''  // 控制数据\n    },\n    events: {\n        'change input': 'onChangeInput',\n        'click button': 'onClickButton'\n    },\n    onClickButton(e) {\n        let value = this.$element.find('input').val()\n        this.data.output = value\n        this.render()\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }\n})\n\n// Controller\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key]\n        }\n        this.$element = $(this.element)\n        if (this.template && this.render) {  // 判断是否有 template\n            this.render()\n        }\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(' ')\n            let eventType = parts.shift()\n            let selector = parts.join(' ')\n            if (typeof this.events[key] === 'function') {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === 'string') {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n    render() {\n        let html = Handlebars.compile(this.template)(this.data)  // 渲染 template 和 data\n        this.$element.html(html)\n    }\n}\n```\n\n和刚刚看起来效果变化不大，但实际上用上了 template 和 data 已经很接近 vue ... 啊不是，是 MVC 了 \n\n![](https://us1.myximage.com/2017/12/03/5673db0242ef4494b3c9affc904f96a5.gif)\n\n```\n// 再举个例子\n// index.html 加上模板\n    <script id=\"module3Template\" type=\"text/x-handlerbars\">\n        <button name=\"decrease\"> - </button>\n        <span>{{number}}</span>\n        <button name=\"increase\"> + </button>    \n    </script>\n    <script type=\"text/javascript\" src=\"bundle.js\"></script>\n\n// module3.js\nnew Controller({\n    element: '.module3',\n    template: '#module3Template',\n    data: {\n        number: 0\n    },\n    events: {\n        'click button[name=increase]': 'increase',\n        'click button[name=decrease]': 'decrease'\n    },\n    increase(){\n        this.data.number += 1\n        this.render()\n    },\n    decrease(){\n        this.data.number -= 1\n        this.render()\n    }    \n})\n\n// Controller.js 的 render 修改成\n    render() {\n        let template = (this.template[0] === '#') ? $(this.template).html() : this.template\n        let html = Handlebars.compile(template)(this.data)\n        this.$element.html(html)\n    }\n```\n\n![](https://us1.myximage.com/2017/12/03/4bf9ab6f7e4d716f90c3b9e5684a710b.gif)\n\n到这一步为止，已经实现 VC 了，视图层\"（View）利用了 template 来实现，控制层\"（Controller）就是 Controller.js，而数据层\"（Model）就是 data，下面来举个例子\n\n因为数据层\"（Model）是从服务器来的，所以刚开始要初始化\n\n```\n// 举个例子\n// 本地模拟数据 data.json\n{\n    \"number\": 10000\n}\n\n// 用 promise 模拟数据更新\nnew Controller({\n    element: '.module4',\n    template: `\n        <button name=\"decrease\"> - </button>\n        <span>{{number}}</span>\n        <button name=\"increase\"> + </button>\n    `,\n    data: {\n        number: 0\n    },\n    init() {\n        $.get('/data.json').then((response) => {\n            this.data = response\n            this.render()\n        })\n    },\n    events: {\n        'click button[name=increase]': 'increase',\n        'click button[name=decrease]': 'decrease'\n    },\n    increase() {\n        this.remoteIncrease.then(() => {\n            this.data.number += 1\n            this.render()\n        })\n    },\n    decrease() {\n        this.remoteDecrease.then(() => {\n            this.data.number -= 1\n            this.render()\n        })\n    },\n    remoteIncrease() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                resolve({\n                    number: this.number + 1\n                })\n            }, 500)\n        })\n    },\n    remoteDecrease() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                resolve({\n                    number: this.number - 1\n                })\n            }, 500)\n        })\n    }\n})\n```\n\n![](https://us1.myximage.com/2017/12/03/7d92010a76b32fcc2c0d222194eec2fa.gif)\n\n再优化一下代码把数据层\"（Model）抽离出来\n\n```\nlet model = {\n    data: {\n        number: 0\n    },\n    get() {\n        return $.get('/data.json').then((response) => {\n            this.data = response\n            return this.data\n        })\n    },\n    increase() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                this.data.number += 1\n                resolve(this.data)\n            }, 500)\n        })\n    },\n    decrease() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                this.data.number -= 1\n                resolve(this.data)\n            }, 500)\n        })\n    }\n}\n\n\nnew Controller({\n    element: '.module4',\n    template: `\n        <button name=\"decrease\"> - </button>\n        <span>{{number}}</span>\n        <button name=\"increase\"> + </button>\n    `,\n    model: model,\n    events: {\n        'click button[name=increase]': 'increase',\n        'click button[name=decrease]': 'decrease'\n    },\n    init() {\n        this.model.get().then(() => {\n            this.render()\n        })\n    },\n    increase() {\n        this.model.increase().then(() => {\n            this.render()\n        })\n    },\n    decrease() {\n        this.model.decrease().then(() => {\n            this.render()\n        })\n    }\n})\n```\n\n这样的好处就很明显了，操作永远只是数据，不会操作到 DOM，就是调一下 model 操作一下 view，以上，就实现了MVC 的全部功能 \n\n## MVVM\n\nObject.defineProperty 可以对属性有读写的控制\n\n```\n// 举个例子\nlet frankie = {\n    _data: {\n        age: 18,\n        name: 'frankie'\n    }\n}\n\nObject.defineProperty(frankie, 'age', {\n    get: () => {\n        console.log('frankie.age 被读取了')\n        return frankie._data.age\n    },\n    set: xxx => {\n        console.log('frankie.age 被设置了')\n        frankie._data.age = xxx\n    }\n})\n\nfrankie.age = 19  // frankie.age 被设置了\nfrankie.age = 20  // frankie.age 被设置了\nfrankie.age = 21  // frankie.age 被设置了\nconsole.log(frankie.age)  // frankie.age 被读取了 21\n```\n\n通过以上代码可以做到监听 input value 的变化去改内存里对象的变化，也可以改 `frankie.age` 来改页面上的数值\n\n例子 => [点击这里](https://jsbin.com/zawapumihe/1/edit?html,js,output)\n\n### 那 MVVM 到底是个啥玩意呢？\n\n以上面这个例子为例：\n\n- M -> frankie (这个是 JS 内存里的)\n- VM -> 能让 V 和 M 互相沟通的东西，当 M 变了就通知 V 变，当 V 变了就通知 M 变。（两头互相监听互相变）\n- V -> HTML / CSS (内容 / 表现层)\n\n### MVVM 的缺点\n\n第一点要注意的是 `Object.defineProperty` 里的 `get` 和 `set` 是同步还是异步（改了之后马上更新 input？改了之后在下一次任务的时候更新 input？）\n\n![](https://us1.myximage.com/2017/12/05/b34439946bad220c9faf564fdbe2f080.png)\n\n![yin](https://us1.myximage.com/2017/12/05/d8b5e5b60652215f6172f7e54a411110.png)\n\n经过上面的测试是同步的\n\n第二点是 DOM 的操作也是同步的（DOM 不存在异步过程）\n\n这样会有一个问题，假如 view 层加了一个 input 就不能增加效果（以为因为新的 VM 没有 set 这个 input）。例子 => [点击这里](https://jsbin.com/cibunafuro/1/edit?html,js,output)\n\n所以 MVVM 的问题就在这里，只能监听已经存在的 key，新加的 key 没法监听\n\n解决方法还是有的，提供一个 API 为新加的 key 服务。例子 => [点击这里](https://jsbin.com/zagacilade/edit?html,js,output)\n\nJS 操作 DOM 很慢，DOM 操作 JS 是很慢的\n\n因为操作是同步的，所以有一个问题是，会很卡。但是 vue.js 很好的解决了这一个问题。（再也不用操作 DOM，从此 \tjQuery 退出历史舞台）\n\n[vue.js 的 Hello world](https://jsbin.com/jeqaqoyeyi/2/edit?html,js,output)","source":"_posts/MVC - MVVM 是什么.md","raw":"---\ntitle: MVC - MVVM 是什么\ndate: 2017-12-06 01:19:34\ntags: [JavaScript]\n---\n# MVC - MVVM 是什么\n\n[谈谈MVC模式 - 阮一峰](http://www.ruanyifeng.com/blog/2007/11/mvc.html)\n\n[MVC，MVP 和 MVVM 的图示 - 阮一峰](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)\n\n[MVC框架与Backbone.js - JavaScript 标准参考教程（alpha） - 阮一峰](http://javascript.ruanyifeng.com/advanced/backbonejs.html)\n\n基于MVC的JavaScript Web富应用开发 - [网盘](https://pan.baidu.com/s/1qY9hJmG) 密码是 y9jv\n\n以下例子代码的仓库在 https://github.com/FRANKIETANG/mvc-mvvm-example \n\n代码变动看 [commit](https://github.com/FRANKIETANG/mvc-mvvm-example/commits/master)\n\n## MVC\n\n如果要先实现一个 MVC ，首先要实现的是中间的那一层 Controller\n\n对于 Controller 的作用，绑事件 / 调用方法可以用对象的形式 / 监听 DOM 并且更新 DOM / 操作数据\n\n下面实现一个 MVC 的轮子吧\n\n```\n// 举个例子\n\n// index.html 核心代码\n    <div class=\"modules\">\n        <div class=\"module1\">\n            <input type=\"text\" name=\"number1\">\n            <button name=\"button1\">点我</button>\n        </div>\n    </div>\n\n// index.js\nimport './module1'\n\n// Controller.js\nimport $ from 'jquery'\n\nclass Controller {\n    constructor(options) {\n        this.$element = $(options.element)\n        this.events = options.events\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(' ')\n            let eventType = parts.shift()\n            let selector = parts.join(' ')\n            this.$element.on(eventType, selector, this.events[key])\n        }\n    }\n}\n\nexport default Controller\n\n// module1.js\nimport Controller from './Controller'\n\nnew Controller({\n    element: '.module1',\n    events: {\n        'change input': e => {\n            console.log('change1')\n        },\n        'click button': e => {\n            console.log('click1')\n        }\n    }\n})\n```\n\n![](https://us1.myximage.com/2017/12/02/90db865271941bd9a64075d1a667d60e.gif)\n\n比如上面这个例子就是当需要 Controller 的时候只需要写上你要绑的元素，要做的事件就好。至于实现方法全部交给 Controller 去处理。\n\n但是上面的例子还是很简单，假如函数逻辑比较复杂该怎么做？可以用对象的形式调用方法。\n\n```\n// 举个例子\n\nnew Controller({\n    element: '.module1',\n    events: {\n        'change input': 'onChangeInput',    \n        'click button': 'addToCart'\n    },\n    addToCart() {\n        let value = this.$element.find('input').val()\n        this.remoteAddCart(value).then(() => { // 假如发送到服务器让服务器知道你已经把什么放到购物车了，下次登录的时候就可以获取数据。\n            this.showAnimation() // 加入到购物车的动画\n        })  \n    },\n    remoteAddCart() {\n        console.log('远程请求')\n        return Promise.resolve(1)\n    },\n    showAnimation(){\n        console.log('展示添加到购物车的动画')\n    }\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }    \n})\n\n// 修改一下 Controller\n\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key] // 把用户传的东西都放到 json\n        }\n        this.$element = $(this.element)\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(' ')\n            let eventType = parts.shift()\n            let selector = parts.join(' ')\n            if (typeof this.events[key] === 'function') {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === 'string') {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n}\n```\n\n![](https://us1.myximage.com/2017/12/02/9bee130d43526daa3c4794d75047aaa0.gif)\n\n那监听 DOM 并且更新 DOM 呢？要怎么搞？（实际上早期的 MVC 更新 DOM 的确是要自己写，所以很麻烦）\n\n```\n// 举个例子\n\nnew Controller({\n    element: '.module2',\n    events: {\n        'change input': 'onChangeInput',\n        'click button': 'onClickButton'\n    },\n    onClickButton(e) {\n        let value = this.$element.find('input').val()\n        this.render(value)\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    },\n    render(value) {\n        let $output = this.$element.find('.output')\n        if ($output.length === 0) {\n            $output = $('<div class=\"output\"></div>').text(value)\n            $output.appendTo(this.$element)\n        } else {\n            $output.text(value)\n        }\n    }\n})\n```\n\n![](https://us1.myximage.com/2017/12/02/53534b163c052c5f0b9a494c3a11f79c.gif)\n\n然后过了一段时间之后就有了 template，在 JS 写模板。并且操作数据。http://handlebarsjs.com/\n\n```\n// 举个例子\n// 先修改html\n<div class=\"module2\"></div>\n\n// 增加 template 和 data\nnew Controller({\n    element: '.module2',\n    template: `\n        <input type=\"text\" name=\"number2\" value=\"{{output}}\">\n        <button name=\"button2\">点我</button>  \n        <div class=\"output\">{{output}}</div>  \n    `,\n    data: {\n        output: ''  // 控制数据\n    },\n    events: {\n        'change input': 'onChangeInput',\n        'click button': 'onClickButton'\n    },\n    onClickButton(e) {\n        let value = this.$element.find('input').val()\n        this.data.output = value\n        this.render()\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }\n})\n\n// Controller\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key]\n        }\n        this.$element = $(this.element)\n        if (this.template && this.render) {  // 判断是否有 template\n            this.render()\n        }\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(' ')\n            let eventType = parts.shift()\n            let selector = parts.join(' ')\n            if (typeof this.events[key] === 'function') {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === 'string') {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n    render() {\n        let html = Handlebars.compile(this.template)(this.data)  // 渲染 template 和 data\n        this.$element.html(html)\n    }\n}\n```\n\n和刚刚看起来效果变化不大，但实际上用上了 template 和 data 已经很接近 vue ... 啊不是，是 MVC 了 \n\n![](https://us1.myximage.com/2017/12/03/5673db0242ef4494b3c9affc904f96a5.gif)\n\n```\n// 再举个例子\n// index.html 加上模板\n    <script id=\"module3Template\" type=\"text/x-handlerbars\">\n        <button name=\"decrease\"> - </button>\n        <span>{{number}}</span>\n        <button name=\"increase\"> + </button>    \n    </script>\n    <script type=\"text/javascript\" src=\"bundle.js\"></script>\n\n// module3.js\nnew Controller({\n    element: '.module3',\n    template: '#module3Template',\n    data: {\n        number: 0\n    },\n    events: {\n        'click button[name=increase]': 'increase',\n        'click button[name=decrease]': 'decrease'\n    },\n    increase(){\n        this.data.number += 1\n        this.render()\n    },\n    decrease(){\n        this.data.number -= 1\n        this.render()\n    }    \n})\n\n// Controller.js 的 render 修改成\n    render() {\n        let template = (this.template[0] === '#') ? $(this.template).html() : this.template\n        let html = Handlebars.compile(template)(this.data)\n        this.$element.html(html)\n    }\n```\n\n![](https://us1.myximage.com/2017/12/03/4bf9ab6f7e4d716f90c3b9e5684a710b.gif)\n\n到这一步为止，已经实现 VC 了，视图层\"（View）利用了 template 来实现，控制层\"（Controller）就是 Controller.js，而数据层\"（Model）就是 data，下面来举个例子\n\n因为数据层\"（Model）是从服务器来的，所以刚开始要初始化\n\n```\n// 举个例子\n// 本地模拟数据 data.json\n{\n    \"number\": 10000\n}\n\n// 用 promise 模拟数据更新\nnew Controller({\n    element: '.module4',\n    template: `\n        <button name=\"decrease\"> - </button>\n        <span>{{number}}</span>\n        <button name=\"increase\"> + </button>\n    `,\n    data: {\n        number: 0\n    },\n    init() {\n        $.get('/data.json').then((response) => {\n            this.data = response\n            this.render()\n        })\n    },\n    events: {\n        'click button[name=increase]': 'increase',\n        'click button[name=decrease]': 'decrease'\n    },\n    increase() {\n        this.remoteIncrease.then(() => {\n            this.data.number += 1\n            this.render()\n        })\n    },\n    decrease() {\n        this.remoteDecrease.then(() => {\n            this.data.number -= 1\n            this.render()\n        })\n    },\n    remoteIncrease() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                resolve({\n                    number: this.number + 1\n                })\n            }, 500)\n        })\n    },\n    remoteDecrease() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                resolve({\n                    number: this.number - 1\n                })\n            }, 500)\n        })\n    }\n})\n```\n\n![](https://us1.myximage.com/2017/12/03/7d92010a76b32fcc2c0d222194eec2fa.gif)\n\n再优化一下代码把数据层\"（Model）抽离出来\n\n```\nlet model = {\n    data: {\n        number: 0\n    },\n    get() {\n        return $.get('/data.json').then((response) => {\n            this.data = response\n            return this.data\n        })\n    },\n    increase() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                this.data.number += 1\n                resolve(this.data)\n            }, 500)\n        })\n    },\n    decrease() {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log('500ms')\n                this.data.number -= 1\n                resolve(this.data)\n            }, 500)\n        })\n    }\n}\n\n\nnew Controller({\n    element: '.module4',\n    template: `\n        <button name=\"decrease\"> - </button>\n        <span>{{number}}</span>\n        <button name=\"increase\"> + </button>\n    `,\n    model: model,\n    events: {\n        'click button[name=increase]': 'increase',\n        'click button[name=decrease]': 'decrease'\n    },\n    init() {\n        this.model.get().then(() => {\n            this.render()\n        })\n    },\n    increase() {\n        this.model.increase().then(() => {\n            this.render()\n        })\n    },\n    decrease() {\n        this.model.decrease().then(() => {\n            this.render()\n        })\n    }\n})\n```\n\n这样的好处就很明显了，操作永远只是数据，不会操作到 DOM，就是调一下 model 操作一下 view，以上，就实现了MVC 的全部功能 \n\n## MVVM\n\nObject.defineProperty 可以对属性有读写的控制\n\n```\n// 举个例子\nlet frankie = {\n    _data: {\n        age: 18,\n        name: 'frankie'\n    }\n}\n\nObject.defineProperty(frankie, 'age', {\n    get: () => {\n        console.log('frankie.age 被读取了')\n        return frankie._data.age\n    },\n    set: xxx => {\n        console.log('frankie.age 被设置了')\n        frankie._data.age = xxx\n    }\n})\n\nfrankie.age = 19  // frankie.age 被设置了\nfrankie.age = 20  // frankie.age 被设置了\nfrankie.age = 21  // frankie.age 被设置了\nconsole.log(frankie.age)  // frankie.age 被读取了 21\n```\n\n通过以上代码可以做到监听 input value 的变化去改内存里对象的变化，也可以改 `frankie.age` 来改页面上的数值\n\n例子 => [点击这里](https://jsbin.com/zawapumihe/1/edit?html,js,output)\n\n### 那 MVVM 到底是个啥玩意呢？\n\n以上面这个例子为例：\n\n- M -> frankie (这个是 JS 内存里的)\n- VM -> 能让 V 和 M 互相沟通的东西，当 M 变了就通知 V 变，当 V 变了就通知 M 变。（两头互相监听互相变）\n- V -> HTML / CSS (内容 / 表现层)\n\n### MVVM 的缺点\n\n第一点要注意的是 `Object.defineProperty` 里的 `get` 和 `set` 是同步还是异步（改了之后马上更新 input？改了之后在下一次任务的时候更新 input？）\n\n![](https://us1.myximage.com/2017/12/05/b34439946bad220c9faf564fdbe2f080.png)\n\n![yin](https://us1.myximage.com/2017/12/05/d8b5e5b60652215f6172f7e54a411110.png)\n\n经过上面的测试是同步的\n\n第二点是 DOM 的操作也是同步的（DOM 不存在异步过程）\n\n这样会有一个问题，假如 view 层加了一个 input 就不能增加效果（以为因为新的 VM 没有 set 这个 input）。例子 => [点击这里](https://jsbin.com/cibunafuro/1/edit?html,js,output)\n\n所以 MVVM 的问题就在这里，只能监听已经存在的 key，新加的 key 没法监听\n\n解决方法还是有的，提供一个 API 为新加的 key 服务。例子 => [点击这里](https://jsbin.com/zagacilade/edit?html,js,output)\n\nJS 操作 DOM 很慢，DOM 操作 JS 是很慢的\n\n因为操作是同步的，所以有一个问题是，会很卡。但是 vue.js 很好的解决了这一个问题。（再也不用操作 DOM，从此 \tjQuery 退出历史舞台）\n\n[vue.js 的 Hello world](https://jsbin.com/jeqaqoyeyi/2/edit?html,js,output)","slug":"MVC - MVVM 是什么","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d7q0006f1xh1u6c15pj","content":"<h1 id=\"MVC-MVVM-是什么\"><a href=\"#MVC-MVVM-是什么\" class=\"headerlink\" title=\"MVC - MVVM 是什么\"></a>MVC - MVVM 是什么</h1><p><a href=\"http://www.ruanyifeng.com/blog/2007/11/mvc.html\" target=\"_blank\" rel=\"noopener\">谈谈MVC模式 - 阮一峰</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"noopener\">MVC，MVP 和 MVVM 的图示 - 阮一峰</a></p>\n<p><a href=\"http://javascript.ruanyifeng.com/advanced/backbonejs.html\" target=\"_blank\" rel=\"noopener\">MVC框架与Backbone.js - JavaScript 标准参考教程（alpha） - 阮一峰</a></p>\n<p>基于MVC的JavaScript Web富应用开发 - <a href=\"https://pan.baidu.com/s/1qY9hJmG\" target=\"_blank\" rel=\"noopener\">网盘</a> 密码是 y9jv</p>\n<p>以下例子代码的仓库在 <a href=\"https://github.com/FRANKIETANG/mvc-mvvm-example\" target=\"_blank\" rel=\"noopener\">https://github.com/FRANKIETANG/mvc-mvvm-example</a> </p>\n<p>代码变动看 <a href=\"https://github.com/FRANKIETANG/mvc-mvvm-example/commits/master\" target=\"_blank\" rel=\"noopener\">commit</a></p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>如果要先实现一个 MVC ，首先要实现的是中间的那一层 Controller</p>\n<p>对于 Controller 的作用，绑事件 / 调用方法可以用对象的形式 / 监听 DOM 并且更新 DOM / 操作数据</p>\n<p>下面实现一个 MVC 的轮子吧</p>\n<pre><code>// 举个例子\n\n// index.html 核心代码\n    &lt;div class=&quot;modules&quot;&gt;\n        &lt;div class=&quot;module1&quot;&gt;\n            &lt;input type=&quot;text&quot; name=&quot;number1&quot;&gt;\n            &lt;button name=&quot;button1&quot;&gt;点我&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n// index.js\nimport &#39;./module1&#39;\n\n// Controller.js\nimport $ from &#39;jquery&#39;\n\nclass Controller {\n    constructor(options) {\n        this.$element = $(options.element)\n        this.events = options.events\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(&#39; &#39;)\n            let eventType = parts.shift()\n            let selector = parts.join(&#39; &#39;)\n            this.$element.on(eventType, selector, this.events[key])\n        }\n    }\n}\n\nexport default Controller\n\n// module1.js\nimport Controller from &#39;./Controller&#39;\n\nnew Controller({\n    element: &#39;.module1&#39;,\n    events: {\n        &#39;change input&#39;: e =&gt; {\n            console.log(&#39;change1&#39;)\n        },\n        &#39;click button&#39;: e =&gt; {\n            console.log(&#39;click1&#39;)\n        }\n    }\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/02/90db865271941bd9a64075d1a667d60e.gif\" alt=\"\"></p>\n<p>比如上面这个例子就是当需要 Controller 的时候只需要写上你要绑的元素，要做的事件就好。至于实现方法全部交给 Controller 去处理。</p>\n<p>但是上面的例子还是很简单，假如函数逻辑比较复杂该怎么做？可以用对象的形式调用方法。</p>\n<pre><code>// 举个例子\n\nnew Controller({\n    element: &#39;.module1&#39;,\n    events: {\n        &#39;change input&#39;: &#39;onChangeInput&#39;,    \n        &#39;click button&#39;: &#39;addToCart&#39;\n    },\n    addToCart() {\n        let value = this.$element.find(&#39;input&#39;).val()\n        this.remoteAddCart(value).then(() =&gt; { // 假如发送到服务器让服务器知道你已经把什么放到购物车了，下次登录的时候就可以获取数据。\n            this.showAnimation() // 加入到购物车的动画\n        })  \n    },\n    remoteAddCart() {\n        console.log(&#39;远程请求&#39;)\n        return Promise.resolve(1)\n    },\n    showAnimation(){\n        console.log(&#39;展示添加到购物车的动画&#39;)\n    }\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }    \n})\n\n// 修改一下 Controller\n\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key] // 把用户传的东西都放到 json\n        }\n        this.$element = $(this.element)\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(&#39; &#39;)\n            let eventType = parts.shift()\n            let selector = parts.join(&#39; &#39;)\n            if (typeof this.events[key] === &#39;function&#39;) {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === &#39;string&#39;) {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n}\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/02/9bee130d43526daa3c4794d75047aaa0.gif\" alt=\"\"></p>\n<p>那监听 DOM 并且更新 DOM 呢？要怎么搞？（实际上早期的 MVC 更新 DOM 的确是要自己写，所以很麻烦）</p>\n<pre><code>// 举个例子\n\nnew Controller({\n    element: &#39;.module2&#39;,\n    events: {\n        &#39;change input&#39;: &#39;onChangeInput&#39;,\n        &#39;click button&#39;: &#39;onClickButton&#39;\n    },\n    onClickButton(e) {\n        let value = this.$element.find(&#39;input&#39;).val()\n        this.render(value)\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    },\n    render(value) {\n        let $output = this.$element.find(&#39;.output&#39;)\n        if ($output.length === 0) {\n            $output = $(&#39;&lt;div class=&quot;output&quot;&gt;&lt;/div&gt;&#39;).text(value)\n            $output.appendTo(this.$element)\n        } else {\n            $output.text(value)\n        }\n    }\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/02/53534b163c052c5f0b9a494c3a11f79c.gif\" alt=\"\"></p>\n<p>然后过了一段时间之后就有了 template，在 JS 写模板。并且操作数据。<a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">http://handlebarsjs.com/</a></p>\n<pre><code>// 举个例子\n// 先修改html\n&lt;div class=&quot;module2&quot;&gt;&lt;/div&gt;\n\n// 增加 template 和 data\nnew Controller({\n    element: &#39;.module2&#39;,\n    template: `\n        &lt;input type=&quot;text&quot; name=&quot;number2&quot; value=&quot;{{output}}&quot;&gt;\n        &lt;button name=&quot;button2&quot;&gt;点我&lt;/button&gt;  \n        &lt;div class=&quot;output&quot;&gt;{{output}}&lt;/div&gt;  \n    `,\n    data: {\n        output: &#39;&#39;  // 控制数据\n    },\n    events: {\n        &#39;change input&#39;: &#39;onChangeInput&#39;,\n        &#39;click button&#39;: &#39;onClickButton&#39;\n    },\n    onClickButton(e) {\n        let value = this.$element.find(&#39;input&#39;).val()\n        this.data.output = value\n        this.render()\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }\n})\n\n// Controller\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key]\n        }\n        this.$element = $(this.element)\n        if (this.template &amp;&amp; this.render) {  // 判断是否有 template\n            this.render()\n        }\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(&#39; &#39;)\n            let eventType = parts.shift()\n            let selector = parts.join(&#39; &#39;)\n            if (typeof this.events[key] === &#39;function&#39;) {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === &#39;string&#39;) {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n    render() {\n        let html = Handlebars.compile(this.template)(this.data)  // 渲染 template 和 data\n        this.$element.html(html)\n    }\n}\n</code></pre><p>和刚刚看起来效果变化不大，但实际上用上了 template 和 data 已经很接近 vue … 啊不是，是 MVC 了 </p>\n<p><img src=\"https://us1.myximage.com/2017/12/03/5673db0242ef4494b3c9affc904f96a5.gif\" alt=\"\"></p>\n<pre><code>// 再举个例子\n// index.html 加上模板\n    &lt;script id=&quot;module3Template&quot; type=&quot;text/x-handlerbars&quot;&gt;\n        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;\n        &lt;span&gt;{{number}}&lt;/span&gt;\n        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;    \n    &lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n\n// module3.js\nnew Controller({\n    element: &#39;.module3&#39;,\n    template: &#39;#module3Template&#39;,\n    data: {\n        number: 0\n    },\n    events: {\n        &#39;click button[name=increase]&#39;: &#39;increase&#39;,\n        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;\n    },\n    increase(){\n        this.data.number += 1\n        this.render()\n    },\n    decrease(){\n        this.data.number -= 1\n        this.render()\n    }    \n})\n\n// Controller.js 的 render 修改成\n    render() {\n        let template = (this.template[0] === &#39;#&#39;) ? $(this.template).html() : this.template\n        let html = Handlebars.compile(template)(this.data)\n        this.$element.html(html)\n    }\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/03/4bf9ab6f7e4d716f90c3b9e5684a710b.gif\" alt=\"\"></p>\n<p>到这一步为止，已经实现 VC 了，视图层”（View）利用了 template 来实现，控制层”（Controller）就是 Controller.js，而数据层”（Model）就是 data，下面来举个例子</p>\n<p>因为数据层”（Model）是从服务器来的，所以刚开始要初始化</p>\n<pre><code>// 举个例子\n// 本地模拟数据 data.json\n{\n    &quot;number&quot;: 10000\n}\n\n// 用 promise 模拟数据更新\nnew Controller({\n    element: &#39;.module4&#39;,\n    template: `\n        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;\n        &lt;span&gt;{{number}}&lt;/span&gt;\n        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;\n    `,\n    data: {\n        number: 0\n    },\n    init() {\n        $.get(&#39;/data.json&#39;).then((response) =&gt; {\n            this.data = response\n            this.render()\n        })\n    },\n    events: {\n        &#39;click button[name=increase]&#39;: &#39;increase&#39;,\n        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;\n    },\n    increase() {\n        this.remoteIncrease.then(() =&gt; {\n            this.data.number += 1\n            this.render()\n        })\n    },\n    decrease() {\n        this.remoteDecrease.then(() =&gt; {\n            this.data.number -= 1\n            this.render()\n        })\n    },\n    remoteIncrease() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                resolve({\n                    number: this.number + 1\n                })\n            }, 500)\n        })\n    },\n    remoteDecrease() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                resolve({\n                    number: this.number - 1\n                })\n            }, 500)\n        })\n    }\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/03/7d92010a76b32fcc2c0d222194eec2fa.gif\" alt=\"\"></p>\n<p>再优化一下代码把数据层”（Model）抽离出来</p>\n<pre><code>let model = {\n    data: {\n        number: 0\n    },\n    get() {\n        return $.get(&#39;/data.json&#39;).then((response) =&gt; {\n            this.data = response\n            return this.data\n        })\n    },\n    increase() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                this.data.number += 1\n                resolve(this.data)\n            }, 500)\n        })\n    },\n    decrease() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                this.data.number -= 1\n                resolve(this.data)\n            }, 500)\n        })\n    }\n}\n\n\nnew Controller({\n    element: &#39;.module4&#39;,\n    template: `\n        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;\n        &lt;span&gt;{{number}}&lt;/span&gt;\n        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;\n    `,\n    model: model,\n    events: {\n        &#39;click button[name=increase]&#39;: &#39;increase&#39;,\n        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;\n    },\n    init() {\n        this.model.get().then(() =&gt; {\n            this.render()\n        })\n    },\n    increase() {\n        this.model.increase().then(() =&gt; {\n            this.render()\n        })\n    },\n    decrease() {\n        this.model.decrease().then(() =&gt; {\n            this.render()\n        })\n    }\n})\n</code></pre><p>这样的好处就很明显了，操作永远只是数据，不会操作到 DOM，就是调一下 model 操作一下 view，以上，就实现了MVC 的全部功能 </p>\n<h2 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h2><p>Object.defineProperty 可以对属性有读写的控制</p>\n<pre><code>// 举个例子\nlet frankie = {\n    _data: {\n        age: 18,\n        name: &#39;frankie&#39;\n    }\n}\n\nObject.defineProperty(frankie, &#39;age&#39;, {\n    get: () =&gt; {\n        console.log(&#39;frankie.age 被读取了&#39;)\n        return frankie._data.age\n    },\n    set: xxx =&gt; {\n        console.log(&#39;frankie.age 被设置了&#39;)\n        frankie._data.age = xxx\n    }\n})\n\nfrankie.age = 19  // frankie.age 被设置了\nfrankie.age = 20  // frankie.age 被设置了\nfrankie.age = 21  // frankie.age 被设置了\nconsole.log(frankie.age)  // frankie.age 被读取了 21\n</code></pre><p>通过以上代码可以做到监听 input value 的变化去改内存里对象的变化，也可以改 <code>frankie.age</code> 来改页面上的数值</p>\n<p>例子 =&gt; <a href=\"https://jsbin.com/zawapumihe/1/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h3 id=\"那-MVVM-到底是个啥玩意呢？\"><a href=\"#那-MVVM-到底是个啥玩意呢？\" class=\"headerlink\" title=\"那 MVVM 到底是个啥玩意呢？\"></a>那 MVVM 到底是个啥玩意呢？</h3><p>以上面这个例子为例：</p>\n<ul>\n<li>M -&gt; frankie (这个是 JS 内存里的)</li>\n<li>VM -&gt; 能让 V 和 M 互相沟通的东西，当 M 变了就通知 V 变，当 V 变了就通知 M 变。（两头互相监听互相变）</li>\n<li>V -&gt; HTML / CSS (内容 / 表现层)</li>\n</ul>\n<h3 id=\"MVVM-的缺点\"><a href=\"#MVVM-的缺点\" class=\"headerlink\" title=\"MVVM 的缺点\"></a>MVVM 的缺点</h3><p>第一点要注意的是 <code>Object.defineProperty</code> 里的 <code>get</code> 和 <code>set</code> 是同步还是异步（改了之后马上更新 input？改了之后在下一次任务的时候更新 input？）</p>\n<p><img src=\"https://us1.myximage.com/2017/12/05/b34439946bad220c9faf564fdbe2f080.png\" alt=\"\"></p>\n<p><img src=\"https://us1.myximage.com/2017/12/05/d8b5e5b60652215f6172f7e54a411110.png\" alt=\"yin\"></p>\n<p>经过上面的测试是同步的</p>\n<p>第二点是 DOM 的操作也是同步的（DOM 不存在异步过程）</p>\n<p>这样会有一个问题，假如 view 层加了一个 input 就不能增加效果（以为因为新的 VM 没有 set 这个 input）。例子 =&gt; <a href=\"https://jsbin.com/cibunafuro/1/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<p>所以 MVVM 的问题就在这里，只能监听已经存在的 key，新加的 key 没法监听</p>\n<p>解决方法还是有的，提供一个 API 为新加的 key 服务。例子 =&gt; <a href=\"https://jsbin.com/zagacilade/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<p>JS 操作 DOM 很慢，DOM 操作 JS 是很慢的</p>\n<p>因为操作是同步的，所以有一个问题是，会很卡。但是 vue.js 很好的解决了这一个问题。（再也不用操作 DOM，从此     jQuery 退出历史舞台）</p>\n<p><a href=\"https://jsbin.com/jeqaqoyeyi/2/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">vue.js 的 Hello world</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MVC-MVVM-是什么\"><a href=\"#MVC-MVVM-是什么\" class=\"headerlink\" title=\"MVC - MVVM 是什么\"></a>MVC - MVVM 是什么</h1><p><a href=\"http://www.ruanyifeng.com/blog/2007/11/mvc.html\" target=\"_blank\" rel=\"noopener\">谈谈MVC模式 - 阮一峰</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"noopener\">MVC，MVP 和 MVVM 的图示 - 阮一峰</a></p>\n<p><a href=\"http://javascript.ruanyifeng.com/advanced/backbonejs.html\" target=\"_blank\" rel=\"noopener\">MVC框架与Backbone.js - JavaScript 标准参考教程（alpha） - 阮一峰</a></p>\n<p>基于MVC的JavaScript Web富应用开发 - <a href=\"https://pan.baidu.com/s/1qY9hJmG\" target=\"_blank\" rel=\"noopener\">网盘</a> 密码是 y9jv</p>\n<p>以下例子代码的仓库在 <a href=\"https://github.com/FRANKIETANG/mvc-mvvm-example\" target=\"_blank\" rel=\"noopener\">https://github.com/FRANKIETANG/mvc-mvvm-example</a> </p>\n<p>代码变动看 <a href=\"https://github.com/FRANKIETANG/mvc-mvvm-example/commits/master\" target=\"_blank\" rel=\"noopener\">commit</a></p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>如果要先实现一个 MVC ，首先要实现的是中间的那一层 Controller</p>\n<p>对于 Controller 的作用，绑事件 / 调用方法可以用对象的形式 / 监听 DOM 并且更新 DOM / 操作数据</p>\n<p>下面实现一个 MVC 的轮子吧</p>\n<pre><code>// 举个例子\n\n// index.html 核心代码\n    &lt;div class=&quot;modules&quot;&gt;\n        &lt;div class=&quot;module1&quot;&gt;\n            &lt;input type=&quot;text&quot; name=&quot;number1&quot;&gt;\n            &lt;button name=&quot;button1&quot;&gt;点我&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n// index.js\nimport &#39;./module1&#39;\n\n// Controller.js\nimport $ from &#39;jquery&#39;\n\nclass Controller {\n    constructor(options) {\n        this.$element = $(options.element)\n        this.events = options.events\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(&#39; &#39;)\n            let eventType = parts.shift()\n            let selector = parts.join(&#39; &#39;)\n            this.$element.on(eventType, selector, this.events[key])\n        }\n    }\n}\n\nexport default Controller\n\n// module1.js\nimport Controller from &#39;./Controller&#39;\n\nnew Controller({\n    element: &#39;.module1&#39;,\n    events: {\n        &#39;change input&#39;: e =&gt; {\n            console.log(&#39;change1&#39;)\n        },\n        &#39;click button&#39;: e =&gt; {\n            console.log(&#39;click1&#39;)\n        }\n    }\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/02/90db865271941bd9a64075d1a667d60e.gif\" alt=\"\"></p>\n<p>比如上面这个例子就是当需要 Controller 的时候只需要写上你要绑的元素，要做的事件就好。至于实现方法全部交给 Controller 去处理。</p>\n<p>但是上面的例子还是很简单，假如函数逻辑比较复杂该怎么做？可以用对象的形式调用方法。</p>\n<pre><code>// 举个例子\n\nnew Controller({\n    element: &#39;.module1&#39;,\n    events: {\n        &#39;change input&#39;: &#39;onChangeInput&#39;,    \n        &#39;click button&#39;: &#39;addToCart&#39;\n    },\n    addToCart() {\n        let value = this.$element.find(&#39;input&#39;).val()\n        this.remoteAddCart(value).then(() =&gt; { // 假如发送到服务器让服务器知道你已经把什么放到购物车了，下次登录的时候就可以获取数据。\n            this.showAnimation() // 加入到购物车的动画\n        })  \n    },\n    remoteAddCart() {\n        console.log(&#39;远程请求&#39;)\n        return Promise.resolve(1)\n    },\n    showAnimation(){\n        console.log(&#39;展示添加到购物车的动画&#39;)\n    }\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }    \n})\n\n// 修改一下 Controller\n\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key] // 把用户传的东西都放到 json\n        }\n        this.$element = $(this.element)\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(&#39; &#39;)\n            let eventType = parts.shift()\n            let selector = parts.join(&#39; &#39;)\n            if (typeof this.events[key] === &#39;function&#39;) {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === &#39;string&#39;) {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n}\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/02/9bee130d43526daa3c4794d75047aaa0.gif\" alt=\"\"></p>\n<p>那监听 DOM 并且更新 DOM 呢？要怎么搞？（实际上早期的 MVC 更新 DOM 的确是要自己写，所以很麻烦）</p>\n<pre><code>// 举个例子\n\nnew Controller({\n    element: &#39;.module2&#39;,\n    events: {\n        &#39;change input&#39;: &#39;onChangeInput&#39;,\n        &#39;click button&#39;: &#39;onClickButton&#39;\n    },\n    onClickButton(e) {\n        let value = this.$element.find(&#39;input&#39;).val()\n        this.render(value)\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    },\n    render(value) {\n        let $output = this.$element.find(&#39;.output&#39;)\n        if ($output.length === 0) {\n            $output = $(&#39;&lt;div class=&quot;output&quot;&gt;&lt;/div&gt;&#39;).text(value)\n            $output.appendTo(this.$element)\n        } else {\n            $output.text(value)\n        }\n    }\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/02/53534b163c052c5f0b9a494c3a11f79c.gif\" alt=\"\"></p>\n<p>然后过了一段时间之后就有了 template，在 JS 写模板。并且操作数据。<a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">http://handlebarsjs.com/</a></p>\n<pre><code>// 举个例子\n// 先修改html\n&lt;div class=&quot;module2&quot;&gt;&lt;/div&gt;\n\n// 增加 template 和 data\nnew Controller({\n    element: &#39;.module2&#39;,\n    template: `\n        &lt;input type=&quot;text&quot; name=&quot;number2&quot; value=&quot;{{output}}&quot;&gt;\n        &lt;button name=&quot;button2&quot;&gt;点我&lt;/button&gt;  \n        &lt;div class=&quot;output&quot;&gt;{{output}}&lt;/div&gt;  \n    `,\n    data: {\n        output: &#39;&#39;  // 控制数据\n    },\n    events: {\n        &#39;change input&#39;: &#39;onChangeInput&#39;,\n        &#39;click button&#39;: &#39;onClickButton&#39;\n    },\n    onClickButton(e) {\n        let value = this.$element.find(&#39;input&#39;).val()\n        this.data.output = value\n        this.render()\n    },\n    onChangeInput(e) {\n        let input = e.currentTarget\n        console.log(input.value)\n    }\n})\n\n// Controller\nclass Controller {\n    constructor(options) {\n        for (let key in options) {\n            this[key] = options[key]\n        }\n        this.$element = $(this.element)\n        if (this.template &amp;&amp; this.render) {  // 判断是否有 template\n            this.render()\n        }\n        this.bindEvents()\n    }\n    bindEvents() {\n        for (let key in this.events) {\n            let parts = key.split(&#39; &#39;)\n            let eventType = parts.shift()\n            let selector = parts.join(&#39; &#39;)\n            if (typeof this.events[key] === &#39;function&#39;) {\n                this.$element.on(eventType, selector, this.events[key])\n            } else if (typeof this.events[key] === &#39;string&#39;) {\n                let methodName = this.events[key]\n                this.$element.on(eventType, selector, this[methodName].bind(this))\n            }\n        }\n    }\n    render() {\n        let html = Handlebars.compile(this.template)(this.data)  // 渲染 template 和 data\n        this.$element.html(html)\n    }\n}\n</code></pre><p>和刚刚看起来效果变化不大，但实际上用上了 template 和 data 已经很接近 vue … 啊不是，是 MVC 了 </p>\n<p><img src=\"https://us1.myximage.com/2017/12/03/5673db0242ef4494b3c9affc904f96a5.gif\" alt=\"\"></p>\n<pre><code>// 再举个例子\n// index.html 加上模板\n    &lt;script id=&quot;module3Template&quot; type=&quot;text/x-handlerbars&quot;&gt;\n        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;\n        &lt;span&gt;{{number}}&lt;/span&gt;\n        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;    \n    &lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n\n// module3.js\nnew Controller({\n    element: &#39;.module3&#39;,\n    template: &#39;#module3Template&#39;,\n    data: {\n        number: 0\n    },\n    events: {\n        &#39;click button[name=increase]&#39;: &#39;increase&#39;,\n        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;\n    },\n    increase(){\n        this.data.number += 1\n        this.render()\n    },\n    decrease(){\n        this.data.number -= 1\n        this.render()\n    }    \n})\n\n// Controller.js 的 render 修改成\n    render() {\n        let template = (this.template[0] === &#39;#&#39;) ? $(this.template).html() : this.template\n        let html = Handlebars.compile(template)(this.data)\n        this.$element.html(html)\n    }\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/03/4bf9ab6f7e4d716f90c3b9e5684a710b.gif\" alt=\"\"></p>\n<p>到这一步为止，已经实现 VC 了，视图层”（View）利用了 template 来实现，控制层”（Controller）就是 Controller.js，而数据层”（Model）就是 data，下面来举个例子</p>\n<p>因为数据层”（Model）是从服务器来的，所以刚开始要初始化</p>\n<pre><code>// 举个例子\n// 本地模拟数据 data.json\n{\n    &quot;number&quot;: 10000\n}\n\n// 用 promise 模拟数据更新\nnew Controller({\n    element: &#39;.module4&#39;,\n    template: `\n        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;\n        &lt;span&gt;{{number}}&lt;/span&gt;\n        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;\n    `,\n    data: {\n        number: 0\n    },\n    init() {\n        $.get(&#39;/data.json&#39;).then((response) =&gt; {\n            this.data = response\n            this.render()\n        })\n    },\n    events: {\n        &#39;click button[name=increase]&#39;: &#39;increase&#39;,\n        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;\n    },\n    increase() {\n        this.remoteIncrease.then(() =&gt; {\n            this.data.number += 1\n            this.render()\n        })\n    },\n    decrease() {\n        this.remoteDecrease.then(() =&gt; {\n            this.data.number -= 1\n            this.render()\n        })\n    },\n    remoteIncrease() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                resolve({\n                    number: this.number + 1\n                })\n            }, 500)\n        })\n    },\n    remoteDecrease() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                resolve({\n                    number: this.number - 1\n                })\n            }, 500)\n        })\n    }\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/03/7d92010a76b32fcc2c0d222194eec2fa.gif\" alt=\"\"></p>\n<p>再优化一下代码把数据层”（Model）抽离出来</p>\n<pre><code>let model = {\n    data: {\n        number: 0\n    },\n    get() {\n        return $.get(&#39;/data.json&#39;).then((response) =&gt; {\n            this.data = response\n            return this.data\n        })\n    },\n    increase() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                this.data.number += 1\n                resolve(this.data)\n            }, 500)\n        })\n    },\n    decrease() {\n        return new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&#39;500ms&#39;)\n                this.data.number -= 1\n                resolve(this.data)\n            }, 500)\n        })\n    }\n}\n\n\nnew Controller({\n    element: &#39;.module4&#39;,\n    template: `\n        &lt;button name=&quot;decrease&quot;&gt; - &lt;/button&gt;\n        &lt;span&gt;{{number}}&lt;/span&gt;\n        &lt;button name=&quot;increase&quot;&gt; + &lt;/button&gt;\n    `,\n    model: model,\n    events: {\n        &#39;click button[name=increase]&#39;: &#39;increase&#39;,\n        &#39;click button[name=decrease]&#39;: &#39;decrease&#39;\n    },\n    init() {\n        this.model.get().then(() =&gt; {\n            this.render()\n        })\n    },\n    increase() {\n        this.model.increase().then(() =&gt; {\n            this.render()\n        })\n    },\n    decrease() {\n        this.model.decrease().then(() =&gt; {\n            this.render()\n        })\n    }\n})\n</code></pre><p>这样的好处就很明显了，操作永远只是数据，不会操作到 DOM，就是调一下 model 操作一下 view，以上，就实现了MVC 的全部功能 </p>\n<h2 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h2><p>Object.defineProperty 可以对属性有读写的控制</p>\n<pre><code>// 举个例子\nlet frankie = {\n    _data: {\n        age: 18,\n        name: &#39;frankie&#39;\n    }\n}\n\nObject.defineProperty(frankie, &#39;age&#39;, {\n    get: () =&gt; {\n        console.log(&#39;frankie.age 被读取了&#39;)\n        return frankie._data.age\n    },\n    set: xxx =&gt; {\n        console.log(&#39;frankie.age 被设置了&#39;)\n        frankie._data.age = xxx\n    }\n})\n\nfrankie.age = 19  // frankie.age 被设置了\nfrankie.age = 20  // frankie.age 被设置了\nfrankie.age = 21  // frankie.age 被设置了\nconsole.log(frankie.age)  // frankie.age 被读取了 21\n</code></pre><p>通过以上代码可以做到监听 input value 的变化去改内存里对象的变化，也可以改 <code>frankie.age</code> 来改页面上的数值</p>\n<p>例子 =&gt; <a href=\"https://jsbin.com/zawapumihe/1/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h3 id=\"那-MVVM-到底是个啥玩意呢？\"><a href=\"#那-MVVM-到底是个啥玩意呢？\" class=\"headerlink\" title=\"那 MVVM 到底是个啥玩意呢？\"></a>那 MVVM 到底是个啥玩意呢？</h3><p>以上面这个例子为例：</p>\n<ul>\n<li>M -&gt; frankie (这个是 JS 内存里的)</li>\n<li>VM -&gt; 能让 V 和 M 互相沟通的东西，当 M 变了就通知 V 变，当 V 变了就通知 M 变。（两头互相监听互相变）</li>\n<li>V -&gt; HTML / CSS (内容 / 表现层)</li>\n</ul>\n<h3 id=\"MVVM-的缺点\"><a href=\"#MVVM-的缺点\" class=\"headerlink\" title=\"MVVM 的缺点\"></a>MVVM 的缺点</h3><p>第一点要注意的是 <code>Object.defineProperty</code> 里的 <code>get</code> 和 <code>set</code> 是同步还是异步（改了之后马上更新 input？改了之后在下一次任务的时候更新 input？）</p>\n<p><img src=\"https://us1.myximage.com/2017/12/05/b34439946bad220c9faf564fdbe2f080.png\" alt=\"\"></p>\n<p><img src=\"https://us1.myximage.com/2017/12/05/d8b5e5b60652215f6172f7e54a411110.png\" alt=\"yin\"></p>\n<p>经过上面的测试是同步的</p>\n<p>第二点是 DOM 的操作也是同步的（DOM 不存在异步过程）</p>\n<p>这样会有一个问题，假如 view 层加了一个 input 就不能增加效果（以为因为新的 VM 没有 set 这个 input）。例子 =&gt; <a href=\"https://jsbin.com/cibunafuro/1/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<p>所以 MVVM 的问题就在这里，只能监听已经存在的 key，新加的 key 没法监听</p>\n<p>解决方法还是有的，提供一个 API 为新加的 key 服务。例子 =&gt; <a href=\"https://jsbin.com/zagacilade/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<p>JS 操作 DOM 很慢，DOM 操作 JS 是很慢的</p>\n<p>因为操作是同步的，所以有一个问题是，会很卡。但是 vue.js 很好的解决了这一个问题。（再也不用操作 DOM，从此     jQuery 退出历史舞台）</p>\n<p><a href=\"https://jsbin.com/jeqaqoyeyi/2/edit?html,js,output\" target=\"_blank\" rel=\"noopener\">vue.js 的 Hello world</a></p>\n"},{"title":"deepin shadowsocks-qt5 全局翻了个墙","date":"2017-10-24T16:58:53.000Z","_content":"# deepin shadowsocks-qt5 全局翻了个墙\n\n最近真的是非常时期 `git push` `git pull` `git clone` 全部显示了\n\nConnection closed by 192.30.255.113 port 22\n\n以下是解决办法\n\n```\nsudo apt-get install shadowsocks-qt5\nsudo apt-get install proxychains\n// 配置 /etc/proxychains.conf\n// 不要 socks4 127.0.0.1 9095 加上\nsocks5 127.0.0.1 1080\n// 然后在每一条命令都加上\nproxychains\n```\n\n关于怎么配 shadowsocks-qt5 网上一搜一大把，祝各位看到这篇文章能早日肉身翻墙吧。","source":"_posts/deepin shadowsocks-qt5 全局翻了个墙.md","raw":"---\ntitle: deepin shadowsocks-qt5 全局翻了个墙\ndate: 2017-10-25 00:58:53\ntags: [fq]\n---\n# deepin shadowsocks-qt5 全局翻了个墙\n\n最近真的是非常时期 `git push` `git pull` `git clone` 全部显示了\n\nConnection closed by 192.30.255.113 port 22\n\n以下是解决办法\n\n```\nsudo apt-get install shadowsocks-qt5\nsudo apt-get install proxychains\n// 配置 /etc/proxychains.conf\n// 不要 socks4 127.0.0.1 9095 加上\nsocks5 127.0.0.1 1080\n// 然后在每一条命令都加上\nproxychains\n```\n\n关于怎么配 shadowsocks-qt5 网上一搜一大把，祝各位看到这篇文章能早日肉身翻墙吧。","slug":"deepin shadowsocks-qt5 全局翻了个墙","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d810007f1xh6vx6phzl","content":"<h1 id=\"deepin-shadowsocks-qt5-全局翻了个墙\"><a href=\"#deepin-shadowsocks-qt5-全局翻了个墙\" class=\"headerlink\" title=\"deepin shadowsocks-qt5 全局翻了个墙\"></a>deepin shadowsocks-qt5 全局翻了个墙</h1><p>最近真的是非常时期 <code>git push</code> <code>git pull</code> <code>git clone</code> 全部显示了</p>\n<p>Connection closed by 192.30.255.113 port 22</p>\n<p>以下是解决办法</p>\n<pre><code>sudo apt-get install shadowsocks-qt5\nsudo apt-get install proxychains\n// 配置 /etc/proxychains.conf\n// 不要 socks4 127.0.0.1 9095 加上\nsocks5 127.0.0.1 1080\n// 然后在每一条命令都加上\nproxychains\n</code></pre><p>关于怎么配 shadowsocks-qt5 网上一搜一大把，祝各位看到这篇文章能早日肉身翻墙吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"deepin-shadowsocks-qt5-全局翻了个墙\"><a href=\"#deepin-shadowsocks-qt5-全局翻了个墙\" class=\"headerlink\" title=\"deepin shadowsocks-qt5 全局翻了个墙\"></a>deepin shadowsocks-qt5 全局翻了个墙</h1><p>最近真的是非常时期 <code>git push</code> <code>git pull</code> <code>git clone</code> 全部显示了</p>\n<p>Connection closed by 192.30.255.113 port 22</p>\n<p>以下是解决办法</p>\n<pre><code>sudo apt-get install shadowsocks-qt5\nsudo apt-get install proxychains\n// 配置 /etc/proxychains.conf\n// 不要 socks4 127.0.0.1 9095 加上\nsocks5 127.0.0.1 1080\n// 然后在每一条命令都加上\nproxychains\n</code></pre><p>关于怎么配 shadowsocks-qt5 网上一搜一大把，祝各位看到这篇文章能早日肉身翻墙吧。</p>\n"},{"title":"做一个音乐 Webapp 的流程","date":"2017-10-15T04:41:39.000Z","_content":"# 做一个音乐 Webapp\n\n超低仿 Vanilla JS 写的 QQ 音乐\n\n[预览](https://frankietang.github.io/qq-music/index.html) | [源码](https://github.com/FRANKIETANG/qq-music)\n\n那么乱的笔记估计就只有我才能看懂\n\n- 按需求制定一下接口\n- 功能拆分成一个一个模块（首页 + 推荐 / 排行榜 / 搜索 / 播放器界面）\n- 技术选型（CSS 预处理器 / JS 库）\n\n## 怎么在网页抄数据\n\n![](https://i.loli.net/2017/09/22/59c4990ac3f33.png)\n\n## 伪造请求\n\n![](https://i.loli.net/2017/09/23/59c5f31f6601d.png)\n\n```\ncurl 'https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&_=1507564199109' -H 'pragma: no-cache' -H 'origin: https://m.y.qq.com' -H 'accept-encoding: gzip, deflate, br' -H 'accept-language: zh-CN,zh;q=0.8' -H 'user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1' -H 'accept: application/json' -H 'cache-control: no-cache' -H 'authority: c.y.qq.com' -H 'cookie: pgv_pvi=1576136704; pgv_si=s2924205056; RK=QfWPx2jbHN; tvfe_boss_uuid=bdd869ba21d19595; o_cookie=350558468; ts_refer=ADTAGmyqq; ptui_loginuin=350558468; ptisp=ctc; ptcz=bde020f9828475fc3e22f0fc78ba0024b7a615fad803b91694a069a02cefdb0b; pt2gguin=o0350558468; LW_sid=11S540S7L3v4m1k4L632K6r1m3; LW_uid=g1l53027M384N1y4K6Z2v6d1L4; eas_sid=H1Y5t0B7H3o461B4f692f682Y2; ts_uid=2559117424; qqmusic_fromtag=10; checkmask=3; yqq_stat=0; ts_refer=www.google.ca/; ts_uid=2559117424; pgv_info=ssid=s8871552255; pgv_pvid=2779555285' -H 'referer: https://m.y.qq.com/' --compressed\n```\n\n`npm install express --save` \n\n`npm install request --save` `npm install request-promise --save`（发请求的库）\n\n[request-promise](https://github.com/request/request-promise)\n\n![](https://i.loli.net/2017/09/23/59c60819cabdf.png)\n\n`npm install -g nodemon`\n\n[nodemon](https://nodemon.io/)\n\n我去...用 nodemon 不能用 `import XXX from 'XXX'` 要用 `var XXX = require('XXX')`\n\n![](https://i.loli.net/2017/09/23/59c60b0dcf706.png)\n\n我去...原来还有 n 模块这玩意...\n\n[n](https://www.npmjs.com/package/n) 接受了这个设定还是挺不错的...\n\n```\n//qq-server 代码\nconst express = require('express')\nconst request = require('request-promise')\n\nconst app = express()\n\napp.get('/', async (req, res) => {\n    const url = `https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: {\n                    'accept': 'application/json',\n                    'authority': 'c.y.qq.com',\n                    'origin': 'https://m.y.qq.com',\n                    'referer': 'https://m.y.qq.com/',\n                    'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1'\n                }\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }\n})\n\napp.listen(4000)\n```\n\n运行 `nodemon qq-server.js` 打开 localhost:4000\n\n![](https://i.loli.net/2017/09/23/59c6163e42f5b.png)\n\n开心 终于不用跨域请求了 也不用自己去抄数据了hhhh 新技能 get\n\n再分析一个 API 接口\n\n```\nhttps://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&w=%E6%9D%8E%E8%8D%A3%E6%B5%A9&zhidaqu=1&catZhida=1&t=0&flag=1&ie=utf-8&sem=1&aggr=0&perpage=20&n=20&p=1&remoteplace=txt.mqq.all&_=1506154238572\n```\n\n`w=%E6%9D%8E%E8%8D%A3%E6%B5%A9` 这个是李荣浩\n\n![](https://i.loli.net/2017/09/23/59c618bbb79d2.png)\n\n```\n//search部分的核心代码\napp.get('/search', async(req,res)=>{\n    const { keyword, page = 1 } = req.query\n    const url=`https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&w=${encodeURIComponent(keyword)}&zhidaqu=1&catZhida=1&t=0&flag=1&ie=utf-8&sem=1&aggr=0&perpage=20&n=20&p=${page}&remoteplace=txt.mqq.all&_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: HEADERS\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }    \n})\n```\n\n![](https://i.loli.net/2017/09/23/59c6200b767cb.png)\n\n所有参数都放在 ? 后面 用 & 链接\n\n你看真的成了\n\n那就是说...我自己做了一个 API ...\n\n让这个 API 跨域 `npm install cors --save`\n\nhttps://zeit.co/now 把做出来的 server.js 上传就可以用了\n\n## 模块化\n\nimport export\n\n## 音乐歌词 API\n\n![](https://i.loli.net/2017/09/25/59c8db302e050.png)\n\n点击 network 看 JS\n\n把这个地址复制，在 console 用 `fetch()` 跑一遍\n\n![](https://i.loli.net/2017/09/25/59c8dbc2a1f79.png)\n\n再回到 network 看 XHR\n\n![](https://i.loli.net/2017/09/25/59c8dc2dd23db.png)\n\n写一个正则，把 callback 去掉，括号去掉。\n\n`MusicJsonCallback({...}).replace(/MusicJsonCallback\\((.*)\\)/, '$1')`\n\n`let json = {...} `\n\n`JSON.parse(json)`\n\n`json.lyric`\n\n`let div = document.createElement('div')`\n\n`div.innerHTML = json.lyric`\n\n`div.firstChild.nodeValue`\n\n## hash\n\n单页面保存数据的方式\n\n就是当你打开这个页面就可以直接转跳到那首歌的入口\n\n`href=\"#player?artist=${artist}&songid=${song.songid}&songname=${song.songname}&albummid=${song.albummid}&duration=${song.interval}\"`\n\n\n## 知识点\n\nfetch / await async\n\n`[].slice.call()`\n\nIntersectionObserver\n\n`map` 和 `forEach` 的区别\n\n懒加载 / 曝光加载\n\n正则\n\n```\n'View frankietang on GitHub'.match(/View (\\w+) on GitHub/)[1]\n'frankietang'\n```\n\ncss 里面的 `filter:blur(15px)` 毛玻璃效果\n\n进度条可以先移到最边边，然后慢慢的往右移。\n\n`max-height: calc(100% - 205px);`\n\n`location.hash` 点击时 url 的变化\n\n![](https://ooo.0o0.ooo/2017/09/28/59ccf1d9533c4.png)\n\nMVC -- Model View Controller\n\nautoprefixer-cli\n\n[NonDocumentTypeChildNode.previousElementSibling](https://developer.mozilla.org/zh-CN/docs/Web/API/NonDocumentTypeChildNode/previousElementSibling)","source":"_posts/做一个音乐 Webapp.md","raw":"---\ntitle: 做一个音乐 Webapp 的流程\ndate: 2017-10-15 12:41:39\ntags: [JavaScript]\n---\n# 做一个音乐 Webapp\n\n超低仿 Vanilla JS 写的 QQ 音乐\n\n[预览](https://frankietang.github.io/qq-music/index.html) | [源码](https://github.com/FRANKIETANG/qq-music)\n\n那么乱的笔记估计就只有我才能看懂\n\n- 按需求制定一下接口\n- 功能拆分成一个一个模块（首页 + 推荐 / 排行榜 / 搜索 / 播放器界面）\n- 技术选型（CSS 预处理器 / JS 库）\n\n## 怎么在网页抄数据\n\n![](https://i.loli.net/2017/09/22/59c4990ac3f33.png)\n\n## 伪造请求\n\n![](https://i.loli.net/2017/09/23/59c5f31f6601d.png)\n\n```\ncurl 'https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&_=1507564199109' -H 'pragma: no-cache' -H 'origin: https://m.y.qq.com' -H 'accept-encoding: gzip, deflate, br' -H 'accept-language: zh-CN,zh;q=0.8' -H 'user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1' -H 'accept: application/json' -H 'cache-control: no-cache' -H 'authority: c.y.qq.com' -H 'cookie: pgv_pvi=1576136704; pgv_si=s2924205056; RK=QfWPx2jbHN; tvfe_boss_uuid=bdd869ba21d19595; o_cookie=350558468; ts_refer=ADTAGmyqq; ptui_loginuin=350558468; ptisp=ctc; ptcz=bde020f9828475fc3e22f0fc78ba0024b7a615fad803b91694a069a02cefdb0b; pt2gguin=o0350558468; LW_sid=11S540S7L3v4m1k4L632K6r1m3; LW_uid=g1l53027M384N1y4K6Z2v6d1L4; eas_sid=H1Y5t0B7H3o461B4f692f682Y2; ts_uid=2559117424; qqmusic_fromtag=10; checkmask=3; yqq_stat=0; ts_refer=www.google.ca/; ts_uid=2559117424; pgv_info=ssid=s8871552255; pgv_pvid=2779555285' -H 'referer: https://m.y.qq.com/' --compressed\n```\n\n`npm install express --save` \n\n`npm install request --save` `npm install request-promise --save`（发请求的库）\n\n[request-promise](https://github.com/request/request-promise)\n\n![](https://i.loli.net/2017/09/23/59c60819cabdf.png)\n\n`npm install -g nodemon`\n\n[nodemon](https://nodemon.io/)\n\n我去...用 nodemon 不能用 `import XXX from 'XXX'` 要用 `var XXX = require('XXX')`\n\n![](https://i.loli.net/2017/09/23/59c60b0dcf706.png)\n\n我去...原来还有 n 模块这玩意...\n\n[n](https://www.npmjs.com/package/n) 接受了这个设定还是挺不错的...\n\n```\n//qq-server 代码\nconst express = require('express')\nconst request = require('request-promise')\n\nconst app = express()\n\napp.get('/', async (req, res) => {\n    const url = `https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: {\n                    'accept': 'application/json',\n                    'authority': 'c.y.qq.com',\n                    'origin': 'https://m.y.qq.com',\n                    'referer': 'https://m.y.qq.com/',\n                    'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1'\n                }\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }\n})\n\napp.listen(4000)\n```\n\n运行 `nodemon qq-server.js` 打开 localhost:4000\n\n![](https://i.loli.net/2017/09/23/59c6163e42f5b.png)\n\n开心 终于不用跨域请求了 也不用自己去抄数据了hhhh 新技能 get\n\n再分析一个 API 接口\n\n```\nhttps://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&w=%E6%9D%8E%E8%8D%A3%E6%B5%A9&zhidaqu=1&catZhida=1&t=0&flag=1&ie=utf-8&sem=1&aggr=0&perpage=20&n=20&p=1&remoteplace=txt.mqq.all&_=1506154238572\n```\n\n`w=%E6%9D%8E%E8%8D%A3%E6%B5%A9` 这个是李荣浩\n\n![](https://i.loli.net/2017/09/23/59c618bbb79d2.png)\n\n```\n//search部分的核心代码\napp.get('/search', async(req,res)=>{\n    const { keyword, page = 1 } = req.query\n    const url=`https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&uin=0&format=json&inCharset=utf-8&outCharset=utf-8&notice=0&platform=h5&needNewCode=1&w=${encodeURIComponent(keyword)}&zhidaqu=1&catZhida=1&t=0&flag=1&ie=utf-8&sem=1&aggr=0&perpage=20&n=20&p=${page}&remoteplace=txt.mqq.all&_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: HEADERS\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }    \n})\n```\n\n![](https://i.loli.net/2017/09/23/59c6200b767cb.png)\n\n所有参数都放在 ? 后面 用 & 链接\n\n你看真的成了\n\n那就是说...我自己做了一个 API ...\n\n让这个 API 跨域 `npm install cors --save`\n\nhttps://zeit.co/now 把做出来的 server.js 上传就可以用了\n\n## 模块化\n\nimport export\n\n## 音乐歌词 API\n\n![](https://i.loli.net/2017/09/25/59c8db302e050.png)\n\n点击 network 看 JS\n\n把这个地址复制，在 console 用 `fetch()` 跑一遍\n\n![](https://i.loli.net/2017/09/25/59c8dbc2a1f79.png)\n\n再回到 network 看 XHR\n\n![](https://i.loli.net/2017/09/25/59c8dc2dd23db.png)\n\n写一个正则，把 callback 去掉，括号去掉。\n\n`MusicJsonCallback({...}).replace(/MusicJsonCallback\\((.*)\\)/, '$1')`\n\n`let json = {...} `\n\n`JSON.parse(json)`\n\n`json.lyric`\n\n`let div = document.createElement('div')`\n\n`div.innerHTML = json.lyric`\n\n`div.firstChild.nodeValue`\n\n## hash\n\n单页面保存数据的方式\n\n就是当你打开这个页面就可以直接转跳到那首歌的入口\n\n`href=\"#player?artist=${artist}&songid=${song.songid}&songname=${song.songname}&albummid=${song.albummid}&duration=${song.interval}\"`\n\n\n## 知识点\n\nfetch / await async\n\n`[].slice.call()`\n\nIntersectionObserver\n\n`map` 和 `forEach` 的区别\n\n懒加载 / 曝光加载\n\n正则\n\n```\n'View frankietang on GitHub'.match(/View (\\w+) on GitHub/)[1]\n'frankietang'\n```\n\ncss 里面的 `filter:blur(15px)` 毛玻璃效果\n\n进度条可以先移到最边边，然后慢慢的往右移。\n\n`max-height: calc(100% - 205px);`\n\n`location.hash` 点击时 url 的变化\n\n![](https://ooo.0o0.ooo/2017/09/28/59ccf1d9533c4.png)\n\nMVC -- Model View Controller\n\nautoprefixer-cli\n\n[NonDocumentTypeChildNode.previousElementSibling](https://developer.mozilla.org/zh-CN/docs/Web/API/NonDocumentTypeChildNode/previousElementSibling)","slug":"做一个音乐 Webapp","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d840008f1xhjzmc6k3w","content":"<h1 id=\"做一个音乐-Webapp\"><a href=\"#做一个音乐-Webapp\" class=\"headerlink\" title=\"做一个音乐 Webapp\"></a>做一个音乐 Webapp</h1><p>超低仿 Vanilla JS 写的 QQ 音乐</p>\n<p><a href=\"https://frankietang.github.io/qq-music/index.html\" target=\"_blank\" rel=\"noopener\">预览</a> | <a href=\"https://github.com/FRANKIETANG/qq-music\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<p>那么乱的笔记估计就只有我才能看懂</p>\n<ul>\n<li>按需求制定一下接口</li>\n<li>功能拆分成一个一个模块（首页 + 推荐 / 排行榜 / 搜索 / 播放器界面）</li>\n<li>技术选型（CSS 预处理器 / JS 库）</li>\n</ul>\n<h2 id=\"怎么在网页抄数据\"><a href=\"#怎么在网页抄数据\" class=\"headerlink\" title=\"怎么在网页抄数据\"></a>怎么在网页抄数据</h2><p><img src=\"https://i.loli.net/2017/09/22/59c4990ac3f33.png\" alt=\"\"></p>\n<h2 id=\"伪造请求\"><a href=\"#伪造请求\" class=\"headerlink\" title=\"伪造请求\"></a>伪造请求</h2><p><img src=\"https://i.loli.net/2017/09/23/59c5f31f6601d.png\" alt=\"\"></p>\n<pre><code>curl &#39;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=1507564199109&#39; -H &#39;pragma: no-cache&#39; -H &#39;origin: https://m.y.qq.com&#39; -H &#39;accept-encoding: gzip, deflate, br&#39; -H &#39;accept-language: zh-CN,zh;q=0.8&#39; -H &#39;user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39; -H &#39;accept: application/json&#39; -H &#39;cache-control: no-cache&#39; -H &#39;authority: c.y.qq.com&#39; -H &#39;cookie: pgv_pvi=1576136704; pgv_si=s2924205056; RK=QfWPx2jbHN; tvfe_boss_uuid=bdd869ba21d19595; o_cookie=350558468; ts_refer=ADTAGmyqq; ptui_loginuin=350558468; ptisp=ctc; ptcz=bde020f9828475fc3e22f0fc78ba0024b7a615fad803b91694a069a02cefdb0b; pt2gguin=o0350558468; LW_sid=11S540S7L3v4m1k4L632K6r1m3; LW_uid=g1l53027M384N1y4K6Z2v6d1L4; eas_sid=H1Y5t0B7H3o461B4f692f682Y2; ts_uid=2559117424; qqmusic_fromtag=10; checkmask=3; yqq_stat=0; ts_refer=www.google.ca/; ts_uid=2559117424; pgv_info=ssid=s8871552255; pgv_pvid=2779555285&#39; -H &#39;referer: https://m.y.qq.com/&#39; --compressed\n</code></pre><p><code>npm install express --save</code> </p>\n<p><code>npm install request --save</code> <code>npm install request-promise --save</code>（发请求的库）</p>\n<p><a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a></p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c60819cabdf.png\" alt=\"\"></p>\n<p><code>npm install -g nodemon</code></p>\n<p><a href=\"https://nodemon.io/\" target=\"_blank\" rel=\"noopener\">nodemon</a></p>\n<p>我去…用 nodemon 不能用 <code>import XXX from &#39;XXX&#39;</code> 要用 <code>var XXX = require(&#39;XXX&#39;)</code></p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c60b0dcf706.png\" alt=\"\"></p>\n<p>我去…原来还有 n 模块这玩意…</p>\n<p><a href=\"https://www.npmjs.com/package/n\" target=\"_blank\" rel=\"noopener\">n</a> 接受了这个设定还是挺不错的…</p>\n<pre><code>//qq-server 代码\nconst express = require(&#39;express&#39;)\nconst request = require(&#39;request-promise&#39;)\n\nconst app = express()\n\napp.get(&#39;/&#39;, async (req, res) =&gt; {\n    const url = `https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: {\n                    &#39;accept&#39;: &#39;application/json&#39;,\n                    &#39;authority&#39;: &#39;c.y.qq.com&#39;,\n                    &#39;origin&#39;: &#39;https://m.y.qq.com&#39;,\n                    &#39;referer&#39;: &#39;https://m.y.qq.com/&#39;,\n                    &#39;user-agent&#39;: &#39;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39;\n                }\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }\n})\n\napp.listen(4000)\n</code></pre><p>运行 <code>nodemon qq-server.js</code> 打开 localhost:4000</p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c6163e42f5b.png\" alt=\"\"></p>\n<p>开心 终于不用跨域请求了 也不用自己去抄数据了hhhh 新技能 get</p>\n<p>再分析一个 API 接口</p>\n<pre><code>https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=%E6%9D%8E%E8%8D%A3%E6%B5%A9&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=1&amp;remoteplace=txt.mqq.all&amp;_=1506154238572\n</code></pre><p><code>w=%E6%9D%8E%E8%8D%A3%E6%B5%A9</code> 这个是李荣浩</p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c618bbb79d2.png\" alt=\"\"></p>\n<pre><code>//search部分的核心代码\napp.get(&#39;/search&#39;, async(req,res)=&gt;{\n    const { keyword, page = 1 } = req.query\n    const url=`https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=${encodeURIComponent(keyword)}&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=${page}&amp;remoteplace=txt.mqq.all&amp;_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: HEADERS\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }    \n})\n</code></pre><p><img src=\"https://i.loli.net/2017/09/23/59c6200b767cb.png\" alt=\"\"></p>\n<p>所有参数都放在 ? 后面 用 &amp; 链接</p>\n<p>你看真的成了</p>\n<p>那就是说…我自己做了一个 API …</p>\n<p>让这个 API 跨域 <code>npm install cors --save</code></p>\n<p><a href=\"https://zeit.co/now\" target=\"_blank\" rel=\"noopener\">https://zeit.co/now</a> 把做出来的 server.js 上传就可以用了</p>\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>import export</p>\n<h2 id=\"音乐歌词-API\"><a href=\"#音乐歌词-API\" class=\"headerlink\" title=\"音乐歌词 API\"></a>音乐歌词 API</h2><p><img src=\"https://i.loli.net/2017/09/25/59c8db302e050.png\" alt=\"\"></p>\n<p>点击 network 看 JS</p>\n<p>把这个地址复制，在 console 用 <code>fetch()</code> 跑一遍</p>\n<p><img src=\"https://i.loli.net/2017/09/25/59c8dbc2a1f79.png\" alt=\"\"></p>\n<p>再回到 network 看 XHR</p>\n<p><img src=\"https://i.loli.net/2017/09/25/59c8dc2dd23db.png\" alt=\"\"></p>\n<p>写一个正则，把 callback 去掉，括号去掉。</p>\n<p><code>MusicJsonCallback({...}).replace(/MusicJsonCallback\\((.*)\\)/, &#39;$1&#39;)</code></p>\n<p><code>let json = {...}</code></p>\n<p><code>JSON.parse(json)</code></p>\n<p><code>json.lyric</code></p>\n<p><code>let div = document.createElement(&#39;div&#39;)</code></p>\n<p><code>div.innerHTML = json.lyric</code></p>\n<p><code>div.firstChild.nodeValue</code></p>\n<h2 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h2><p>单页面保存数据的方式</p>\n<p>就是当你打开这个页面就可以直接转跳到那首歌的入口</p>\n<p><code>href=&quot;#player?artist=${artist}&amp;songid=${song.songid}&amp;songname=${song.songname}&amp;albummid=${song.albummid}&amp;duration=${song.interval}&quot;</code></p>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><p>fetch / await async</p>\n<p><code>[].slice.call()</code></p>\n<p>IntersectionObserver</p>\n<p><code>map</code> 和 <code>forEach</code> 的区别</p>\n<p>懒加载 / 曝光加载</p>\n<p>正则</p>\n<pre><code>&#39;View frankietang on GitHub&#39;.match(/View (\\w+) on GitHub/)[1]\n&#39;frankietang&#39;\n</code></pre><p>css 里面的 <code>filter:blur(15px)</code> 毛玻璃效果</p>\n<p>进度条可以先移到最边边，然后慢慢的往右移。</p>\n<p><code>max-height: calc(100% - 205px);</code></p>\n<p><code>location.hash</code> 点击时 url 的变化</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/09/28/59ccf1d9533c4.png\" alt=\"\"></p>\n<p>MVC – Model View Controller</p>\n<p>autoprefixer-cli</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NonDocumentTypeChildNode/previousElementSibling\" target=\"_blank\" rel=\"noopener\">NonDocumentTypeChildNode.previousElementSibling</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"做一个音乐-Webapp\"><a href=\"#做一个音乐-Webapp\" class=\"headerlink\" title=\"做一个音乐 Webapp\"></a>做一个音乐 Webapp</h1><p>超低仿 Vanilla JS 写的 QQ 音乐</p>\n<p><a href=\"https://frankietang.github.io/qq-music/index.html\" target=\"_blank\" rel=\"noopener\">预览</a> | <a href=\"https://github.com/FRANKIETANG/qq-music\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<p>那么乱的笔记估计就只有我才能看懂</p>\n<ul>\n<li>按需求制定一下接口</li>\n<li>功能拆分成一个一个模块（首页 + 推荐 / 排行榜 / 搜索 / 播放器界面）</li>\n<li>技术选型（CSS 预处理器 / JS 库）</li>\n</ul>\n<h2 id=\"怎么在网页抄数据\"><a href=\"#怎么在网页抄数据\" class=\"headerlink\" title=\"怎么在网页抄数据\"></a>怎么在网页抄数据</h2><p><img src=\"https://i.loli.net/2017/09/22/59c4990ac3f33.png\" alt=\"\"></p>\n<h2 id=\"伪造请求\"><a href=\"#伪造请求\" class=\"headerlink\" title=\"伪造请求\"></a>伪造请求</h2><p><img src=\"https://i.loli.net/2017/09/23/59c5f31f6601d.png\" alt=\"\"></p>\n<pre><code>curl &#39;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=1507564199109&#39; -H &#39;pragma: no-cache&#39; -H &#39;origin: https://m.y.qq.com&#39; -H &#39;accept-encoding: gzip, deflate, br&#39; -H &#39;accept-language: zh-CN,zh;q=0.8&#39; -H &#39;user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39; -H &#39;accept: application/json&#39; -H &#39;cache-control: no-cache&#39; -H &#39;authority: c.y.qq.com&#39; -H &#39;cookie: pgv_pvi=1576136704; pgv_si=s2924205056; RK=QfWPx2jbHN; tvfe_boss_uuid=bdd869ba21d19595; o_cookie=350558468; ts_refer=ADTAGmyqq; ptui_loginuin=350558468; ptisp=ctc; ptcz=bde020f9828475fc3e22f0fc78ba0024b7a615fad803b91694a069a02cefdb0b; pt2gguin=o0350558468; LW_sid=11S540S7L3v4m1k4L632K6r1m3; LW_uid=g1l53027M384N1y4K6Z2v6d1L4; eas_sid=H1Y5t0B7H3o461B4f692f682Y2; ts_uid=2559117424; qqmusic_fromtag=10; checkmask=3; yqq_stat=0; ts_refer=www.google.ca/; ts_uid=2559117424; pgv_info=ssid=s8871552255; pgv_pvid=2779555285&#39; -H &#39;referer: https://m.y.qq.com/&#39; --compressed\n</code></pre><p><code>npm install express --save</code> </p>\n<p><code>npm install request --save</code> <code>npm install request-promise --save</code>（发请求的库）</p>\n<p><a href=\"https://github.com/request/request-promise\" target=\"_blank\" rel=\"noopener\">request-promise</a></p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c60819cabdf.png\" alt=\"\"></p>\n<p><code>npm install -g nodemon</code></p>\n<p><a href=\"https://nodemon.io/\" target=\"_blank\" rel=\"noopener\">nodemon</a></p>\n<p>我去…用 nodemon 不能用 <code>import XXX from &#39;XXX&#39;</code> 要用 <code>var XXX = require(&#39;XXX&#39;)</code></p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c60b0dcf706.png\" alt=\"\"></p>\n<p>我去…原来还有 n 模块这玩意…</p>\n<p><a href=\"https://www.npmjs.com/package/n\" target=\"_blank\" rel=\"noopener\">n</a> 接受了这个设定还是挺不错的…</p>\n<pre><code>//qq-server 代码\nconst express = require(&#39;express&#39;)\nconst request = require(&#39;request-promise&#39;)\n\nconst app = express()\n\napp.get(&#39;/&#39;, async (req, res) =&gt; {\n    const url = `https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: {\n                    &#39;accept&#39;: &#39;application/json&#39;,\n                    &#39;authority&#39;: &#39;c.y.qq.com&#39;,\n                    &#39;origin&#39;: &#39;https://m.y.qq.com&#39;,\n                    &#39;referer&#39;: &#39;https://m.y.qq.com/&#39;,\n                    &#39;user-agent&#39;: &#39;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39;\n                }\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }\n})\n\napp.listen(4000)\n</code></pre><p>运行 <code>nodemon qq-server.js</code> 打开 localhost:4000</p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c6163e42f5b.png\" alt=\"\"></p>\n<p>开心 终于不用跨域请求了 也不用自己去抄数据了hhhh 新技能 get</p>\n<p>再分析一个 API 接口</p>\n<pre><code>https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=%E6%9D%8E%E8%8D%A3%E6%B5%A9&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=1&amp;remoteplace=txt.mqq.all&amp;_=1506154238572\n</code></pre><p><code>w=%E6%9D%8E%E8%8D%A3%E6%B5%A9</code> 这个是李荣浩</p>\n<p><img src=\"https://i.loli.net/2017/09/23/59c618bbb79d2.png\" alt=\"\"></p>\n<pre><code>//search部分的核心代码\napp.get(&#39;/search&#39;, async(req,res)=&gt;{\n    const { keyword, page = 1 } = req.query\n    const url=`https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=${encodeURIComponent(keyword)}&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=${page}&amp;remoteplace=txt.mqq.all&amp;_=${+ new Date()}`\n    try {\n        res.json(\n            await request({\n                uri: url,\n                json: true,\n                headers: HEADERS\n            })\n        )\n    } catch (e) {\n        res.json({ error: e.message })\n    }    \n})\n</code></pre><p><img src=\"https://i.loli.net/2017/09/23/59c6200b767cb.png\" alt=\"\"></p>\n<p>所有参数都放在 ? 后面 用 &amp; 链接</p>\n<p>你看真的成了</p>\n<p>那就是说…我自己做了一个 API …</p>\n<p>让这个 API 跨域 <code>npm install cors --save</code></p>\n<p><a href=\"https://zeit.co/now\" target=\"_blank\" rel=\"noopener\">https://zeit.co/now</a> 把做出来的 server.js 上传就可以用了</p>\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>import export</p>\n<h2 id=\"音乐歌词-API\"><a href=\"#音乐歌词-API\" class=\"headerlink\" title=\"音乐歌词 API\"></a>音乐歌词 API</h2><p><img src=\"https://i.loli.net/2017/09/25/59c8db302e050.png\" alt=\"\"></p>\n<p>点击 network 看 JS</p>\n<p>把这个地址复制，在 console 用 <code>fetch()</code> 跑一遍</p>\n<p><img src=\"https://i.loli.net/2017/09/25/59c8dbc2a1f79.png\" alt=\"\"></p>\n<p>再回到 network 看 XHR</p>\n<p><img src=\"https://i.loli.net/2017/09/25/59c8dc2dd23db.png\" alt=\"\"></p>\n<p>写一个正则，把 callback 去掉，括号去掉。</p>\n<p><code>MusicJsonCallback({...}).replace(/MusicJsonCallback\\((.*)\\)/, &#39;$1&#39;)</code></p>\n<p><code>let json = {...}</code></p>\n<p><code>JSON.parse(json)</code></p>\n<p><code>json.lyric</code></p>\n<p><code>let div = document.createElement(&#39;div&#39;)</code></p>\n<p><code>div.innerHTML = json.lyric</code></p>\n<p><code>div.firstChild.nodeValue</code></p>\n<h2 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h2><p>单页面保存数据的方式</p>\n<p>就是当你打开这个页面就可以直接转跳到那首歌的入口</p>\n<p><code>href=&quot;#player?artist=${artist}&amp;songid=${song.songid}&amp;songname=${song.songname}&amp;albummid=${song.albummid}&amp;duration=${song.interval}&quot;</code></p>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><p>fetch / await async</p>\n<p><code>[].slice.call()</code></p>\n<p>IntersectionObserver</p>\n<p><code>map</code> 和 <code>forEach</code> 的区别</p>\n<p>懒加载 / 曝光加载</p>\n<p>正则</p>\n<pre><code>&#39;View frankietang on GitHub&#39;.match(/View (\\w+) on GitHub/)[1]\n&#39;frankietang&#39;\n</code></pre><p>css 里面的 <code>filter:blur(15px)</code> 毛玻璃效果</p>\n<p>进度条可以先移到最边边，然后慢慢的往右移。</p>\n<p><code>max-height: calc(100% - 205px);</code></p>\n<p><code>location.hash</code> 点击时 url 的变化</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/09/28/59ccf1d9533c4.png\" alt=\"\"></p>\n<p>MVC – Model View Controller</p>\n<p>autoprefixer-cli</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/NonDocumentTypeChildNode/previousElementSibling\" target=\"_blank\" rel=\"noopener\">NonDocumentTypeChildNode.previousElementSibling</a></p>\n"},{"title":"摸到 ES6 的门把手","date":"2017-10-13T16:01:50.000Z","_content":"# ES 6标准入门（个人笔记）\n\n## 1.`let` 和 `const`\n\n主要是解决作用域问题。\n\n### 1.1`let`\n\n#### 1.1.1for 循环\n\n```\n//在 var 里\nvar a = 0\nfor (var i = 0;i < 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//10\n```\n\n```\n//而在 let 则不一样\nlet a = 0\nfor (let i = 0;i < 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//undefined\n//等于\nvar a = 0\nfor (var _i = 0;_i < 10;_i++) {\n  console.log(_i)\n}\nconsole.log(i)\n```\n\n#### 1.1.2块级作用域\n\n```\nfunction f1() {\n  var n = 5\n  if (true) {\n    var n = 10\n  }\n  console.log(n)//10\n}\nf1()\n```\n\n```\n//而在 let 里面，会偷梁换柱\nfunction f1() {\n  let n = 5\n  if (true) {\n    let n = 10\n  }\n  console.log(n)//5\n}\n//相当于\nfunction f1() {\n  var n = 5\n  if (true) {\n    var _n = 10\n  }\n  console.log(n)//5\n}\n//换掉了变量名\n```\n\n### 1.2`const`\n\n```\n//这样写会报错\nconst b = 0\nb = 1\n//这样写反而不会报错\nconst c = {\n  a:1\n}\nc.a = 2\n//为什么呢？\n//因为 b 指向了另外一个地方\n//用 const 赋值的时候，b 是 only 的。\n//而 c.a 并没有改变 c 的指向\n//如果是\n/*\nc = {a:2}\n*/\n//这样就会报错，指向另外一个地方了\n```\n\nconst 能在块级作用域里吗？\n\n```\n\tconst C = 'c';\n\tconst s = () => {\n\t\tconst C = 's';\n\t\treturn {\n\t\t\ta: 'hello world'\n\t\t}\n\t}\n\t//相当于\n    var C = 'c';\n    var s = function s() {\n        var C = 's';\n        return {\n            a: 'hello world'\n        };\n    };\t\n```\n\n是可以的。\n\n## 2.解构赋值\n\n### 2.1基本用法\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。\n\n解构赋值是讲究叶子节点的。\n\n```\n//一个简单的例子\nlet [a,b,c] = [1,2,3]\n//相当于\nvar a = 1,\n    b = 2,\n    c = 3\n```\n\n```\n//我们再来看一个例子\nlet { d,e }={ d:1, e:2 }\n//相当于\nvar _d$e = { d:1,e:2 },\n\td = _d$e.d\n\te = _d$e.e\n```\n\n### 2.2深度解构\n\n```\n//例子\nlet obj = {\n  p: [\n    'Hello',\n    {y:'World'}\n  ]\n}\n\nlet { p:[x,{ y }] } = obj\n//相当于\nvar obj = {\n  p: ['Hello',{ y:'World' }]\n}\n\nvar _obj$p = _slicedToArray(obj.p,2),\n\tx = _obj$p[0],\n\ty = _obj$p[1].y\n\t\n//_slicedToArray 只是一个方法，了解就好\n//先把 obj 给克隆下来，层级展开，其实就是递归\n```\n\n```\n//_slicedToArray\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }()\n```\n\n### 2.3应用\n\n#### 2.3.1`function add(a,b){return a+b}`\n\n```\n//传入数组相加\nfunction add([x,y]){\n  return x+y\n}\nadd([1,2])//3\n//相当于\nfunction add(_ref){\n  var _ref2 = _slicedToArray(_ref,2),\n  \t  x = _ref2[0],\n  \t  y = _ref2[1]\n  \t  \n  return x + y\n}\n\nadd([1,2])//3\n```\n\n#### 2.3.2字符串解构\n\n```\nconst [a1,b1,c1,d1,e1] = 'hello'\n//相当于\nvar _hello = 'hello',\n\t_hello2 = _slicedToArray(_hello,5),\n\ta1 = _hello2[0],\n\tb1 = _hello2[1],\n\tc1 = _hello2[2],\n\td1 = _hello2[3],\n\te1 = _hello2[4]\n```\n\n#### 2.3.3 rest 解构\n\n```\nconst { p,...rest } = {p:1,a:2,c:2}\nconsole.log(rest) // {a:2,c:2}\n//相当于\nvar _p$a$c = {p:1,a:2,c:2},\n\tp = _p$a$c.p,\n\trest = _objectWithoutProperties(_p$a$c,['p'])\nconsole.log(rest)//{a:2, c:2}\n//_objectWithoutProperties 也是一个方法，知道就好\n```\n\n```\n//_objectWithoutProperties\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n```\n\n```\n//最后一个例子\nfunction add({\n  name,\n  list:[x,y]\n}){\n  return name+y\n}\nadd({name:'tangkalun',list:['21','male']})\n```\n\n## 3.函数\n\n### 3.1函数参数默认值\n\n```\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\nlog('hello'); // log('Hello') // Hello World\n//相当于\nfunction log(x) {\n\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'World';\n\tconsole.log(x, y);\n}\nlog('hello'); // log('Hello') // Hello World\n```\n\n### 3.2 rest 参数\n\n```\nfunction add(a, b, ...values) {\n  console.log(values)\n}\nadd(2, 5, 3) // 3\n//相当于\nfunction add(a, b) {\n\tfor (var _len = arguments.length, values = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\tvalues[_key - 2] = arguments[_key];\n\t}\n\n\tconsole.log(values);\n}\nadd(2, 5, 3); // 3\n```\n\n### 3.3扩展运算符\n\n```\nconsole.log(5,...[1, 2, 3])\n//相当于\n(_console = console).log.apply(_console, [5].concat([1, 2, 3]));\n//注意如果 console.log(...5,[1,2,3]) 会出错\n//...要放在最后一项\n```\n\n### 3.4箭头函数\n\n```\nvar f = v => v;\nvar f1 = v => {\n  return v\n}\n//相当于\nvar f = function f(v) {\n\treturn v;\n};\nvar f1 = function f1(v) {\n\treturn v;\n};\n```\n\n```\nconst pa = () => [1,2,3]\npa()\n//[1,2,3]\n```\n\n```\n\tconst pa = (...args) => {\n\t\tconsole.log(args);\n\t\treturn args.reduce((pre,cur) => {\n\t\t\treturn pre+cur;\n\t\t}, 0);\n\t};\n\tpa.apply(this, [1,2,45]);\n\t//[1,2,45]\n\t//48\n```\n\n#### 3.4.1箭头函数的 this\n\n```\nvar f1 = v=>{\n\tconsole.log(this)\n}\nvar f3 = function(v){\n\t//this\n\treturn v=>{\n\t\tconsole.log(this);\n\t}\n}\n//相当于\nvar f1 = function f1(v) {\n\tconsole.log(undefined);\n};\nvar f3 = function f3(v) {\n\tvar _this = this;\n\t//this\n\treturn function (v) {\n\t\tconsole.log(_this);\n\t};\n};\n//由于函数作用域的关系，this 的指向会指向上级作用域\n//作用域没有就 undefined\n//这样搞都是假 this\n```\n\n```\nconst s = () => {\n  console.log(this)\n}\ns()\n//window\n//注意 babel 环境下输出的 this 是 undefined\n```\n\n>箭头函数有几个使用注意点。\n>\n>（1）函数体内的this对象，就是定义时所在的对象。\n>\n>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n>\n>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n>\n>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n## 4. Promise\n\n```\nlet p = new Promise((resolve,reject)=>{\n\tsetTimeout(resolve,3000,1)\n})\nlet q = new Promise((resolve, reject) => {\n\treject('not good time')\n})\nlet pending = new Promise((resolve,reject)=>{\n\t\n})\n\n// p ==> fulfilled 1\n// Promise的状态 fulfilled pending rejected\n// Promise的值  \n\n// 3s 后\nlet p1 = p.then(val=>{\n\tval += 2;\n\t//return 2\n\treturn new Promise((res, rej) => {\n\t\tres(2)\n\t})\n}).then((val) => {\n\tconsole.log(val);\n});\n\n//只要 return 的话这个 return 的值就是 p1 的当前的状态\n```\n\n[为什么要加 setTimeout](https://www.zhihu.com/question/36972010) 神坑，这里我也不是很懂。\n\n其实我们只用知道这只是一个异步过程\n\n```\nlet p = new Promise((resolve,reject)=>{\n\tsetTimeout(resolve,3000,1)\n})\np\n//Promise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\n//3s 后\n//Promise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: 1}\n```\n\n## 5. Iterator\n\n```\nlet t = [1,2,3];\n\nfor(let val of t){\n\tconsole.log(val)\n};\n//1 2 3\n```\n\n```\nconst s= function(){\n\tfor(let val of arguments){\n\t\tconsole.log(val)\n\t};\n}\ns(1,2,34);\n//for...of 可以同时处理数组和类数组对象\n//就是说，可以循环一个数据结构\n```\n\n## 6. Class\n\n```\n//例子\nclass Test{\n  constructor(){\n    this.a = 'a'\n    this.b = 'b'    \n  }\n}\n//等于\nlet Test = function(argument){\n  this.a = 'a'\n  this.b = 'b'\n}\n\nlet inst = new Test()\nconsole.log(inst.a)\n//这个例子是用 class 来实现语法转换的一个例子\n```\n\n```\n//实现面向对象\nlet Test = function(argument){\n  this.a = 'a'\n  this.b = 'b'\n}\nTest.prototype.c =()=> {console.log('c')}\n\nlet inst = new Test()\nconsole.log(inst.c)\n//用 class 来实现\nclass Test{\n  constructor(){\n    this.a = 'a'\n    this.b = 'b'    \n  }\n  c(){console.log('c')}\n}\nlet inst = new Test()\nconsole.log(inst.c())\n//这里会有个 undefined ，因为 console.log('c') 并没有返回值\n```\n\n```\n//以前我们写构造函数会这样写\nlet Test = function(argument){\n  this.a = a\n  this.b = b\n}\nTest.prototype.c = function(){\n  return 'ddddd'\n}\n//用 class\nclass Test{\n  constructor(){\n    this.a = 'a'\n    this.b = 'b'\n  }\n  c(){\n    return 'ddddd'\n  }\n}\n```\n\n关于 `super()` 的问题\n\n```\nclass TestSuper {\n  constructor() {\n    this.a = 'a'\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = 'b'\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:'a',b:'b'}\n```\n\n## 7. Module \n\n```\n//a.js\nfunction f1(){\n  let a = 1\n}\nexport {f1}\n```\n\n```\n//module.js\nimport {f1} from './let_const.js'\n//相当于\nvar _let_const = require('./a.js')\n//只有 nodejs 有 require 函数\n//先把 import...form 转换成 require 的形式\n//用 webpack 来处理 require 函数\n```\n\n```\na.js ==>  require('./b.js').kkkkk\nb.js ==>  require('./c.js').kkkkk\nc.js ==>  require('./a.js').kkkkk\n\nAMD  define + require\n\nwebpack ==> node.js的fs io体系来把所有的require依赖放在一个文件里面\nbundle.js\n\n(function(moduleArr) {\n    // XXX\n}[\n    a.js ,\n    c.js,\n    d.js\n])()\n```\n\nwebpack3 会自己封装一层 require\n\n## 8. Generator\n\n是一种异步编程解决方案\n\n`yield` 产出\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n};\n//最好仅在 nodejs 上使用 generator\n//yield 执行完之后是停止的\n//需要手动执行 .next()\nvar hw = helloWorldGenerator();\nlet a = hw.next();\nlet b = hw.next();\nlet c = hw.next();\nconsole.log(a,b,c)\n/*\n{ value: 'hello', done: false } { value: 'world', done: false } { value: 'ending', done: true }\n*/\n```\n\n## ES6 语法测试\n\n- 安装babel命令行\n\n```bash\n$ cnpm install babel-cli\n```\n\n[参考文档](http://es6.ruanyifeng.com/)\n\n第一次接触 `'use strict'` \n\n看来踩的坑还有点少。\n\n[Javascript 严格模式详解 - 阮一峰](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)\n\n这只是笔记，多看看阮一峰的 ES6 文档吧。","source":"_posts/摸到 ES6 的门把手.md","raw":"---\ntitle: 摸到 ES6 的门把手\ndate: 2017-10-14 00:01:50\ntags: [ES6,JavaScript,Black History]\n---\n# ES 6标准入门（个人笔记）\n\n## 1.`let` 和 `const`\n\n主要是解决作用域问题。\n\n### 1.1`let`\n\n#### 1.1.1for 循环\n\n```\n//在 var 里\nvar a = 0\nfor (var i = 0;i < 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//10\n```\n\n```\n//而在 let 则不一样\nlet a = 0\nfor (let i = 0;i < 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//undefined\n//等于\nvar a = 0\nfor (var _i = 0;_i < 10;_i++) {\n  console.log(_i)\n}\nconsole.log(i)\n```\n\n#### 1.1.2块级作用域\n\n```\nfunction f1() {\n  var n = 5\n  if (true) {\n    var n = 10\n  }\n  console.log(n)//10\n}\nf1()\n```\n\n```\n//而在 let 里面，会偷梁换柱\nfunction f1() {\n  let n = 5\n  if (true) {\n    let n = 10\n  }\n  console.log(n)//5\n}\n//相当于\nfunction f1() {\n  var n = 5\n  if (true) {\n    var _n = 10\n  }\n  console.log(n)//5\n}\n//换掉了变量名\n```\n\n### 1.2`const`\n\n```\n//这样写会报错\nconst b = 0\nb = 1\n//这样写反而不会报错\nconst c = {\n  a:1\n}\nc.a = 2\n//为什么呢？\n//因为 b 指向了另外一个地方\n//用 const 赋值的时候，b 是 only 的。\n//而 c.a 并没有改变 c 的指向\n//如果是\n/*\nc = {a:2}\n*/\n//这样就会报错，指向另外一个地方了\n```\n\nconst 能在块级作用域里吗？\n\n```\n\tconst C = 'c';\n\tconst s = () => {\n\t\tconst C = 's';\n\t\treturn {\n\t\t\ta: 'hello world'\n\t\t}\n\t}\n\t//相当于\n    var C = 'c';\n    var s = function s() {\n        var C = 's';\n        return {\n            a: 'hello world'\n        };\n    };\t\n```\n\n是可以的。\n\n## 2.解构赋值\n\n### 2.1基本用法\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。\n\n解构赋值是讲究叶子节点的。\n\n```\n//一个简单的例子\nlet [a,b,c] = [1,2,3]\n//相当于\nvar a = 1,\n    b = 2,\n    c = 3\n```\n\n```\n//我们再来看一个例子\nlet { d,e }={ d:1, e:2 }\n//相当于\nvar _d$e = { d:1,e:2 },\n\td = _d$e.d\n\te = _d$e.e\n```\n\n### 2.2深度解构\n\n```\n//例子\nlet obj = {\n  p: [\n    'Hello',\n    {y:'World'}\n  ]\n}\n\nlet { p:[x,{ y }] } = obj\n//相当于\nvar obj = {\n  p: ['Hello',{ y:'World' }]\n}\n\nvar _obj$p = _slicedToArray(obj.p,2),\n\tx = _obj$p[0],\n\ty = _obj$p[1].y\n\t\n//_slicedToArray 只是一个方法，了解就好\n//先把 obj 给克隆下来，层级展开，其实就是递归\n```\n\n```\n//_slicedToArray\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }()\n```\n\n### 2.3应用\n\n#### 2.3.1`function add(a,b){return a+b}`\n\n```\n//传入数组相加\nfunction add([x,y]){\n  return x+y\n}\nadd([1,2])//3\n//相当于\nfunction add(_ref){\n  var _ref2 = _slicedToArray(_ref,2),\n  \t  x = _ref2[0],\n  \t  y = _ref2[1]\n  \t  \n  return x + y\n}\n\nadd([1,2])//3\n```\n\n#### 2.3.2字符串解构\n\n```\nconst [a1,b1,c1,d1,e1] = 'hello'\n//相当于\nvar _hello = 'hello',\n\t_hello2 = _slicedToArray(_hello,5),\n\ta1 = _hello2[0],\n\tb1 = _hello2[1],\n\tc1 = _hello2[2],\n\td1 = _hello2[3],\n\te1 = _hello2[4]\n```\n\n#### 2.3.3 rest 解构\n\n```\nconst { p,...rest } = {p:1,a:2,c:2}\nconsole.log(rest) // {a:2,c:2}\n//相当于\nvar _p$a$c = {p:1,a:2,c:2},\n\tp = _p$a$c.p,\n\trest = _objectWithoutProperties(_p$a$c,['p'])\nconsole.log(rest)//{a:2, c:2}\n//_objectWithoutProperties 也是一个方法，知道就好\n```\n\n```\n//_objectWithoutProperties\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n```\n\n```\n//最后一个例子\nfunction add({\n  name,\n  list:[x,y]\n}){\n  return name+y\n}\nadd({name:'tangkalun',list:['21','male']})\n```\n\n## 3.函数\n\n### 3.1函数参数默认值\n\n```\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\nlog('hello'); // log('Hello') // Hello World\n//相当于\nfunction log(x) {\n\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'World';\n\tconsole.log(x, y);\n}\nlog('hello'); // log('Hello') // Hello World\n```\n\n### 3.2 rest 参数\n\n```\nfunction add(a, b, ...values) {\n  console.log(values)\n}\nadd(2, 5, 3) // 3\n//相当于\nfunction add(a, b) {\n\tfor (var _len = arguments.length, values = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\tvalues[_key - 2] = arguments[_key];\n\t}\n\n\tconsole.log(values);\n}\nadd(2, 5, 3); // 3\n```\n\n### 3.3扩展运算符\n\n```\nconsole.log(5,...[1, 2, 3])\n//相当于\n(_console = console).log.apply(_console, [5].concat([1, 2, 3]));\n//注意如果 console.log(...5,[1,2,3]) 会出错\n//...要放在最后一项\n```\n\n### 3.4箭头函数\n\n```\nvar f = v => v;\nvar f1 = v => {\n  return v\n}\n//相当于\nvar f = function f(v) {\n\treturn v;\n};\nvar f1 = function f1(v) {\n\treturn v;\n};\n```\n\n```\nconst pa = () => [1,2,3]\npa()\n//[1,2,3]\n```\n\n```\n\tconst pa = (...args) => {\n\t\tconsole.log(args);\n\t\treturn args.reduce((pre,cur) => {\n\t\t\treturn pre+cur;\n\t\t}, 0);\n\t};\n\tpa.apply(this, [1,2,45]);\n\t//[1,2,45]\n\t//48\n```\n\n#### 3.4.1箭头函数的 this\n\n```\nvar f1 = v=>{\n\tconsole.log(this)\n}\nvar f3 = function(v){\n\t//this\n\treturn v=>{\n\t\tconsole.log(this);\n\t}\n}\n//相当于\nvar f1 = function f1(v) {\n\tconsole.log(undefined);\n};\nvar f3 = function f3(v) {\n\tvar _this = this;\n\t//this\n\treturn function (v) {\n\t\tconsole.log(_this);\n\t};\n};\n//由于函数作用域的关系，this 的指向会指向上级作用域\n//作用域没有就 undefined\n//这样搞都是假 this\n```\n\n```\nconst s = () => {\n  console.log(this)\n}\ns()\n//window\n//注意 babel 环境下输出的 this 是 undefined\n```\n\n>箭头函数有几个使用注意点。\n>\n>（1）函数体内的this对象，就是定义时所在的对象。\n>\n>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n>\n>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n>\n>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n## 4. Promise\n\n```\nlet p = new Promise((resolve,reject)=>{\n\tsetTimeout(resolve,3000,1)\n})\nlet q = new Promise((resolve, reject) => {\n\treject('not good time')\n})\nlet pending = new Promise((resolve,reject)=>{\n\t\n})\n\n// p ==> fulfilled 1\n// Promise的状态 fulfilled pending rejected\n// Promise的值  \n\n// 3s 后\nlet p1 = p.then(val=>{\n\tval += 2;\n\t//return 2\n\treturn new Promise((res, rej) => {\n\t\tres(2)\n\t})\n}).then((val) => {\n\tconsole.log(val);\n});\n\n//只要 return 的话这个 return 的值就是 p1 的当前的状态\n```\n\n[为什么要加 setTimeout](https://www.zhihu.com/question/36972010) 神坑，这里我也不是很懂。\n\n其实我们只用知道这只是一个异步过程\n\n```\nlet p = new Promise((resolve,reject)=>{\n\tsetTimeout(resolve,3000,1)\n})\np\n//Promise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\n//3s 后\n//Promise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: 1}\n```\n\n## 5. Iterator\n\n```\nlet t = [1,2,3];\n\nfor(let val of t){\n\tconsole.log(val)\n};\n//1 2 3\n```\n\n```\nconst s= function(){\n\tfor(let val of arguments){\n\t\tconsole.log(val)\n\t};\n}\ns(1,2,34);\n//for...of 可以同时处理数组和类数组对象\n//就是说，可以循环一个数据结构\n```\n\n## 6. Class\n\n```\n//例子\nclass Test{\n  constructor(){\n    this.a = 'a'\n    this.b = 'b'    \n  }\n}\n//等于\nlet Test = function(argument){\n  this.a = 'a'\n  this.b = 'b'\n}\n\nlet inst = new Test()\nconsole.log(inst.a)\n//这个例子是用 class 来实现语法转换的一个例子\n```\n\n```\n//实现面向对象\nlet Test = function(argument){\n  this.a = 'a'\n  this.b = 'b'\n}\nTest.prototype.c =()=> {console.log('c')}\n\nlet inst = new Test()\nconsole.log(inst.c)\n//用 class 来实现\nclass Test{\n  constructor(){\n    this.a = 'a'\n    this.b = 'b'    \n  }\n  c(){console.log('c')}\n}\nlet inst = new Test()\nconsole.log(inst.c())\n//这里会有个 undefined ，因为 console.log('c') 并没有返回值\n```\n\n```\n//以前我们写构造函数会这样写\nlet Test = function(argument){\n  this.a = a\n  this.b = b\n}\nTest.prototype.c = function(){\n  return 'ddddd'\n}\n//用 class\nclass Test{\n  constructor(){\n    this.a = 'a'\n    this.b = 'b'\n  }\n  c(){\n    return 'ddddd'\n  }\n}\n```\n\n关于 `super()` 的问题\n\n```\nclass TestSuper {\n  constructor() {\n    this.a = 'a'\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = 'b'\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:'a',b:'b'}\n```\n\n## 7. Module \n\n```\n//a.js\nfunction f1(){\n  let a = 1\n}\nexport {f1}\n```\n\n```\n//module.js\nimport {f1} from './let_const.js'\n//相当于\nvar _let_const = require('./a.js')\n//只有 nodejs 有 require 函数\n//先把 import...form 转换成 require 的形式\n//用 webpack 来处理 require 函数\n```\n\n```\na.js ==>  require('./b.js').kkkkk\nb.js ==>  require('./c.js').kkkkk\nc.js ==>  require('./a.js').kkkkk\n\nAMD  define + require\n\nwebpack ==> node.js的fs io体系来把所有的require依赖放在一个文件里面\nbundle.js\n\n(function(moduleArr) {\n    // XXX\n}[\n    a.js ,\n    c.js,\n    d.js\n])()\n```\n\nwebpack3 会自己封装一层 require\n\n## 8. Generator\n\n是一种异步编程解决方案\n\n`yield` 产出\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n};\n//最好仅在 nodejs 上使用 generator\n//yield 执行完之后是停止的\n//需要手动执行 .next()\nvar hw = helloWorldGenerator();\nlet a = hw.next();\nlet b = hw.next();\nlet c = hw.next();\nconsole.log(a,b,c)\n/*\n{ value: 'hello', done: false } { value: 'world', done: false } { value: 'ending', done: true }\n*/\n```\n\n## ES6 语法测试\n\n- 安装babel命令行\n\n```bash\n$ cnpm install babel-cli\n```\n\n[参考文档](http://es6.ruanyifeng.com/)\n\n第一次接触 `'use strict'` \n\n看来踩的坑还有点少。\n\n[Javascript 严格模式详解 - 阮一峰](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)\n\n这只是笔记，多看看阮一峰的 ES6 文档吧。","slug":"摸到 ES6 的门把手","published":1,"updated":"2017-12-13T10:16:49.973Z","_id":"cjb4q0d87000bf1xhha3nlsgs","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"ES-6标准入门（个人笔记）\"><a href=\"#ES-6标准入门（个人笔记）\" class=\"headerlink\" title=\"ES 6标准入门（个人笔记）\"></a>ES 6标准入门（个人笔记）</h1><h2 id=\"1-let-和-const\"><a href=\"#1-let-和-const\" class=\"headerlink\" title=\"1.let 和 const\"></a>1.<code>let</code> 和 <code>const</code></h2><p>主要是解决作用域问题。</p>\n<h3 id=\"1-1let\"><a href=\"#1-1let\" class=\"headerlink\" title=\"1.1let\"></a>1.1<code>let</code></h3><h4 id=\"1-1-1for-循环\"><a href=\"#1-1-1for-循环\" class=\"headerlink\" title=\"1.1.1for 循环\"></a>1.1.1for 循环</h4><pre><code>//在 var 里\nvar a = 0\nfor (var i = 0;i &lt; 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//10\n</code></pre><pre><code>//而在 let 则不一样\nlet a = 0\nfor (let i = 0;i &lt; 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//undefined\n//等于\nvar a = 0\nfor (var _i = 0;_i &lt; 10;_i++) {\n  console.log(_i)\n}\nconsole.log(i)\n</code></pre><h4 id=\"1-1-2块级作用域\"><a href=\"#1-1-2块级作用域\" class=\"headerlink\" title=\"1.1.2块级作用域\"></a>1.1.2块级作用域</h4><pre><code>function f1() {\n  var n = 5\n  if (true) {\n    var n = 10\n  }\n  console.log(n)//10\n}\nf1()\n</code></pre><pre><code>//而在 let 里面，会偷梁换柱\nfunction f1() {\n  let n = 5\n  if (true) {\n    let n = 10\n  }\n  console.log(n)//5\n}\n//相当于\nfunction f1() {\n  var n = 5\n  if (true) {\n    var _n = 10\n  }\n  console.log(n)//5\n}\n//换掉了变量名\n</code></pre><h3 id=\"1-2const\"><a href=\"#1-2const\" class=\"headerlink\" title=\"1.2const\"></a>1.2<code>const</code></h3><pre><code>//这样写会报错\nconst b = 0\nb = 1\n//这样写反而不会报错\nconst c = {\n  a:1\n}\nc.a = 2\n//为什么呢？\n//因为 b 指向了另外一个地方\n//用 const 赋值的时候，b 是 only 的。\n//而 c.a 并没有改变 c 的指向\n//如果是\n/*\nc = {a:2}\n*/\n//这样就会报错，指向另外一个地方了\n</code></pre><p>const 能在块级作用域里吗？</p>\n<pre><code>    const C = &#39;c&#39;;\n    const s = () =&gt; {\n        const C = &#39;s&#39;;\n        return {\n            a: &#39;hello world&#39;\n        }\n    }\n    //相当于\n    var C = &#39;c&#39;;\n    var s = function s() {\n        var C = &#39;s&#39;;\n        return {\n            a: &#39;hello world&#39;\n        };\n    };\n</code></pre><p>是可以的。</p>\n<h2 id=\"2-解构赋值\"><a href=\"#2-解构赋值\" class=\"headerlink\" title=\"2.解构赋值\"></a>2.解构赋值</h2><h3 id=\"2-1基本用法\"><a href=\"#2-1基本用法\" class=\"headerlink\" title=\"2.1基本用法\"></a>2.1基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>\n<p>解构赋值是讲究叶子节点的。</p>\n<pre><code>//一个简单的例子\nlet [a,b,c] = [1,2,3]\n//相当于\nvar a = 1,\n    b = 2,\n    c = 3\n</code></pre><pre><code>//我们再来看一个例子\nlet { d,e }={ d:1, e:2 }\n//相当于\nvar _d$e = { d:1,e:2 },\n    d = _d$e.d\n    e = _d$e.e\n</code></pre><h3 id=\"2-2深度解构\"><a href=\"#2-2深度解构\" class=\"headerlink\" title=\"2.2深度解构\"></a>2.2深度解构</h3><pre><code>//例子\nlet obj = {\n  p: [\n    &#39;Hello&#39;,\n    {y:&#39;World&#39;}\n  ]\n}\n\nlet { p:[x,{ y }] } = obj\n//相当于\nvar obj = {\n  p: [&#39;Hello&#39;,{ y:&#39;World&#39; }]\n}\n\nvar _obj$p = _slicedToArray(obj.p,2),\n    x = _obj$p[0],\n    y = _obj$p[1].y\n\n//_slicedToArray 只是一个方法，了解就好\n//先把 obj 给克隆下来，层级展开，其实就是递归\n</code></pre><pre><code>//_slicedToArray\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[&quot;return&quot;]) _i[&quot;return&quot;](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance&quot;); } }; }()\n</code></pre><h3 id=\"2-3应用\"><a href=\"#2-3应用\" class=\"headerlink\" title=\"2.3应用\"></a>2.3应用</h3><h4 id=\"2-3-1function-add-a-b-return-a-b\"><a href=\"#2-3-1function-add-a-b-return-a-b\" class=\"headerlink\" title=\"2.3.1function add(a,b){return a+b}\"></a>2.3.1<code>function add(a,b){return a+b}</code></h4><pre><code>//传入数组相加\nfunction add([x,y]){\n  return x+y\n}\nadd([1,2])//3\n//相当于\nfunction add(_ref){\n  var _ref2 = _slicedToArray(_ref,2),\n        x = _ref2[0],\n        y = _ref2[1]\n\n  return x + y\n}\n\nadd([1,2])//3\n</code></pre><h4 id=\"2-3-2字符串解构\"><a href=\"#2-3-2字符串解构\" class=\"headerlink\" title=\"2.3.2字符串解构\"></a>2.3.2字符串解构</h4><pre><code>const [a1,b1,c1,d1,e1] = &#39;hello&#39;\n//相当于\nvar _hello = &#39;hello&#39;,\n    _hello2 = _slicedToArray(_hello,5),\n    a1 = _hello2[0],\n    b1 = _hello2[1],\n    c1 = _hello2[2],\n    d1 = _hello2[3],\n    e1 = _hello2[4]\n</code></pre><h4 id=\"2-3-3-rest-解构\"><a href=\"#2-3-3-rest-解构\" class=\"headerlink\" title=\"2.3.3 rest 解构\"></a>2.3.3 rest 解构</h4><pre><code>const { p,...rest } = {p:1,a:2,c:2}\nconsole.log(rest) // {a:2,c:2}\n//相当于\nvar _p$a$c = {p:1,a:2,c:2},\n    p = _p$a$c.p,\n    rest = _objectWithoutProperties(_p$a$c,[&#39;p&#39;])\nconsole.log(rest)//{a:2, c:2}\n//_objectWithoutProperties 也是一个方法，知道就好\n</code></pre><pre><code>//_objectWithoutProperties\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) &gt;= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n</code></pre><pre><code>//最后一个例子\nfunction add({\n  name,\n  list:[x,y]\n}){\n  return name+y\n}\nadd({name:&#39;tangkalun&#39;,list:[&#39;21&#39;,&#39;male&#39;]})\n</code></pre><h2 id=\"3-函数\"><a href=\"#3-函数\" class=\"headerlink\" title=\"3.函数\"></a>3.函数</h2><h3 id=\"3-1函数参数默认值\"><a href=\"#3-1函数参数默认值\" class=\"headerlink\" title=\"3.1函数参数默认值\"></a>3.1函数参数默认值</h3><pre><code>function log(x, y = &#39;World&#39;) {\n  console.log(x, y);\n}\nlog(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World\n//相当于\nfunction log(x) {\n    var y = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &#39;World&#39;;\n    console.log(x, y);\n}\nlog(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World\n</code></pre><h3 id=\"3-2-rest-参数\"><a href=\"#3-2-rest-参数\" class=\"headerlink\" title=\"3.2 rest 参数\"></a>3.2 rest 参数</h3><pre><code>function add(a, b, ...values) {\n  console.log(values)\n}\nadd(2, 5, 3) // 3\n//相当于\nfunction add(a, b) {\n    for (var _len = arguments.length, values = Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {\n        values[_key - 2] = arguments[_key];\n    }\n\n    console.log(values);\n}\nadd(2, 5, 3); // 3\n</code></pre><h3 id=\"3-3扩展运算符\"><a href=\"#3-3扩展运算符\" class=\"headerlink\" title=\"3.3扩展运算符\"></a>3.3扩展运算符</h3><pre><code>console.log(5,...[1, 2, 3])\n//相当于\n(_console = console).log.apply(_console, [5].concat([1, 2, 3]));\n//注意如果 console.log(...5,[1,2,3]) 会出错\n//...要放在最后一项\n</code></pre><h3 id=\"3-4箭头函数\"><a href=\"#3-4箭头函数\" class=\"headerlink\" title=\"3.4箭头函数\"></a>3.4箭头函数</h3><pre><code>var f = v =&gt; v;\nvar f1 = v =&gt; {\n  return v\n}\n//相当于\nvar f = function f(v) {\n    return v;\n};\nvar f1 = function f1(v) {\n    return v;\n};\n</code></pre><pre><code>const pa = () =&gt; [1,2,3]\npa()\n//[1,2,3]\n</code></pre><pre><code>    const pa = (...args) =&gt; {\n        console.log(args);\n        return args.reduce((pre,cur) =&gt; {\n            return pre+cur;\n        }, 0);\n    };\n    pa.apply(this, [1,2,45]);\n    //[1,2,45]\n    //48\n</code></pre><h4 id=\"3-4-1箭头函数的-this\"><a href=\"#3-4-1箭头函数的-this\" class=\"headerlink\" title=\"3.4.1箭头函数的 this\"></a>3.4.1箭头函数的 this</h4><pre><code>var f1 = v=&gt;{\n    console.log(this)\n}\nvar f3 = function(v){\n    //this\n    return v=&gt;{\n        console.log(this);\n    }\n}\n//相当于\nvar f1 = function f1(v) {\n    console.log(undefined);\n};\nvar f3 = function f3(v) {\n    var _this = this;\n    //this\n    return function (v) {\n        console.log(_this);\n    };\n};\n//由于函数作用域的关系，this 的指向会指向上级作用域\n//作用域没有就 undefined\n//这样搞都是假 this\n</code></pre><pre><code>const s = () =&gt; {\n  console.log(this)\n}\ns()\n//window\n//注意 babel 环境下输出的 this 是 undefined\n</code></pre><blockquote>\n<p>箭头函数有几个使用注意点。</p>\n<p>（1）函数体内的this对象，就是定义时所在的对象。</p>\n<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>\n</blockquote>\n<h2 id=\"4-Promise\"><a href=\"#4-Promise\" class=\"headerlink\" title=\"4. Promise\"></a>4. Promise</h2><pre><code>let p = new Promise((resolve,reject)=&gt;{\n    setTimeout(resolve,3000,1)\n})\nlet q = new Promise((resolve, reject) =&gt; {\n    reject(&#39;not good time&#39;)\n})\nlet pending = new Promise((resolve,reject)=&gt;{\n\n})\n\n// p ==&gt; fulfilled 1\n// Promise的状态 fulfilled pending rejected\n// Promise的值  \n\n// 3s 后\nlet p1 = p.then(val=&gt;{\n    val += 2;\n    //return 2\n    return new Promise((res, rej) =&gt; {\n        res(2)\n    })\n}).then((val) =&gt; {\n    console.log(val);\n});\n\n//只要 return 的话这个 return 的值就是 p1 的当前的状态\n</code></pre><p><a href=\"https://www.zhihu.com/question/36972010\" target=\"_blank\" rel=\"noopener\">为什么要加 setTimeout</a> 神坑，这里我也不是很懂。</p>\n<p>其实我们只用知道这只是一个异步过程</p>\n<pre><code>let p = new Promise((resolve,reject)=&gt;{\n    setTimeout(resolve,3000,1)\n})\np\n//Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}\n//3s 后\n//Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1}\n</code></pre><h2 id=\"5-Iterator\"><a href=\"#5-Iterator\" class=\"headerlink\" title=\"5. Iterator\"></a>5. Iterator</h2><pre><code>let t = [1,2,3];\n\nfor(let val of t){\n    console.log(val)\n};\n//1 2 3\n</code></pre><pre><code>const s= function(){\n    for(let val of arguments){\n        console.log(val)\n    };\n}\ns(1,2,34);\n//for...of 可以同时处理数组和类数组对象\n//就是说，可以循环一个数据结构\n</code></pre><h2 id=\"6-Class\"><a href=\"#6-Class\" class=\"headerlink\" title=\"6. Class\"></a>6. Class</h2><pre><code>//例子\nclass Test{\n  constructor(){\n    this.a = &#39;a&#39;\n    this.b = &#39;b&#39;    \n  }\n}\n//等于\nlet Test = function(argument){\n  this.a = &#39;a&#39;\n  this.b = &#39;b&#39;\n}\n\nlet inst = new Test()\nconsole.log(inst.a)\n//这个例子是用 class 来实现语法转换的一个例子\n</code></pre><pre><code>//实现面向对象\nlet Test = function(argument){\n  this.a = &#39;a&#39;\n  this.b = &#39;b&#39;\n}\nTest.prototype.c =()=&gt; {console.log(&#39;c&#39;)}\n\nlet inst = new Test()\nconsole.log(inst.c)\n//用 class 来实现\nclass Test{\n  constructor(){\n    this.a = &#39;a&#39;\n    this.b = &#39;b&#39;    \n  }\n  c(){console.log(&#39;c&#39;)}\n}\nlet inst = new Test()\nconsole.log(inst.c())\n//这里会有个 undefined ，因为 console.log(&#39;c&#39;) 并没有返回值\n</code></pre><pre><code>//以前我们写构造函数会这样写\nlet Test = function(argument){\n  this.a = a\n  this.b = b\n}\nTest.prototype.c = function(){\n  return &#39;ddddd&#39;\n}\n//用 class\nclass Test{\n  constructor(){\n    this.a = &#39;a&#39;\n    this.b = &#39;b&#39;\n  }\n  c(){\n    return &#39;ddddd&#39;\n  }\n}\n</code></pre><p>关于 <code>super()</code> 的问题</p>\n<pre><code>class TestSuper {\n  constructor() {\n    this.a = &#39;a&#39;\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = &#39;b&#39;\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:&#39;a&#39;,b:&#39;b&#39;}\n</code></pre><h2 id=\"7-Module\"><a href=\"#7-Module\" class=\"headerlink\" title=\"7. Module\"></a>7. Module</h2><pre><code>//a.js\nfunction f1(){\n  let a = 1\n}\nexport {f1}\n</code></pre><pre><code>//module.js\nimport {f1} from &#39;./let_const.js&#39;\n//相当于\nvar _let_const = require(&#39;./a.js&#39;)\n//只有 nodejs 有 require 函数\n//先把 import...form 转换成 require 的形式\n//用 webpack 来处理 require 函数\n</code></pre><pre><code>a.js ==&gt;  require(&#39;./b.js&#39;).kkkkk\nb.js ==&gt;  require(&#39;./c.js&#39;).kkkkk\nc.js ==&gt;  require(&#39;./a.js&#39;).kkkkk\n\nAMD  define + require\n\nwebpack ==&gt; node.js的fs io体系来把所有的require依赖放在一个文件里面\nbundle.js\n\n(function(moduleArr) {\n    // XXX\n}[\n    a.js ,\n    c.js,\n    d.js\n])()\n</code></pre><p>webpack3 会自己封装一层 require</p>\n<h2 id=\"8-Generator\"><a href=\"#8-Generator\" class=\"headerlink\" title=\"8. Generator\"></a>8. Generator</h2><p>是一种异步编程解决方案</p>\n<p><code>yield</code> 产出</p>\n<pre><code>function* helloWorldGenerator() {\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n  return &#39;ending&#39;;\n};\n//最好仅在 nodejs 上使用 generator\n//yield 执行完之后是停止的\n//需要手动执行 .next()\nvar hw = helloWorldGenerator();\nlet a = hw.next();\nlet b = hw.next();\nlet c = hw.next();\nconsole.log(a,b,c)\n/*\n{ value: &#39;hello&#39;, done: false } { value: &#39;world&#39;, done: false } { value: &#39;ending&#39;, done: true }\n*/\n</code></pre><h2 id=\"ES6-语法测试\"><a href=\"#ES6-语法测试\" class=\"headerlink\" title=\"ES6 语法测试\"></a>ES6 语法测试</h2><ul>\n<li>安装babel命令行</li>\n</ul>\n<pre><code class=\"bash\">$ cnpm install babel-cli\n</code></pre>\n<p><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>第一次接触 <code>&#39;use strict&#39;</code> </p>\n<p>看来踩的坑还有点少。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html\" target=\"_blank\" rel=\"noopener\">Javascript 严格模式详解 - 阮一峰</a></p>\n<p>这只是笔记，多看看阮一峰的 ES6 文档吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES-6标准入门（个人笔记）\"><a href=\"#ES-6标准入门（个人笔记）\" class=\"headerlink\" title=\"ES 6标准入门（个人笔记）\"></a>ES 6标准入门（个人笔记）</h1><h2 id=\"1-let-和-const\"><a href=\"#1-let-和-const\" class=\"headerlink\" title=\"1.let 和 const\"></a>1.<code>let</code> 和 <code>const</code></h2><p>主要是解决作用域问题。</p>\n<h3 id=\"1-1let\"><a href=\"#1-1let\" class=\"headerlink\" title=\"1.1let\"></a>1.1<code>let</code></h3><h4 id=\"1-1-1for-循环\"><a href=\"#1-1-1for-循环\" class=\"headerlink\" title=\"1.1.1for 循环\"></a>1.1.1for 循环</h4><pre><code>//在 var 里\nvar a = 0\nfor (var i = 0;i &lt; 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//10\n</code></pre><pre><code>//而在 let 则不一样\nlet a = 0\nfor (let i = 0;i &lt; 10;i++) {\n  console.log(i)//10\n}\nconsole.log(i)//undefined\n//等于\nvar a = 0\nfor (var _i = 0;_i &lt; 10;_i++) {\n  console.log(_i)\n}\nconsole.log(i)\n</code></pre><h4 id=\"1-1-2块级作用域\"><a href=\"#1-1-2块级作用域\" class=\"headerlink\" title=\"1.1.2块级作用域\"></a>1.1.2块级作用域</h4><pre><code>function f1() {\n  var n = 5\n  if (true) {\n    var n = 10\n  }\n  console.log(n)//10\n}\nf1()\n</code></pre><pre><code>//而在 let 里面，会偷梁换柱\nfunction f1() {\n  let n = 5\n  if (true) {\n    let n = 10\n  }\n  console.log(n)//5\n}\n//相当于\nfunction f1() {\n  var n = 5\n  if (true) {\n    var _n = 10\n  }\n  console.log(n)//5\n}\n//换掉了变量名\n</code></pre><h3 id=\"1-2const\"><a href=\"#1-2const\" class=\"headerlink\" title=\"1.2const\"></a>1.2<code>const</code></h3><pre><code>//这样写会报错\nconst b = 0\nb = 1\n//这样写反而不会报错\nconst c = {\n  a:1\n}\nc.a = 2\n//为什么呢？\n//因为 b 指向了另外一个地方\n//用 const 赋值的时候，b 是 only 的。\n//而 c.a 并没有改变 c 的指向\n//如果是\n/*\nc = {a:2}\n*/\n//这样就会报错，指向另外一个地方了\n</code></pre><p>const 能在块级作用域里吗？</p>\n<pre><code>    const C = &#39;c&#39;;\n    const s = () =&gt; {\n        const C = &#39;s&#39;;\n        return {\n            a: &#39;hello world&#39;\n        }\n    }\n    //相当于\n    var C = &#39;c&#39;;\n    var s = function s() {\n        var C = &#39;s&#39;;\n        return {\n            a: &#39;hello world&#39;\n        };\n    };\n</code></pre><p>是可以的。</p>\n<h2 id=\"2-解构赋值\"><a href=\"#2-解构赋值\" class=\"headerlink\" title=\"2.解构赋值\"></a>2.解构赋值</h2><h3 id=\"2-1基本用法\"><a href=\"#2-1基本用法\" class=\"headerlink\" title=\"2.1基本用法\"></a>2.1基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>\n<p>解构赋值是讲究叶子节点的。</p>\n<pre><code>//一个简单的例子\nlet [a,b,c] = [1,2,3]\n//相当于\nvar a = 1,\n    b = 2,\n    c = 3\n</code></pre><pre><code>//我们再来看一个例子\nlet { d,e }={ d:1, e:2 }\n//相当于\nvar _d$e = { d:1,e:2 },\n    d = _d$e.d\n    e = _d$e.e\n</code></pre><h3 id=\"2-2深度解构\"><a href=\"#2-2深度解构\" class=\"headerlink\" title=\"2.2深度解构\"></a>2.2深度解构</h3><pre><code>//例子\nlet obj = {\n  p: [\n    &#39;Hello&#39;,\n    {y:&#39;World&#39;}\n  ]\n}\n\nlet { p:[x,{ y }] } = obj\n//相当于\nvar obj = {\n  p: [&#39;Hello&#39;,{ y:&#39;World&#39; }]\n}\n\nvar _obj$p = _slicedToArray(obj.p,2),\n    x = _obj$p[0],\n    y = _obj$p[1].y\n\n//_slicedToArray 只是一个方法，了解就好\n//先把 obj 给克隆下来，层级展开，其实就是递归\n</code></pre><pre><code>//_slicedToArray\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[&quot;return&quot;]) _i[&quot;return&quot;](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance&quot;); } }; }()\n</code></pre><h3 id=\"2-3应用\"><a href=\"#2-3应用\" class=\"headerlink\" title=\"2.3应用\"></a>2.3应用</h3><h4 id=\"2-3-1function-add-a-b-return-a-b\"><a href=\"#2-3-1function-add-a-b-return-a-b\" class=\"headerlink\" title=\"2.3.1function add(a,b){return a+b}\"></a>2.3.1<code>function add(a,b){return a+b}</code></h4><pre><code>//传入数组相加\nfunction add([x,y]){\n  return x+y\n}\nadd([1,2])//3\n//相当于\nfunction add(_ref){\n  var _ref2 = _slicedToArray(_ref,2),\n        x = _ref2[0],\n        y = _ref2[1]\n\n  return x + y\n}\n\nadd([1,2])//3\n</code></pre><h4 id=\"2-3-2字符串解构\"><a href=\"#2-3-2字符串解构\" class=\"headerlink\" title=\"2.3.2字符串解构\"></a>2.3.2字符串解构</h4><pre><code>const [a1,b1,c1,d1,e1] = &#39;hello&#39;\n//相当于\nvar _hello = &#39;hello&#39;,\n    _hello2 = _slicedToArray(_hello,5),\n    a1 = _hello2[0],\n    b1 = _hello2[1],\n    c1 = _hello2[2],\n    d1 = _hello2[3],\n    e1 = _hello2[4]\n</code></pre><h4 id=\"2-3-3-rest-解构\"><a href=\"#2-3-3-rest-解构\" class=\"headerlink\" title=\"2.3.3 rest 解构\"></a>2.3.3 rest 解构</h4><pre><code>const { p,...rest } = {p:1,a:2,c:2}\nconsole.log(rest) // {a:2,c:2}\n//相当于\nvar _p$a$c = {p:1,a:2,c:2},\n    p = _p$a$c.p,\n    rest = _objectWithoutProperties(_p$a$c,[&#39;p&#39;])\nconsole.log(rest)//{a:2, c:2}\n//_objectWithoutProperties 也是一个方法，知道就好\n</code></pre><pre><code>//_objectWithoutProperties\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) &gt;= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n</code></pre><pre><code>//最后一个例子\nfunction add({\n  name,\n  list:[x,y]\n}){\n  return name+y\n}\nadd({name:&#39;tangkalun&#39;,list:[&#39;21&#39;,&#39;male&#39;]})\n</code></pre><h2 id=\"3-函数\"><a href=\"#3-函数\" class=\"headerlink\" title=\"3.函数\"></a>3.函数</h2><h3 id=\"3-1函数参数默认值\"><a href=\"#3-1函数参数默认值\" class=\"headerlink\" title=\"3.1函数参数默认值\"></a>3.1函数参数默认值</h3><pre><code>function log(x, y = &#39;World&#39;) {\n  console.log(x, y);\n}\nlog(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World\n//相当于\nfunction log(x) {\n    var y = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &#39;World&#39;;\n    console.log(x, y);\n}\nlog(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World\n</code></pre><h3 id=\"3-2-rest-参数\"><a href=\"#3-2-rest-参数\" class=\"headerlink\" title=\"3.2 rest 参数\"></a>3.2 rest 参数</h3><pre><code>function add(a, b, ...values) {\n  console.log(values)\n}\nadd(2, 5, 3) // 3\n//相当于\nfunction add(a, b) {\n    for (var _len = arguments.length, values = Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {\n        values[_key - 2] = arguments[_key];\n    }\n\n    console.log(values);\n}\nadd(2, 5, 3); // 3\n</code></pre><h3 id=\"3-3扩展运算符\"><a href=\"#3-3扩展运算符\" class=\"headerlink\" title=\"3.3扩展运算符\"></a>3.3扩展运算符</h3><pre><code>console.log(5,...[1, 2, 3])\n//相当于\n(_console = console).log.apply(_console, [5].concat([1, 2, 3]));\n//注意如果 console.log(...5,[1,2,3]) 会出错\n//...要放在最后一项\n</code></pre><h3 id=\"3-4箭头函数\"><a href=\"#3-4箭头函数\" class=\"headerlink\" title=\"3.4箭头函数\"></a>3.4箭头函数</h3><pre><code>var f = v =&gt; v;\nvar f1 = v =&gt; {\n  return v\n}\n//相当于\nvar f = function f(v) {\n    return v;\n};\nvar f1 = function f1(v) {\n    return v;\n};\n</code></pre><pre><code>const pa = () =&gt; [1,2,3]\npa()\n//[1,2,3]\n</code></pre><pre><code>    const pa = (...args) =&gt; {\n        console.log(args);\n        return args.reduce((pre,cur) =&gt; {\n            return pre+cur;\n        }, 0);\n    };\n    pa.apply(this, [1,2,45]);\n    //[1,2,45]\n    //48\n</code></pre><h4 id=\"3-4-1箭头函数的-this\"><a href=\"#3-4-1箭头函数的-this\" class=\"headerlink\" title=\"3.4.1箭头函数的 this\"></a>3.4.1箭头函数的 this</h4><pre><code>var f1 = v=&gt;{\n    console.log(this)\n}\nvar f3 = function(v){\n    //this\n    return v=&gt;{\n        console.log(this);\n    }\n}\n//相当于\nvar f1 = function f1(v) {\n    console.log(undefined);\n};\nvar f3 = function f3(v) {\n    var _this = this;\n    //this\n    return function (v) {\n        console.log(_this);\n    };\n};\n//由于函数作用域的关系，this 的指向会指向上级作用域\n//作用域没有就 undefined\n//这样搞都是假 this\n</code></pre><pre><code>const s = () =&gt; {\n  console.log(this)\n}\ns()\n//window\n//注意 babel 环境下输出的 this 是 undefined\n</code></pre><blockquote>\n<p>箭头函数有几个使用注意点。</p>\n<p>（1）函数体内的this对象，就是定义时所在的对象。</p>\n<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>\n</blockquote>\n<h2 id=\"4-Promise\"><a href=\"#4-Promise\" class=\"headerlink\" title=\"4. Promise\"></a>4. Promise</h2><pre><code>let p = new Promise((resolve,reject)=&gt;{\n    setTimeout(resolve,3000,1)\n})\nlet q = new Promise((resolve, reject) =&gt; {\n    reject(&#39;not good time&#39;)\n})\nlet pending = new Promise((resolve,reject)=&gt;{\n\n})\n\n// p ==&gt; fulfilled 1\n// Promise的状态 fulfilled pending rejected\n// Promise的值  \n\n// 3s 后\nlet p1 = p.then(val=&gt;{\n    val += 2;\n    //return 2\n    return new Promise((res, rej) =&gt; {\n        res(2)\n    })\n}).then((val) =&gt; {\n    console.log(val);\n});\n\n//只要 return 的话这个 return 的值就是 p1 的当前的状态\n</code></pre><p><a href=\"https://www.zhihu.com/question/36972010\" target=\"_blank\" rel=\"noopener\">为什么要加 setTimeout</a> 神坑，这里我也不是很懂。</p>\n<p>其实我们只用知道这只是一个异步过程</p>\n<pre><code>let p = new Promise((resolve,reject)=&gt;{\n    setTimeout(resolve,3000,1)\n})\np\n//Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}\n//3s 后\n//Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1}\n</code></pre><h2 id=\"5-Iterator\"><a href=\"#5-Iterator\" class=\"headerlink\" title=\"5. Iterator\"></a>5. Iterator</h2><pre><code>let t = [1,2,3];\n\nfor(let val of t){\n    console.log(val)\n};\n//1 2 3\n</code></pre><pre><code>const s= function(){\n    for(let val of arguments){\n        console.log(val)\n    };\n}\ns(1,2,34);\n//for...of 可以同时处理数组和类数组对象\n//就是说，可以循环一个数据结构\n</code></pre><h2 id=\"6-Class\"><a href=\"#6-Class\" class=\"headerlink\" title=\"6. Class\"></a>6. Class</h2><pre><code>//例子\nclass Test{\n  constructor(){\n    this.a = &#39;a&#39;\n    this.b = &#39;b&#39;    \n  }\n}\n//等于\nlet Test = function(argument){\n  this.a = &#39;a&#39;\n  this.b = &#39;b&#39;\n}\n\nlet inst = new Test()\nconsole.log(inst.a)\n//这个例子是用 class 来实现语法转换的一个例子\n</code></pre><pre><code>//实现面向对象\nlet Test = function(argument){\n  this.a = &#39;a&#39;\n  this.b = &#39;b&#39;\n}\nTest.prototype.c =()=&gt; {console.log(&#39;c&#39;)}\n\nlet inst = new Test()\nconsole.log(inst.c)\n//用 class 来实现\nclass Test{\n  constructor(){\n    this.a = &#39;a&#39;\n    this.b = &#39;b&#39;    \n  }\n  c(){console.log(&#39;c&#39;)}\n}\nlet inst = new Test()\nconsole.log(inst.c())\n//这里会有个 undefined ，因为 console.log(&#39;c&#39;) 并没有返回值\n</code></pre><pre><code>//以前我们写构造函数会这样写\nlet Test = function(argument){\n  this.a = a\n  this.b = b\n}\nTest.prototype.c = function(){\n  return &#39;ddddd&#39;\n}\n//用 class\nclass Test{\n  constructor(){\n    this.a = &#39;a&#39;\n    this.b = &#39;b&#39;\n  }\n  c(){\n    return &#39;ddddd&#39;\n  }\n}\n</code></pre><p>关于 <code>super()</code> 的问题</p>\n<pre><code>class TestSuper {\n  constructor() {\n    this.a = &#39;a&#39;\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = &#39;b&#39;\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:&#39;a&#39;,b:&#39;b&#39;}\n</code></pre><h2 id=\"7-Module\"><a href=\"#7-Module\" class=\"headerlink\" title=\"7. Module\"></a>7. Module</h2><pre><code>//a.js\nfunction f1(){\n  let a = 1\n}\nexport {f1}\n</code></pre><pre><code>//module.js\nimport {f1} from &#39;./let_const.js&#39;\n//相当于\nvar _let_const = require(&#39;./a.js&#39;)\n//只有 nodejs 有 require 函数\n//先把 import...form 转换成 require 的形式\n//用 webpack 来处理 require 函数\n</code></pre><pre><code>a.js ==&gt;  require(&#39;./b.js&#39;).kkkkk\nb.js ==&gt;  require(&#39;./c.js&#39;).kkkkk\nc.js ==&gt;  require(&#39;./a.js&#39;).kkkkk\n\nAMD  define + require\n\nwebpack ==&gt; node.js的fs io体系来把所有的require依赖放在一个文件里面\nbundle.js\n\n(function(moduleArr) {\n    // XXX\n}[\n    a.js ,\n    c.js,\n    d.js\n])()\n</code></pre><p>webpack3 会自己封装一层 require</p>\n<h2 id=\"8-Generator\"><a href=\"#8-Generator\" class=\"headerlink\" title=\"8. Generator\"></a>8. Generator</h2><p>是一种异步编程解决方案</p>\n<p><code>yield</code> 产出</p>\n<pre><code>function* helloWorldGenerator() {\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n  return &#39;ending&#39;;\n};\n//最好仅在 nodejs 上使用 generator\n//yield 执行完之后是停止的\n//需要手动执行 .next()\nvar hw = helloWorldGenerator();\nlet a = hw.next();\nlet b = hw.next();\nlet c = hw.next();\nconsole.log(a,b,c)\n/*\n{ value: &#39;hello&#39;, done: false } { value: &#39;world&#39;, done: false } { value: &#39;ending&#39;, done: true }\n*/\n</code></pre><h2 id=\"ES6-语法测试\"><a href=\"#ES6-语法测试\" class=\"headerlink\" title=\"ES6 语法测试\"></a>ES6 语法测试</h2><ul>\n<li>安装babel命令行</li>\n</ul>\n<pre><code class=\"bash\">$ cnpm install babel-cli\n</code></pre>\n<p><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<p>第一次接触 <code>&#39;use strict&#39;</code> </p>\n<p>看来踩的坑还有点少。</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html\" target=\"_blank\" rel=\"noopener\">Javascript 严格模式详解 - 阮一峰</a></p>\n<p>这只是笔记，多看看阮一峰的 ES6 文档吧。</p>\n"},{"title":"摸到 Promise 的门把手","date":"2017-10-13T16:03:09.000Z","_content":"# Promise\n\n这其实是异步的一种方法。\n\n### 回调函数\n\n```\n//假定有两个函数f1和f2，后者等待前者的执行结果。\nf1()\nf2()\n//如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。\nfunction f1(callback){\n  setTimeout(function(){\n    //f1 的任务代码\n    callback()\n  },1000)\n}\n//是不是有点像 AJAX\n//执行代码就变成下面这样：\nf1(f2)\n//例子\nfunction f2(){\n  let b = 2\n  console.log(b)\n}\n\nfunction f1(callback){\n  setTimeout(function(){    \n    let a = 1\n    console.log(a)\n    callback()\n  },3000)\n}\n\nf1(f2)\n```\n\n### Promises对象\n\n>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供[统一接口](http://wiki.commonjs.org/wiki/Promises/A)。\n>\n>简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n\n注意这个 `then` \n\n```\n//f1 的回调函数 f2\nf1().then(f2)\n//看下面这个例子\nf1().then(f2).then(f3)\n//比如说\n//先执行 f1() 函数\n//执行完后获取一个对象，叫 promise 对象\n//这个 promise 对象呢，它上面有个方法叫做 then\n//所以就调用了 then(f2)\n//如果数据到来之后就会执行 then(f2)\n//这个数据的参数传给 f2\n//then(f2) 执行完后再执行 then(f3)\nf1().then(f2).fail(f3)\n//如果执行失败就执行 fail(f3)\n```\n\n### 为什么要用 Promise\n\n```\n$.get(url, function(data){\n  console.log(data)\n  $.get(url2, function(data){\n    console.log(data)\n    $.get(url3, function(date){\n      ........\n    })\n  })\n})\n//Promise\n$.get(url)\n .then()\n .then()\n .then()\n```\n\n### 如何实现一个 Promise\n\n```\nclass Promise{\n  constructor(){\n    this.callbacks = []    //这个数组存储的是对象\n  }\n  \n  then(onsuccess,onfail){\n    this.callbacks.push({\n      resolve: onsuccess,\n      reject: onfail\n    })\n    return this\n  }\n  \n  resolve(result){\n    this.complete('resolve',result)\n  }\n  \n  reject(result){\n    this.complete('reject',result)\n  }\n  \n  complete(type,result){\n    var callbackObj = this.callbacks.shift()\n    callbackObj[type](result)     //callbackObj[resolve] 等于 fn1 所以就是 fn1(result)\n  }\n  \n}\n\n// function Promise(){\n  \n// }\n\n// Promise.prototype.then = function(){\n  \n// }\n\nvar p = new Promise()\n\nfunction fn() {\n  console.log('fn1')\n  setTimeout(function(){\n    p.resolve('data1')\n  },1000)\n  return p\n}\n\nfunction fn1(result) {\n  console.log('fn1',result)\n  setTimeout(function(){\n    p.resolve('data2')\n//     p.reject()\n    fn2()\n  },2000)\n}\n\nfunction fn2(result) {\n  console.log('fn2',result)\n}\n\nfn().then(fn1).then(fn2)\n//[{resolve:fn1,reject:undefined},{resolve:fn2,reject:undefined}]\n```","source":"_posts/摸到 Promise 的门把手.md","raw":"---\ntitle: 摸到 Promise 的门把手\ndate: 2017-10-14 00:03:09\ntags: [ES6,JavaScript,Black History]\n---\n# Promise\n\n这其实是异步的一种方法。\n\n### 回调函数\n\n```\n//假定有两个函数f1和f2，后者等待前者的执行结果。\nf1()\nf2()\n//如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。\nfunction f1(callback){\n  setTimeout(function(){\n    //f1 的任务代码\n    callback()\n  },1000)\n}\n//是不是有点像 AJAX\n//执行代码就变成下面这样：\nf1(f2)\n//例子\nfunction f2(){\n  let b = 2\n  console.log(b)\n}\n\nfunction f1(callback){\n  setTimeout(function(){    \n    let a = 1\n    console.log(a)\n    callback()\n  },3000)\n}\n\nf1(f2)\n```\n\n### Promises对象\n\n>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供[统一接口](http://wiki.commonjs.org/wiki/Promises/A)。\n>\n>简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n\n注意这个 `then` \n\n```\n//f1 的回调函数 f2\nf1().then(f2)\n//看下面这个例子\nf1().then(f2).then(f3)\n//比如说\n//先执行 f1() 函数\n//执行完后获取一个对象，叫 promise 对象\n//这个 promise 对象呢，它上面有个方法叫做 then\n//所以就调用了 then(f2)\n//如果数据到来之后就会执行 then(f2)\n//这个数据的参数传给 f2\n//then(f2) 执行完后再执行 then(f3)\nf1().then(f2).fail(f3)\n//如果执行失败就执行 fail(f3)\n```\n\n### 为什么要用 Promise\n\n```\n$.get(url, function(data){\n  console.log(data)\n  $.get(url2, function(data){\n    console.log(data)\n    $.get(url3, function(date){\n      ........\n    })\n  })\n})\n//Promise\n$.get(url)\n .then()\n .then()\n .then()\n```\n\n### 如何实现一个 Promise\n\n```\nclass Promise{\n  constructor(){\n    this.callbacks = []    //这个数组存储的是对象\n  }\n  \n  then(onsuccess,onfail){\n    this.callbacks.push({\n      resolve: onsuccess,\n      reject: onfail\n    })\n    return this\n  }\n  \n  resolve(result){\n    this.complete('resolve',result)\n  }\n  \n  reject(result){\n    this.complete('reject',result)\n  }\n  \n  complete(type,result){\n    var callbackObj = this.callbacks.shift()\n    callbackObj[type](result)     //callbackObj[resolve] 等于 fn1 所以就是 fn1(result)\n  }\n  \n}\n\n// function Promise(){\n  \n// }\n\n// Promise.prototype.then = function(){\n  \n// }\n\nvar p = new Promise()\n\nfunction fn() {\n  console.log('fn1')\n  setTimeout(function(){\n    p.resolve('data1')\n  },1000)\n  return p\n}\n\nfunction fn1(result) {\n  console.log('fn1',result)\n  setTimeout(function(){\n    p.resolve('data2')\n//     p.reject()\n    fn2()\n  },2000)\n}\n\nfunction fn2(result) {\n  console.log('fn2',result)\n}\n\nfn().then(fn1).then(fn2)\n//[{resolve:fn1,reject:undefined},{resolve:fn2,reject:undefined}]\n```","slug":"摸到 Promise 的门把手","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8a000cf1xh0k2v72mh","content":"<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><p>这其实是异步的一种方法。</p>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><pre><code>//假定有两个函数f1和f2，后者等待前者的执行结果。\nf1()\nf2()\n//如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。\nfunction f1(callback){\n  setTimeout(function(){\n    //f1 的任务代码\n    callback()\n  },1000)\n}\n//是不是有点像 AJAX\n//执行代码就变成下面这样：\nf1(f2)\n//例子\nfunction f2(){\n  let b = 2\n  console.log(b)\n}\n\nfunction f1(callback){\n  setTimeout(function(){    \n    let a = 1\n    console.log(a)\n    callback()\n  },3000)\n}\n\nf1(f2)\n</code></pre><h3 id=\"Promises对象\"><a href=\"#Promises对象\" class=\"headerlink\" title=\"Promises对象\"></a>Promises对象</h3><blockquote>\n<p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供<a href=\"http://wiki.commonjs.org/wiki/Promises/A\" target=\"_blank\" rel=\"noopener\">统一接口</a>。</p>\n<p>简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。</p>\n</blockquote>\n<p>注意这个 <code>then</code> </p>\n<pre><code>//f1 的回调函数 f2\nf1().then(f2)\n//看下面这个例子\nf1().then(f2).then(f3)\n//比如说\n//先执行 f1() 函数\n//执行完后获取一个对象，叫 promise 对象\n//这个 promise 对象呢，它上面有个方法叫做 then\n//所以就调用了 then(f2)\n//如果数据到来之后就会执行 then(f2)\n//这个数据的参数传给 f2\n//then(f2) 执行完后再执行 then(f3)\nf1().then(f2).fail(f3)\n//如果执行失败就执行 fail(f3)\n</code></pre><h3 id=\"为什么要用-Promise\"><a href=\"#为什么要用-Promise\" class=\"headerlink\" title=\"为什么要用 Promise\"></a>为什么要用 Promise</h3><pre><code>$.get(url, function(data){\n  console.log(data)\n  $.get(url2, function(data){\n    console.log(data)\n    $.get(url3, function(date){\n      ........\n    })\n  })\n})\n//Promise\n$.get(url)\n .then()\n .then()\n .then()\n</code></pre><h3 id=\"如何实现一个-Promise\"><a href=\"#如何实现一个-Promise\" class=\"headerlink\" title=\"如何实现一个 Promise\"></a>如何实现一个 Promise</h3><pre><code>class Promise{\n  constructor(){\n    this.callbacks = []    //这个数组存储的是对象\n  }\n\n  then(onsuccess,onfail){\n    this.callbacks.push({\n      resolve: onsuccess,\n      reject: onfail\n    })\n    return this\n  }\n\n  resolve(result){\n    this.complete(&#39;resolve&#39;,result)\n  }\n\n  reject(result){\n    this.complete(&#39;reject&#39;,result)\n  }\n\n  complete(type,result){\n    var callbackObj = this.callbacks.shift()\n    callbackObj[type](result)     //callbackObj[resolve] 等于 fn1 所以就是 fn1(result)\n  }\n\n}\n\n// function Promise(){\n\n// }\n\n// Promise.prototype.then = function(){\n\n// }\n\nvar p = new Promise()\n\nfunction fn() {\n  console.log(&#39;fn1&#39;)\n  setTimeout(function(){\n    p.resolve(&#39;data1&#39;)\n  },1000)\n  return p\n}\n\nfunction fn1(result) {\n  console.log(&#39;fn1&#39;,result)\n  setTimeout(function(){\n    p.resolve(&#39;data2&#39;)\n//     p.reject()\n    fn2()\n  },2000)\n}\n\nfunction fn2(result) {\n  console.log(&#39;fn2&#39;,result)\n}\n\nfn().then(fn1).then(fn2)\n//[{resolve:fn1,reject:undefined},{resolve:fn2,reject:undefined}]\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><p>这其实是异步的一种方法。</p>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><pre><code>//假定有两个函数f1和f2，后者等待前者的执行结果。\nf1()\nf2()\n//如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。\nfunction f1(callback){\n  setTimeout(function(){\n    //f1 的任务代码\n    callback()\n  },1000)\n}\n//是不是有点像 AJAX\n//执行代码就变成下面这样：\nf1(f2)\n//例子\nfunction f2(){\n  let b = 2\n  console.log(b)\n}\n\nfunction f1(callback){\n  setTimeout(function(){    \n    let a = 1\n    console.log(a)\n    callback()\n  },3000)\n}\n\nf1(f2)\n</code></pre><h3 id=\"Promises对象\"><a href=\"#Promises对象\" class=\"headerlink\" title=\"Promises对象\"></a>Promises对象</h3><blockquote>\n<p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供<a href=\"http://wiki.commonjs.org/wiki/Promises/A\" target=\"_blank\" rel=\"noopener\">统一接口</a>。</p>\n<p>简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。</p>\n</blockquote>\n<p>注意这个 <code>then</code> </p>\n<pre><code>//f1 的回调函数 f2\nf1().then(f2)\n//看下面这个例子\nf1().then(f2).then(f3)\n//比如说\n//先执行 f1() 函数\n//执行完后获取一个对象，叫 promise 对象\n//这个 promise 对象呢，它上面有个方法叫做 then\n//所以就调用了 then(f2)\n//如果数据到来之后就会执行 then(f2)\n//这个数据的参数传给 f2\n//then(f2) 执行完后再执行 then(f3)\nf1().then(f2).fail(f3)\n//如果执行失败就执行 fail(f3)\n</code></pre><h3 id=\"为什么要用-Promise\"><a href=\"#为什么要用-Promise\" class=\"headerlink\" title=\"为什么要用 Promise\"></a>为什么要用 Promise</h3><pre><code>$.get(url, function(data){\n  console.log(data)\n  $.get(url2, function(data){\n    console.log(data)\n    $.get(url3, function(date){\n      ........\n    })\n  })\n})\n//Promise\n$.get(url)\n .then()\n .then()\n .then()\n</code></pre><h3 id=\"如何实现一个-Promise\"><a href=\"#如何实现一个-Promise\" class=\"headerlink\" title=\"如何实现一个 Promise\"></a>如何实现一个 Promise</h3><pre><code>class Promise{\n  constructor(){\n    this.callbacks = []    //这个数组存储的是对象\n  }\n\n  then(onsuccess,onfail){\n    this.callbacks.push({\n      resolve: onsuccess,\n      reject: onfail\n    })\n    return this\n  }\n\n  resolve(result){\n    this.complete(&#39;resolve&#39;,result)\n  }\n\n  reject(result){\n    this.complete(&#39;reject&#39;,result)\n  }\n\n  complete(type,result){\n    var callbackObj = this.callbacks.shift()\n    callbackObj[type](result)     //callbackObj[resolve] 等于 fn1 所以就是 fn1(result)\n  }\n\n}\n\n// function Promise(){\n\n// }\n\n// Promise.prototype.then = function(){\n\n// }\n\nvar p = new Promise()\n\nfunction fn() {\n  console.log(&#39;fn1&#39;)\n  setTimeout(function(){\n    p.resolve(&#39;data1&#39;)\n  },1000)\n  return p\n}\n\nfunction fn1(result) {\n  console.log(&#39;fn1&#39;,result)\n  setTimeout(function(){\n    p.resolve(&#39;data2&#39;)\n//     p.reject()\n    fn2()\n  },2000)\n}\n\nfunction fn2(result) {\n  console.log(&#39;fn2&#39;,result)\n}\n\nfn().then(fn1).then(fn2)\n//[{resolve:fn1,reject:undefined},{resolve:fn2,reject:undefined}]\n</code></pre>"},{"title":"摸到 React 的门把手 (2)","date":"2017-10-13T16:07:46.000Z","_content":"# 摸到 React 的门把手 (2)\n\n经过了上一篇 [摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) 的踩坑，我们现在可以更加深入的看看 React 其中的奥妙了。\n\n## 安装\n\n点击 Get Started 第一个就是 ReactDOM 的 Hello World，我们先别看这些，先看看怎么安装，点击 Installation\n\n那我们就试试 Create a New App \n\n![](http://upload-images.jianshu.io/upload_images/3191557-5c60dc8c2e8b2bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n搞完 `create-react-app my-app` 后会有提示，看看就好，记住这四句命令\n\n![](http://upload-images.jianshu.io/upload_images/3191557-b2844d1fd40c9dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n弹出如下页面就成功了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-237bac3ead01e3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## create-react-app 里面有什么\n\n我们来看一下文件目录\n\n![](http://upload-images.jianshu.io/upload_images/3191557-52e47859bb2f5dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- src 目录，用于存放所有源代码，最重要的就是 index.js 了。和 webpack 那个 index.js 差不多\n- public 目录，用于存放不需要 build 的资源，如 publib/index.html\n\n当我们运行了 `npm run build` 这句话，我们会发现多了一个 build 文件夹，里面的文件全部都压缩过了，感觉有点像 webpack 啊。。\n\n## 试着写写 React \n\n我们把全部文件删掉，然后运行\n\n```\ncreate-react-app .\nnpm start\n```\n\n改 src/inden.js \n\n```\nReactDOM.render(\n    <h1>Hello, world!</h1>,\n    document.getElementById('root')\n)\n```\n\n展现出一个大大的 hello world \n\n我们做点小修改\n\n-  我们把 Hello World 改成 Hi World，只用直接在 `<h1>text</h1>` 这里改就好了。\n\n- 把 document.getElementById('root') 改为 document.getElementById('root2')，哟吼？网页直接显示了报错信息\n\n  ![](http://upload-images.jianshu.io/upload_images/3191557-c625b5538e2c6912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n-  把 publib/index.html 里的 19 行改为 `<div id=\"root2\"></div>`，我们会发现页面有变回去了，说明这些都是相关联的。\n\n-  `<div id=\"root\"></div>` 里添加了在 index.js 写好了的 HTML 代码。\n\n## 将这个应用部署到 GitHub \n\n```\ngit add .\ngit commit -m 'update'\nnpm run build\n```\n\n我们会发现看上去好像已经上传了，但实际上并没有，上网查了查原来是 .gitignore 被 create-react-app 改掉了，你需要删除 .gitignore 里面的 /build 这一行。\n\n然后我们就可以愉快的 push 上去了\n\n嗯？怎么没有效果啊？还记得前面曾经有提示![](http://upload-images.jianshu.io/upload_images/3191557-ece626b7c04a108c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好，我们设置好路径\n\n```\n\"homepage\": \"https://frankietang.github.io/react-demo/build\"\n```\n\n搞定。\n\n## [看看成果](https://github.com/FRANKIETANG/react-demo)","source":"_posts/摸到 React 的门把手 (2).md","raw":"---\ntitle: 摸到 React 的门把手 (2)\ndate: 2017-10-14 00:07:46\ntags: [React,Black History]\n---\n# 摸到 React 的门把手 (2)\n\n经过了上一篇 [摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) 的踩坑，我们现在可以更加深入的看看 React 其中的奥妙了。\n\n## 安装\n\n点击 Get Started 第一个就是 ReactDOM 的 Hello World，我们先别看这些，先看看怎么安装，点击 Installation\n\n那我们就试试 Create a New App \n\n![](http://upload-images.jianshu.io/upload_images/3191557-5c60dc8c2e8b2bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n搞完 `create-react-app my-app` 后会有提示，看看就好，记住这四句命令\n\n![](http://upload-images.jianshu.io/upload_images/3191557-b2844d1fd40c9dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n弹出如下页面就成功了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-237bac3ead01e3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## create-react-app 里面有什么\n\n我们来看一下文件目录\n\n![](http://upload-images.jianshu.io/upload_images/3191557-52e47859bb2f5dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- src 目录，用于存放所有源代码，最重要的就是 index.js 了。和 webpack 那个 index.js 差不多\n- public 目录，用于存放不需要 build 的资源，如 publib/index.html\n\n当我们运行了 `npm run build` 这句话，我们会发现多了一个 build 文件夹，里面的文件全部都压缩过了，感觉有点像 webpack 啊。。\n\n## 试着写写 React \n\n我们把全部文件删掉，然后运行\n\n```\ncreate-react-app .\nnpm start\n```\n\n改 src/inden.js \n\n```\nReactDOM.render(\n    <h1>Hello, world!</h1>,\n    document.getElementById('root')\n)\n```\n\n展现出一个大大的 hello world \n\n我们做点小修改\n\n-  我们把 Hello World 改成 Hi World，只用直接在 `<h1>text</h1>` 这里改就好了。\n\n- 把 document.getElementById('root') 改为 document.getElementById('root2')，哟吼？网页直接显示了报错信息\n\n  ![](http://upload-images.jianshu.io/upload_images/3191557-c625b5538e2c6912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n-  把 publib/index.html 里的 19 行改为 `<div id=\"root2\"></div>`，我们会发现页面有变回去了，说明这些都是相关联的。\n\n-  `<div id=\"root\"></div>` 里添加了在 index.js 写好了的 HTML 代码。\n\n## 将这个应用部署到 GitHub \n\n```\ngit add .\ngit commit -m 'update'\nnpm run build\n```\n\n我们会发现看上去好像已经上传了，但实际上并没有，上网查了查原来是 .gitignore 被 create-react-app 改掉了，你需要删除 .gitignore 里面的 /build 这一行。\n\n然后我们就可以愉快的 push 上去了\n\n嗯？怎么没有效果啊？还记得前面曾经有提示![](http://upload-images.jianshu.io/upload_images/3191557-ece626b7c04a108c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好，我们设置好路径\n\n```\n\"homepage\": \"https://frankietang.github.io/react-demo/build\"\n```\n\n搞定。\n\n## [看看成果](https://github.com/FRANKIETANG/react-demo)","slug":"摸到 React 的门把手 (2)","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8c000ef1xh0pzdmugu","content":"<h1 id=\"摸到-React-的门把手-2\"><a href=\"#摸到-React-的门把手-2\" class=\"headerlink\" title=\"摸到 React 的门把手 (2)\"></a>摸到 React 的门把手 (2)</h1><p>经过了上一篇 <a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a> 的踩坑，我们现在可以更加深入的看看 React 其中的奥妙了。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>点击 Get Started 第一个就是 ReactDOM 的 Hello World，我们先别看这些，先看看怎么安装，点击 Installation</p>\n<p>那我们就试试 Create a New App </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-5c60dc8c2e8b2bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>搞完 <code>create-react-app my-app</code> 后会有提示，看看就好，记住这四句命令</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-b2844d1fd40c9dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>弹出如下页面就成功了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-237bac3ead01e3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"create-react-app-里面有什么\"><a href=\"#create-react-app-里面有什么\" class=\"headerlink\" title=\"create-react-app 里面有什么\"></a>create-react-app 里面有什么</h2><p>我们来看一下文件目录</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-52e47859bb2f5dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ul>\n<li>src 目录，用于存放所有源代码，最重要的就是 index.js 了。和 webpack 那个 index.js 差不多</li>\n<li>public 目录，用于存放不需要 build 的资源，如 publib/index.html</li>\n</ul>\n<p>当我们运行了 <code>npm run build</code> 这句话，我们会发现多了一个 build 文件夹，里面的文件全部都压缩过了，感觉有点像 webpack 啊。。</p>\n<h2 id=\"试着写写-React\"><a href=\"#试着写写-React\" class=\"headerlink\" title=\"试着写写 React\"></a>试着写写 React</h2><p>我们把全部文件删掉，然后运行</p>\n<pre><code>create-react-app .\nnpm start\n</code></pre><p>改 src/inden.js </p>\n<pre><code>ReactDOM.render(\n    &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n    document.getElementById(&#39;root&#39;)\n)\n</code></pre><p>展现出一个大大的 hello world </p>\n<p>我们做点小修改</p>\n<ul>\n<li><p>我们把 Hello World 改成 Hi World，只用直接在 <code>&lt;h1&gt;text&lt;/h1&gt;</code> 这里改就好了。</p>\n</li>\n<li><p>把 document.getElementById(‘root’) 改为 document.getElementById(‘root2’)，哟吼？网页直接显示了报错信息</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c625b5538e2c6912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>把 publib/index.html 里的 19 行改为 <code>&lt;div id=&quot;root2&quot;&gt;&lt;/div&gt;</code>，我们会发现页面有变回去了，说明这些都是相关联的。</p>\n</li>\n<li><p><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 里添加了在 index.js 写好了的 HTML 代码。</p>\n</li>\n</ul>\n<h2 id=\"将这个应用部署到-GitHub\"><a href=\"#将这个应用部署到-GitHub\" class=\"headerlink\" title=\"将这个应用部署到 GitHub\"></a>将这个应用部署到 GitHub</h2><pre><code>git add .\ngit commit -m &#39;update&#39;\nnpm run build\n</code></pre><p>我们会发现看上去好像已经上传了，但实际上并没有，上网查了查原来是 .gitignore 被 create-react-app 改掉了，你需要删除 .gitignore 里面的 /build 这一行。</p>\n<p>然后我们就可以愉快的 push 上去了</p>\n<p>嗯？怎么没有效果啊？还记得前面曾经有提示<img src=\"http://upload-images.jianshu.io/upload_images/3191557-ece626b7c04a108c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>好，我们设置好路径</p>\n<pre><code>&quot;homepage&quot;: &quot;https://frankietang.github.io/react-demo/build&quot;\n</code></pre><p>搞定。</p>\n<h2 id=\"看看成果\"><a href=\"#看看成果\" class=\"headerlink\" title=\"看看成果\"></a><a href=\"https://github.com/FRANKIETANG/react-demo\" target=\"_blank\" rel=\"noopener\">看看成果</a></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-React-的门把手-2\"><a href=\"#摸到-React-的门把手-2\" class=\"headerlink\" title=\"摸到 React 的门把手 (2)\"></a>摸到 React 的门把手 (2)</h1><p>经过了上一篇 <a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a> 的踩坑，我们现在可以更加深入的看看 React 其中的奥妙了。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>点击 Get Started 第一个就是 ReactDOM 的 Hello World，我们先别看这些，先看看怎么安装，点击 Installation</p>\n<p>那我们就试试 Create a New App </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-5c60dc8c2e8b2bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>搞完 <code>create-react-app my-app</code> 后会有提示，看看就好，记住这四句命令</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-b2844d1fd40c9dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>弹出如下页面就成功了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-237bac3ead01e3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"create-react-app-里面有什么\"><a href=\"#create-react-app-里面有什么\" class=\"headerlink\" title=\"create-react-app 里面有什么\"></a>create-react-app 里面有什么</h2><p>我们来看一下文件目录</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-52e47859bb2f5dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ul>\n<li>src 目录，用于存放所有源代码，最重要的就是 index.js 了。和 webpack 那个 index.js 差不多</li>\n<li>public 目录，用于存放不需要 build 的资源，如 publib/index.html</li>\n</ul>\n<p>当我们运行了 <code>npm run build</code> 这句话，我们会发现多了一个 build 文件夹，里面的文件全部都压缩过了，感觉有点像 webpack 啊。。</p>\n<h2 id=\"试着写写-React\"><a href=\"#试着写写-React\" class=\"headerlink\" title=\"试着写写 React\"></a>试着写写 React</h2><p>我们把全部文件删掉，然后运行</p>\n<pre><code>create-react-app .\nnpm start\n</code></pre><p>改 src/inden.js </p>\n<pre><code>ReactDOM.render(\n    &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n    document.getElementById(&#39;root&#39;)\n)\n</code></pre><p>展现出一个大大的 hello world </p>\n<p>我们做点小修改</p>\n<ul>\n<li><p>我们把 Hello World 改成 Hi World，只用直接在 <code>&lt;h1&gt;text&lt;/h1&gt;</code> 这里改就好了。</p>\n</li>\n<li><p>把 document.getElementById(‘root’) 改为 document.getElementById(‘root2’)，哟吼？网页直接显示了报错信息</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c625b5538e2c6912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>把 publib/index.html 里的 19 行改为 <code>&lt;div id=&quot;root2&quot;&gt;&lt;/div&gt;</code>，我们会发现页面有变回去了，说明这些都是相关联的。</p>\n</li>\n<li><p><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 里添加了在 index.js 写好了的 HTML 代码。</p>\n</li>\n</ul>\n<h2 id=\"将这个应用部署到-GitHub\"><a href=\"#将这个应用部署到-GitHub\" class=\"headerlink\" title=\"将这个应用部署到 GitHub\"></a>将这个应用部署到 GitHub</h2><pre><code>git add .\ngit commit -m &#39;update&#39;\nnpm run build\n</code></pre><p>我们会发现看上去好像已经上传了，但实际上并没有，上网查了查原来是 .gitignore 被 create-react-app 改掉了，你需要删除 .gitignore 里面的 /build 这一行。</p>\n<p>然后我们就可以愉快的 push 上去了</p>\n<p>嗯？怎么没有效果啊？还记得前面曾经有提示<img src=\"http://upload-images.jianshu.io/upload_images/3191557-ece626b7c04a108c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>好，我们设置好路径</p>\n<pre><code>&quot;homepage&quot;: &quot;https://frankietang.github.io/react-demo/build&quot;\n</code></pre><p>搞定。</p>\n<h2 id=\"看看成果\"><a href=\"#看看成果\" class=\"headerlink\" title=\"看看成果\"></a><a href=\"https://github.com/FRANKIETANG/react-demo\" target=\"_blank\" rel=\"noopener\">看看成果</a></h2>"},{"title":"摸到 React 的门把手 (3)","date":"2017-10-13T16:08:13.000Z","_content":"# 摸到 React 的门把手 (3)\n\n经过了上几篇文章 [摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) [摸到 React 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(2)/) 的踩坑，我们估计很快就可以摸到门把手了。\n\n## 关于 JSX\n\n实际上 JSX 并不是 JavaScript 和 HTML 的结合，而是和 XML 的结合，就像这样。[https://babeljs.io/repl/](https://babeljs.io/repl/)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-264608323011334e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[Introducing - JSX](https://facebook.github.io/react/docs/introducing-jsx.html)\n\n## 关于 React 的虚拟 DOM\n\n> 你用这些 XML 写出来的标签，都不会出现在页面里，只会出现在内存里。React 会使用虚拟 DOM 计算出真正的页面结构，然后再更新到页面中（真正的 DOM 操作）。\n>\n> 让 JS 操作内存肯定比操作 DOM 要快很多。\n\n![.](http://upload-images.jianshu.io/upload_images/3191557-04a725ede551ad1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看看这一段代码：\n\n- 用 XML 语法声明一个 h1\n- babel 将 h1 转为 React Element（虚拟元素）\n- React 将虚拟元素转化为真正的 DOM，插入到 #root 里。\n\n## 按需更新\n\n>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to `ReactDOM.render()`.\n\n所以说更新一个元素的唯一方法就是新的元素\n\n我们改一下 index.js\n\n```\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n这个示例通过 [`setInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval) 方法，每秒钟调用一次 `ReactDOM.render()`.\n\n## 组件\n\n```\nclass Welcome extends React.Component {\n    render() {\n        return <h1>Component</h1>\n    }\n}\n\nReactDOM.render(\n    <Welcome/>,\n    document.getElementById('root')\n)\n```\n\n这样我们就造了一个 `<Welcome/>` 的组件\n\n`extends React.Component` 不能删掉。\n\n## 组件成为一个单独代码\n\n```\n//src/Welcome.js\nimport React from 'react'\n\nclass Welcome extends React.Component {\n    render() {\n        return <h1>Component</h1>\n    }\n}\n\nexport default Welcome\n```\n\n`import React from 'react'` 这个是引用 React ，不写这一句就在这个组件代码里就用不了 `React.Component`\n\n`export` 和 `export default` 作用是导出常量/函数/文件/模块 这些\n\n`export` 和 `import` 可以有多个，`export default` 只能有一个\n\n`export` 导出导入的时候要加 {}，`export default` 则不需要\n\n[ES6：export default 和 export 区别](http://www.jianshu.com/p/edaf43e9384f)\n\n```\n//src/index.js\nimport Welcome from './Welcome'\n\nReactDOM.render(\n  <Welcome/>,\n  document.getElementById('root')\n)\n```\n\n## props\n\n```\n//src/Welcome.js\nclass Welcome extends React.Component {\n    render() {\n        return <h1>I am {this.props.name}</h1>\n    }\n}\n//其中 class Welcome 变成 funciton Welcome\n```\n\n```\nReactDOM.render(\n    <Welcome name=\"tangkalun\"/>,\n    document.getElementById('root')\n)\n```\n\n## state\n\n>组件不能改变得到的 props，那么组件中可以变的东西放在哪呢？答案是 state（函数形式的组件不支持 state）。\n\n```\n//src/Welcome.js\nclass Welcome extends React.Component {\n    constructor(props){\n        super(props)\n        this.state = {\n            date: new Date()\n        }\n    }\n    render() {\n        return (\n            <div>\n                <h1>I am {this.props.name}</h1>\n                <h2>{this.state.date.toString()}.</h2>                \n            </div>\n        )\n    }\n}\n```\n\n## 改变 state\n\n这里我们可以用 `setState()` 来改变 state。\n\n```\n//在 constructor 里加\nsetInterval(function(){\n  this.state = {\n    date: new Date()\n  }\n})\n```\n\n这上面的代码是有问题的，实际上还要 `.bind(this)`\n\n```\nsetInterval(function(){\n  this.setState({\n    date: new Date()\n  })\n}.bind(this))\n```\n\n> The callback is made in a different context. You need to `bind` to `this` in order to have access inside the callback\n\n[React this.setState is not a function](https://stackoverflow.com/questions/31045716/react-this-setstate-is-not-a-function)\n\n[setState：这个API设计到底怎么样](https://zhuanlan.zhihu.com/p/25954470)\n\n我讨厌 setState 这个 API\n\n## 生命周期\n\n[The Component Lifecycle](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle)\n\nReact 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）\n\n### mount\n\n> mount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。\n>\n> 这个过程会暴露几个钩子（hook）方便你往里面加代码：\n>\n> - `constructor()` 初始化 props 和 state\n> - `componentWillMount()` 我要插入了\n> - `render()` 将 render 里的 return 的内容插入到页面中\n> - `componentDidMount()` 插进去后该做点什么吗？\n\ncommit: [钩子](https://github.com/FRANKIETANG/react-demo/commit/cad040489620cf5b4f7e02a571cb2e3c06803932)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-c31f16851c918ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### update\n\n>mount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子：\n>\n>- `componentWillReceiveProps(nextProps)` - 我要读取 props 啦！\n>- `shouldComponentUpdate(nextProps, nextState)` - 请问要不要更新组件？true / false\n>- `componentWillUpdate()` - 我要更新组件啦！\n>- `render()` - 更新！\n>- `componentDidUpdate()` - 更新完毕啦！\n\n### unmount\n\n>当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子：\n>\n>- componentWillUnmount() - 我要死啦！\n\n## setState 应该放在哪？\n\ncommit: [哪些钩子里面可以加 setState](https://github.com/FRANKIETANG/react-demo/commit/3b2061343d754f2975356ef4502d445e943eef5a)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-6dc701032129deb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里面有三个错误\n\n第一个错误说明不能在 constructor 里面 setState\n\n第二个错误说明不能在 render 里面 setState\n\n第三个错误说明 Welcome.shouldComponentUpdate 必须返回 boolean value，那我们改改\n\n![](http://upload-images.jianshu.io/upload_images/3191557-ace3aae6e3f84a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好吧错误都是 render 的，那就都删掉吧。\n\n还是会有 bug 原因是在 componentWillUpdate 和 componentDidUpdate 里 setState 了，因为每次 setState 都会触发这两个钩子，而这两个钩子却又触发了 setState。\n\n所以只能在这几个钩子里 setState：\n\n- `componentWillMount`\n- `componentDidMount`\n- `componentWillReceiveProps`\n- `componentDidUpdate`\n\n## [看看成果](https://github.com/FRANKIETANG/react-demo)","source":"_posts/摸到 React 的门把手 (3).md","raw":"---\ntitle: 摸到 React 的门把手 (3)\ndate: 2017-10-14 00:08:13\ntags: [React,Black History]\n---\n# 摸到 React 的门把手 (3)\n\n经过了上几篇文章 [摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) [摸到 React 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(2)/) 的踩坑，我们估计很快就可以摸到门把手了。\n\n## 关于 JSX\n\n实际上 JSX 并不是 JavaScript 和 HTML 的结合，而是和 XML 的结合，就像这样。[https://babeljs.io/repl/](https://babeljs.io/repl/)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-264608323011334e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[Introducing - JSX](https://facebook.github.io/react/docs/introducing-jsx.html)\n\n## 关于 React 的虚拟 DOM\n\n> 你用这些 XML 写出来的标签，都不会出现在页面里，只会出现在内存里。React 会使用虚拟 DOM 计算出真正的页面结构，然后再更新到页面中（真正的 DOM 操作）。\n>\n> 让 JS 操作内存肯定比操作 DOM 要快很多。\n\n![.](http://upload-images.jianshu.io/upload_images/3191557-04a725ede551ad1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看看这一段代码：\n\n- 用 XML 语法声明一个 h1\n- babel 将 h1 转为 React Element（虚拟元素）\n- React 将虚拟元素转化为真正的 DOM，插入到 #root 里。\n\n## 按需更新\n\n>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to `ReactDOM.render()`.\n\n所以说更新一个元素的唯一方法就是新的元素\n\n我们改一下 index.js\n\n```\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n这个示例通过 [`setInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval) 方法，每秒钟调用一次 `ReactDOM.render()`.\n\n## 组件\n\n```\nclass Welcome extends React.Component {\n    render() {\n        return <h1>Component</h1>\n    }\n}\n\nReactDOM.render(\n    <Welcome/>,\n    document.getElementById('root')\n)\n```\n\n这样我们就造了一个 `<Welcome/>` 的组件\n\n`extends React.Component` 不能删掉。\n\n## 组件成为一个单独代码\n\n```\n//src/Welcome.js\nimport React from 'react'\n\nclass Welcome extends React.Component {\n    render() {\n        return <h1>Component</h1>\n    }\n}\n\nexport default Welcome\n```\n\n`import React from 'react'` 这个是引用 React ，不写这一句就在这个组件代码里就用不了 `React.Component`\n\n`export` 和 `export default` 作用是导出常量/函数/文件/模块 这些\n\n`export` 和 `import` 可以有多个，`export default` 只能有一个\n\n`export` 导出导入的时候要加 {}，`export default` 则不需要\n\n[ES6：export default 和 export 区别](http://www.jianshu.com/p/edaf43e9384f)\n\n```\n//src/index.js\nimport Welcome from './Welcome'\n\nReactDOM.render(\n  <Welcome/>,\n  document.getElementById('root')\n)\n```\n\n## props\n\n```\n//src/Welcome.js\nclass Welcome extends React.Component {\n    render() {\n        return <h1>I am {this.props.name}</h1>\n    }\n}\n//其中 class Welcome 变成 funciton Welcome\n```\n\n```\nReactDOM.render(\n    <Welcome name=\"tangkalun\"/>,\n    document.getElementById('root')\n)\n```\n\n## state\n\n>组件不能改变得到的 props，那么组件中可以变的东西放在哪呢？答案是 state（函数形式的组件不支持 state）。\n\n```\n//src/Welcome.js\nclass Welcome extends React.Component {\n    constructor(props){\n        super(props)\n        this.state = {\n            date: new Date()\n        }\n    }\n    render() {\n        return (\n            <div>\n                <h1>I am {this.props.name}</h1>\n                <h2>{this.state.date.toString()}.</h2>                \n            </div>\n        )\n    }\n}\n```\n\n## 改变 state\n\n这里我们可以用 `setState()` 来改变 state。\n\n```\n//在 constructor 里加\nsetInterval(function(){\n  this.state = {\n    date: new Date()\n  }\n})\n```\n\n这上面的代码是有问题的，实际上还要 `.bind(this)`\n\n```\nsetInterval(function(){\n  this.setState({\n    date: new Date()\n  })\n}.bind(this))\n```\n\n> The callback is made in a different context. You need to `bind` to `this` in order to have access inside the callback\n\n[React this.setState is not a function](https://stackoverflow.com/questions/31045716/react-this-setstate-is-not-a-function)\n\n[setState：这个API设计到底怎么样](https://zhuanlan.zhihu.com/p/25954470)\n\n我讨厌 setState 这个 API\n\n## 生命周期\n\n[The Component Lifecycle](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle)\n\nReact 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）\n\n### mount\n\n> mount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。\n>\n> 这个过程会暴露几个钩子（hook）方便你往里面加代码：\n>\n> - `constructor()` 初始化 props 和 state\n> - `componentWillMount()` 我要插入了\n> - `render()` 将 render 里的 return 的内容插入到页面中\n> - `componentDidMount()` 插进去后该做点什么吗？\n\ncommit: [钩子](https://github.com/FRANKIETANG/react-demo/commit/cad040489620cf5b4f7e02a571cb2e3c06803932)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-c31f16851c918ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### update\n\n>mount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子：\n>\n>- `componentWillReceiveProps(nextProps)` - 我要读取 props 啦！\n>- `shouldComponentUpdate(nextProps, nextState)` - 请问要不要更新组件？true / false\n>- `componentWillUpdate()` - 我要更新组件啦！\n>- `render()` - 更新！\n>- `componentDidUpdate()` - 更新完毕啦！\n\n### unmount\n\n>当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子：\n>\n>- componentWillUnmount() - 我要死啦！\n\n## setState 应该放在哪？\n\ncommit: [哪些钩子里面可以加 setState](https://github.com/FRANKIETANG/react-demo/commit/3b2061343d754f2975356ef4502d445e943eef5a)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-6dc701032129deb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里面有三个错误\n\n第一个错误说明不能在 constructor 里面 setState\n\n第二个错误说明不能在 render 里面 setState\n\n第三个错误说明 Welcome.shouldComponentUpdate 必须返回 boolean value，那我们改改\n\n![](http://upload-images.jianshu.io/upload_images/3191557-ace3aae6e3f84a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好吧错误都是 render 的，那就都删掉吧。\n\n还是会有 bug 原因是在 componentWillUpdate 和 componentDidUpdate 里 setState 了，因为每次 setState 都会触发这两个钩子，而这两个钩子却又触发了 setState。\n\n所以只能在这几个钩子里 setState：\n\n- `componentWillMount`\n- `componentDidMount`\n- `componentWillReceiveProps`\n- `componentDidUpdate`\n\n## [看看成果](https://github.com/FRANKIETANG/react-demo)","slug":"摸到 React 的门把手 (3)","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8e000ff1xhkdzwsw43","content":"<h1 id=\"摸到-React-的门把手-3\"><a href=\"#摸到-React-的门把手-3\" class=\"headerlink\" title=\"摸到 React 的门把手 (3)\"></a>摸到 React 的门把手 (3)</h1><p>经过了上几篇文章 <a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a> <a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(2\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (2)</a>/) 的踩坑，我们估计很快就可以摸到门把手了。</p>\n<h2 id=\"关于-JSX\"><a href=\"#关于-JSX\" class=\"headerlink\" title=\"关于 JSX\"></a>关于 JSX</h2><p>实际上 JSX 并不是 JavaScript 和 HTML 的结合，而是和 XML 的结合，就像这样。<a href=\"https://babeljs.io/repl/\" target=\"_blank\" rel=\"noopener\">https://babeljs.io/repl/</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-264608323011334e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><a href=\"https://facebook.github.io/react/docs/introducing-jsx.html\" target=\"_blank\" rel=\"noopener\">Introducing - JSX</a></p>\n<h2 id=\"关于-React-的虚拟-DOM\"><a href=\"#关于-React-的虚拟-DOM\" class=\"headerlink\" title=\"关于 React 的虚拟 DOM\"></a>关于 React 的虚拟 DOM</h2><blockquote>\n<p>你用这些 XML 写出来的标签，都不会出现在页面里，只会出现在内存里。React 会使用虚拟 DOM 计算出真正的页面结构，然后再更新到页面中（真正的 DOM 操作）。</p>\n<p>让 JS 操作内存肯定比操作 DOM 要快很多。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-04a725ede551ad1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\".\"></p>\n<p>看看这一段代码：</p>\n<ul>\n<li>用 XML 语法声明一个 h1</li>\n<li>babel 将 h1 转为 React Element（虚拟元素）</li>\n<li>React 将虚拟元素转化为真正的 DOM，插入到 #root 里。</li>\n</ul>\n<h2 id=\"按需更新\"><a href=\"#按需更新\" class=\"headerlink\" title=\"按需更新\"></a>按需更新</h2><blockquote>\n<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>\n</blockquote>\n<p>所以说更新一个元素的唯一方法就是新的元素</p>\n<p>我们改一下 index.js</p>\n<pre><code>function tick() {\n  const element = (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById(&#39;root&#39;)\n  );\n}\n\nsetInterval(tick, 1000);\n</code></pre><p>这个示例通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval\" target=\"_blank\" rel=\"noopener\"><code>setInterval()</code></a> 方法，每秒钟调用一次 <code>ReactDOM.render()</code>.</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><pre><code>class Welcome extends React.Component {\n    render() {\n        return &lt;h1&gt;Component&lt;/h1&gt;\n    }\n}\n\nReactDOM.render(\n    &lt;Welcome/&gt;,\n    document.getElementById(&#39;root&#39;)\n)\n</code></pre><p>这样我们就造了一个 <code>&lt;Welcome/&gt;</code> 的组件</p>\n<p><code>extends React.Component</code> 不能删掉。</p>\n<h2 id=\"组件成为一个单独代码\"><a href=\"#组件成为一个单独代码\" class=\"headerlink\" title=\"组件成为一个单独代码\"></a>组件成为一个单独代码</h2><pre><code>//src/Welcome.js\nimport React from &#39;react&#39;\n\nclass Welcome extends React.Component {\n    render() {\n        return &lt;h1&gt;Component&lt;/h1&gt;\n    }\n}\n\nexport default Welcome\n</code></pre><p><code>import React from &#39;react&#39;</code> 这个是引用 React ，不写这一句就在这个组件代码里就用不了 <code>React.Component</code></p>\n<p><code>export</code> 和 <code>export default</code> 作用是导出常量/函数/文件/模块 这些</p>\n<p><code>export</code> 和 <code>import</code> 可以有多个，<code>export default</code> 只能有一个</p>\n<p><code>export</code> 导出导入的时候要加 {}，<code>export default</code> 则不需要</p>\n<p><a href=\"http://www.jianshu.com/p/edaf43e9384f\" target=\"_blank\" rel=\"noopener\">ES6：export default 和 export 区别</a></p>\n<pre><code>//src/index.js\nimport Welcome from &#39;./Welcome&#39;\n\nReactDOM.render(\n  &lt;Welcome/&gt;,\n  document.getElementById(&#39;root&#39;)\n)\n</code></pre><h2 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h2><pre><code>//src/Welcome.js\nclass Welcome extends React.Component {\n    render() {\n        return &lt;h1&gt;I am {this.props.name}&lt;/h1&gt;\n    }\n}\n//其中 class Welcome 变成 funciton Welcome\n</code></pre><pre><code>ReactDOM.render(\n    &lt;Welcome name=&quot;tangkalun&quot;/&gt;,\n    document.getElementById(&#39;root&#39;)\n)\n</code></pre><h2 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h2><blockquote>\n<p>组件不能改变得到的 props，那么组件中可以变的东西放在哪呢？答案是 state（函数形式的组件不支持 state）。</p>\n</blockquote>\n<pre><code>//src/Welcome.js\nclass Welcome extends React.Component {\n    constructor(props){\n        super(props)\n        this.state = {\n            date: new Date()\n        }\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;I am {this.props.name}&lt;/h1&gt;\n                &lt;h2&gt;{this.state.date.toString()}.&lt;/h2&gt;                \n            &lt;/div&gt;\n        )\n    }\n}\n</code></pre><h2 id=\"改变-state\"><a href=\"#改变-state\" class=\"headerlink\" title=\"改变 state\"></a>改变 state</h2><p>这里我们可以用 <code>setState()</code> 来改变 state。</p>\n<pre><code>//在 constructor 里加\nsetInterval(function(){\n  this.state = {\n    date: new Date()\n  }\n})\n</code></pre><p>这上面的代码是有问题的，实际上还要 <code>.bind(this)</code></p>\n<pre><code>setInterval(function(){\n  this.setState({\n    date: new Date()\n  })\n}.bind(this))\n</code></pre><blockquote>\n<p>The callback is made in a different context. You need to <code>bind</code> to <code>this</code> in order to have access inside the callback</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/31045716/react-this-setstate-is-not-a-function\" target=\"_blank\" rel=\"noopener\">React this.setState is not a function</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/25954470\" target=\"_blank\" rel=\"noopener\">setState：这个API设计到底怎么样</a></p>\n<p>我讨厌 setState 这个 API</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p><a href=\"https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle\" target=\"_blank\" rel=\"noopener\">The Component Lifecycle</a></p>\n<p>React 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><blockquote>\n<p>mount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。</p>\n<p>这个过程会暴露几个钩子（hook）方便你往里面加代码：</p>\n<ul>\n<li><code>constructor()</code> 初始化 props 和 state</li>\n<li><code>componentWillMount()</code> 我要插入了</li>\n<li><code>render()</code> 将 render 里的 return 的内容插入到页面中</li>\n<li><code>componentDidMount()</code> 插进去后该做点什么吗？</li>\n</ul>\n</blockquote>\n<p>commit: <a href=\"https://github.com/FRANKIETANG/react-demo/commit/cad040489620cf5b4f7e02a571cb2e3c06803932\" target=\"_blank\" rel=\"noopener\">钩子</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c31f16851c918ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update\"></a>update</h3><blockquote>\n<p>mount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子：</p>\n<ul>\n<li><code>componentWillReceiveProps(nextProps)</code> - 我要读取 props 啦！</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code> - 请问要不要更新组件？true / false</li>\n<li><code>componentWillUpdate()</code> - 我要更新组件啦！</li>\n<li><code>render()</code> - 更新！</li>\n<li><code>componentDidUpdate()</code> - 更新完毕啦！</li>\n</ul>\n</blockquote>\n<h3 id=\"unmount\"><a href=\"#unmount\" class=\"headerlink\" title=\"unmount\"></a>unmount</h3><blockquote>\n<p>当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子：</p>\n<ul>\n<li>componentWillUnmount() - 我要死啦！</li>\n</ul>\n</blockquote>\n<h2 id=\"setState-应该放在哪？\"><a href=\"#setState-应该放在哪？\" class=\"headerlink\" title=\"setState 应该放在哪？\"></a>setState 应该放在哪？</h2><p>commit: <a href=\"https://github.com/FRANKIETANG/react-demo/commit/3b2061343d754f2975356ef4502d445e943eef5a\" target=\"_blank\" rel=\"noopener\">哪些钩子里面可以加 setState</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-6dc701032129deb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里面有三个错误</p>\n<p>第一个错误说明不能在 constructor 里面 setState</p>\n<p>第二个错误说明不能在 render 里面 setState</p>\n<p>第三个错误说明 Welcome.shouldComponentUpdate 必须返回 boolean value，那我们改改</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-ace3aae6e3f84a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>好吧错误都是 render 的，那就都删掉吧。</p>\n<p>还是会有 bug 原因是在 componentWillUpdate 和 componentDidUpdate 里 setState 了，因为每次 setState 都会触发这两个钩子，而这两个钩子却又触发了 setState。</p>\n<p>所以只能在这几个钩子里 setState：</p>\n<ul>\n<li><code>componentWillMount</code></li>\n<li><code>componentDidMount</code></li>\n<li><code>componentWillReceiveProps</code></li>\n<li><code>componentDidUpdate</code></li>\n</ul>\n<h2 id=\"看看成果\"><a href=\"#看看成果\" class=\"headerlink\" title=\"看看成果\"></a><a href=\"https://github.com/FRANKIETANG/react-demo\" target=\"_blank\" rel=\"noopener\">看看成果</a></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-React-的门把手-3\"><a href=\"#摸到-React-的门把手-3\" class=\"headerlink\" title=\"摸到 React 的门把手 (3)\"></a>摸到 React 的门把手 (3)</h1><p>经过了上几篇文章 <a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a> <a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(2\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (2)</a>/) 的踩坑，我们估计很快就可以摸到门把手了。</p>\n<h2 id=\"关于-JSX\"><a href=\"#关于-JSX\" class=\"headerlink\" title=\"关于 JSX\"></a>关于 JSX</h2><p>实际上 JSX 并不是 JavaScript 和 HTML 的结合，而是和 XML 的结合，就像这样。<a href=\"https://babeljs.io/repl/\" target=\"_blank\" rel=\"noopener\">https://babeljs.io/repl/</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-264608323011334e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><a href=\"https://facebook.github.io/react/docs/introducing-jsx.html\" target=\"_blank\" rel=\"noopener\">Introducing - JSX</a></p>\n<h2 id=\"关于-React-的虚拟-DOM\"><a href=\"#关于-React-的虚拟-DOM\" class=\"headerlink\" title=\"关于 React 的虚拟 DOM\"></a>关于 React 的虚拟 DOM</h2><blockquote>\n<p>你用这些 XML 写出来的标签，都不会出现在页面里，只会出现在内存里。React 会使用虚拟 DOM 计算出真正的页面结构，然后再更新到页面中（真正的 DOM 操作）。</p>\n<p>让 JS 操作内存肯定比操作 DOM 要快很多。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-04a725ede551ad1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\".\"></p>\n<p>看看这一段代码：</p>\n<ul>\n<li>用 XML 语法声明一个 h1</li>\n<li>babel 将 h1 转为 React Element（虚拟元素）</li>\n<li>React 将虚拟元素转化为真正的 DOM，插入到 #root 里。</li>\n</ul>\n<h2 id=\"按需更新\"><a href=\"#按需更新\" class=\"headerlink\" title=\"按需更新\"></a>按需更新</h2><blockquote>\n<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>\n</blockquote>\n<p>所以说更新一个元素的唯一方法就是新的元素</p>\n<p>我们改一下 index.js</p>\n<pre><code>function tick() {\n  const element = (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById(&#39;root&#39;)\n  );\n}\n\nsetInterval(tick, 1000);\n</code></pre><p>这个示例通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval\" target=\"_blank\" rel=\"noopener\"><code>setInterval()</code></a> 方法，每秒钟调用一次 <code>ReactDOM.render()</code>.</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><pre><code>class Welcome extends React.Component {\n    render() {\n        return &lt;h1&gt;Component&lt;/h1&gt;\n    }\n}\n\nReactDOM.render(\n    &lt;Welcome/&gt;,\n    document.getElementById(&#39;root&#39;)\n)\n</code></pre><p>这样我们就造了一个 <code>&lt;Welcome/&gt;</code> 的组件</p>\n<p><code>extends React.Component</code> 不能删掉。</p>\n<h2 id=\"组件成为一个单独代码\"><a href=\"#组件成为一个单独代码\" class=\"headerlink\" title=\"组件成为一个单独代码\"></a>组件成为一个单独代码</h2><pre><code>//src/Welcome.js\nimport React from &#39;react&#39;\n\nclass Welcome extends React.Component {\n    render() {\n        return &lt;h1&gt;Component&lt;/h1&gt;\n    }\n}\n\nexport default Welcome\n</code></pre><p><code>import React from &#39;react&#39;</code> 这个是引用 React ，不写这一句就在这个组件代码里就用不了 <code>React.Component</code></p>\n<p><code>export</code> 和 <code>export default</code> 作用是导出常量/函数/文件/模块 这些</p>\n<p><code>export</code> 和 <code>import</code> 可以有多个，<code>export default</code> 只能有一个</p>\n<p><code>export</code> 导出导入的时候要加 {}，<code>export default</code> 则不需要</p>\n<p><a href=\"http://www.jianshu.com/p/edaf43e9384f\" target=\"_blank\" rel=\"noopener\">ES6：export default 和 export 区别</a></p>\n<pre><code>//src/index.js\nimport Welcome from &#39;./Welcome&#39;\n\nReactDOM.render(\n  &lt;Welcome/&gt;,\n  document.getElementById(&#39;root&#39;)\n)\n</code></pre><h2 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h2><pre><code>//src/Welcome.js\nclass Welcome extends React.Component {\n    render() {\n        return &lt;h1&gt;I am {this.props.name}&lt;/h1&gt;\n    }\n}\n//其中 class Welcome 变成 funciton Welcome\n</code></pre><pre><code>ReactDOM.render(\n    &lt;Welcome name=&quot;tangkalun&quot;/&gt;,\n    document.getElementById(&#39;root&#39;)\n)\n</code></pre><h2 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h2><blockquote>\n<p>组件不能改变得到的 props，那么组件中可以变的东西放在哪呢？答案是 state（函数形式的组件不支持 state）。</p>\n</blockquote>\n<pre><code>//src/Welcome.js\nclass Welcome extends React.Component {\n    constructor(props){\n        super(props)\n        this.state = {\n            date: new Date()\n        }\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;I am {this.props.name}&lt;/h1&gt;\n                &lt;h2&gt;{this.state.date.toString()}.&lt;/h2&gt;                \n            &lt;/div&gt;\n        )\n    }\n}\n</code></pre><h2 id=\"改变-state\"><a href=\"#改变-state\" class=\"headerlink\" title=\"改变 state\"></a>改变 state</h2><p>这里我们可以用 <code>setState()</code> 来改变 state。</p>\n<pre><code>//在 constructor 里加\nsetInterval(function(){\n  this.state = {\n    date: new Date()\n  }\n})\n</code></pre><p>这上面的代码是有问题的，实际上还要 <code>.bind(this)</code></p>\n<pre><code>setInterval(function(){\n  this.setState({\n    date: new Date()\n  })\n}.bind(this))\n</code></pre><blockquote>\n<p>The callback is made in a different context. You need to <code>bind</code> to <code>this</code> in order to have access inside the callback</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/31045716/react-this-setstate-is-not-a-function\" target=\"_blank\" rel=\"noopener\">React this.setState is not a function</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/25954470\" target=\"_blank\" rel=\"noopener\">setState：这个API设计到底怎么样</a></p>\n<p>我讨厌 setState 这个 API</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p><a href=\"https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle\" target=\"_blank\" rel=\"noopener\">The Component Lifecycle</a></p>\n<p>React 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><blockquote>\n<p>mount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。</p>\n<p>这个过程会暴露几个钩子（hook）方便你往里面加代码：</p>\n<ul>\n<li><code>constructor()</code> 初始化 props 和 state</li>\n<li><code>componentWillMount()</code> 我要插入了</li>\n<li><code>render()</code> 将 render 里的 return 的内容插入到页面中</li>\n<li><code>componentDidMount()</code> 插进去后该做点什么吗？</li>\n</ul>\n</blockquote>\n<p>commit: <a href=\"https://github.com/FRANKIETANG/react-demo/commit/cad040489620cf5b4f7e02a571cb2e3c06803932\" target=\"_blank\" rel=\"noopener\">钩子</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c31f16851c918ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update\"></a>update</h3><blockquote>\n<p>mount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子：</p>\n<ul>\n<li><code>componentWillReceiveProps(nextProps)</code> - 我要读取 props 啦！</li>\n<li><code>shouldComponentUpdate(nextProps, nextState)</code> - 请问要不要更新组件？true / false</li>\n<li><code>componentWillUpdate()</code> - 我要更新组件啦！</li>\n<li><code>render()</code> - 更新！</li>\n<li><code>componentDidUpdate()</code> - 更新完毕啦！</li>\n</ul>\n</blockquote>\n<h3 id=\"unmount\"><a href=\"#unmount\" class=\"headerlink\" title=\"unmount\"></a>unmount</h3><blockquote>\n<p>当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子：</p>\n<ul>\n<li>componentWillUnmount() - 我要死啦！</li>\n</ul>\n</blockquote>\n<h2 id=\"setState-应该放在哪？\"><a href=\"#setState-应该放在哪？\" class=\"headerlink\" title=\"setState 应该放在哪？\"></a>setState 应该放在哪？</h2><p>commit: <a href=\"https://github.com/FRANKIETANG/react-demo/commit/3b2061343d754f2975356ef4502d445e943eef5a\" target=\"_blank\" rel=\"noopener\">哪些钩子里面可以加 setState</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-6dc701032129deb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里面有三个错误</p>\n<p>第一个错误说明不能在 constructor 里面 setState</p>\n<p>第二个错误说明不能在 render 里面 setState</p>\n<p>第三个错误说明 Welcome.shouldComponentUpdate 必须返回 boolean value，那我们改改</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-ace3aae6e3f84a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>好吧错误都是 render 的，那就都删掉吧。</p>\n<p>还是会有 bug 原因是在 componentWillUpdate 和 componentDidUpdate 里 setState 了，因为每次 setState 都会触发这两个钩子，而这两个钩子却又触发了 setState。</p>\n<p>所以只能在这几个钩子里 setState：</p>\n<ul>\n<li><code>componentWillMount</code></li>\n<li><code>componentDidMount</code></li>\n<li><code>componentWillReceiveProps</code></li>\n<li><code>componentDidUpdate</code></li>\n</ul>\n<h2 id=\"看看成果\"><a href=\"#看看成果\" class=\"headerlink\" title=\"看看成果\"></a><a href=\"https://github.com/FRANKIETANG/react-demo\" target=\"_blank\" rel=\"noopener\">看看成果</a></h2>"},{"title":"摸到 React 的门把手 (4)","date":"2017-10-13T16:09:14.000Z","_content":"# 摸到 React 的门把手 (4)\n\n经过一段时间的踩坑 [摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) [摸到 React 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/) [摸到 React 的门把手 (3)](https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/) ，是不是可以做一个项目了？\n\n## Todo List\n\n不管学什么框架，好像大家都喜欢做 Todo List 啊... AngularJS Vue.js React 都有Todo List ... 那我也做一个呗。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-46b343dbe1c59d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 有什么功能\n\n- 输入框输入要做的事\n- 按回车添加要做的事\n- 添加要做的事后输入框清空\n- 每一个要做的事可以标记成已完成\n- 要做的事能删除\n\n## Todo List长什么样\n\n- 有一个大盒子\n\n- 里面有一个标题\n\n- 有一个类似 `<input>` 的玩意\n\n- 一个列表，重点\n\n  - todoList\n    - 一个数组 id 用来区分要做的事\n    - title 是这个要做的事是什么\n    - status 要有一个 completed 值表示完成，空表示未完成\n    - deleted 是一个 boolean ，表示是否要删除\n\n\n  - newTodo 用来容纳用户在 input 输入的值，为什么不用 input 的 value 属性？因为 value= 后面加引号会错。在 React 中是无法直接更改 from 表单元素的值的，必须通过 setState() 去响应用户的输入。\n\n## 开始写代码\n\n注意 JavaScript 会自动给行末添加分号。如果 return 后面换行不加括号就会变成 `return;`，所以为了提高可读性还是加括号会比较好。\n\n添加 CSS `npm i -S normalize.css`\n\n然后在 `import` 加上 CSS 和 JS ，另外一定要注意顺序。normalize.css 要放在最前面。\n\n## 怎么交互\n\n试了一下 newTodo 的值改成 `''` ，在 input 里什么都输入不了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-2fe83ce52dc119fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n浏览器告诉了我们两种方法\n\n- If the field should be mutable use `defaultValue`.\n- set either `onChange` or `readOnly`.\n\n那我们用一下 `defaultValue` ，ok 了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-0a3d90f9199c3e88.gif?imageMogr2/auto-orient/strip)\n\n监听用户的回车事件 我们可以用 [GlobalEventHandlers.onkeypress](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onkeypress) 这个属性\n\n![](http://upload-images.jianshu.io/upload_images/3191557-383c1bddda0d2c8c.gif?imageMogr2/auto-orient/strip)\n\n我们用 props 的话我们要注意绑定按回车那个 this ，就是我系列文章上一篇的 bind(this) \n\n这样，我们就能够往里面加东西了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-1b876867916258d3.gif?imageMogr2/auto-orient/strip)\n\n但是我们又发现了一个问题，input 的 value 没有重置。那是因为 defaultValue，只会影响 input 的第一次值，后面的 newTodo 怎么变，都不会影响 input\n\n那我们试试 onChange 这种方法，成了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-2fc657e33903e0cb.gif?imageMogr2/auto-orient/strip)\n\n紧接着是标记为已完成的事件和未完成的事件\n\n我们让 checked 的值先等于 null，点击后就变成了 completed\n\n![](http://upload-images.jianshu.io/upload_images/3191557-44d0d5f42f5c0a9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](http://upload-images.jianshu.io/upload_images/3191557-5d8f997dcfc09154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击 checkbox 后增加了 `status: 'completed'`\n\n接下来新增一个删除 todo\n\n![](http://upload-images.jianshu.io/upload_images/3191557-a6bbcdeda9ada74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](http://upload-images.jianshu.io/upload_images/3191557-3279099d4a906453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们还要让 deleted 变成真 deleted\n\n那我们就用 `filter` 这个 API ，`.filter((item)=> !item.deleted)`\n\n![](http://upload-images.jianshu.io/upload_images/3191557-76ff1267a6ea4bd5.gif?imageMogr2/auto-orient/strip)\n\n基本功能已经做出来了\n\n##代码\n\n- [基本骨架完成](https://github.com/FRANKIETANG/react-todo-list/commit/2431a2a81415c3fd674f14a894a2bd3f7777f805)\n- [将输入框变成 TodoInput 组件](https://github.com/FRANKIETANG/react-todo-list/commit/37a39392ac65e03d4a4551ca6f2aa33400fcd5ec)\n- [将每个待办封装成 TodoItem 组件](https://github.com/FRANKIETANG/react-todo-list/commit/db78ca8d08545394b5ecd93e344fc955508ce393)\n- [添加 normalize.css](https://github.com/FRANKIETANG/react-todo-list/commit/ad05ce18fe7083a2e76573c3032b28cc6c715103)\n- [添加 reset.css](https://github.com/FRANKIETANG/react-todo-list/commit/9b62a921aa2adbfec99c17c04cc4438e7ae17b69)\n- [fix value](https://github.com/FRANKIETANG/react-todo-list/commit/556f760571f1b60c7b7c25f46e6698bacb168d67)\n- [监听回车事件](https://github.com/FRANKIETANG/react-todo-list/commit/5eeef99c4ae2678e60c28a691b0b5d935c1b2591)\n- [App 传一个函数给 TodoInput](https://github.com/FRANKIETANG/react-todo-list/commit/c8727d8482b81f84e1441166f3be016b8affea9a)\n- [bind(this)](https://github.com/FRANKIETANG/react-todo-list/commit/b9de4886314df06317d176b00b769196fcbd642d)\n- [可以添加 todo 了](https://github.com/FRANKIETANG/react-todo-list/commit/b765bebe0097d7283d34209f84404e9433e667c4)\n- [fix value again](https://github.com/FRANKIETANG/react-todo-list/commit/20701a8e764cfe158b3b387c6686fada36f54c52)\n- [fix value again and again](https://github.com/FRANKIETANG/react-todo-list/commit/730db326d22892d3ef4e32e6e705c061d24a1142)\n- [标记为已完成或者未完成](https://github.com/FRANKIETANG/react-todo-list/commit/a78fea70fd172c1aa35b77d85e1f9720f738ea1c)\n- [删除 todo](https://github.com/FRANKIETANG/react-todo-list/commit/9bc07f8a2c564c95bacc7e8ba1728e4b69b20784)\n- [真正删除 todo](https://github.com/FRANKIETANG/react-todo-list/commit/f0ea5a391f90588fd093eb859c273bbd96a05930)\n- [TodoItem 样式](https://github.com/FRANKIETANG/react-todo-list/commit/85b7255e4daa64699badfa2b35f8eab4268516f5)\n- [TodoInput 样式](https://github.com/FRANKIETANG/react-todo-list/commit/d1df4c1ecadaf9aa5af0a55e30d295e2b8b943c5)","source":"_posts/摸到 React 的门把手 (4).md","raw":"---\ntitle: 摸到 React 的门把手 (4)\ndate: 2017-10-14 00:09:14\ntags: [React,Black History]\n---\n# 摸到 React 的门把手 (4)\n\n经过一段时间的踩坑 [摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) [摸到 React 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/) [摸到 React 的门把手 (3)](https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/) ，是不是可以做一个项目了？\n\n## Todo List\n\n不管学什么框架，好像大家都喜欢做 Todo List 啊... AngularJS Vue.js React 都有Todo List ... 那我也做一个呗。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-46b343dbe1c59d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 有什么功能\n\n- 输入框输入要做的事\n- 按回车添加要做的事\n- 添加要做的事后输入框清空\n- 每一个要做的事可以标记成已完成\n- 要做的事能删除\n\n## Todo List长什么样\n\n- 有一个大盒子\n\n- 里面有一个标题\n\n- 有一个类似 `<input>` 的玩意\n\n- 一个列表，重点\n\n  - todoList\n    - 一个数组 id 用来区分要做的事\n    - title 是这个要做的事是什么\n    - status 要有一个 completed 值表示完成，空表示未完成\n    - deleted 是一个 boolean ，表示是否要删除\n\n\n  - newTodo 用来容纳用户在 input 输入的值，为什么不用 input 的 value 属性？因为 value= 后面加引号会错。在 React 中是无法直接更改 from 表单元素的值的，必须通过 setState() 去响应用户的输入。\n\n## 开始写代码\n\n注意 JavaScript 会自动给行末添加分号。如果 return 后面换行不加括号就会变成 `return;`，所以为了提高可读性还是加括号会比较好。\n\n添加 CSS `npm i -S normalize.css`\n\n然后在 `import` 加上 CSS 和 JS ，另外一定要注意顺序。normalize.css 要放在最前面。\n\n## 怎么交互\n\n试了一下 newTodo 的值改成 `''` ，在 input 里什么都输入不了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-2fe83ce52dc119fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n浏览器告诉了我们两种方法\n\n- If the field should be mutable use `defaultValue`.\n- set either `onChange` or `readOnly`.\n\n那我们用一下 `defaultValue` ，ok 了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-0a3d90f9199c3e88.gif?imageMogr2/auto-orient/strip)\n\n监听用户的回车事件 我们可以用 [GlobalEventHandlers.onkeypress](https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onkeypress) 这个属性\n\n![](http://upload-images.jianshu.io/upload_images/3191557-383c1bddda0d2c8c.gif?imageMogr2/auto-orient/strip)\n\n我们用 props 的话我们要注意绑定按回车那个 this ，就是我系列文章上一篇的 bind(this) \n\n这样，我们就能够往里面加东西了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-1b876867916258d3.gif?imageMogr2/auto-orient/strip)\n\n但是我们又发现了一个问题，input 的 value 没有重置。那是因为 defaultValue，只会影响 input 的第一次值，后面的 newTodo 怎么变，都不会影响 input\n\n那我们试试 onChange 这种方法，成了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-2fc657e33903e0cb.gif?imageMogr2/auto-orient/strip)\n\n紧接着是标记为已完成的事件和未完成的事件\n\n我们让 checked 的值先等于 null，点击后就变成了 completed\n\n![](http://upload-images.jianshu.io/upload_images/3191557-44d0d5f42f5c0a9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](http://upload-images.jianshu.io/upload_images/3191557-5d8f997dcfc09154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击 checkbox 后增加了 `status: 'completed'`\n\n接下来新增一个删除 todo\n\n![](http://upload-images.jianshu.io/upload_images/3191557-a6bbcdeda9ada74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![](http://upload-images.jianshu.io/upload_images/3191557-3279099d4a906453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们还要让 deleted 变成真 deleted\n\n那我们就用 `filter` 这个 API ，`.filter((item)=> !item.deleted)`\n\n![](http://upload-images.jianshu.io/upload_images/3191557-76ff1267a6ea4bd5.gif?imageMogr2/auto-orient/strip)\n\n基本功能已经做出来了\n\n##代码\n\n- [基本骨架完成](https://github.com/FRANKIETANG/react-todo-list/commit/2431a2a81415c3fd674f14a894a2bd3f7777f805)\n- [将输入框变成 TodoInput 组件](https://github.com/FRANKIETANG/react-todo-list/commit/37a39392ac65e03d4a4551ca6f2aa33400fcd5ec)\n- [将每个待办封装成 TodoItem 组件](https://github.com/FRANKIETANG/react-todo-list/commit/db78ca8d08545394b5ecd93e344fc955508ce393)\n- [添加 normalize.css](https://github.com/FRANKIETANG/react-todo-list/commit/ad05ce18fe7083a2e76573c3032b28cc6c715103)\n- [添加 reset.css](https://github.com/FRANKIETANG/react-todo-list/commit/9b62a921aa2adbfec99c17c04cc4438e7ae17b69)\n- [fix value](https://github.com/FRANKIETANG/react-todo-list/commit/556f760571f1b60c7b7c25f46e6698bacb168d67)\n- [监听回车事件](https://github.com/FRANKIETANG/react-todo-list/commit/5eeef99c4ae2678e60c28a691b0b5d935c1b2591)\n- [App 传一个函数给 TodoInput](https://github.com/FRANKIETANG/react-todo-list/commit/c8727d8482b81f84e1441166f3be016b8affea9a)\n- [bind(this)](https://github.com/FRANKIETANG/react-todo-list/commit/b9de4886314df06317d176b00b769196fcbd642d)\n- [可以添加 todo 了](https://github.com/FRANKIETANG/react-todo-list/commit/b765bebe0097d7283d34209f84404e9433e667c4)\n- [fix value again](https://github.com/FRANKIETANG/react-todo-list/commit/20701a8e764cfe158b3b387c6686fada36f54c52)\n- [fix value again and again](https://github.com/FRANKIETANG/react-todo-list/commit/730db326d22892d3ef4e32e6e705c061d24a1142)\n- [标记为已完成或者未完成](https://github.com/FRANKIETANG/react-todo-list/commit/a78fea70fd172c1aa35b77d85e1f9720f738ea1c)\n- [删除 todo](https://github.com/FRANKIETANG/react-todo-list/commit/9bc07f8a2c564c95bacc7e8ba1728e4b69b20784)\n- [真正删除 todo](https://github.com/FRANKIETANG/react-todo-list/commit/f0ea5a391f90588fd093eb859c273bbd96a05930)\n- [TodoItem 样式](https://github.com/FRANKIETANG/react-todo-list/commit/85b7255e4daa64699badfa2b35f8eab4268516f5)\n- [TodoInput 样式](https://github.com/FRANKIETANG/react-todo-list/commit/d1df4c1ecadaf9aa5af0a55e30d295e2b8b943c5)","slug":"摸到 React 的门把手 (4)","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8f000hf1xhu5zj9bn9","content":"<h1 id=\"摸到-React-的门把手-4\"><a href=\"#摸到-React-的门把手-4\" class=\"headerlink\" title=\"摸到 React 的门把手 (4)\"></a>摸到 React 的门把手 (4)</h1><p>经过一段时间的踩坑 <a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a> <a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (2)</a> <a href=\"https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (3)</a> ，是不是可以做一个项目了？</p>\n<h2 id=\"Todo-List\"><a href=\"#Todo-List\" class=\"headerlink\" title=\"Todo List\"></a>Todo List</h2><p>不管学什么框架，好像大家都喜欢做 Todo List 啊… AngularJS Vue.js React 都有Todo List … 那我也做一个呗。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-46b343dbe1c59d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"有什么功能\"><a href=\"#有什么功能\" class=\"headerlink\" title=\"有什么功能\"></a>有什么功能</h2><ul>\n<li>输入框输入要做的事</li>\n<li>按回车添加要做的事</li>\n<li>添加要做的事后输入框清空</li>\n<li>每一个要做的事可以标记成已完成</li>\n<li>要做的事能删除</li>\n</ul>\n<h2 id=\"Todo-List长什么样\"><a href=\"#Todo-List长什么样\" class=\"headerlink\" title=\"Todo List长什么样\"></a>Todo List长什么样</h2><ul>\n<li><p>有一个大盒子</p>\n</li>\n<li><p>里面有一个标题</p>\n</li>\n<li><p>有一个类似 <code>&lt;input&gt;</code> 的玩意</p>\n</li>\n<li><p>一个列表，重点</p>\n<ul>\n<li>todoList<ul>\n<li>一个数组 id 用来区分要做的事</li>\n<li>title 是这个要做的事是什么</li>\n<li>status 要有一个 completed 值表示完成，空表示未完成</li>\n<li>deleted 是一个 boolean ，表示是否要删除</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>newTodo 用来容纳用户在 input 输入的值，为什么不用 input 的 value 属性？因为 value= 后面加引号会错。在 React 中是无法直接更改 from 表单元素的值的，必须通过 setState() 去响应用户的输入。</li>\n</ul>\n<h2 id=\"开始写代码\"><a href=\"#开始写代码\" class=\"headerlink\" title=\"开始写代码\"></a>开始写代码</h2><p>注意 JavaScript 会自动给行末添加分号。如果 return 后面换行不加括号就会变成 <code>return;</code>，所以为了提高可读性还是加括号会比较好。</p>\n<p>添加 CSS <code>npm i -S normalize.css</code></p>\n<p>然后在 <code>import</code> 加上 CSS 和 JS ，另外一定要注意顺序。normalize.css 要放在最前面。</p>\n<h2 id=\"怎么交互\"><a href=\"#怎么交互\" class=\"headerlink\" title=\"怎么交互\"></a>怎么交互</h2><p>试了一下 newTodo 的值改成 <code>&#39;&#39;</code> ，在 input 里什么都输入不了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-2fe83ce52dc119fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>浏览器告诉了我们两种方法</p>\n<ul>\n<li>If the field should be mutable use <code>defaultValue</code>.</li>\n<li>set either <code>onChange</code> or <code>readOnly</code>.</li>\n</ul>\n<p>那我们用一下 <code>defaultValue</code> ，ok 了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-0a3d90f9199c3e88.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>监听用户的回车事件 我们可以用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onkeypress\" target=\"_blank\" rel=\"noopener\">GlobalEventHandlers.onkeypress</a> 这个属性</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-383c1bddda0d2c8c.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>我们用 props 的话我们要注意绑定按回车那个 this ，就是我系列文章上一篇的 bind(this) </p>\n<p>这样，我们就能够往里面加东西了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-1b876867916258d3.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>但是我们又发现了一个问题，input 的 value 没有重置。那是因为 defaultValue，只会影响 input 的第一次值，后面的 newTodo 怎么变，都不会影响 input</p>\n<p>那我们试试 onChange 这种方法，成了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-2fc657e33903e0cb.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>紧接着是标记为已完成的事件和未完成的事件</p>\n<p>我们让 checked 的值先等于 null，点击后就变成了 completed</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-44d0d5f42f5c0a9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><img src=\"http://upload-images.jianshu.io/upload_images/3191557-5d8f997dcfc09154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>点击 checkbox 后增加了 <code>status: &#39;completed&#39;</code></p>\n<p>接下来新增一个删除 todo</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-a6bbcdeda9ada74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><img src=\"http://upload-images.jianshu.io/upload_images/3191557-3279099d4a906453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我们还要让 deleted 变成真 deleted</p>\n<p>那我们就用 <code>filter</code> 这个 API ，<code>.filter((item)=&gt; !item.deleted)</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-76ff1267a6ea4bd5.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>基本功能已经做出来了</p>\n<p>##代码</p>\n<ul>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/2431a2a81415c3fd674f14a894a2bd3f7777f805\" target=\"_blank\" rel=\"noopener\">基本骨架完成</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/37a39392ac65e03d4a4551ca6f2aa33400fcd5ec\" target=\"_blank\" rel=\"noopener\">将输入框变成 TodoInput 组件</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/db78ca8d08545394b5ecd93e344fc955508ce393\" target=\"_blank\" rel=\"noopener\">将每个待办封装成 TodoItem 组件</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/ad05ce18fe7083a2e76573c3032b28cc6c715103\" target=\"_blank\" rel=\"noopener\">添加 normalize.css</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/9b62a921aa2adbfec99c17c04cc4438e7ae17b69\" target=\"_blank\" rel=\"noopener\">添加 reset.css</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/556f760571f1b60c7b7c25f46e6698bacb168d67\" target=\"_blank\" rel=\"noopener\">fix value</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/5eeef99c4ae2678e60c28a691b0b5d935c1b2591\" target=\"_blank\" rel=\"noopener\">监听回车事件</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/c8727d8482b81f84e1441166f3be016b8affea9a\" target=\"_blank\" rel=\"noopener\">App 传一个函数给 TodoInput</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/b9de4886314df06317d176b00b769196fcbd642d\" target=\"_blank\" rel=\"noopener\">bind(this)</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/b765bebe0097d7283d34209f84404e9433e667c4\" target=\"_blank\" rel=\"noopener\">可以添加 todo 了</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/20701a8e764cfe158b3b387c6686fada36f54c52\" target=\"_blank\" rel=\"noopener\">fix value again</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/730db326d22892d3ef4e32e6e705c061d24a1142\" target=\"_blank\" rel=\"noopener\">fix value again and again</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/a78fea70fd172c1aa35b77d85e1f9720f738ea1c\" target=\"_blank\" rel=\"noopener\">标记为已完成或者未完成</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/9bc07f8a2c564c95bacc7e8ba1728e4b69b20784\" target=\"_blank\" rel=\"noopener\">删除 todo</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/f0ea5a391f90588fd093eb859c273bbd96a05930\" target=\"_blank\" rel=\"noopener\">真正删除 todo</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/85b7255e4daa64699badfa2b35f8eab4268516f5\" target=\"_blank\" rel=\"noopener\">TodoItem 样式</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/d1df4c1ecadaf9aa5af0a55e30d295e2b8b943c5\" target=\"_blank\" rel=\"noopener\">TodoInput 样式</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-React-的门把手-4\"><a href=\"#摸到-React-的门把手-4\" class=\"headerlink\" title=\"摸到 React 的门把手 (4)\"></a>摸到 React 的门把手 (4)</h1><p>经过一段时间的踩坑 <a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a> <a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (2)</a> <a href=\"https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (3)</a> ，是不是可以做一个项目了？</p>\n<h2 id=\"Todo-List\"><a href=\"#Todo-List\" class=\"headerlink\" title=\"Todo List\"></a>Todo List</h2><p>不管学什么框架，好像大家都喜欢做 Todo List 啊… AngularJS Vue.js React 都有Todo List … 那我也做一个呗。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-46b343dbe1c59d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"有什么功能\"><a href=\"#有什么功能\" class=\"headerlink\" title=\"有什么功能\"></a>有什么功能</h2><ul>\n<li>输入框输入要做的事</li>\n<li>按回车添加要做的事</li>\n<li>添加要做的事后输入框清空</li>\n<li>每一个要做的事可以标记成已完成</li>\n<li>要做的事能删除</li>\n</ul>\n<h2 id=\"Todo-List长什么样\"><a href=\"#Todo-List长什么样\" class=\"headerlink\" title=\"Todo List长什么样\"></a>Todo List长什么样</h2><ul>\n<li><p>有一个大盒子</p>\n</li>\n<li><p>里面有一个标题</p>\n</li>\n<li><p>有一个类似 <code>&lt;input&gt;</code> 的玩意</p>\n</li>\n<li><p>一个列表，重点</p>\n<ul>\n<li>todoList<ul>\n<li>一个数组 id 用来区分要做的事</li>\n<li>title 是这个要做的事是什么</li>\n<li>status 要有一个 completed 值表示完成，空表示未完成</li>\n<li>deleted 是一个 boolean ，表示是否要删除</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>newTodo 用来容纳用户在 input 输入的值，为什么不用 input 的 value 属性？因为 value= 后面加引号会错。在 React 中是无法直接更改 from 表单元素的值的，必须通过 setState() 去响应用户的输入。</li>\n</ul>\n<h2 id=\"开始写代码\"><a href=\"#开始写代码\" class=\"headerlink\" title=\"开始写代码\"></a>开始写代码</h2><p>注意 JavaScript 会自动给行末添加分号。如果 return 后面换行不加括号就会变成 <code>return;</code>，所以为了提高可读性还是加括号会比较好。</p>\n<p>添加 CSS <code>npm i -S normalize.css</code></p>\n<p>然后在 <code>import</code> 加上 CSS 和 JS ，另外一定要注意顺序。normalize.css 要放在最前面。</p>\n<h2 id=\"怎么交互\"><a href=\"#怎么交互\" class=\"headerlink\" title=\"怎么交互\"></a>怎么交互</h2><p>试了一下 newTodo 的值改成 <code>&#39;&#39;</code> ，在 input 里什么都输入不了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-2fe83ce52dc119fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>浏览器告诉了我们两种方法</p>\n<ul>\n<li>If the field should be mutable use <code>defaultValue</code>.</li>\n<li>set either <code>onChange</code> or <code>readOnly</code>.</li>\n</ul>\n<p>那我们用一下 <code>defaultValue</code> ，ok 了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-0a3d90f9199c3e88.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>监听用户的回车事件 我们可以用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onkeypress\" target=\"_blank\" rel=\"noopener\">GlobalEventHandlers.onkeypress</a> 这个属性</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-383c1bddda0d2c8c.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>我们用 props 的话我们要注意绑定按回车那个 this ，就是我系列文章上一篇的 bind(this) </p>\n<p>这样，我们就能够往里面加东西了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-1b876867916258d3.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>但是我们又发现了一个问题，input 的 value 没有重置。那是因为 defaultValue，只会影响 input 的第一次值，后面的 newTodo 怎么变，都不会影响 input</p>\n<p>那我们试试 onChange 这种方法，成了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-2fc657e33903e0cb.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>紧接着是标记为已完成的事件和未完成的事件</p>\n<p>我们让 checked 的值先等于 null，点击后就变成了 completed</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-44d0d5f42f5c0a9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><img src=\"http://upload-images.jianshu.io/upload_images/3191557-5d8f997dcfc09154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>点击 checkbox 后增加了 <code>status: &#39;completed&#39;</code></p>\n<p>接下来新增一个删除 todo</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-a6bbcdeda9ada74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><img src=\"http://upload-images.jianshu.io/upload_images/3191557-3279099d4a906453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我们还要让 deleted 变成真 deleted</p>\n<p>那我们就用 <code>filter</code> 这个 API ，<code>.filter((item)=&gt; !item.deleted)</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-76ff1267a6ea4bd5.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>基本功能已经做出来了</p>\n<p>##代码</p>\n<ul>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/2431a2a81415c3fd674f14a894a2bd3f7777f805\" target=\"_blank\" rel=\"noopener\">基本骨架完成</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/37a39392ac65e03d4a4551ca6f2aa33400fcd5ec\" target=\"_blank\" rel=\"noopener\">将输入框变成 TodoInput 组件</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/db78ca8d08545394b5ecd93e344fc955508ce393\" target=\"_blank\" rel=\"noopener\">将每个待办封装成 TodoItem 组件</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/ad05ce18fe7083a2e76573c3032b28cc6c715103\" target=\"_blank\" rel=\"noopener\">添加 normalize.css</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/9b62a921aa2adbfec99c17c04cc4438e7ae17b69\" target=\"_blank\" rel=\"noopener\">添加 reset.css</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/556f760571f1b60c7b7c25f46e6698bacb168d67\" target=\"_blank\" rel=\"noopener\">fix value</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/5eeef99c4ae2678e60c28a691b0b5d935c1b2591\" target=\"_blank\" rel=\"noopener\">监听回车事件</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/c8727d8482b81f84e1441166f3be016b8affea9a\" target=\"_blank\" rel=\"noopener\">App 传一个函数给 TodoInput</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/b9de4886314df06317d176b00b769196fcbd642d\" target=\"_blank\" rel=\"noopener\">bind(this)</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/b765bebe0097d7283d34209f84404e9433e667c4\" target=\"_blank\" rel=\"noopener\">可以添加 todo 了</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/20701a8e764cfe158b3b387c6686fada36f54c52\" target=\"_blank\" rel=\"noopener\">fix value again</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/730db326d22892d3ef4e32e6e705c061d24a1142\" target=\"_blank\" rel=\"noopener\">fix value again and again</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/a78fea70fd172c1aa35b77d85e1f9720f738ea1c\" target=\"_blank\" rel=\"noopener\">标记为已完成或者未完成</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/9bc07f8a2c564c95bacc7e8ba1728e4b69b20784\" target=\"_blank\" rel=\"noopener\">删除 todo</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/f0ea5a391f90588fd093eb859c273bbd96a05930\" target=\"_blank\" rel=\"noopener\">真正删除 todo</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/85b7255e4daa64699badfa2b35f8eab4268516f5\" target=\"_blank\" rel=\"noopener\">TodoItem 样式</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commit/d1df4c1ecadaf9aa5af0a55e30d295e2b8b943c5\" target=\"_blank\" rel=\"noopener\">TodoInput 样式</a></li>\n</ul>\n"},{"title":"摸到 React 的门把手 (5)","date":"2017-10-13T16:09:47.000Z","_content":"# 摸到 React 的门把手 (5)\n\n这次我们就来天我们上一次挖的深坑 [摸到 React 的门把手 (4)](https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(4)/) ，慢慢填，不用急。干那么快干嘛，要好好享受过程。体验学到知识的快感。\n\n## localStorage\n\n看名字就感觉应该是一个保存本地数据的玩意对吧（我猜的）[loocalStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)\n\n我们用这个方法就可以保存数据而不会一刷新就会初始化了\n\n- 用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage\n- 重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList\n\n封装 localStorage 封装成两个函数\n\n```\nexport function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n```\n\nload 和 save 的调用\n\n```\n// load\nlocalStore.load('todoList') || []\n// save\nlocalStore.save('todoList',this.state.todoList)\n```\n\n![](http://upload-images.jianshu.io/upload_images/3191557-7c1b95c23aa12525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`||` 居然还有这种操作？可以用来定义默认参数？\n\n![](http://upload-images.jianshu.io/upload_images/3191557-0dcd24f922e4a0aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过 ES6 有了新的默认参数用法\n\n![](http://upload-images.jianshu.io/upload_images/3191557-48b523717d27a58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好了这里就不展开了。\n\n## 优化代码\n\n之前在每个 setState 之后会运行一次 save，但是我们知道 componentDidUpdate 会在组件更新之后调用，相当于 “组件更新” 等价于 “数据更新”\n\n利用 componentDidUpdate 封装代码。\n\n## 数据库\n\n其实我们不需要服务器，用 LeanCloud 就可以了。\n\n点击创建应用\n\n![](http://upload-images.jianshu.io/upload_images/3191557-f47971710bf3edd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[看文档](https://leancloud.cn/docs/leanstorage_guide-js.html)\n\n[JavaScript SDK 安装指南](https://leancloud.cn/docs/sdk_setup-js.html)\n\n安装\n\n```\n$ sudo npm install leancloud-storage --save\n```\n\n复制这一段代码到我们的App.js\n\n![](http://upload-images.jianshu.io/upload_images/3191557-49cd74d87191419f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nping api.leancloud.cn\n```\n\n验证结果如下则正常\n\n![](http://upload-images.jianshu.io/upload_images/3191557-e10c06115a5054f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们测试下面这一段代码。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-d0ceaa7fa89d6cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK 了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-4797976d0ab6e532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们就继续把 LeanCloud 的对象和用户的开发文档看一遍，就可以继续写代码了。\n\n## 继续撸代码\n\n先把我们上面的 localStore 给删掉\n\n然后做出一个登录框\n\n![](http://upload-images.jianshu.io/upload_images/3191557-c5799a036bc6459c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n还要让它变成一个选项卡来回切换\n\n![](http://upload-images.jianshu.io/upload_images/3191557-caefa908df34d17f.gif?imageMogr2/auto-orient/strip)\n\n把 form 表单的 input 和 formData 绑定用下面这种方法是不行的\n\n```\n    changeUsername(e){\n        this.state.formData.username = e.target.value\n        this.setState(this.state)\n    }\n```\n\n其实是不行的，原因看 [Why can't I directly modify a component's state, really?](https://stackoverflow.com/questions/37755997/why-cant-i-directly-modify-a-components-state-really) 里面 [Pranesh Ravi](https://stackoverflow.com/users/4945468/pranesh-ravi) 的答案。\n\n>Just a reminder: most basic methods for cloning in JS (`slice`, ES6 destructuring, etc.) are shallow. If you have a nested array or nested objects you'll need to look at other methods of deep copying, e.g. `JSON.parse(JSON.stringify(obj))` (though this particular method won't work if your object has circular references). \n\n因为对象是嵌套的，所以要用深拷贝的方法。\n\n点击注册后使用 LeanCloud API 来注册\n\n![](http://upload-images.jianshu.io/upload_images/3191557-0359d75695fc17ef.gif?imageMogr2/auto-orient/strip)\n\n这样数据就能来到了\n\n来到后还要把它记住并显示出来\n\n![](http://upload-images.jianshu.io/upload_images/3191557-a186a02fe0ba8bc2.gif?imageMogr2/auto-orient/strip)\n\n实现注册成功关闭窗口\n\n![](http://upload-images.jianshu.io/upload_images/3191557-d801a196febd2d97.gif?imageMogr2/auto-orient/strip)\n\n用户进入页面时读取上次登录的 user\n\n![](http://upload-images.jianshu.io/upload_images/3191557-bbc5b207c51506ce.gif?imageMogr2/auto-orient/strip)\n\n做出可以登出的功能\n\n![](http://upload-images.jianshu.io/upload_images/3191557-963e5edeb970c9f1.gif?imageMogr2/auto-orient/strip)\n\n完成登录功能\n\n![](http://upload-images.jianshu.io/upload_images/3191557-10f8da0986e07f6b.gif?imageMogr2/auto-orient/strip)\n\n代码：\n\n- [LeanCloud](https://github.com/FRANKIETANG/banana-todolist/commits/master)\n- [localStore](https://github.com/FRANKIETANG/react-todo-list/commits/master)","source":"_posts/摸到 React 的门把手 (5).md","raw":"---\ntitle: 摸到 React 的门把手 (5)\ndate: 2017-10-14 00:09:47\ntags: [React,Black History]\n---\n# 摸到 React 的门把手 (5)\n\n这次我们就来天我们上一次挖的深坑 [摸到 React 的门把手 (4)](https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(4)/) ，慢慢填，不用急。干那么快干嘛，要好好享受过程。体验学到知识的快感。\n\n## localStorage\n\n看名字就感觉应该是一个保存本地数据的玩意对吧（我猜的）[loocalStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)\n\n我们用这个方法就可以保存数据而不会一刷新就会初始化了\n\n- 用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage\n- 重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList\n\n封装 localStorage 封装成两个函数\n\n```\nexport function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n```\n\nload 和 save 的调用\n\n```\n// load\nlocalStore.load('todoList') || []\n// save\nlocalStore.save('todoList',this.state.todoList)\n```\n\n![](http://upload-images.jianshu.io/upload_images/3191557-7c1b95c23aa12525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`||` 居然还有这种操作？可以用来定义默认参数？\n\n![](http://upload-images.jianshu.io/upload_images/3191557-0dcd24f922e4a0aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过 ES6 有了新的默认参数用法\n\n![](http://upload-images.jianshu.io/upload_images/3191557-48b523717d27a58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n好了这里就不展开了。\n\n## 优化代码\n\n之前在每个 setState 之后会运行一次 save，但是我们知道 componentDidUpdate 会在组件更新之后调用，相当于 “组件更新” 等价于 “数据更新”\n\n利用 componentDidUpdate 封装代码。\n\n## 数据库\n\n其实我们不需要服务器，用 LeanCloud 就可以了。\n\n点击创建应用\n\n![](http://upload-images.jianshu.io/upload_images/3191557-f47971710bf3edd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n[看文档](https://leancloud.cn/docs/leanstorage_guide-js.html)\n\n[JavaScript SDK 安装指南](https://leancloud.cn/docs/sdk_setup-js.html)\n\n安装\n\n```\n$ sudo npm install leancloud-storage --save\n```\n\n复制这一段代码到我们的App.js\n\n![](http://upload-images.jianshu.io/upload_images/3191557-49cd74d87191419f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nping api.leancloud.cn\n```\n\n验证结果如下则正常\n\n![](http://upload-images.jianshu.io/upload_images/3191557-e10c06115a5054f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们测试下面这一段代码。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-d0ceaa7fa89d6cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK 了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-4797976d0ab6e532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们就继续把 LeanCloud 的对象和用户的开发文档看一遍，就可以继续写代码了。\n\n## 继续撸代码\n\n先把我们上面的 localStore 给删掉\n\n然后做出一个登录框\n\n![](http://upload-images.jianshu.io/upload_images/3191557-c5799a036bc6459c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n还要让它变成一个选项卡来回切换\n\n![](http://upload-images.jianshu.io/upload_images/3191557-caefa908df34d17f.gif?imageMogr2/auto-orient/strip)\n\n把 form 表单的 input 和 formData 绑定用下面这种方法是不行的\n\n```\n    changeUsername(e){\n        this.state.formData.username = e.target.value\n        this.setState(this.state)\n    }\n```\n\n其实是不行的，原因看 [Why can't I directly modify a component's state, really?](https://stackoverflow.com/questions/37755997/why-cant-i-directly-modify-a-components-state-really) 里面 [Pranesh Ravi](https://stackoverflow.com/users/4945468/pranesh-ravi) 的答案。\n\n>Just a reminder: most basic methods for cloning in JS (`slice`, ES6 destructuring, etc.) are shallow. If you have a nested array or nested objects you'll need to look at other methods of deep copying, e.g. `JSON.parse(JSON.stringify(obj))` (though this particular method won't work if your object has circular references). \n\n因为对象是嵌套的，所以要用深拷贝的方法。\n\n点击注册后使用 LeanCloud API 来注册\n\n![](http://upload-images.jianshu.io/upload_images/3191557-0359d75695fc17ef.gif?imageMogr2/auto-orient/strip)\n\n这样数据就能来到了\n\n来到后还要把它记住并显示出来\n\n![](http://upload-images.jianshu.io/upload_images/3191557-a186a02fe0ba8bc2.gif?imageMogr2/auto-orient/strip)\n\n实现注册成功关闭窗口\n\n![](http://upload-images.jianshu.io/upload_images/3191557-d801a196febd2d97.gif?imageMogr2/auto-orient/strip)\n\n用户进入页面时读取上次登录的 user\n\n![](http://upload-images.jianshu.io/upload_images/3191557-bbc5b207c51506ce.gif?imageMogr2/auto-orient/strip)\n\n做出可以登出的功能\n\n![](http://upload-images.jianshu.io/upload_images/3191557-963e5edeb970c9f1.gif?imageMogr2/auto-orient/strip)\n\n完成登录功能\n\n![](http://upload-images.jianshu.io/upload_images/3191557-10f8da0986e07f6b.gif?imageMogr2/auto-orient/strip)\n\n代码：\n\n- [LeanCloud](https://github.com/FRANKIETANG/banana-todolist/commits/master)\n- [localStore](https://github.com/FRANKIETANG/react-todo-list/commits/master)","slug":"摸到 React 的门把手 (5)","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8h000jf1xhzzemlbl5","content":"<h1 id=\"摸到-React-的门把手-5\"><a href=\"#摸到-React-的门把手-5\" class=\"headerlink\" title=\"摸到 React 的门把手 (5)\"></a>摸到 React 的门把手 (5)</h1><p>这次我们就来天我们上一次挖的深坑 <a href=\"https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(4\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (4)</a>/) ，慢慢填，不用急。干那么快干嘛，要好好享受过程。体验学到知识的快感。</p>\n<h2 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h2><p>看名字就感觉应该是一个保存本地数据的玩意对吧（我猜的）<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage\" target=\"_blank\" rel=\"noopener\">loocalStorage</a></p>\n<p>我们用这个方法就可以保存数据而不会一刷新就会初始化了</p>\n<ul>\n<li>用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage</li>\n<li>重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList</li>\n</ul>\n<p>封装 localStorage 封装成两个函数</p>\n<pre><code>export function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n</code></pre><p>load 和 save 的调用</p>\n<pre><code>// load\nlocalStore.load(&#39;todoList&#39;) || []\n// save\nlocalStore.save(&#39;todoList&#39;,this.state.todoList)\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-7c1b95c23aa12525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><code>||</code> 居然还有这种操作？可以用来定义默认参数？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-0dcd24f922e4a0aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>不过 ES6 有了新的默认参数用法</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-48b523717d27a58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>好了这里就不展开了。</p>\n<h2 id=\"优化代码\"><a href=\"#优化代码\" class=\"headerlink\" title=\"优化代码\"></a>优化代码</h2><p>之前在每个 setState 之后会运行一次 save，但是我们知道 componentDidUpdate 会在组件更新之后调用，相当于 “组件更新” 等价于 “数据更新”</p>\n<p>利用 componentDidUpdate 封装代码。</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><p>其实我们不需要服务器，用 LeanCloud 就可以了。</p>\n<p>点击创建应用</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-f47971710bf3edd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html\" target=\"_blank\" rel=\"noopener\">看文档</a></p>\n<p><a href=\"https://leancloud.cn/docs/sdk_setup-js.html\" target=\"_blank\" rel=\"noopener\">JavaScript SDK 安装指南</a></p>\n<p>安装</p>\n<pre><code>$ sudo npm install leancloud-storage --save\n</code></pre><p>复制这一段代码到我们的App.js</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-49cd74d87191419f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<pre><code>ping api.leancloud.cn\n</code></pre><p>验证结果如下则正常</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-e10c06115a5054f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>然后我们测试下面这一段代码。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-d0ceaa7fa89d6cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>OK 了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-4797976d0ab6e532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>然后我们就继续把 LeanCloud 的对象和用户的开发文档看一遍，就可以继续写代码了。</p>\n<h2 id=\"继续撸代码\"><a href=\"#继续撸代码\" class=\"headerlink\" title=\"继续撸代码\"></a>继续撸代码</h2><p>先把我们上面的 localStore 给删掉</p>\n<p>然后做出一个登录框</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c5799a036bc6459c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>还要让它变成一个选项卡来回切换</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-caefa908df34d17f.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>把 form 表单的 input 和 formData 绑定用下面这种方法是不行的</p>\n<pre><code>    changeUsername(e){\n        this.state.formData.username = e.target.value\n        this.setState(this.state)\n    }\n</code></pre><p>其实是不行的，原因看 <a href=\"https://stackoverflow.com/questions/37755997/why-cant-i-directly-modify-a-components-state-really\" target=\"_blank\" rel=\"noopener\">Why can’t I directly modify a component’s state, really?</a> 里面 <a href=\"https://stackoverflow.com/users/4945468/pranesh-ravi\" target=\"_blank\" rel=\"noopener\">Pranesh Ravi</a> 的答案。</p>\n<blockquote>\n<p>Just a reminder: most basic methods for cloning in JS (<code>slice</code>, ES6 destructuring, etc.) are shallow. If you have a nested array or nested objects you’ll need to look at other methods of deep copying, e.g. <code>JSON.parse(JSON.stringify(obj))</code> (though this particular method won’t work if your object has circular references). </p>\n</blockquote>\n<p>因为对象是嵌套的，所以要用深拷贝的方法。</p>\n<p>点击注册后使用 LeanCloud API 来注册</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-0359d75695fc17ef.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>这样数据就能来到了</p>\n<p>来到后还要把它记住并显示出来</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-a186a02fe0ba8bc2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>实现注册成功关闭窗口</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-d801a196febd2d97.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>用户进入页面时读取上次登录的 user</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-bbc5b207c51506ce.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>做出可以登出的功能</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-963e5edeb970c9f1.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>完成登录功能</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-10f8da0986e07f6b.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>代码：</p>\n<ul>\n<li><a href=\"https://github.com/FRANKIETANG/banana-todolist/commits/master\" target=\"_blank\" rel=\"noopener\">LeanCloud</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commits/master\" target=\"_blank\" rel=\"noopener\">localStore</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-React-的门把手-5\"><a href=\"#摸到-React-的门把手-5\" class=\"headerlink\" title=\"摸到 React 的门把手 (5)\"></a>摸到 React 的门把手 (5)</h1><p>这次我们就来天我们上一次挖的深坑 <a href=\"https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(4\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (4)</a>/) ，慢慢填，不用急。干那么快干嘛，要好好享受过程。体验学到知识的快感。</p>\n<h2 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h2><p>看名字就感觉应该是一个保存本地数据的玩意对吧（我猜的）<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage\" target=\"_blank\" rel=\"noopener\">loocalStorage</a></p>\n<p>我们用这个方法就可以保存数据而不会一刷新就会初始化了</p>\n<ul>\n<li>用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage</li>\n<li>重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList</li>\n</ul>\n<p>封装 localStorage 封装成两个函数</p>\n<pre><code>export function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n</code></pre><p>load 和 save 的调用</p>\n<pre><code>// load\nlocalStore.load(&#39;todoList&#39;) || []\n// save\nlocalStore.save(&#39;todoList&#39;,this.state.todoList)\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-7c1b95c23aa12525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><code>||</code> 居然还有这种操作？可以用来定义默认参数？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-0dcd24f922e4a0aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>不过 ES6 有了新的默认参数用法</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-48b523717d27a58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>好了这里就不展开了。</p>\n<h2 id=\"优化代码\"><a href=\"#优化代码\" class=\"headerlink\" title=\"优化代码\"></a>优化代码</h2><p>之前在每个 setState 之后会运行一次 save，但是我们知道 componentDidUpdate 会在组件更新之后调用，相当于 “组件更新” 等价于 “数据更新”</p>\n<p>利用 componentDidUpdate 封装代码。</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><p>其实我们不需要服务器，用 LeanCloud 就可以了。</p>\n<p>点击创建应用</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-f47971710bf3edd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html\" target=\"_blank\" rel=\"noopener\">看文档</a></p>\n<p><a href=\"https://leancloud.cn/docs/sdk_setup-js.html\" target=\"_blank\" rel=\"noopener\">JavaScript SDK 安装指南</a></p>\n<p>安装</p>\n<pre><code>$ sudo npm install leancloud-storage --save\n</code></pre><p>复制这一段代码到我们的App.js</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-49cd74d87191419f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<pre><code>ping api.leancloud.cn\n</code></pre><p>验证结果如下则正常</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-e10c06115a5054f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>然后我们测试下面这一段代码。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-d0ceaa7fa89d6cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>OK 了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-4797976d0ab6e532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>然后我们就继续把 LeanCloud 的对象和用户的开发文档看一遍，就可以继续写代码了。</p>\n<h2 id=\"继续撸代码\"><a href=\"#继续撸代码\" class=\"headerlink\" title=\"继续撸代码\"></a>继续撸代码</h2><p>先把我们上面的 localStore 给删掉</p>\n<p>然后做出一个登录框</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c5799a036bc6459c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>还要让它变成一个选项卡来回切换</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-caefa908df34d17f.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>把 form 表单的 input 和 formData 绑定用下面这种方法是不行的</p>\n<pre><code>    changeUsername(e){\n        this.state.formData.username = e.target.value\n        this.setState(this.state)\n    }\n</code></pre><p>其实是不行的，原因看 <a href=\"https://stackoverflow.com/questions/37755997/why-cant-i-directly-modify-a-components-state-really\" target=\"_blank\" rel=\"noopener\">Why can’t I directly modify a component’s state, really?</a> 里面 <a href=\"https://stackoverflow.com/users/4945468/pranesh-ravi\" target=\"_blank\" rel=\"noopener\">Pranesh Ravi</a> 的答案。</p>\n<blockquote>\n<p>Just a reminder: most basic methods for cloning in JS (<code>slice</code>, ES6 destructuring, etc.) are shallow. If you have a nested array or nested objects you’ll need to look at other methods of deep copying, e.g. <code>JSON.parse(JSON.stringify(obj))</code> (though this particular method won’t work if your object has circular references). </p>\n</blockquote>\n<p>因为对象是嵌套的，所以要用深拷贝的方法。</p>\n<p>点击注册后使用 LeanCloud API 来注册</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-0359d75695fc17ef.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>这样数据就能来到了</p>\n<p>来到后还要把它记住并显示出来</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-a186a02fe0ba8bc2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>实现注册成功关闭窗口</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-d801a196febd2d97.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>用户进入页面时读取上次登录的 user</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-bbc5b207c51506ce.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>做出可以登出的功能</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-963e5edeb970c9f1.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>完成登录功能</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-10f8da0986e07f6b.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>代码：</p>\n<ul>\n<li><a href=\"https://github.com/FRANKIETANG/banana-todolist/commits/master\" target=\"_blank\" rel=\"noopener\">LeanCloud</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/react-todo-list/commits/master\" target=\"_blank\" rel=\"noopener\">localStore</a></li>\n</ul>\n"},{"title":"摸到 React 的门把手 (6)","date":"2017-10-13T16:10:29.000Z","_content":"# 摸到 React 的门把手 (6)\n\n慢慢的撸出一个应用，就像看着自己的孩子长大一样。\n\n## 继续撸代码\n\n增加邮箱注册并找回密码的方法。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-adc098e0863d2a19.gif?imageMogr2/auto-orient/strip)\n\n请求 LeanCloud 的 API\n\n![](http://upload-images.jianshu.io/upload_images/3191557-d526e3072a087e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n返回登录框\n\n![](http://upload-images.jianshu.io/upload_images/3191557-cb586c8af567044d.gif?imageMogr2/auto-orient/strip)\n\n## 分成一个一个小模块\n\n就是把每个功能分成一个一个的小模块，但是在这一步要注意，会有大量的`props`和`state`。只要不弄混，你就能体会到模块化的好处。\n\n[React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-85d314006e43f8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们用 props 在组件直接传递数据（从父组件到子组件），用 state 保存组件自身的数据，这就是 props 和 state 的区别。\n\n注意每个模块的`state` \n\nApp 的 `state`\n\n```\nthis.state = {\n  user: getCurrentUser() || {},\n  newTodo: '',\n  todoList: []\n}\n```\n\nUserDialog 的 `state`\n\n```\nthis.state = {\n  selectedTeb: 'signInOrSignUp', //forgotPassword\n  formData: {\n    email: '',\n    username: '',\n    password: '',\n  }\n}\n```\n\nSignInOrSignUp 的 `state`\n\n```\nthis.state = {\n  selected: 'signUp'\n}\n```\n\n所以说`state`的分布策略是每个组件只保存与自己有关系的数据到state里。而`props`的用法就是，负责传递数据或函数到子组件中。\n\n如果一个组件没有`state`只有`props`，说明这个组件没有特殊逻辑，是一个纯（pure）的组件，而且还有一个特点是不能对（props）做任何修改。\n\n[Props are Read-Only](https://facebook.github.io/react/docs/components-and-props.html#props-are-read-only)\n\n我们可以把组件只有 `props` 没有 `state` 写成一个函数。\n\n在封装的时候要注意`this`，因为之前还是一个组件，所以是可以利用`this`来接住父组件的数据的，而变成了一个函数之后，`this`传入就是这个函数的东西了。所以 `{this.props.xxx}`就变成了`{props.props.xxx}`。\n\n另外如果组件只有一个方法，也可以改写一个函数\n\n注意\n\n```\nexport default function (props) {\n    return <input type=\"text\" value={props.content} \n    className=\"TodoInput\" \n    onKeyPress={submit.bind(null,props)} \n    onChange={changeTitle.bind(null,props)}/>\n}\n//相当于\nlet temp = function(e){\n    changeTitle.call(null, props, e)\n}\nonChange={temp}\n```\n\n可以说这几行代码是很看基础的。\n\n为什么在那几个函数明明没有用到 React ，但是要用 import React 。这是因为这个函数里面有 JSX ，而引用了这句话后`import React from 'react`浏览器就能读懂。[我想这将是最有价值的 react 入门与进阶教程](http://web.jobbole.com/91637/)\n\n重构到此为止\n\n## 把 TodoItem 的数据上传到云端\n\n我们再回过去看看 LeanCloud 的文档\n\n![](http://upload-images.jianshu.io/upload_images/3191557-087167c7a4e954a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n把这段代码复制来用一下，却得到了这样的反馈。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-4c6b054d27c27e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n控制中心也收到数据了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-1cb2b198f0b21514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以我们就思考一下 TodoItem 的流程\n\n- 创建一个 Todo，就在中心留下一条记录\n- 用户修改一个 Todo，就发请求修改对应的 Todo\n- 用户删除 Todo，我们就删除一个\n\n![](http://upload-images.jianshu.io/upload_images/3191557-213d7d92c6c93bf2.gif?imageMogr2/auto-orient/strip)\n\n这里要用到文档里的代码 [批量操作](https://leancloud.cn/docs/leanstorage_guide-js.html#批量操作) [单用户权限设置](https://leancloud.cn/docs/acl-guide.html#单用户权限设置) [删除对象](https://leancloud.cn/docs/leanstorage_guide-js.html#删除对象) [更新对象](https://leancloud.cn/docs/leanstorage_guide-js.html#更新对象)\n\n注意在更新对象的函数\n\n```\n  update({id,title,status,deleted},successFn,errorFn){\n    let todo = AV.Object.createWithoutData('Todo',id)\n    title !== undefined && todo.set('title',title)\n    status !== undefined && todo.set('status',status)\n    deleted !== undefined && todo.set('deleted',deleted)\n//这里为什么要那么麻烦？\n//为什么我要像上面那样写代码？\n//考虑如下场景\n//update({id:1, title:'hi'})\n//调用 update 时，很有可能没有传 status 和 deleted\n//也就是说，用户只想「局部更新」\n//所以我们只 set 该 set 的\n//那么为什么不写成 title && todo.set('title', title) 呢，为什么要多此一举跟 undefined 做对比呢？\n//考虑如下场景\n//update({id:1, title: '', status: null}}\n//用户想将 title 和 status 置空，我们要满足\n    todo.save().then((response) => {\n      successFn && successFn.call(null)\n    },(error) => {\n      errorFn && errorFn.call(null,error)\n    })\n  }\n```\n\n啊真的累，React 真的难啊，几个小模块就那么多接口...\n\n[所有代码](https://github.com/FRANKIETANG/banana-todolist/commits/master)\n\n[预览](https://frankietang.github.io/banana-todolist/build/index.html)\n\n我会另开几篇文章来详解这里免得知识点的，因为涉及的知识点有点多。","source":"_posts/摸到 React 的门把手 (6).md","raw":"---\ntitle: 摸到 React 的门把手 (6)\ndate: 2017-10-14 00:10:29\ntags: [React,Black History]\n---\n# 摸到 React 的门把手 (6)\n\n慢慢的撸出一个应用，就像看着自己的孩子长大一样。\n\n## 继续撸代码\n\n增加邮箱注册并找回密码的方法。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-adc098e0863d2a19.gif?imageMogr2/auto-orient/strip)\n\n请求 LeanCloud 的 API\n\n![](http://upload-images.jianshu.io/upload_images/3191557-d526e3072a087e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n返回登录框\n\n![](http://upload-images.jianshu.io/upload_images/3191557-cb586c8af567044d.gif?imageMogr2/auto-orient/strip)\n\n## 分成一个一个小模块\n\n就是把每个功能分成一个一个的小模块，但是在这一步要注意，会有大量的`props`和`state`。只要不弄混，你就能体会到模块化的好处。\n\n[React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n\n![](http://upload-images.jianshu.io/upload_images/3191557-85d314006e43f8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们用 props 在组件直接传递数据（从父组件到子组件），用 state 保存组件自身的数据，这就是 props 和 state 的区别。\n\n注意每个模块的`state` \n\nApp 的 `state`\n\n```\nthis.state = {\n  user: getCurrentUser() || {},\n  newTodo: '',\n  todoList: []\n}\n```\n\nUserDialog 的 `state`\n\n```\nthis.state = {\n  selectedTeb: 'signInOrSignUp', //forgotPassword\n  formData: {\n    email: '',\n    username: '',\n    password: '',\n  }\n}\n```\n\nSignInOrSignUp 的 `state`\n\n```\nthis.state = {\n  selected: 'signUp'\n}\n```\n\n所以说`state`的分布策略是每个组件只保存与自己有关系的数据到state里。而`props`的用法就是，负责传递数据或函数到子组件中。\n\n如果一个组件没有`state`只有`props`，说明这个组件没有特殊逻辑，是一个纯（pure）的组件，而且还有一个特点是不能对（props）做任何修改。\n\n[Props are Read-Only](https://facebook.github.io/react/docs/components-and-props.html#props-are-read-only)\n\n我们可以把组件只有 `props` 没有 `state` 写成一个函数。\n\n在封装的时候要注意`this`，因为之前还是一个组件，所以是可以利用`this`来接住父组件的数据的，而变成了一个函数之后，`this`传入就是这个函数的东西了。所以 `{this.props.xxx}`就变成了`{props.props.xxx}`。\n\n另外如果组件只有一个方法，也可以改写一个函数\n\n注意\n\n```\nexport default function (props) {\n    return <input type=\"text\" value={props.content} \n    className=\"TodoInput\" \n    onKeyPress={submit.bind(null,props)} \n    onChange={changeTitle.bind(null,props)}/>\n}\n//相当于\nlet temp = function(e){\n    changeTitle.call(null, props, e)\n}\nonChange={temp}\n```\n\n可以说这几行代码是很看基础的。\n\n为什么在那几个函数明明没有用到 React ，但是要用 import React 。这是因为这个函数里面有 JSX ，而引用了这句话后`import React from 'react`浏览器就能读懂。[我想这将是最有价值的 react 入门与进阶教程](http://web.jobbole.com/91637/)\n\n重构到此为止\n\n## 把 TodoItem 的数据上传到云端\n\n我们再回过去看看 LeanCloud 的文档\n\n![](http://upload-images.jianshu.io/upload_images/3191557-087167c7a4e954a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n把这段代码复制来用一下，却得到了这样的反馈。\n\n![](http://upload-images.jianshu.io/upload_images/3191557-4c6b054d27c27e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n控制中心也收到数据了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-1cb2b198f0b21514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n所以我们就思考一下 TodoItem 的流程\n\n- 创建一个 Todo，就在中心留下一条记录\n- 用户修改一个 Todo，就发请求修改对应的 Todo\n- 用户删除 Todo，我们就删除一个\n\n![](http://upload-images.jianshu.io/upload_images/3191557-213d7d92c6c93bf2.gif?imageMogr2/auto-orient/strip)\n\n这里要用到文档里的代码 [批量操作](https://leancloud.cn/docs/leanstorage_guide-js.html#批量操作) [单用户权限设置](https://leancloud.cn/docs/acl-guide.html#单用户权限设置) [删除对象](https://leancloud.cn/docs/leanstorage_guide-js.html#删除对象) [更新对象](https://leancloud.cn/docs/leanstorage_guide-js.html#更新对象)\n\n注意在更新对象的函数\n\n```\n  update({id,title,status,deleted},successFn,errorFn){\n    let todo = AV.Object.createWithoutData('Todo',id)\n    title !== undefined && todo.set('title',title)\n    status !== undefined && todo.set('status',status)\n    deleted !== undefined && todo.set('deleted',deleted)\n//这里为什么要那么麻烦？\n//为什么我要像上面那样写代码？\n//考虑如下场景\n//update({id:1, title:'hi'})\n//调用 update 时，很有可能没有传 status 和 deleted\n//也就是说，用户只想「局部更新」\n//所以我们只 set 该 set 的\n//那么为什么不写成 title && todo.set('title', title) 呢，为什么要多此一举跟 undefined 做对比呢？\n//考虑如下场景\n//update({id:1, title: '', status: null}}\n//用户想将 title 和 status 置空，我们要满足\n    todo.save().then((response) => {\n      successFn && successFn.call(null)\n    },(error) => {\n      errorFn && errorFn.call(null,error)\n    })\n  }\n```\n\n啊真的累，React 真的难啊，几个小模块就那么多接口...\n\n[所有代码](https://github.com/FRANKIETANG/banana-todolist/commits/master)\n\n[预览](https://frankietang.github.io/banana-todolist/build/index.html)\n\n我会另开几篇文章来详解这里免得知识点的，因为涉及的知识点有点多。","slug":"摸到 React 的门把手 (6)","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8i000mf1xh62uvwmuk","content":"<h1 id=\"摸到-React-的门把手-6\"><a href=\"#摸到-React-的门把手-6\" class=\"headerlink\" title=\"摸到 React 的门把手 (6)\"></a>摸到 React 的门把手 (6)</h1><p>慢慢的撸出一个应用，就像看着自己的孩子长大一样。</p>\n<h2 id=\"继续撸代码\"><a href=\"#继续撸代码\" class=\"headerlink\" title=\"继续撸代码\"></a>继续撸代码</h2><p>增加邮箱注册并找回密码的方法。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-adc098e0863d2a19.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>请求 LeanCloud 的 API</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-d526e3072a087e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>返回登录框</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-cb586c8af567044d.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<h2 id=\"分成一个一个小模块\"><a href=\"#分成一个一个小模块\" class=\"headerlink\" title=\"分成一个一个小模块\"></a>分成一个一个小模块</h2><p>就是把每个功能分成一个一个的小模块，但是在这一步要注意，会有大量的<code>props</code>和<code>state</code>。只要不弄混，你就能体会到模块化的好处。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"noopener\">React Developer Tools</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-85d314006e43f8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我们用 props 在组件直接传递数据（从父组件到子组件），用 state 保存组件自身的数据，这就是 props 和 state 的区别。</p>\n<p>注意每个模块的<code>state</code> </p>\n<p>App 的 <code>state</code></p>\n<pre><code>this.state = {\n  user: getCurrentUser() || {},\n  newTodo: &#39;&#39;,\n  todoList: []\n}\n</code></pre><p>UserDialog 的 <code>state</code></p>\n<pre><code>this.state = {\n  selectedTeb: &#39;signInOrSignUp&#39;, //forgotPassword\n  formData: {\n    email: &#39;&#39;,\n    username: &#39;&#39;,\n    password: &#39;&#39;,\n  }\n}\n</code></pre><p>SignInOrSignUp 的 <code>state</code></p>\n<pre><code>this.state = {\n  selected: &#39;signUp&#39;\n}\n</code></pre><p>所以说<code>state</code>的分布策略是每个组件只保存与自己有关系的数据到state里。而<code>props</code>的用法就是，负责传递数据或函数到子组件中。</p>\n<p>如果一个组件没有<code>state</code>只有<code>props</code>，说明这个组件没有特殊逻辑，是一个纯（pure）的组件，而且还有一个特点是不能对（props）做任何修改。</p>\n<p><a href=\"https://facebook.github.io/react/docs/components-and-props.html#props-are-read-only\" target=\"_blank\" rel=\"noopener\">Props are Read-Only</a></p>\n<p>我们可以把组件只有 <code>props</code> 没有 <code>state</code> 写成一个函数。</p>\n<p>在封装的时候要注意<code>this</code>，因为之前还是一个组件，所以是可以利用<code>this</code>来接住父组件的数据的，而变成了一个函数之后，<code>this</code>传入就是这个函数的东西了。所以 <code>{this.props.xxx}</code>就变成了<code>{props.props.xxx}</code>。</p>\n<p>另外如果组件只有一个方法，也可以改写一个函数</p>\n<p>注意</p>\n<pre><code>export default function (props) {\n    return &lt;input type=&quot;text&quot; value={props.content} \n    className=&quot;TodoInput&quot; \n    onKeyPress={submit.bind(null,props)} \n    onChange={changeTitle.bind(null,props)}/&gt;\n}\n//相当于\nlet temp = function(e){\n    changeTitle.call(null, props, e)\n}\nonChange={temp}\n</code></pre><p>可以说这几行代码是很看基础的。</p>\n<p>为什么在那几个函数明明没有用到 React ，但是要用 import React 。这是因为这个函数里面有 JSX ，而引用了这句话后<code>import React from &#39;react</code>浏览器就能读懂。<a href=\"http://web.jobbole.com/91637/\" target=\"_blank\" rel=\"noopener\">我想这将是最有价值的 react 入门与进阶教程</a></p>\n<p>重构到此为止</p>\n<h2 id=\"把-TodoItem-的数据上传到云端\"><a href=\"#把-TodoItem-的数据上传到云端\" class=\"headerlink\" title=\"把 TodoItem 的数据上传到云端\"></a>把 TodoItem 的数据上传到云端</h2><p>我们再回过去看看 LeanCloud 的文档</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-087167c7a4e954a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>把这段代码复制来用一下，却得到了这样的反馈。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-4c6b054d27c27e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>控制中心也收到数据了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-1cb2b198f0b21514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>所以我们就思考一下 TodoItem 的流程</p>\n<ul>\n<li>创建一个 Todo，就在中心留下一条记录</li>\n<li>用户修改一个 Todo，就发请求修改对应的 Todo</li>\n<li>用户删除 Todo，我们就删除一个</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-213d7d92c6c93bf2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>这里要用到文档里的代码 <a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#批量操作\" target=\"_blank\" rel=\"noopener\">批量操作</a> <a href=\"https://leancloud.cn/docs/acl-guide.html#单用户权限设置\" target=\"_blank\" rel=\"noopener\">单用户权限设置</a> <a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#删除对象\" target=\"_blank\" rel=\"noopener\">删除对象</a> <a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#更新对象\" target=\"_blank\" rel=\"noopener\">更新对象</a></p>\n<p>注意在更新对象的函数</p>\n<pre><code>  update({id,title,status,deleted},successFn,errorFn){\n    let todo = AV.Object.createWithoutData(&#39;Todo&#39;,id)\n    title !== undefined &amp;&amp; todo.set(&#39;title&#39;,title)\n    status !== undefined &amp;&amp; todo.set(&#39;status&#39;,status)\n    deleted !== undefined &amp;&amp; todo.set(&#39;deleted&#39;,deleted)\n//这里为什么要那么麻烦？\n//为什么我要像上面那样写代码？\n//考虑如下场景\n//update({id:1, title:&#39;hi&#39;})\n//调用 update 时，很有可能没有传 status 和 deleted\n//也就是说，用户只想「局部更新」\n//所以我们只 set 该 set 的\n//那么为什么不写成 title &amp;&amp; todo.set(&#39;title&#39;, title) 呢，为什么要多此一举跟 undefined 做对比呢？\n//考虑如下场景\n//update({id:1, title: &#39;&#39;, status: null}}\n//用户想将 title 和 status 置空，我们要满足\n    todo.save().then((response) =&gt; {\n      successFn &amp;&amp; successFn.call(null)\n    },(error) =&gt; {\n      errorFn &amp;&amp; errorFn.call(null,error)\n    })\n  }\n</code></pre><p>啊真的累，React 真的难啊，几个小模块就那么多接口…</p>\n<p><a href=\"https://github.com/FRANKIETANG/banana-todolist/commits/master\" target=\"_blank\" rel=\"noopener\">所有代码</a></p>\n<p><a href=\"https://frankietang.github.io/banana-todolist/build/index.html\" target=\"_blank\" rel=\"noopener\">预览</a></p>\n<p>我会另开几篇文章来详解这里免得知识点的，因为涉及的知识点有点多。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-React-的门把手-6\"><a href=\"#摸到-React-的门把手-6\" class=\"headerlink\" title=\"摸到 React 的门把手 (6)\"></a>摸到 React 的门把手 (6)</h1><p>慢慢的撸出一个应用，就像看着自己的孩子长大一样。</p>\n<h2 id=\"继续撸代码\"><a href=\"#继续撸代码\" class=\"headerlink\" title=\"继续撸代码\"></a>继续撸代码</h2><p>增加邮箱注册并找回密码的方法。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-adc098e0863d2a19.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>请求 LeanCloud 的 API</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-d526e3072a087e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>返回登录框</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-cb586c8af567044d.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<h2 id=\"分成一个一个小模块\"><a href=\"#分成一个一个小模块\" class=\"headerlink\" title=\"分成一个一个小模块\"></a>分成一个一个小模块</h2><p>就是把每个功能分成一个一个的小模块，但是在这一步要注意，会有大量的<code>props</code>和<code>state</code>。只要不弄混，你就能体会到模块化的好处。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"noopener\">React Developer Tools</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-85d314006e43f8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>我们用 props 在组件直接传递数据（从父组件到子组件），用 state 保存组件自身的数据，这就是 props 和 state 的区别。</p>\n<p>注意每个模块的<code>state</code> </p>\n<p>App 的 <code>state</code></p>\n<pre><code>this.state = {\n  user: getCurrentUser() || {},\n  newTodo: &#39;&#39;,\n  todoList: []\n}\n</code></pre><p>UserDialog 的 <code>state</code></p>\n<pre><code>this.state = {\n  selectedTeb: &#39;signInOrSignUp&#39;, //forgotPassword\n  formData: {\n    email: &#39;&#39;,\n    username: &#39;&#39;,\n    password: &#39;&#39;,\n  }\n}\n</code></pre><p>SignInOrSignUp 的 <code>state</code></p>\n<pre><code>this.state = {\n  selected: &#39;signUp&#39;\n}\n</code></pre><p>所以说<code>state</code>的分布策略是每个组件只保存与自己有关系的数据到state里。而<code>props</code>的用法就是，负责传递数据或函数到子组件中。</p>\n<p>如果一个组件没有<code>state</code>只有<code>props</code>，说明这个组件没有特殊逻辑，是一个纯（pure）的组件，而且还有一个特点是不能对（props）做任何修改。</p>\n<p><a href=\"https://facebook.github.io/react/docs/components-and-props.html#props-are-read-only\" target=\"_blank\" rel=\"noopener\">Props are Read-Only</a></p>\n<p>我们可以把组件只有 <code>props</code> 没有 <code>state</code> 写成一个函数。</p>\n<p>在封装的时候要注意<code>this</code>，因为之前还是一个组件，所以是可以利用<code>this</code>来接住父组件的数据的，而变成了一个函数之后，<code>this</code>传入就是这个函数的东西了。所以 <code>{this.props.xxx}</code>就变成了<code>{props.props.xxx}</code>。</p>\n<p>另外如果组件只有一个方法，也可以改写一个函数</p>\n<p>注意</p>\n<pre><code>export default function (props) {\n    return &lt;input type=&quot;text&quot; value={props.content} \n    className=&quot;TodoInput&quot; \n    onKeyPress={submit.bind(null,props)} \n    onChange={changeTitle.bind(null,props)}/&gt;\n}\n//相当于\nlet temp = function(e){\n    changeTitle.call(null, props, e)\n}\nonChange={temp}\n</code></pre><p>可以说这几行代码是很看基础的。</p>\n<p>为什么在那几个函数明明没有用到 React ，但是要用 import React 。这是因为这个函数里面有 JSX ，而引用了这句话后<code>import React from &#39;react</code>浏览器就能读懂。<a href=\"http://web.jobbole.com/91637/\" target=\"_blank\" rel=\"noopener\">我想这将是最有价值的 react 入门与进阶教程</a></p>\n<p>重构到此为止</p>\n<h2 id=\"把-TodoItem-的数据上传到云端\"><a href=\"#把-TodoItem-的数据上传到云端\" class=\"headerlink\" title=\"把 TodoItem 的数据上传到云端\"></a>把 TodoItem 的数据上传到云端</h2><p>我们再回过去看看 LeanCloud 的文档</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-087167c7a4e954a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>把这段代码复制来用一下，却得到了这样的反馈。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-4c6b054d27c27e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>控制中心也收到数据了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-1cb2b198f0b21514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>所以我们就思考一下 TodoItem 的流程</p>\n<ul>\n<li>创建一个 Todo，就在中心留下一条记录</li>\n<li>用户修改一个 Todo，就发请求修改对应的 Todo</li>\n<li>用户删除 Todo，我们就删除一个</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-213d7d92c6c93bf2.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>这里要用到文档里的代码 <a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#批量操作\" target=\"_blank\" rel=\"noopener\">批量操作</a> <a href=\"https://leancloud.cn/docs/acl-guide.html#单用户权限设置\" target=\"_blank\" rel=\"noopener\">单用户权限设置</a> <a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#删除对象\" target=\"_blank\" rel=\"noopener\">删除对象</a> <a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#更新对象\" target=\"_blank\" rel=\"noopener\">更新对象</a></p>\n<p>注意在更新对象的函数</p>\n<pre><code>  update({id,title,status,deleted},successFn,errorFn){\n    let todo = AV.Object.createWithoutData(&#39;Todo&#39;,id)\n    title !== undefined &amp;&amp; todo.set(&#39;title&#39;,title)\n    status !== undefined &amp;&amp; todo.set(&#39;status&#39;,status)\n    deleted !== undefined &amp;&amp; todo.set(&#39;deleted&#39;,deleted)\n//这里为什么要那么麻烦？\n//为什么我要像上面那样写代码？\n//考虑如下场景\n//update({id:1, title:&#39;hi&#39;})\n//调用 update 时，很有可能没有传 status 和 deleted\n//也就是说，用户只想「局部更新」\n//所以我们只 set 该 set 的\n//那么为什么不写成 title &amp;&amp; todo.set(&#39;title&#39;, title) 呢，为什么要多此一举跟 undefined 做对比呢？\n//考虑如下场景\n//update({id:1, title: &#39;&#39;, status: null}}\n//用户想将 title 和 status 置空，我们要满足\n    todo.save().then((response) =&gt; {\n      successFn &amp;&amp; successFn.call(null)\n    },(error) =&gt; {\n      errorFn &amp;&amp; errorFn.call(null,error)\n    })\n  }\n</code></pre><p>啊真的累，React 真的难啊，几个小模块就那么多接口…</p>\n<p><a href=\"https://github.com/FRANKIETANG/banana-todolist/commits/master\" target=\"_blank\" rel=\"noopener\">所有代码</a></p>\n<p><a href=\"https://frankietang.github.io/banana-todolist/build/index.html\" target=\"_blank\" rel=\"noopener\">预览</a></p>\n<p>我会另开几篇文章来详解这里免得知识点的，因为涉及的知识点有点多。</p>\n"},{"title":"摸到 React 的门把手 (完)","date":"2017-10-13T16:11:08.000Z","_content":"# 摸到 React 的门把手 (完)\n\n写啊写啊终于把大概功能给写完了 [效果](https://frankietang.github.io/banana-todolist/build/index.html#) ，CSS 真难写啊... 我的同学说，审美这些东西要慢慢培养。\n\n接下来我们来说说这个项目用到了什么知识点。\n\n## 1. JSX / React / webpack / LeanCloud 等知识。\n\n在我博客都有很详细的介绍，这里就不多说了。[我的博客](https://frankietang.github.io/)\n\n## 2. HTML\n\n### 2.1 form 表单\n\n`<input id=\"xxx\">` 和 `<label for=\"xxx\">` 可以对应关联\n\n### 2.2 HTML5 LocalStorage 本地存储\n\n在这个项目里 LocalStorage 的用法是这样的\n\n- 用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage\n- 重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList\n\n```\nexport function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n```\n\n## 3. CSS\n\n### 3.1 flex 布局\n\n[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)\n\n### 3.2 CSS 选择器\n\n[CSS 选择器 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started/Selectors)\n\n## 4. JavaScript\n\n### 4.1 import...from...\n\n[import - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)\n\n**import 语句 **用于从一个已经导出的外部模块或另一个脚本中导入函数，对象或原始类型。\n\n### 4.2 ES6 - Class\n\n[Class - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes) [Class 的基本语法](http://es6.ruanyifeng.com/#docs/class#Class-的-Generator-方法)\n\n而我的项目最多是用到 `constructor()` / `extends` / `super()` ，这里举一个例子\n\n```\nclass TestSuper {\n  constructor() {\n    this.a = 'a'\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = 'b'\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:'a',b:'b'}\n```\n\n`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n`extends` 关键词被用在[类声明](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class)或者[类表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class)上，以创建一个类是另一个类的子类。\n\n`super` 关键字用于调用一个对象的父对象上的函数。\n\n### 4.3 ES6 - 箭头函数\n\n```\nvar f = v => v;\nvar f1 = v => {\n  return v\n}\n//相当于\nvar f = function f(v) {\n\treturn v;\n};\nvar f1 = function f1(v) {\n\treturn v;\n};\n```\n\n### 4.4 拓展运算符\n\n[扩展语句 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator)\n\n```\nconst pa = (...args) => {\n\tconsole.log(args);\n\treturn args.reduce((pre,cur) => {\n\t\treturn pre+cur;\n\t}, 0);\n};\npa.apply(this, [1,2,45]);\n//[1,2,45]\n//48\n```\n\n### 4.5 逻辑运算符 || 用来定义默认参数\n\n[逻辑运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators)\n\n```\nvar link = function (height,color,url) {\n  var height = height || 50\n  var color = color || 'red'\n  var url = url || 'https://frankie.github.io'\n}\n```\n\n### 4.6 深拷贝\n\n```\n//deep Clone\nlet obj1 = {a: 0, b: {c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // {a: 0, b: {c: 0}}\n```\n\n### 4.7 条件（三元）运算符\n\n[条件运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)\n\n```\ncondition ? expr1 : expr2\n```\n\n### 4.8 apply() / call() / bind() \n\n```\nvar xw = {\n  name : \"小王\",\n  gender : \"男\",\n  age : 24,\n  say : function() {\n\t  alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age);        \n\t}\n}\nvar xh = {\n  name : \"小红\",\n  gender : \"女\",\n  age : 18\n}\nxw.say();\nxw.say.call(xh);\nxw.say.apply(xh);\nxw.say.bind(xh)();\n```\n\ncall和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。\n\n```\nvar xw = {\n  name : \"小王\",\n  gender : \"男\",\n  age : 24,\n  say : function(school,grade) {\n    alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age + \" ,在\" + school + \"上\" + grade);  \n  }\n}\nvar xh = {\n  name : \"小红\",\n  gender : \"女\",\n  age : 18\n}\nxw.say.call(xh,\"实验小学\",\"六年级\");\nxw.say.apply(xh,[\"实验小学\",\"六年级\"]);\nxw.say.bind(xh,\"实验小学\",\"六年级\")();\nxw.say.bind(xh)(\"实验小学\",\"六年级\");\n```\n\ncall后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。\n那么bind怎么传参呢？它可以像call那样传参。\n\n### 4.9 event.preventDefault\n\n如果事件可取消，则取消该事件，而不停止事件的进一步传播。\n\n例子：切换复选框是单击复选框的默认操作。此示例演示如何防止这种情况发生\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>event.preventDefault()</title>\n</head>\n<body>\n    <p>请点击复选框控件</p>\n    <form>\n        <label for=\"id-checkbox\">Checkbox</label>\n        <input type=\"checkbox\" id=\"id-checkbox\" name=\"checkbox\" />\n    </form>\n    <script>\n        document.querySelector(\"#id-checkbox\").addEventListener(\"click\", function(event){\n            alert(\"preventDefault会阻止该复选框被勾选.\")\n            event.preventDefault();\n            //阻止该复选框被勾选\n        }, false);\n    </script>\n</body>\n</html>\n```\n\n### 4.10 this\n\n[this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n\n[Javascript的this用法](http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html)\n\n[this 的值到底是什么？一次说清楚](https://zhuanlan.zhihu.com/p/23804247?refer=study-fe)\n\n[你怎么还没搞懂this](https://zhuanlan.zhihu.com/p/25991271)\n\n### 4.11 JavaScript 的 new\n\n[JS 的 new 到底是干什么的？](https://zhuanlan.zhihu.com/p/23987456?refer=study-fe)\n\n## 5. 最后的一点建议\n\n还是好好的刷一遍《JavaScript 高级程序设计》和《ES6 标准入门》吧，要不然基础差的你很难上手 React 。\n\n## 6. 相关链接\n\n[摸到 ES6 的门把手](https://frankietang.github.io/2017/08/17/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\n[摸到 webpack 的门把手](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\n[摸到 webpack 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/)\n\n[摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\n[摸到 React 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/)\n\n[摸到 React 的门把手 (3)](https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/)\n\n[摸到 React 的门把手 (4)](https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%284%29/)\n\n[摸到 React 的门把手 (5)](https://frankietang.github.io/2017/08/24/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%285%29/)\n\n[摸到 React 的门把手 (6)](https://frankietang.github.io/2017/08/25/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%286%29/)\n\n这个项目的 2.0 版将会无限期跳票...","source":"_posts/摸到 React 的门把手 (完).md","raw":"---\ntitle: 摸到 React 的门把手 (完)\ndate: 2017-10-14 00:11:08\ntags: [React,Black History]\n---\n# 摸到 React 的门把手 (完)\n\n写啊写啊终于把大概功能给写完了 [效果](https://frankietang.github.io/banana-todolist/build/index.html#) ，CSS 真难写啊... 我的同学说，审美这些东西要慢慢培养。\n\n接下来我们来说说这个项目用到了什么知识点。\n\n## 1. JSX / React / webpack / LeanCloud 等知识。\n\n在我博客都有很详细的介绍，这里就不多说了。[我的博客](https://frankietang.github.io/)\n\n## 2. HTML\n\n### 2.1 form 表单\n\n`<input id=\"xxx\">` 和 `<label for=\"xxx\">` 可以对应关联\n\n### 2.2 HTML5 LocalStorage 本地存储\n\n在这个项目里 LocalStorage 的用法是这样的\n\n- 用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage\n- 重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList\n\n```\nexport function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n```\n\n## 3. CSS\n\n### 3.1 flex 布局\n\n[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)\n\n### 3.2 CSS 选择器\n\n[CSS 选择器 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started/Selectors)\n\n## 4. JavaScript\n\n### 4.1 import...from...\n\n[import - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)\n\n**import 语句 **用于从一个已经导出的外部模块或另一个脚本中导入函数，对象或原始类型。\n\n### 4.2 ES6 - Class\n\n[Class - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes) [Class 的基本语法](http://es6.ruanyifeng.com/#docs/class#Class-的-Generator-方法)\n\n而我的项目最多是用到 `constructor()` / `extends` / `super()` ，这里举一个例子\n\n```\nclass TestSuper {\n  constructor() {\n    this.a = 'a'\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = 'b'\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:'a',b:'b'}\n```\n\n`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n`extends` 关键词被用在[类声明](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class)或者[类表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class)上，以创建一个类是另一个类的子类。\n\n`super` 关键字用于调用一个对象的父对象上的函数。\n\n### 4.3 ES6 - 箭头函数\n\n```\nvar f = v => v;\nvar f1 = v => {\n  return v\n}\n//相当于\nvar f = function f(v) {\n\treturn v;\n};\nvar f1 = function f1(v) {\n\treturn v;\n};\n```\n\n### 4.4 拓展运算符\n\n[扩展语句 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator)\n\n```\nconst pa = (...args) => {\n\tconsole.log(args);\n\treturn args.reduce((pre,cur) => {\n\t\treturn pre+cur;\n\t}, 0);\n};\npa.apply(this, [1,2,45]);\n//[1,2,45]\n//48\n```\n\n### 4.5 逻辑运算符 || 用来定义默认参数\n\n[逻辑运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators)\n\n```\nvar link = function (height,color,url) {\n  var height = height || 50\n  var color = color || 'red'\n  var url = url || 'https://frankie.github.io'\n}\n```\n\n### 4.6 深拷贝\n\n```\n//deep Clone\nlet obj1 = {a: 0, b: {c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // {a: 0, b: {c: 0}}\n```\n\n### 4.7 条件（三元）运算符\n\n[条件运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)\n\n```\ncondition ? expr1 : expr2\n```\n\n### 4.8 apply() / call() / bind() \n\n```\nvar xw = {\n  name : \"小王\",\n  gender : \"男\",\n  age : 24,\n  say : function() {\n\t  alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age);        \n\t}\n}\nvar xh = {\n  name : \"小红\",\n  gender : \"女\",\n  age : 18\n}\nxw.say();\nxw.say.call(xh);\nxw.say.apply(xh);\nxw.say.bind(xh)();\n```\n\ncall和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。\n\n```\nvar xw = {\n  name : \"小王\",\n  gender : \"男\",\n  age : 24,\n  say : function(school,grade) {\n    alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age + \" ,在\" + school + \"上\" + grade);  \n  }\n}\nvar xh = {\n  name : \"小红\",\n  gender : \"女\",\n  age : 18\n}\nxw.say.call(xh,\"实验小学\",\"六年级\");\nxw.say.apply(xh,[\"实验小学\",\"六年级\"]);\nxw.say.bind(xh,\"实验小学\",\"六年级\")();\nxw.say.bind(xh)(\"实验小学\",\"六年级\");\n```\n\ncall后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。\n那么bind怎么传参呢？它可以像call那样传参。\n\n### 4.9 event.preventDefault\n\n如果事件可取消，则取消该事件，而不停止事件的进一步传播。\n\n例子：切换复选框是单击复选框的默认操作。此示例演示如何防止这种情况发生\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>event.preventDefault()</title>\n</head>\n<body>\n    <p>请点击复选框控件</p>\n    <form>\n        <label for=\"id-checkbox\">Checkbox</label>\n        <input type=\"checkbox\" id=\"id-checkbox\" name=\"checkbox\" />\n    </form>\n    <script>\n        document.querySelector(\"#id-checkbox\").addEventListener(\"click\", function(event){\n            alert(\"preventDefault会阻止该复选框被勾选.\")\n            event.preventDefault();\n            //阻止该复选框被勾选\n        }, false);\n    </script>\n</body>\n</html>\n```\n\n### 4.10 this\n\n[this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n\n[Javascript的this用法](http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html)\n\n[this 的值到底是什么？一次说清楚](https://zhuanlan.zhihu.com/p/23804247?refer=study-fe)\n\n[你怎么还没搞懂this](https://zhuanlan.zhihu.com/p/25991271)\n\n### 4.11 JavaScript 的 new\n\n[JS 的 new 到底是干什么的？](https://zhuanlan.zhihu.com/p/23987456?refer=study-fe)\n\n## 5. 最后的一点建议\n\n还是好好的刷一遍《JavaScript 高级程序设计》和《ES6 标准入门》吧，要不然基础差的你很难上手 React 。\n\n## 6. 相关链接\n\n[摸到 ES6 的门把手](https://frankietang.github.io/2017/08/17/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\n[摸到 webpack 的门把手](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\n[摸到 webpack 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/)\n\n[摸到 React 的门把手](https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\n[摸到 React 的门把手 (2)](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/)\n\n[摸到 React 的门把手 (3)](https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/)\n\n[摸到 React 的门把手 (4)](https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%284%29/)\n\n[摸到 React 的门把手 (5)](https://frankietang.github.io/2017/08/24/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%285%29/)\n\n[摸到 React 的门把手 (6)](https://frankietang.github.io/2017/08/25/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%286%29/)\n\n这个项目的 2.0 版将会无限期跳票...","slug":"摸到 React 的门把手 (完)","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8k000of1xhtir0fwe1","content":"<h1 id=\"摸到-React-的门把手-完\"><a href=\"#摸到-React-的门把手-完\" class=\"headerlink\" title=\"摸到 React 的门把手 (完)\"></a>摸到 React 的门把手 (完)</h1><p>写啊写啊终于把大概功能给写完了 <a href=\"https://frankietang.github.io/banana-todolist/build/index.html#\" target=\"_blank\" rel=\"noopener\">效果</a> ，CSS 真难写啊… 我的同学说，审美这些东西要慢慢培养。</p>\n<p>接下来我们来说说这个项目用到了什么知识点。</p>\n<h2 id=\"1-JSX-React-webpack-LeanCloud-等知识。\"><a href=\"#1-JSX-React-webpack-LeanCloud-等知识。\" class=\"headerlink\" title=\"1. JSX / React / webpack / LeanCloud 等知识。\"></a>1. JSX / React / webpack / LeanCloud 等知识。</h2><p>在我博客都有很详细的介绍，这里就不多说了。<a href=\"https://frankietang.github.io/\" target=\"_blank\" rel=\"noopener\">我的博客</a></p>\n<h2 id=\"2-HTML\"><a href=\"#2-HTML\" class=\"headerlink\" title=\"2. HTML\"></a>2. HTML</h2><h3 id=\"2-1-form-表单\"><a href=\"#2-1-form-表单\" class=\"headerlink\" title=\"2.1 form 表单\"></a>2.1 form 表单</h3><p><code>&lt;input id=&quot;xxx&quot;&gt;</code> 和 <code>&lt;label for=&quot;xxx&quot;&gt;</code> 可以对应关联</p>\n<h3 id=\"2-2-HTML5-LocalStorage-本地存储\"><a href=\"#2-2-HTML5-LocalStorage-本地存储\" class=\"headerlink\" title=\"2.2 HTML5 LocalStorage 本地存储\"></a>2.2 HTML5 LocalStorage 本地存储</h3><p>在这个项目里 LocalStorage 的用法是这样的</p>\n<ul>\n<li>用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage</li>\n<li>重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList</li>\n</ul>\n<pre><code>export function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n</code></pre><h2 id=\"3-CSS\"><a href=\"#3-CSS\" class=\"headerlink\" title=\"3. CSS\"></a>3. CSS</h2><h3 id=\"3-1-flex-布局\"><a href=\"#3-1-flex-布局\" class=\"headerlink\" title=\"3.1 flex 布局\"></a>3.1 flex 布局</h3><p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">Flex 布局教程：实例篇</a></p>\n<h3 id=\"3-2-CSS-选择器\"><a href=\"#3-2-CSS-选择器\" class=\"headerlink\" title=\"3.2 CSS 选择器\"></a>3.2 CSS 选择器</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started/Selectors\" target=\"_blank\" rel=\"noopener\">CSS 选择器 - MDN</a></p>\n<h2 id=\"4-JavaScript\"><a href=\"#4-JavaScript\" class=\"headerlink\" title=\"4. JavaScript\"></a>4. JavaScript</h2><h3 id=\"4-1-import…from…\"><a href=\"#4-1-import…from…\" class=\"headerlink\" title=\"4.1 import…from…\"></a>4.1 import…from…</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import\" target=\"_blank\" rel=\"noopener\">import - MDN</a></p>\n<p><strong>import 语句 </strong>用于从一个已经导出的外部模块或另一个脚本中导入函数，对象或原始类型。</p>\n<h3 id=\"4-2-ES6-Class\"><a href=\"#4-2-ES6-Class\" class=\"headerlink\" title=\"4.2 ES6 - Class\"></a>4.2 ES6 - Class</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\" target=\"_blank\" rel=\"noopener\">Class - MDN</a> <a href=\"http://es6.ruanyifeng.com/#docs/class#Class-的-Generator-方法\" target=\"_blank\" rel=\"noopener\">Class 的基本语法</a></p>\n<p>而我的项目最多是用到 <code>constructor()</code> / <code>extends</code> / <code>super()</code> ，这里举一个例子</p>\n<pre><code>class TestSuper {\n  constructor() {\n    this.a = &#39;a&#39;\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = &#39;b&#39;\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:&#39;a&#39;,b:&#39;b&#39;}\n</code></pre><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<p><code>extends</code> 关键词被用在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class\" target=\"_blank\" rel=\"noopener\">类声明</a>或者<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class\" target=\"_blank\" rel=\"noopener\">类表达式</a>上，以创建一个类是另一个类的子类。</p>\n<p><code>super</code> 关键字用于调用一个对象的父对象上的函数。</p>\n<h3 id=\"4-3-ES6-箭头函数\"><a href=\"#4-3-ES6-箭头函数\" class=\"headerlink\" title=\"4.3 ES6 - 箭头函数\"></a>4.3 ES6 - 箭头函数</h3><pre><code>var f = v =&gt; v;\nvar f1 = v =&gt; {\n  return v\n}\n//相当于\nvar f = function f(v) {\n    return v;\n};\nvar f1 = function f1(v) {\n    return v;\n};\n</code></pre><h3 id=\"4-4-拓展运算符\"><a href=\"#4-4-拓展运算符\" class=\"headerlink\" title=\"4.4 拓展运算符\"></a>4.4 拓展运算符</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">扩展语句 - MDN</a></p>\n<pre><code>const pa = (...args) =&gt; {\n    console.log(args);\n    return args.reduce((pre,cur) =&gt; {\n        return pre+cur;\n    }, 0);\n};\npa.apply(this, [1,2,45]);\n//[1,2,45]\n//48\n</code></pre><h3 id=\"4-5-逻辑运算符-用来定义默认参数\"><a href=\"#4-5-逻辑运算符-用来定义默认参数\" class=\"headerlink\" title=\"4.5 逻辑运算符 || 用来定义默认参数\"></a>4.5 逻辑运算符 || 用来定义默认参数</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators\" target=\"_blank\" rel=\"noopener\">逻辑运算符</a></p>\n<pre><code>var link = function (height,color,url) {\n  var height = height || 50\n  var color = color || &#39;red&#39;\n  var url = url || &#39;https://frankie.github.io&#39;\n}\n</code></pre><h3 id=\"4-6-深拷贝\"><a href=\"#4-6-深拷贝\" class=\"headerlink\" title=\"4.6 深拷贝\"></a>4.6 深拷贝</h3><pre><code>//deep Clone\nlet obj1 = {a: 0, b: {c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // {a: 0, b: {c: 0}}\n</code></pre><h3 id=\"4-7-条件（三元）运算符\"><a href=\"#4-7-条件（三元）运算符\" class=\"headerlink\" title=\"4.7 条件（三元）运算符\"></a>4.7 条件（三元）运算符</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" target=\"_blank\" rel=\"noopener\">条件运算符</a></p>\n<pre><code>condition ? expr1 : expr2\n</code></pre><h3 id=\"4-8-apply-call-bind\"><a href=\"#4-8-apply-call-bind\" class=\"headerlink\" title=\"4.8 apply() / call() / bind()\"></a>4.8 apply() / call() / bind()</h3><pre><code>var xw = {\n  name : &quot;小王&quot;,\n  gender : &quot;男&quot;,\n  age : 24,\n  say : function() {\n      alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age);        \n    }\n}\nvar xh = {\n  name : &quot;小红&quot;,\n  gender : &quot;女&quot;,\n  age : 18\n}\nxw.say();\nxw.say.call(xh);\nxw.say.apply(xh);\nxw.say.bind(xh)();\n</code></pre><p>call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。</p>\n<pre><code>var xw = {\n  name : &quot;小王&quot;,\n  gender : &quot;男&quot;,\n  age : 24,\n  say : function(school,grade) {\n    alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age + &quot; ,在&quot; + school + &quot;上&quot; + grade);  \n  }\n}\nvar xh = {\n  name : &quot;小红&quot;,\n  gender : &quot;女&quot;,\n  age : 18\n}\nxw.say.call(xh,&quot;实验小学&quot;,&quot;六年级&quot;);\nxw.say.apply(xh,[&quot;实验小学&quot;,&quot;六年级&quot;]);\nxw.say.bind(xh,&quot;实验小学&quot;,&quot;六年级&quot;)();\nxw.say.bind(xh)(&quot;实验小学&quot;,&quot;六年级&quot;);\n</code></pre><p>call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。<br>那么bind怎么传参呢？它可以像call那样传参。</p>\n<h3 id=\"4-9-event-preventDefault\"><a href=\"#4-9-event-preventDefault\" class=\"headerlink\" title=\"4.9 event.preventDefault\"></a>4.9 event.preventDefault</h3><p>如果事件可取消，则取消该事件，而不停止事件的进一步传播。</p>\n<p>例子：切换复选框是单击复选框的默认操作。此示例演示如何防止这种情况发生</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;event.preventDefault()&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;请点击复选框控件&lt;/p&gt;\n    &lt;form&gt;\n        &lt;label for=&quot;id-checkbox&quot;&gt;Checkbox&lt;/label&gt;\n        &lt;input type=&quot;checkbox&quot; id=&quot;id-checkbox&quot; name=&quot;checkbox&quot; /&gt;\n    &lt;/form&gt;\n    &lt;script&gt;\n        document.querySelector(&quot;#id-checkbox&quot;).addEventListener(&quot;click&quot;, function(event){\n            alert(&quot;preventDefault会阻止该复选框被勾选.&quot;)\n            event.preventDefault();\n            //阻止该复选框被勾选\n        }, false);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"4-10-this\"><a href=\"#4-10-this\" class=\"headerlink\" title=\"4.10 this\"></a>4.10 this</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">this</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html\" target=\"_blank\" rel=\"noopener\">Javascript的this用法</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/23804247?refer=study-fe\" target=\"_blank\" rel=\"noopener\">this 的值到底是什么？一次说清楚</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/25991271\" target=\"_blank\" rel=\"noopener\">你怎么还没搞懂this</a></p>\n<h3 id=\"4-11-JavaScript-的-new\"><a href=\"#4-11-JavaScript-的-new\" class=\"headerlink\" title=\"4.11 JavaScript 的 new\"></a>4.11 JavaScript 的 new</h3><p><a href=\"https://zhuanlan.zhihu.com/p/23987456?refer=study-fe\" target=\"_blank\" rel=\"noopener\">JS 的 new 到底是干什么的？</a></p>\n<h2 id=\"5-最后的一点建议\"><a href=\"#5-最后的一点建议\" class=\"headerlink\" title=\"5. 最后的一点建议\"></a>5. 最后的一点建议</h2><p>还是好好的刷一遍《JavaScript 高级程序设计》和《ES6 标准入门》吧，要不然基础差的你很难上手 React 。</p>\n<h2 id=\"6-相关链接\"><a href=\"#6-相关链接\" class=\"headerlink\" title=\"6. 相关链接\"></a>6. 相关链接</h2><p><a href=\"https://frankietang.github.io/2017/08/17/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 ES6 的门把手</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 webpack 的门把手</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/\" target=\"_blank\" rel=\"noopener\">摸到 webpack 的门把手 (2)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (2)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (3)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%284%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (4)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/24/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%285%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (5)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/25/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%286%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (6)</a></p>\n<p>这个项目的 2.0 版将会无限期跳票…</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-React-的门把手-完\"><a href=\"#摸到-React-的门把手-完\" class=\"headerlink\" title=\"摸到 React 的门把手 (完)\"></a>摸到 React 的门把手 (完)</h1><p>写啊写啊终于把大概功能给写完了 <a href=\"https://frankietang.github.io/banana-todolist/build/index.html#\" target=\"_blank\" rel=\"noopener\">效果</a> ，CSS 真难写啊… 我的同学说，审美这些东西要慢慢培养。</p>\n<p>接下来我们来说说这个项目用到了什么知识点。</p>\n<h2 id=\"1-JSX-React-webpack-LeanCloud-等知识。\"><a href=\"#1-JSX-React-webpack-LeanCloud-等知识。\" class=\"headerlink\" title=\"1. JSX / React / webpack / LeanCloud 等知识。\"></a>1. JSX / React / webpack / LeanCloud 等知识。</h2><p>在我博客都有很详细的介绍，这里就不多说了。<a href=\"https://frankietang.github.io/\" target=\"_blank\" rel=\"noopener\">我的博客</a></p>\n<h2 id=\"2-HTML\"><a href=\"#2-HTML\" class=\"headerlink\" title=\"2. HTML\"></a>2. HTML</h2><h3 id=\"2-1-form-表单\"><a href=\"#2-1-form-表单\" class=\"headerlink\" title=\"2.1 form 表单\"></a>2.1 form 表单</h3><p><code>&lt;input id=&quot;xxx&quot;&gt;</code> 和 <code>&lt;label for=&quot;xxx&quot;&gt;</code> 可以对应关联</p>\n<h3 id=\"2-2-HTML5-LocalStorage-本地存储\"><a href=\"#2-2-HTML5-LocalStorage-本地存储\" class=\"headerlink\" title=\"2.2 HTML5 LocalStorage 本地存储\"></a>2.2 HTML5 LocalStorage 本地存储</h3><p>在这个项目里 LocalStorage 的用法是这样的</p>\n<ul>\n<li>用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage</li>\n<li>重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList</li>\n</ul>\n<pre><code>export function save(key,value){\n    return window.localStorage.setItem(key,\n        JSON.stringify(value))\n}\n\nexport function load(key){\n    return JSON.parse(window.localStorage.getItem(key))\n}\n</code></pre><h2 id=\"3-CSS\"><a href=\"#3-CSS\" class=\"headerlink\" title=\"3. CSS\"></a>3. CSS</h2><h3 id=\"3-1-flex-布局\"><a href=\"#3-1-flex-布局\" class=\"headerlink\" title=\"3.1 flex 布局\"></a>3.1 flex 布局</h3><p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">Flex 布局教程：实例篇</a></p>\n<h3 id=\"3-2-CSS-选择器\"><a href=\"#3-2-CSS-选择器\" class=\"headerlink\" title=\"3.2 CSS 选择器\"></a>3.2 CSS 选择器</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started/Selectors\" target=\"_blank\" rel=\"noopener\">CSS 选择器 - MDN</a></p>\n<h2 id=\"4-JavaScript\"><a href=\"#4-JavaScript\" class=\"headerlink\" title=\"4. JavaScript\"></a>4. JavaScript</h2><h3 id=\"4-1-import…from…\"><a href=\"#4-1-import…from…\" class=\"headerlink\" title=\"4.1 import…from…\"></a>4.1 import…from…</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import\" target=\"_blank\" rel=\"noopener\">import - MDN</a></p>\n<p><strong>import 语句 </strong>用于从一个已经导出的外部模块或另一个脚本中导入函数，对象或原始类型。</p>\n<h3 id=\"4-2-ES6-Class\"><a href=\"#4-2-ES6-Class\" class=\"headerlink\" title=\"4.2 ES6 - Class\"></a>4.2 ES6 - Class</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\" target=\"_blank\" rel=\"noopener\">Class - MDN</a> <a href=\"http://es6.ruanyifeng.com/#docs/class#Class-的-Generator-方法\" target=\"_blank\" rel=\"noopener\">Class 的基本语法</a></p>\n<p>而我的项目最多是用到 <code>constructor()</code> / <code>extends</code> / <code>super()</code> ，这里举一个例子</p>\n<pre><code>class TestSuper {\n  constructor() {\n    this.a = &#39;a&#39;\n  }\n}\nclass Test extends TestSuper {\n  constructor() {\n    super()\n    this.b = &#39;b&#39;\n  }\n}\nlet inst = new Test()\nconsole.log(inst.a)   //a\nconsole.log(inst)     //Test{a:&#39;a&#39;,b:&#39;b&#39;}\n</code></pre><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<p><code>extends</code> 关键词被用在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class\" target=\"_blank\" rel=\"noopener\">类声明</a>或者<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class\" target=\"_blank\" rel=\"noopener\">类表达式</a>上，以创建一个类是另一个类的子类。</p>\n<p><code>super</code> 关键字用于调用一个对象的父对象上的函数。</p>\n<h3 id=\"4-3-ES6-箭头函数\"><a href=\"#4-3-ES6-箭头函数\" class=\"headerlink\" title=\"4.3 ES6 - 箭头函数\"></a>4.3 ES6 - 箭头函数</h3><pre><code>var f = v =&gt; v;\nvar f1 = v =&gt; {\n  return v\n}\n//相当于\nvar f = function f(v) {\n    return v;\n};\nvar f1 = function f1(v) {\n    return v;\n};\n</code></pre><h3 id=\"4-4-拓展运算符\"><a href=\"#4-4-拓展运算符\" class=\"headerlink\" title=\"4.4 拓展运算符\"></a>4.4 拓展运算符</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">扩展语句 - MDN</a></p>\n<pre><code>const pa = (...args) =&gt; {\n    console.log(args);\n    return args.reduce((pre,cur) =&gt; {\n        return pre+cur;\n    }, 0);\n};\npa.apply(this, [1,2,45]);\n//[1,2,45]\n//48\n</code></pre><h3 id=\"4-5-逻辑运算符-用来定义默认参数\"><a href=\"#4-5-逻辑运算符-用来定义默认参数\" class=\"headerlink\" title=\"4.5 逻辑运算符 || 用来定义默认参数\"></a>4.5 逻辑运算符 || 用来定义默认参数</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators\" target=\"_blank\" rel=\"noopener\">逻辑运算符</a></p>\n<pre><code>var link = function (height,color,url) {\n  var height = height || 50\n  var color = color || &#39;red&#39;\n  var url = url || &#39;https://frankie.github.io&#39;\n}\n</code></pre><h3 id=\"4-6-深拷贝\"><a href=\"#4-6-深拷贝\" class=\"headerlink\" title=\"4.6 深拷贝\"></a>4.6 深拷贝</h3><pre><code>//deep Clone\nlet obj1 = {a: 0, b: {c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // {a: 0, b: {c: 0}}\n</code></pre><h3 id=\"4-7-条件（三元）运算符\"><a href=\"#4-7-条件（三元）运算符\" class=\"headerlink\" title=\"4.7 条件（三元）运算符\"></a>4.7 条件（三元）运算符</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" target=\"_blank\" rel=\"noopener\">条件运算符</a></p>\n<pre><code>condition ? expr1 : expr2\n</code></pre><h3 id=\"4-8-apply-call-bind\"><a href=\"#4-8-apply-call-bind\" class=\"headerlink\" title=\"4.8 apply() / call() / bind()\"></a>4.8 apply() / call() / bind()</h3><pre><code>var xw = {\n  name : &quot;小王&quot;,\n  gender : &quot;男&quot;,\n  age : 24,\n  say : function() {\n      alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age);        \n    }\n}\nvar xh = {\n  name : &quot;小红&quot;,\n  gender : &quot;女&quot;,\n  age : 18\n}\nxw.say();\nxw.say.call(xh);\nxw.say.apply(xh);\nxw.say.bind(xh)();\n</code></pre><p>call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。</p>\n<pre><code>var xw = {\n  name : &quot;小王&quot;,\n  gender : &quot;男&quot;,\n  age : 24,\n  say : function(school,grade) {\n    alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age + &quot; ,在&quot; + school + &quot;上&quot; + grade);  \n  }\n}\nvar xh = {\n  name : &quot;小红&quot;,\n  gender : &quot;女&quot;,\n  age : 18\n}\nxw.say.call(xh,&quot;实验小学&quot;,&quot;六年级&quot;);\nxw.say.apply(xh,[&quot;实验小学&quot;,&quot;六年级&quot;]);\nxw.say.bind(xh,&quot;实验小学&quot;,&quot;六年级&quot;)();\nxw.say.bind(xh)(&quot;实验小学&quot;,&quot;六年级&quot;);\n</code></pre><p>call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。<br>那么bind怎么传参呢？它可以像call那样传参。</p>\n<h3 id=\"4-9-event-preventDefault\"><a href=\"#4-9-event-preventDefault\" class=\"headerlink\" title=\"4.9 event.preventDefault\"></a>4.9 event.preventDefault</h3><p>如果事件可取消，则取消该事件，而不停止事件的进一步传播。</p>\n<p>例子：切换复选框是单击复选框的默认操作。此示例演示如何防止这种情况发生</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;event.preventDefault()&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;请点击复选框控件&lt;/p&gt;\n    &lt;form&gt;\n        &lt;label for=&quot;id-checkbox&quot;&gt;Checkbox&lt;/label&gt;\n        &lt;input type=&quot;checkbox&quot; id=&quot;id-checkbox&quot; name=&quot;checkbox&quot; /&gt;\n    &lt;/form&gt;\n    &lt;script&gt;\n        document.querySelector(&quot;#id-checkbox&quot;).addEventListener(&quot;click&quot;, function(event){\n            alert(&quot;preventDefault会阻止该复选框被勾选.&quot;)\n            event.preventDefault();\n            //阻止该复选框被勾选\n        }, false);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"4-10-this\"><a href=\"#4-10-this\" class=\"headerlink\" title=\"4.10 this\"></a>4.10 this</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener\">this</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html\" target=\"_blank\" rel=\"noopener\">Javascript的this用法</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/23804247?refer=study-fe\" target=\"_blank\" rel=\"noopener\">this 的值到底是什么？一次说清楚</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/25991271\" target=\"_blank\" rel=\"noopener\">你怎么还没搞懂this</a></p>\n<h3 id=\"4-11-JavaScript-的-new\"><a href=\"#4-11-JavaScript-的-new\" class=\"headerlink\" title=\"4.11 JavaScript 的 new\"></a>4.11 JavaScript 的 new</h3><p><a href=\"https://zhuanlan.zhihu.com/p/23987456?refer=study-fe\" target=\"_blank\" rel=\"noopener\">JS 的 new 到底是干什么的？</a></p>\n<h2 id=\"5-最后的一点建议\"><a href=\"#5-最后的一点建议\" class=\"headerlink\" title=\"5. 最后的一点建议\"></a>5. 最后的一点建议</h2><p>还是好好的刷一遍《JavaScript 高级程序设计》和《ES6 标准入门》吧，要不然基础差的你很难上手 React 。</p>\n<h2 id=\"6-相关链接\"><a href=\"#6-相关链接\" class=\"headerlink\" title=\"6. 相关链接\"></a>6. 相关链接</h2><p><a href=\"https://frankietang.github.io/2017/08/17/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 ES6 的门把手</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 webpack 的门把手</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/\" target=\"_blank\" rel=\"noopener\">摸到 webpack 的门把手 (2)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (2)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (3)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%284%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (4)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/24/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%285%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (5)</a></p>\n<p><a href=\"https://frankietang.github.io/2017/08/25/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%286%29/\" target=\"_blank\" rel=\"noopener\">摸到 React 的门把手 (6)</a></p>\n<p>这个项目的 2.0 版将会无限期跳票…</p>\n"},{"title":"摸到 React 的门把手","date":"2017-10-13T16:06:56.000Z","_content":"# 摸到 React 的门把手\n\n[React 入门实例教程 - 阮一峰](http://www.ruanyifeng.com/blog/2015/03/react.html)\n\n阮一峰真的很适合当老师，这里我们就慢慢的跟上阮一峰老师步伐，摸上 React 的门把手。\n\n## 起步\n\n```\nnpm init\nnpm install --save react react-dom\n```\n\n而阮一峰的 demo 包自带了 React ，那我们就直接用吧。\n\n```\n$ git clone git@github.com:ruanyf/react-demos.git\n```\n\n## 第一个 demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      ReactDOM.render(\n        <h1>Hello, world!</h1>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 并非一定要引用 browser.js ，引入它的作用是使浏览器支持`babel`，你可以使用`ES2015`（具体可以看[阮一峰的ECMAScript 6 入门](http://es6.ruanyifeng.com/)）进行编码。如果你用ES5，可以不引入。而在这里的作用是将 JSX 语法转为 JavaScript 语法。\n\n   ```\n   // The ES5 way\n   var Photo = React.createClass({\n     handleDoubleTap: function(e) { … },\n     render: function() { … },\n   });\n   ```\n\n   ```\n   // The ES6+ way\n   class Photo extends React.Component {\n     handleDoubleTap(e) { … }\n     render() { … }\n   }\n   ```\n\n\n2. 注意 React 是用了 JSX 的语法，跟 JavaScript 不兼容。使用了 JSX 的地方都要加上 `type='text/babel'`\n3. `ReactDOM.render` 是一个 API ，将模板转成 HTML 语言，并插入制定的 DOM 节点。\n\n## 第二个 demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var names = ['Alice', 'Emily', 'Kate'];\n\n      ReactDOM.render(\n        <div>\n        {\n          names.map(function (name, index) {\n            return <div key={index}>Hello, {name}!</div>\n          })\n        }\n        </div>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 在这个例子中我觉得 JSX 语法原来可以这样用，其实就是等于 HTML 和 JavaScript 的混写。\n2. 遇到 HTML 标签（以 `<` 开头），就用 HTML 规则解析；遇到代码块（以 `{` 开头），就用 JavaScript 规则解析。\n\n## 第三个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var arr = [\n        <h1 key=\"1\">Hello world!</h1>,\n        <h2 key=\"2\">React is awesome</h2>,\n      ];\n      ReactDOM.render(\n        <div>{arr}</div>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 这里有一个亮点，就是用了这行代码 `<div>{arr}</div>` 把数组成员全部展现到模板上，如果让我想我只会想到用 for 循环再一个一个加到 HTML 那里。。。\n\n## 第四个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var HelloMessage = React.createClass({\n        render: function() {\n          return <h1>Hello {this.props.name}</h1>;\n        }\n      });\n\n      ReactDOM.render(\n        <HelloMessage name=\"John\" />,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 也就是说，用 `React.createClass` 可以把一个段代码封装成组件，然后像普通的 HTML 标签一样在网页插入这个组件。\n\n2. 要保证自己的组件拥有 `ReactDOM.render` 这个 API 来输出组件。\n\n3. 组件类的第一个字母必须大写，否则会报错。如 `HelloMessage` 不能写成 `helloMessage`。\n\n4. 还有组件类只能包含一个顶层标签，否则会出错 \n\n   ```\n   var HelloMessage = React.createClass({\n     render: function() {\n       return <h1>\n         Hello {this.props.name}\n       </h1><p>\n         some text\n       </p>;\n     }\n   });\n   ```\n\n5. 组件的用法和 HTML 的用法是一样的，可以加入任何的属性，比如 `<HelloMessage name=\"John\">` 就是 `HelloMessage` 中加入一个 `name` 属性。组件的属性可以在组件类的 `this.props` 对象上获取，比如 `name` 属性就可以通过 `this.props.name` 读取。\n\n6. 添加组件属性，有一个地方需要注意，就是 `class` 属性需要写成 `className` ，`for` 属性需要写成 `htmlFor` ，这是因为 `class` 和 `for` 是 JavaScript 的保留字。\n\n## 第五个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var NotesList = React.createClass({\n        render: function() {\n          return (\n            <ol>\n              {\n                React.Children.map(this.props.children, function (child) {\n                  return <li>{child}</li>;\n                })\n              }\n            </ol>\n          );\n        }\n      });\n\n      ReactDOM.render(\n        <NotesList>\n          <span>hello</span>\n          <span>world</span>\n        </NotesList>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 这一个例子主要是讲解了 `this.props.children` 属性。它表示组件的所有子节点。\n2. `this.props.children` 的值有三种可能：如果当前组件没有子节点，它就是 `undefined` ;如果有一个子节点，数据类型是 `object` ；如果有多个子节点，数据类型就是 `array` 。所以，处理 `this.props.children` 的时候要小心。\n3. React 提供一个工具方法 [`React.Children`](https://facebook.github.io/react/docs/top-level-api.html#react.children) 来处理 `this.props.children` 。我们可以用 `React.Children.map` 来遍历子节点，而不用担心 `this.props.children` 的数据类型是 `undefined` 还是 `object`。\n\n## 第六的demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n\n      var data = 123;\n\n      var MyTitle = React.createClass({\n        propTypes: {\n          title: React.PropTypes.string.isRequired,\n        },\n\n        render: function() {\n          return <h1> {this.props.title} </h1>;\n        }\n      });\n\n      ReactDOM.render(\n        <MyTitle title={data} />,\n        document.getElementById('example')\n      );\n\n    </script>\n  </body>\n</html>\n```\n\n1. `PropTypes`属性，就是用来验证组件实例的属性是否符合要求。\n\n2. `Mytitle`组件有一个`title`属性。`PropTypes` 告诉 React，这个 `title` 属性是必须的，而且它的值必须是字符串。`title` 没有通过验证。\n\n   ![](http://upload-images.jianshu.io/upload_images/3191557-a577caebac60a9c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3. 另外，阮一峰老师还介绍了`getDefaultProps` 方法可以用来设置组件属性的默认值。\n\n   ```\n   var MyTitle = React.createClass({\n     getDefaultProps : function () {\n       return {\n         title : 'Hello World'\n       };\n     },\n\n     render: function() {\n        return <h1> {this.props.title} </h1>;\n      }\n   });\n\n   ReactDOM.render(\n     <MyTitle />,\n     document.body\n   );\n   //上面代码会输出\"Hello World\"。\n   ```\n\n## 第七个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var MyComponent = React.createClass({\n        handleClick: function() {\n          this.refs.myTextInput.focus();\n        },\n        render: function() {\n          return (\n            <div>\n              <input type=\"text\" ref=\"myTextInput\" />\n              <input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} />\n            </div>\n          );\n        }\n      });\n\n      ReactDOM.render(\n        <MyComponent />,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n//这样就能通过点击 button 来获取 input 的 focus\n```\n\n1. 组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 [DOM diff](http://calendar.perfplanet.com/2013/diff/) ，它可以极大提高网页的性能表现。\n\n   但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 `ref` 属性。\n\n2. 上面代码中，组件 `MyComponent` 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 `ref` 属性，然后 `this.refs.[refName]` 就会返回这个真实的 DOM 节点。\n\n3. 需要注意的是，由于 `this.refs.[refName]` 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 `Click` 事件的回调函数，确保了只有等到真实 DOM 发生 `Click` 事件之后，才会读取 `this.refs.[refName]` 属性。\n\n4. 除了 `Click` 事件以外，还有 `KeyDown` 、`Copy`、`Scroll` 等\n\n## 第八个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\nvar LikeButton = React.createClass({\n  getInitialState: function() {\n    return {liked: false};\n  },\n  handleClick: function(event) {\n    this.setState({liked: !this.state.liked});\n  },\n  render: function() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n});\n\nReactDOM.render(\n  <LikeButton />,\n  document.getElementById('example')\n);\n    </script>\n  </body>\n</html>\n```\n\n1. 组件的状态，用来和用户互动，组件一开始有一个状态，然后用户操作导致状态改变，从而改变状态，根据状态重新渲染页面。\n2. `return {liked: false}` 初始化组件的状态\n3. `this.setState({liked: !this.state.liked})` 将组件状态设置为当前状态相反状态\n\n## 第九个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var Input = React.createClass({\n        getInitialState: function() {\n          return {value: 'Hello!'};\n        },\n        handleChange: function(event) {\n          this.setState({value: event.target.value});\n        },\n        render: function () {\n          var value = this.state.value;\n          return (\n            <div>\n              <input type=\"text\" value={value} onChange={this.handleChange} />\n              <p>{value}</p>\n            </div>\n          );\n        }\n      });\n\n      ReactDOM.render(<Input/>, document.getElementById('example'));\n    </script>\n  </body>\n</html>\n```\n\n1. 第一次看这个，呦吼？这难道是传说中的双向绑定？[React的双向绑定](http://www.cnblogs.com/kuailingmin/p/4609721.html)\n2. 上面代码中，文本输入框的值，不能用 `this.props.value` 读取，而要定义一个 `onChange` 事件的回调函数，通过 `event.target.value` 读取用户输入的值。\n\n## 第十个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var Hello = React.createClass({\n        getInitialState: function () {\n          return {\n            opacity: 1.0\n          };\n        },\n\n        componentDidMount: function () {\n          this.timer = setInterval(function () {\n            var opacity = this.state.opacity;\n            opacity -= .05;\n            if (opacity < 0.1) {\n              opacity = 1.0;\n            }\n            this.setState({\n              opacity: opacity\n            });\n          }.bind(this), 100);\n        },\n\n        render: function () {\n          return (\n            <div style={{opacity: this.state.opacity}}>\n              Hello {this.props.name}\n            </div>\n          );\n        }\n      });\n\n      ReactDOM.render(\n        <Hello name=\"world\"/>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 这里主要是介绍了关于组件的生命周期\n\n2. React 为每个状态都提供了两种处理函数，`will` 是我要插入了！`did` 是我插进去之后，要不要搞点东西？\n\n3. 阮一峰老师的这个 demo 是在`hello`组件加载以后，通过 `componentDidMount` 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。\n\n4. 注意组件 `style` 属性的设置方式\n\n   ```\n   //这样是错的\n   style=\"opacity:{this.state.opacity};\"\n   //而要写成\n   style={{opacity: this.state.opacity}}\n   ```\n\n   这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。\n\n## 第十一个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n    <script src=\"../build/jquery.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\nvar UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: '',\n      lastGistUrl: ''\n    };\n  },\n\n  componentDidMount: function() {\n    $.get(this.props.source, function(result) {\n      var lastGist = result[0];\n      if (this.isMounted()) {\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      <div>\n        {this.state.username}'s last gist is <a href={this.state.lastGistUrl}>here</a>.\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <UserGist source=\"https://api.github.com/users/octocat/gists\" />,\n  document.getElementById('example')\n);\n    </script>\n  </body>\n</html>\n```\n\n1. 把数据通过 AJAX 请求的方法从服务器获取，阮一峰老师这里是用了 `componentDidMount` 方法设置 AJAX 请求，再用 `this.setState` 方法重新渲染 UI，`InitialState` 初始数据为空\n\n## 第十二个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n    <script src=\"../build/jquery.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\nvar RepoList = React.createClass({\n  getInitialState: function() {\n    return {\n      loading: true,\n      error: null,\n      data: null\n    };\n  },\n\n  componentDidMount() {\n    this.props.promise.then(\n      value => this.setState({loading: false, data: value}),\n      error => this.setState({loading: false, error: error}));\n  },\n\n  render: function() {\n    if (this.state.loading) {\n      return <span>Loading...</span>;\n    }\n    else if (this.state.error !== null) {\n      return <span>Error: {this.state.error.message}</span>;\n    }\n    else {\n      var repos = this.state.data.items;\n      var repoList = repos.map(function (repo, index) {\n        return (\n          <li key={index}><a href={repo.html_url}>{repo.name}</a> ({repo.stargazers_count} stars) <br/> {repo.description}</li>\n        );\n      });\n      return (\n        <main>\n          <h1>Most Popular JavaScript Projects in Github</h1>\n          <ol>{repoList}</ol>\n        </main>\n      );\n    }\n  }\n});\n\nReactDOM.render(\n  <RepoList promise={$.getJSON('https://api.github.com/search/repositories?q=javascript&sort=stars')} />,\n  document.getElementById('example')\n);\n    </script>\n  </body>\n</html>\n```\n\n1. 数据传来后赋值\n\n   ```\n   componentDidMount() {\n     this.props.promise.then(\n       value => this.setState({loading: false, data: value}),\n       error => this.setState({loading: false, error: error}));\n   },\n   ```\n\n   如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。\n\n   ```\n   getInitialState: function() {\n     return {\n       loading: true,\n       error: null,\n       data: null\n     };\n   },\n   ```\n\n   Promise对象正在抓取数据（pending状态），组件显示\"正在加载\"\n\n## 第十三个demo\n\n- 这里不贴代码\n\n- 这是一个 React 的服务器渲染\n\n- 根据 readme.md 的提示，我们搞好依赖，`node server.js` 来监听 http://localhost:3000 ![](http://upload-images.jianshu.io/upload_images/3191557-888bf6bd6f540557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 这看着是非常像手写服务器的方法，如果有 JavaScript权威指南 这本书，我建议你看看 P302 如何手写服务器。![](http://upload-images.jianshu.io/upload_images/3191557-bc51896f11363644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 这里推荐一篇文章 [从零开始 React 服务器渲染](http://www.alloyteam.com/2017/01/react-from-scratch-server-render/)","source":"_posts/摸到 React 的门把手.md","raw":"---\ntitle: 摸到 React 的门把手\ndate: 2017-10-14 00:06:56\ntags: [React,Black History]\n---\n# 摸到 React 的门把手\n\n[React 入门实例教程 - 阮一峰](http://www.ruanyifeng.com/blog/2015/03/react.html)\n\n阮一峰真的很适合当老师，这里我们就慢慢的跟上阮一峰老师步伐，摸上 React 的门把手。\n\n## 起步\n\n```\nnpm init\nnpm install --save react react-dom\n```\n\n而阮一峰的 demo 包自带了 React ，那我们就直接用吧。\n\n```\n$ git clone git@github.com:ruanyf/react-demos.git\n```\n\n## 第一个 demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      ReactDOM.render(\n        <h1>Hello, world!</h1>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 并非一定要引用 browser.js ，引入它的作用是使浏览器支持`babel`，你可以使用`ES2015`（具体可以看[阮一峰的ECMAScript 6 入门](http://es6.ruanyifeng.com/)）进行编码。如果你用ES5，可以不引入。而在这里的作用是将 JSX 语法转为 JavaScript 语法。\n\n   ```\n   // The ES5 way\n   var Photo = React.createClass({\n     handleDoubleTap: function(e) { … },\n     render: function() { … },\n   });\n   ```\n\n   ```\n   // The ES6+ way\n   class Photo extends React.Component {\n     handleDoubleTap(e) { … }\n     render() { … }\n   }\n   ```\n\n\n2. 注意 React 是用了 JSX 的语法，跟 JavaScript 不兼容。使用了 JSX 的地方都要加上 `type='text/babel'`\n3. `ReactDOM.render` 是一个 API ，将模板转成 HTML 语言，并插入制定的 DOM 节点。\n\n## 第二个 demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var names = ['Alice', 'Emily', 'Kate'];\n\n      ReactDOM.render(\n        <div>\n        {\n          names.map(function (name, index) {\n            return <div key={index}>Hello, {name}!</div>\n          })\n        }\n        </div>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 在这个例子中我觉得 JSX 语法原来可以这样用，其实就是等于 HTML 和 JavaScript 的混写。\n2. 遇到 HTML 标签（以 `<` 开头），就用 HTML 规则解析；遇到代码块（以 `{` 开头），就用 JavaScript 规则解析。\n\n## 第三个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var arr = [\n        <h1 key=\"1\">Hello world!</h1>,\n        <h2 key=\"2\">React is awesome</h2>,\n      ];\n      ReactDOM.render(\n        <div>{arr}</div>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 这里有一个亮点，就是用了这行代码 `<div>{arr}</div>` 把数组成员全部展现到模板上，如果让我想我只会想到用 for 循环再一个一个加到 HTML 那里。。。\n\n## 第四个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var HelloMessage = React.createClass({\n        render: function() {\n          return <h1>Hello {this.props.name}</h1>;\n        }\n      });\n\n      ReactDOM.render(\n        <HelloMessage name=\"John\" />,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 也就是说，用 `React.createClass` 可以把一个段代码封装成组件，然后像普通的 HTML 标签一样在网页插入这个组件。\n\n2. 要保证自己的组件拥有 `ReactDOM.render` 这个 API 来输出组件。\n\n3. 组件类的第一个字母必须大写，否则会报错。如 `HelloMessage` 不能写成 `helloMessage`。\n\n4. 还有组件类只能包含一个顶层标签，否则会出错 \n\n   ```\n   var HelloMessage = React.createClass({\n     render: function() {\n       return <h1>\n         Hello {this.props.name}\n       </h1><p>\n         some text\n       </p>;\n     }\n   });\n   ```\n\n5. 组件的用法和 HTML 的用法是一样的，可以加入任何的属性，比如 `<HelloMessage name=\"John\">` 就是 `HelloMessage` 中加入一个 `name` 属性。组件的属性可以在组件类的 `this.props` 对象上获取，比如 `name` 属性就可以通过 `this.props.name` 读取。\n\n6. 添加组件属性，有一个地方需要注意，就是 `class` 属性需要写成 `className` ，`for` 属性需要写成 `htmlFor` ，这是因为 `class` 和 `for` 是 JavaScript 的保留字。\n\n## 第五个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var NotesList = React.createClass({\n        render: function() {\n          return (\n            <ol>\n              {\n                React.Children.map(this.props.children, function (child) {\n                  return <li>{child}</li>;\n                })\n              }\n            </ol>\n          );\n        }\n      });\n\n      ReactDOM.render(\n        <NotesList>\n          <span>hello</span>\n          <span>world</span>\n        </NotesList>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 这一个例子主要是讲解了 `this.props.children` 属性。它表示组件的所有子节点。\n2. `this.props.children` 的值有三种可能：如果当前组件没有子节点，它就是 `undefined` ;如果有一个子节点，数据类型是 `object` ；如果有多个子节点，数据类型就是 `array` 。所以，处理 `this.props.children` 的时候要小心。\n3. React 提供一个工具方法 [`React.Children`](https://facebook.github.io/react/docs/top-level-api.html#react.children) 来处理 `this.props.children` 。我们可以用 `React.Children.map` 来遍历子节点，而不用担心 `this.props.children` 的数据类型是 `undefined` 还是 `object`。\n\n## 第六的demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n\n      var data = 123;\n\n      var MyTitle = React.createClass({\n        propTypes: {\n          title: React.PropTypes.string.isRequired,\n        },\n\n        render: function() {\n          return <h1> {this.props.title} </h1>;\n        }\n      });\n\n      ReactDOM.render(\n        <MyTitle title={data} />,\n        document.getElementById('example')\n      );\n\n    </script>\n  </body>\n</html>\n```\n\n1. `PropTypes`属性，就是用来验证组件实例的属性是否符合要求。\n\n2. `Mytitle`组件有一个`title`属性。`PropTypes` 告诉 React，这个 `title` 属性是必须的，而且它的值必须是字符串。`title` 没有通过验证。\n\n   ![](http://upload-images.jianshu.io/upload_images/3191557-a577caebac60a9c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3. 另外，阮一峰老师还介绍了`getDefaultProps` 方法可以用来设置组件属性的默认值。\n\n   ```\n   var MyTitle = React.createClass({\n     getDefaultProps : function () {\n       return {\n         title : 'Hello World'\n       };\n     },\n\n     render: function() {\n        return <h1> {this.props.title} </h1>;\n      }\n   });\n\n   ReactDOM.render(\n     <MyTitle />,\n     document.body\n   );\n   //上面代码会输出\"Hello World\"。\n   ```\n\n## 第七个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var MyComponent = React.createClass({\n        handleClick: function() {\n          this.refs.myTextInput.focus();\n        },\n        render: function() {\n          return (\n            <div>\n              <input type=\"text\" ref=\"myTextInput\" />\n              <input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} />\n            </div>\n          );\n        }\n      });\n\n      ReactDOM.render(\n        <MyComponent />,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n//这样就能通过点击 button 来获取 input 的 focus\n```\n\n1. 组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 [DOM diff](http://calendar.perfplanet.com/2013/diff/) ，它可以极大提高网页的性能表现。\n\n   但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 `ref` 属性。\n\n2. 上面代码中，组件 `MyComponent` 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 `ref` 属性，然后 `this.refs.[refName]` 就会返回这个真实的 DOM 节点。\n\n3. 需要注意的是，由于 `this.refs.[refName]` 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 `Click` 事件的回调函数，确保了只有等到真实 DOM 发生 `Click` 事件之后，才会读取 `this.refs.[refName]` 属性。\n\n4. 除了 `Click` 事件以外，还有 `KeyDown` 、`Copy`、`Scroll` 等\n\n## 第八个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\nvar LikeButton = React.createClass({\n  getInitialState: function() {\n    return {liked: false};\n  },\n  handleClick: function(event) {\n    this.setState({liked: !this.state.liked});\n  },\n  render: function() {\n    var text = this.state.liked ? 'like' : 'haven\\'t liked';\n    return (\n      <p onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </p>\n    );\n  }\n});\n\nReactDOM.render(\n  <LikeButton />,\n  document.getElementById('example')\n);\n    </script>\n  </body>\n</html>\n```\n\n1. 组件的状态，用来和用户互动，组件一开始有一个状态，然后用户操作导致状态改变，从而改变状态，根据状态重新渲染页面。\n2. `return {liked: false}` 初始化组件的状态\n3. `this.setState({liked: !this.state.liked})` 将组件状态设置为当前状态相反状态\n\n## 第九个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var Input = React.createClass({\n        getInitialState: function() {\n          return {value: 'Hello!'};\n        },\n        handleChange: function(event) {\n          this.setState({value: event.target.value});\n        },\n        render: function () {\n          var value = this.state.value;\n          return (\n            <div>\n              <input type=\"text\" value={value} onChange={this.handleChange} />\n              <p>{value}</p>\n            </div>\n          );\n        }\n      });\n\n      ReactDOM.render(<Input/>, document.getElementById('example'));\n    </script>\n  </body>\n</html>\n```\n\n1. 第一次看这个，呦吼？这难道是传说中的双向绑定？[React的双向绑定](http://www.cnblogs.com/kuailingmin/p/4609721.html)\n2. 上面代码中，文本输入框的值，不能用 `this.props.value` 读取，而要定义一个 `onChange` 事件的回调函数，通过 `event.target.value` 读取用户输入的值。\n\n## 第十个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\n      var Hello = React.createClass({\n        getInitialState: function () {\n          return {\n            opacity: 1.0\n          };\n        },\n\n        componentDidMount: function () {\n          this.timer = setInterval(function () {\n            var opacity = this.state.opacity;\n            opacity -= .05;\n            if (opacity < 0.1) {\n              opacity = 1.0;\n            }\n            this.setState({\n              opacity: opacity\n            });\n          }.bind(this), 100);\n        },\n\n        render: function () {\n          return (\n            <div style={{opacity: this.state.opacity}}>\n              Hello {this.props.name}\n            </div>\n          );\n        }\n      });\n\n      ReactDOM.render(\n        <Hello name=\"world\"/>,\n        document.getElementById('example')\n      );\n    </script>\n  </body>\n</html>\n```\n\n1. 这里主要是介绍了关于组件的生命周期\n\n2. React 为每个状态都提供了两种处理函数，`will` 是我要插入了！`did` 是我插进去之后，要不要搞点东西？\n\n3. 阮一峰老师的这个 demo 是在`hello`组件加载以后，通过 `componentDidMount` 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。\n\n4. 注意组件 `style` 属性的设置方式\n\n   ```\n   //这样是错的\n   style=\"opacity:{this.state.opacity};\"\n   //而要写成\n   style={{opacity: this.state.opacity}}\n   ```\n\n   这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。\n\n## 第十一个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n    <script src=\"../build/jquery.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\nvar UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: '',\n      lastGistUrl: ''\n    };\n  },\n\n  componentDidMount: function() {\n    $.get(this.props.source, function(result) {\n      var lastGist = result[0];\n      if (this.isMounted()) {\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      <div>\n        {this.state.username}'s last gist is <a href={this.state.lastGistUrl}>here</a>.\n      </div>\n    );\n  }\n});\n\nReactDOM.render(\n  <UserGist source=\"https://api.github.com/users/octocat/gists\" />,\n  document.getElementById('example')\n);\n    </script>\n  </body>\n</html>\n```\n\n1. 把数据通过 AJAX 请求的方法从服务器获取，阮一峰老师这里是用了 `componentDidMount` 方法设置 AJAX 请求，再用 `this.setState` 方法重新渲染 UI，`InitialState` 初始数据为空\n\n## 第十二个demo\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <script src=\"../build/react.js\"></script>\n    <script src=\"../build/react-dom.js\"></script>\n    <script src=\"../build/browser.min.js\"></script>\n    <script src=\"../build/jquery.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"example\"></div>\n    <script type=\"text/babel\">\nvar RepoList = React.createClass({\n  getInitialState: function() {\n    return {\n      loading: true,\n      error: null,\n      data: null\n    };\n  },\n\n  componentDidMount() {\n    this.props.promise.then(\n      value => this.setState({loading: false, data: value}),\n      error => this.setState({loading: false, error: error}));\n  },\n\n  render: function() {\n    if (this.state.loading) {\n      return <span>Loading...</span>;\n    }\n    else if (this.state.error !== null) {\n      return <span>Error: {this.state.error.message}</span>;\n    }\n    else {\n      var repos = this.state.data.items;\n      var repoList = repos.map(function (repo, index) {\n        return (\n          <li key={index}><a href={repo.html_url}>{repo.name}</a> ({repo.stargazers_count} stars) <br/> {repo.description}</li>\n        );\n      });\n      return (\n        <main>\n          <h1>Most Popular JavaScript Projects in Github</h1>\n          <ol>{repoList}</ol>\n        </main>\n      );\n    }\n  }\n});\n\nReactDOM.render(\n  <RepoList promise={$.getJSON('https://api.github.com/search/repositories?q=javascript&sort=stars')} />,\n  document.getElementById('example')\n);\n    </script>\n  </body>\n</html>\n```\n\n1. 数据传来后赋值\n\n   ```\n   componentDidMount() {\n     this.props.promise.then(\n       value => this.setState({loading: false, data: value}),\n       error => this.setState({loading: false, error: error}));\n   },\n   ```\n\n   如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。\n\n   ```\n   getInitialState: function() {\n     return {\n       loading: true,\n       error: null,\n       data: null\n     };\n   },\n   ```\n\n   Promise对象正在抓取数据（pending状态），组件显示\"正在加载\"\n\n## 第十三个demo\n\n- 这里不贴代码\n\n- 这是一个 React 的服务器渲染\n\n- 根据 readme.md 的提示，我们搞好依赖，`node server.js` 来监听 http://localhost:3000 ![](http://upload-images.jianshu.io/upload_images/3191557-888bf6bd6f540557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 这看着是非常像手写服务器的方法，如果有 JavaScript权威指南 这本书，我建议你看看 P302 如何手写服务器。![](http://upload-images.jianshu.io/upload_images/3191557-bc51896f11363644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 这里推荐一篇文章 [从零开始 React 服务器渲染](http://www.alloyteam.com/2017/01/react-from-scratch-server-render/)","slug":"摸到 React 的门把手","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8l000pf1xh19adjq4m","content":"<h1 id=\"摸到-React-的门把手\"><a href=\"#摸到-React-的门把手\" class=\"headerlink\" title=\"摸到 React 的门把手\"></a>摸到 React 的门把手</h1><p><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">React 入门实例教程 - 阮一峰</a></p>\n<p>阮一峰真的很适合当老师，这里我们就慢慢的跟上阮一峰老师步伐，摸上 React 的门把手。</p>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><pre><code>npm init\nnpm install --save react react-dom\n</code></pre><p>而阮一峰的 demo 包自带了 React ，那我们就直接用吧。</p>\n<pre><code>$ git clone git@github.com:ruanyf/react-demos.git\n</code></pre><h2 id=\"第一个-demo\"><a href=\"#第一个-demo\" class=\"headerlink\" title=\"第一个 demo\"></a>第一个 demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      ReactDOM.render(\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>并非一定要引用 browser.js ，引入它的作用是使浏览器支持<code>babel</code>，你可以使用<code>ES2015</code>（具体可以看<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰的ECMAScript 6 入门</a>）进行编码。如果你用ES5，可以不引入。而在这里的作用是将 JSX 语法转为 JavaScript 语法。</p>\n<pre><code>// The ES5 way\nvar Photo = React.createClass({\n  handleDoubleTap: function(e) { … },\n  render: function() { … },\n});\n</code></pre><pre><code>// The ES6+ way\nclass Photo extends React.Component {\n  handleDoubleTap(e) { … }\n  render() { … }\n}\n</code></pre></li>\n</ol>\n<ol>\n<li>注意 React 是用了 JSX 的语法，跟 JavaScript 不兼容。使用了 JSX 的地方都要加上 <code>type=&#39;text/babel&#39;</code></li>\n<li><code>ReactDOM.render</code> 是一个 API ，将模板转成 HTML 语言，并插入制定的 DOM 节点。</li>\n</ol>\n<h2 id=\"第二个-demo\"><a href=\"#第二个-demo\" class=\"headerlink\" title=\"第二个 demo\"></a>第二个 demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var names = [&#39;Alice&#39;, &#39;Emily&#39;, &#39;Kate&#39;];\n\n      ReactDOM.render(\n        &lt;div&gt;\n        {\n          names.map(function (name, index) {\n            return &lt;div key={index}&gt;Hello, {name}!&lt;/div&gt;\n          })\n        }\n        &lt;/div&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>在这个例子中我觉得 JSX 语法原来可以这样用，其实就是等于 HTML 和 JavaScript 的混写。</li>\n<li>遇到 HTML 标签（以 <code>&lt;</code> 开头），就用 HTML 规则解析；遇到代码块（以 <code>{</code> 开头），就用 JavaScript 规则解析。</li>\n</ol>\n<h2 id=\"第三个demo\"><a href=\"#第三个demo\" class=\"headerlink\" title=\"第三个demo\"></a>第三个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var arr = [\n        &lt;h1 key=&quot;1&quot;&gt;Hello world!&lt;/h1&gt;,\n        &lt;h2 key=&quot;2&quot;&gt;React is awesome&lt;/h2&gt;,\n      ];\n      ReactDOM.render(\n        &lt;div&gt;{arr}&lt;/div&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>这里有一个亮点，就是用了这行代码 <code>&lt;div&gt;{arr}&lt;/div&gt;</code> 把数组成员全部展现到模板上，如果让我想我只会想到用 for 循环再一个一个加到 HTML 那里。。。</li>\n</ol>\n<h2 id=\"第四个demo\"><a href=\"#第四个demo\" class=\"headerlink\" title=\"第四个demo\"></a>第四个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var HelloMessage = React.createClass({\n        render: function() {\n          return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;\n        }\n      });\n\n      ReactDOM.render(\n        &lt;HelloMessage name=&quot;John&quot; /&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>也就是说，用 <code>React.createClass</code> 可以把一个段代码封装成组件，然后像普通的 HTML 标签一样在网页插入这个组件。</p>\n</li>\n<li><p>要保证自己的组件拥有 <code>ReactDOM.render</code> 这个 API 来输出组件。</p>\n</li>\n<li><p>组件类的第一个字母必须大写，否则会报错。如 <code>HelloMessage</code> 不能写成 <code>helloMessage</code>。</p>\n</li>\n<li><p>还有组件类只能包含一个顶层标签，否则会出错 </p>\n<pre><code>var HelloMessage = React.createClass({\n  render: function() {\n    return &lt;h1&gt;\n      Hello {this.props.name}\n    &lt;/h1&gt;&lt;p&gt;\n      some text\n    &lt;/p&gt;;\n  }\n});\n</code></pre></li>\n<li><p>组件的用法和 HTML 的用法是一样的，可以加入任何的属性，比如 <code>&lt;HelloMessage name=&quot;John&quot;&gt;</code> 就是 <code>HelloMessage</code> 中加入一个 <code>name</code> 属性。组件的属性可以在组件类的 <code>this.props</code> 对象上获取，比如 <code>name</code> 属性就可以通过 <code>this.props.name</code> 读取。</p>\n</li>\n<li><p>添加组件属性，有一个地方需要注意，就是 <code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code> ，这是因为 <code>class</code> 和 <code>for</code> 是 JavaScript 的保留字。</p>\n</li>\n</ol>\n<h2 id=\"第五个demo\"><a href=\"#第五个demo\" class=\"headerlink\" title=\"第五个demo\"></a>第五个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var NotesList = React.createClass({\n        render: function() {\n          return (\n            &lt;ol&gt;\n              {\n                React.Children.map(this.props.children, function (child) {\n                  return &lt;li&gt;{child}&lt;/li&gt;;\n                })\n              }\n            &lt;/ol&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(\n        &lt;NotesList&gt;\n          &lt;span&gt;hello&lt;/span&gt;\n          &lt;span&gt;world&lt;/span&gt;\n        &lt;/NotesList&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>这一个例子主要是讲解了 <code>this.props.children</code> 属性。它表示组件的所有子节点。</li>\n<li><code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。</li>\n<li>React 提供一个工具方法 <a href=\"https://facebook.github.io/react/docs/top-level-api.html#react.children\" target=\"_blank\" rel=\"noopener\"><code>React.Children</code></a> 来处理 <code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。</li>\n</ol>\n<h2 id=\"第六的demo\"><a href=\"#第六的demo\" class=\"headerlink\" title=\"第六的demo\"></a>第六的demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n\n      var data = 123;\n\n      var MyTitle = React.createClass({\n        propTypes: {\n          title: React.PropTypes.string.isRequired,\n        },\n\n        render: function() {\n          return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;\n        }\n      });\n\n      ReactDOM.render(\n        &lt;MyTitle title={data} /&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p><code>PropTypes</code>属性，就是用来验证组件实例的属性是否符合要求。</p>\n</li>\n<li><p><code>Mytitle</code>组件有一个<code>title</code>属性。<code>PropTypes</code> 告诉 React，这个 <code>title</code> 属性是必须的，而且它的值必须是字符串。<code>title</code> 没有通过验证。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-a577caebac60a9c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>另外，阮一峰老师还介绍了<code>getDefaultProps</code> 方法可以用来设置组件属性的默认值。</p>\n<pre><code>var MyTitle = React.createClass({\n  getDefaultProps : function () {\n    return {\n      title : &#39;Hello World&#39;\n    };\n  },\n\n  render: function() {\n     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;\n   }\n});\n\nReactDOM.render(\n  &lt;MyTitle /&gt;,\n  document.body\n);\n//上面代码会输出&quot;Hello World&quot;。\n</code></pre></li>\n</ol>\n<h2 id=\"第七个demo\"><a href=\"#第七个demo\" class=\"headerlink\" title=\"第七个demo\"></a>第七个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var MyComponent = React.createClass({\n        handleClick: function() {\n          this.refs.myTextInput.focus();\n        },\n        render: function() {\n          return (\n            &lt;div&gt;\n              &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;\n              &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt;\n            &lt;/div&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(\n        &lt;MyComponent /&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n//这样就能通过点击 button 来获取 input 的 focus\n</code></pre><ol>\n<li><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <a href=\"http://calendar.perfplanet.com/2013/diff/\" target=\"_blank\" rel=\"noopener\">DOM diff</a> ，它可以极大提高网页的性能表现。</p>\n<p>但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。</p>\n</li>\n<li><p>上面代码中，组件 <code>MyComponent</code> 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 <code>ref</code> 属性，然后 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。</p>\n</li>\n<li><p>需要注意的是，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 <code>Click</code> 事件的回调函数，确保了只有等到真实 DOM 发生 <code>Click</code> 事件之后，才会读取 <code>this.refs.[refName]</code> 属性。</p>\n</li>\n<li><p>除了 <code>Click</code> 事件以外，还有 <code>KeyDown</code> 、<code>Copy</code>、<code>Scroll</code> 等</p>\n</li>\n</ol>\n<h2 id=\"第八个demo\"><a href=\"#第八个demo\" class=\"headerlink\" title=\"第八个demo\"></a>第八个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\nvar LikeButton = React.createClass({\n  getInitialState: function() {\n    return {liked: false};\n  },\n  handleClick: function(event) {\n    this.setState({liked: !this.state.liked});\n  },\n  render: function() {\n    var text = this.state.liked ? &#39;like&#39; : &#39;haven\\&#39;t liked&#39;;\n    return (\n      &lt;p onClick={this.handleClick}&gt;\n        You {text} this. Click to toggle.\n      &lt;/p&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;LikeButton /&gt;,\n  document.getElementById(&#39;example&#39;)\n);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>组件的状态，用来和用户互动，组件一开始有一个状态，然后用户操作导致状态改变，从而改变状态，根据状态重新渲染页面。</li>\n<li><code>return {liked: false}</code> 初始化组件的状态</li>\n<li><code>this.setState({liked: !this.state.liked})</code> 将组件状态设置为当前状态相反状态</li>\n</ol>\n<h2 id=\"第九个demo\"><a href=\"#第九个demo\" class=\"headerlink\" title=\"第九个demo\"></a>第九个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var Input = React.createClass({\n        getInitialState: function() {\n          return {value: &#39;Hello!&#39;};\n        },\n        handleChange: function(event) {\n          this.setState({value: event.target.value});\n        },\n        render: function () {\n          var value = this.state.value;\n          return (\n            &lt;div&gt;\n              &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;\n              &lt;p&gt;{value}&lt;/p&gt;\n            &lt;/div&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(&lt;Input/&gt;, document.getElementById(&#39;example&#39;));\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>第一次看这个，呦吼？这难道是传说中的双向绑定？<a href=\"http://www.cnblogs.com/kuailingmin/p/4609721.html\" target=\"_blank\" rel=\"noopener\">React的双向绑定</a></li>\n<li>上面代码中，文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。</li>\n</ol>\n<h2 id=\"第十个demo\"><a href=\"#第十个demo\" class=\"headerlink\" title=\"第十个demo\"></a>第十个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var Hello = React.createClass({\n        getInitialState: function () {\n          return {\n            opacity: 1.0\n          };\n        },\n\n        componentDidMount: function () {\n          this.timer = setInterval(function () {\n            var opacity = this.state.opacity;\n            opacity -= .05;\n            if (opacity &lt; 0.1) {\n              opacity = 1.0;\n            }\n            this.setState({\n              opacity: opacity\n            });\n          }.bind(this), 100);\n        },\n\n        render: function () {\n          return (\n            &lt;div style={{opacity: this.state.opacity}}&gt;\n              Hello {this.props.name}\n            &lt;/div&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(\n        &lt;Hello name=&quot;world&quot;/&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>这里主要是介绍了关于组件的生命周期</p>\n</li>\n<li><p>React 为每个状态都提供了两种处理函数，<code>will</code> 是我要插入了！<code>did</code> 是我插进去之后，要不要搞点东西？</p>\n</li>\n<li><p>阮一峰老师的这个 demo 是在<code>hello</code>组件加载以后，通过 <code>componentDidMount</code> 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。</p>\n</li>\n<li><p>注意组件 <code>style</code> 属性的设置方式</p>\n<pre><code>//这样是错的\nstyle=&quot;opacity:{this.state.opacity};&quot;\n//而要写成\nstyle={{opacity: this.state.opacity}}\n</code></pre><p>这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>\n</li>\n</ol>\n<h2 id=\"第十一个demo\"><a href=\"#第十一个demo\" class=\"headerlink\" title=\"第十一个demo\"></a>第十一个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/jquery.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\nvar UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: &#39;&#39;,\n      lastGistUrl: &#39;&#39;\n    };\n  },\n\n  componentDidMount: function() {\n    $.get(this.props.source, function(result) {\n      var lastGist = result[0];\n      if (this.isMounted()) {\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      &lt;div&gt;\n        {this.state.username}&#39;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,\n  document.getElementById(&#39;example&#39;)\n);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>把数据通过 AJAX 请求的方法从服务器获取，阮一峰老师这里是用了 <code>componentDidMount</code> 方法设置 AJAX 请求，再用 <code>this.setState</code> 方法重新渲染 UI，<code>InitialState</code> 初始数据为空</li>\n</ol>\n<h2 id=\"第十二个demo\"><a href=\"#第十二个demo\" class=\"headerlink\" title=\"第十二个demo\"></a>第十二个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/jquery.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\nvar RepoList = React.createClass({\n  getInitialState: function() {\n    return {\n      loading: true,\n      error: null,\n      data: null\n    };\n  },\n\n  componentDidMount() {\n    this.props.promise.then(\n      value =&gt; this.setState({loading: false, data: value}),\n      error =&gt; this.setState({loading: false, error: error}));\n  },\n\n  render: function() {\n    if (this.state.loading) {\n      return &lt;span&gt;Loading...&lt;/span&gt;;\n    }\n    else if (this.state.error !== null) {\n      return &lt;span&gt;Error: {this.state.error.message}&lt;/span&gt;;\n    }\n    else {\n      var repos = this.state.data.items;\n      var repoList = repos.map(function (repo, index) {\n        return (\n          &lt;li key={index}&gt;&lt;a href={repo.html_url}&gt;{repo.name}&lt;/a&gt; ({repo.stargazers_count} stars) &lt;br/&gt; {repo.description}&lt;/li&gt;\n        );\n      });\n      return (\n        &lt;main&gt;\n          &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt;\n          &lt;ol&gt;{repoList}&lt;/ol&gt;\n        &lt;/main&gt;\n      );\n    }\n  }\n});\n\nReactDOM.render(\n  &lt;RepoList promise={$.getJSON(&#39;https://api.github.com/search/repositories?q=javascript&amp;sort=stars&#39;)} /&gt;,\n  document.getElementById(&#39;example&#39;)\n);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>数据传来后赋值</p>\n<pre><code>componentDidMount() {\n  this.props.promise.then(\n    value =&gt; this.setState({loading: false, data: value}),\n    error =&gt; this.setState({loading: false, error: error}));\n},\n</code></pre><p>如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。</p>\n<pre><code>getInitialState: function() {\n  return {\n    loading: true,\n    error: null,\n    data: null\n  };\n},\n</code></pre><p>Promise对象正在抓取数据（pending状态），组件显示”正在加载”</p>\n</li>\n</ol>\n<h2 id=\"第十三个demo\"><a href=\"#第十三个demo\" class=\"headerlink\" title=\"第十三个demo\"></a>第十三个demo</h2><ul>\n<li><p>这里不贴代码</p>\n</li>\n<li><p>这是一个 React 的服务器渲染</p>\n</li>\n<li><p>根据 readme.md 的提示，我们搞好依赖，<code>node server.js</code> 来监听 <a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener\">http://localhost:3000</a> <img src=\"http://upload-images.jianshu.io/upload_images/3191557-888bf6bd6f540557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>这看着是非常像手写服务器的方法，如果有 JavaScript权威指南 这本书，我建议你看看 P302 如何手写服务器。<img src=\"http://upload-images.jianshu.io/upload_images/3191557-bc51896f11363644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>这里推荐一篇文章 <a href=\"http://www.alloyteam.com/2017/01/react-from-scratch-server-render/\" target=\"_blank\" rel=\"noopener\">从零开始 React 服务器渲染</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-React-的门把手\"><a href=\"#摸到-React-的门把手\" class=\"headerlink\" title=\"摸到 React 的门把手\"></a>摸到 React 的门把手</h1><p><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">React 入门实例教程 - 阮一峰</a></p>\n<p>阮一峰真的很适合当老师，这里我们就慢慢的跟上阮一峰老师步伐，摸上 React 的门把手。</p>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><pre><code>npm init\nnpm install --save react react-dom\n</code></pre><p>而阮一峰的 demo 包自带了 React ，那我们就直接用吧。</p>\n<pre><code>$ git clone git@github.com:ruanyf/react-demos.git\n</code></pre><h2 id=\"第一个-demo\"><a href=\"#第一个-demo\" class=\"headerlink\" title=\"第一个 demo\"></a>第一个 demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      ReactDOM.render(\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>并非一定要引用 browser.js ，引入它的作用是使浏览器支持<code>babel</code>，你可以使用<code>ES2015</code>（具体可以看<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰的ECMAScript 6 入门</a>）进行编码。如果你用ES5，可以不引入。而在这里的作用是将 JSX 语法转为 JavaScript 语法。</p>\n<pre><code>// The ES5 way\nvar Photo = React.createClass({\n  handleDoubleTap: function(e) { … },\n  render: function() { … },\n});\n</code></pre><pre><code>// The ES6+ way\nclass Photo extends React.Component {\n  handleDoubleTap(e) { … }\n  render() { … }\n}\n</code></pre></li>\n</ol>\n<ol>\n<li>注意 React 是用了 JSX 的语法，跟 JavaScript 不兼容。使用了 JSX 的地方都要加上 <code>type=&#39;text/babel&#39;</code></li>\n<li><code>ReactDOM.render</code> 是一个 API ，将模板转成 HTML 语言，并插入制定的 DOM 节点。</li>\n</ol>\n<h2 id=\"第二个-demo\"><a href=\"#第二个-demo\" class=\"headerlink\" title=\"第二个 demo\"></a>第二个 demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var names = [&#39;Alice&#39;, &#39;Emily&#39;, &#39;Kate&#39;];\n\n      ReactDOM.render(\n        &lt;div&gt;\n        {\n          names.map(function (name, index) {\n            return &lt;div key={index}&gt;Hello, {name}!&lt;/div&gt;\n          })\n        }\n        &lt;/div&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>在这个例子中我觉得 JSX 语法原来可以这样用，其实就是等于 HTML 和 JavaScript 的混写。</li>\n<li>遇到 HTML 标签（以 <code>&lt;</code> 开头），就用 HTML 规则解析；遇到代码块（以 <code>{</code> 开头），就用 JavaScript 规则解析。</li>\n</ol>\n<h2 id=\"第三个demo\"><a href=\"#第三个demo\" class=\"headerlink\" title=\"第三个demo\"></a>第三个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var arr = [\n        &lt;h1 key=&quot;1&quot;&gt;Hello world!&lt;/h1&gt;,\n        &lt;h2 key=&quot;2&quot;&gt;React is awesome&lt;/h2&gt;,\n      ];\n      ReactDOM.render(\n        &lt;div&gt;{arr}&lt;/div&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>这里有一个亮点，就是用了这行代码 <code>&lt;div&gt;{arr}&lt;/div&gt;</code> 把数组成员全部展现到模板上，如果让我想我只会想到用 for 循环再一个一个加到 HTML 那里。。。</li>\n</ol>\n<h2 id=\"第四个demo\"><a href=\"#第四个demo\" class=\"headerlink\" title=\"第四个demo\"></a>第四个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var HelloMessage = React.createClass({\n        render: function() {\n          return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;\n        }\n      });\n\n      ReactDOM.render(\n        &lt;HelloMessage name=&quot;John&quot; /&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>也就是说，用 <code>React.createClass</code> 可以把一个段代码封装成组件，然后像普通的 HTML 标签一样在网页插入这个组件。</p>\n</li>\n<li><p>要保证自己的组件拥有 <code>ReactDOM.render</code> 这个 API 来输出组件。</p>\n</li>\n<li><p>组件类的第一个字母必须大写，否则会报错。如 <code>HelloMessage</code> 不能写成 <code>helloMessage</code>。</p>\n</li>\n<li><p>还有组件类只能包含一个顶层标签，否则会出错 </p>\n<pre><code>var HelloMessage = React.createClass({\n  render: function() {\n    return &lt;h1&gt;\n      Hello {this.props.name}\n    &lt;/h1&gt;&lt;p&gt;\n      some text\n    &lt;/p&gt;;\n  }\n});\n</code></pre></li>\n<li><p>组件的用法和 HTML 的用法是一样的，可以加入任何的属性，比如 <code>&lt;HelloMessage name=&quot;John&quot;&gt;</code> 就是 <code>HelloMessage</code> 中加入一个 <code>name</code> 属性。组件的属性可以在组件类的 <code>this.props</code> 对象上获取，比如 <code>name</code> 属性就可以通过 <code>this.props.name</code> 读取。</p>\n</li>\n<li><p>添加组件属性，有一个地方需要注意，就是 <code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code> ，这是因为 <code>class</code> 和 <code>for</code> 是 JavaScript 的保留字。</p>\n</li>\n</ol>\n<h2 id=\"第五个demo\"><a href=\"#第五个demo\" class=\"headerlink\" title=\"第五个demo\"></a>第五个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var NotesList = React.createClass({\n        render: function() {\n          return (\n            &lt;ol&gt;\n              {\n                React.Children.map(this.props.children, function (child) {\n                  return &lt;li&gt;{child}&lt;/li&gt;;\n                })\n              }\n            &lt;/ol&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(\n        &lt;NotesList&gt;\n          &lt;span&gt;hello&lt;/span&gt;\n          &lt;span&gt;world&lt;/span&gt;\n        &lt;/NotesList&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>这一个例子主要是讲解了 <code>this.props.children</code> 属性。它表示组件的所有子节点。</li>\n<li><code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。</li>\n<li>React 提供一个工具方法 <a href=\"https://facebook.github.io/react/docs/top-level-api.html#react.children\" target=\"_blank\" rel=\"noopener\"><code>React.Children</code></a> 来处理 <code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。</li>\n</ol>\n<h2 id=\"第六的demo\"><a href=\"#第六的demo\" class=\"headerlink\" title=\"第六的demo\"></a>第六的demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n\n      var data = 123;\n\n      var MyTitle = React.createClass({\n        propTypes: {\n          title: React.PropTypes.string.isRequired,\n        },\n\n        render: function() {\n          return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;\n        }\n      });\n\n      ReactDOM.render(\n        &lt;MyTitle title={data} /&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p><code>PropTypes</code>属性，就是用来验证组件实例的属性是否符合要求。</p>\n</li>\n<li><p><code>Mytitle</code>组件有一个<code>title</code>属性。<code>PropTypes</code> 告诉 React，这个 <code>title</code> 属性是必须的，而且它的值必须是字符串。<code>title</code> 没有通过验证。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-a577caebac60a9c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>另外，阮一峰老师还介绍了<code>getDefaultProps</code> 方法可以用来设置组件属性的默认值。</p>\n<pre><code>var MyTitle = React.createClass({\n  getDefaultProps : function () {\n    return {\n      title : &#39;Hello World&#39;\n    };\n  },\n\n  render: function() {\n     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;\n   }\n});\n\nReactDOM.render(\n  &lt;MyTitle /&gt;,\n  document.body\n);\n//上面代码会输出&quot;Hello World&quot;。\n</code></pre></li>\n</ol>\n<h2 id=\"第七个demo\"><a href=\"#第七个demo\" class=\"headerlink\" title=\"第七个demo\"></a>第七个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var MyComponent = React.createClass({\n        handleClick: function() {\n          this.refs.myTextInput.focus();\n        },\n        render: function() {\n          return (\n            &lt;div&gt;\n              &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;\n              &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt;\n            &lt;/div&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(\n        &lt;MyComponent /&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n//这样就能通过点击 button 来获取 input 的 focus\n</code></pre><ol>\n<li><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <a href=\"http://calendar.perfplanet.com/2013/diff/\" target=\"_blank\" rel=\"noopener\">DOM diff</a> ，它可以极大提高网页的性能表现。</p>\n<p>但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。</p>\n</li>\n<li><p>上面代码中，组件 <code>MyComponent</code> 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 <code>ref</code> 属性，然后 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。</p>\n</li>\n<li><p>需要注意的是，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 <code>Click</code> 事件的回调函数，确保了只有等到真实 DOM 发生 <code>Click</code> 事件之后，才会读取 <code>this.refs.[refName]</code> 属性。</p>\n</li>\n<li><p>除了 <code>Click</code> 事件以外，还有 <code>KeyDown</code> 、<code>Copy</code>、<code>Scroll</code> 等</p>\n</li>\n</ol>\n<h2 id=\"第八个demo\"><a href=\"#第八个demo\" class=\"headerlink\" title=\"第八个demo\"></a>第八个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\nvar LikeButton = React.createClass({\n  getInitialState: function() {\n    return {liked: false};\n  },\n  handleClick: function(event) {\n    this.setState({liked: !this.state.liked});\n  },\n  render: function() {\n    var text = this.state.liked ? &#39;like&#39; : &#39;haven\\&#39;t liked&#39;;\n    return (\n      &lt;p onClick={this.handleClick}&gt;\n        You {text} this. Click to toggle.\n      &lt;/p&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;LikeButton /&gt;,\n  document.getElementById(&#39;example&#39;)\n);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>组件的状态，用来和用户互动，组件一开始有一个状态，然后用户操作导致状态改变，从而改变状态，根据状态重新渲染页面。</li>\n<li><code>return {liked: false}</code> 初始化组件的状态</li>\n<li><code>this.setState({liked: !this.state.liked})</code> 将组件状态设置为当前状态相反状态</li>\n</ol>\n<h2 id=\"第九个demo\"><a href=\"#第九个demo\" class=\"headerlink\" title=\"第九个demo\"></a>第九个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var Input = React.createClass({\n        getInitialState: function() {\n          return {value: &#39;Hello!&#39;};\n        },\n        handleChange: function(event) {\n          this.setState({value: event.target.value});\n        },\n        render: function () {\n          var value = this.state.value;\n          return (\n            &lt;div&gt;\n              &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;\n              &lt;p&gt;{value}&lt;/p&gt;\n            &lt;/div&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(&lt;Input/&gt;, document.getElementById(&#39;example&#39;));\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>第一次看这个，呦吼？这难道是传说中的双向绑定？<a href=\"http://www.cnblogs.com/kuailingmin/p/4609721.html\" target=\"_blank\" rel=\"noopener\">React的双向绑定</a></li>\n<li>上面代码中，文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。</li>\n</ol>\n<h2 id=\"第十个demo\"><a href=\"#第十个demo\" class=\"headerlink\" title=\"第十个demo\"></a>第十个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n      var Hello = React.createClass({\n        getInitialState: function () {\n          return {\n            opacity: 1.0\n          };\n        },\n\n        componentDidMount: function () {\n          this.timer = setInterval(function () {\n            var opacity = this.state.opacity;\n            opacity -= .05;\n            if (opacity &lt; 0.1) {\n              opacity = 1.0;\n            }\n            this.setState({\n              opacity: opacity\n            });\n          }.bind(this), 100);\n        },\n\n        render: function () {\n          return (\n            &lt;div style={{opacity: this.state.opacity}}&gt;\n              Hello {this.props.name}\n            &lt;/div&gt;\n          );\n        }\n      });\n\n      ReactDOM.render(\n        &lt;Hello name=&quot;world&quot;/&gt;,\n        document.getElementById(&#39;example&#39;)\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>这里主要是介绍了关于组件的生命周期</p>\n</li>\n<li><p>React 为每个状态都提供了两种处理函数，<code>will</code> 是我要插入了！<code>did</code> 是我插进去之后，要不要搞点东西？</p>\n</li>\n<li><p>阮一峰老师的这个 demo 是在<code>hello</code>组件加载以后，通过 <code>componentDidMount</code> 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。</p>\n</li>\n<li><p>注意组件 <code>style</code> 属性的设置方式</p>\n<pre><code>//这样是错的\nstyle=&quot;opacity:{this.state.opacity};&quot;\n//而要写成\nstyle={{opacity: this.state.opacity}}\n</code></pre><p>这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>\n</li>\n</ol>\n<h2 id=\"第十一个demo\"><a href=\"#第十一个demo\" class=\"headerlink\" title=\"第十一个demo\"></a>第十一个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/jquery.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\nvar UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: &#39;&#39;,\n      lastGistUrl: &#39;&#39;\n    };\n  },\n\n  componentDidMount: function() {\n    $.get(this.props.source, function(result) {\n      var lastGist = result[0];\n      if (this.isMounted()) {\n        this.setState({\n          username: lastGist.owner.login,\n          lastGistUrl: lastGist.html_url\n        });\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      &lt;div&gt;\n        {this.state.username}&#39;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,\n  document.getElementById(&#39;example&#39;)\n);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li>把数据通过 AJAX 请求的方法从服务器获取，阮一峰老师这里是用了 <code>componentDidMount</code> 方法设置 AJAX 请求，再用 <code>this.setState</code> 方法重新渲染 UI，<code>InitialState</code> 初始数据为空</li>\n</ol>\n<h2 id=\"第十二个demo\"><a href=\"#第十二个demo\" class=\"headerlink\" title=\"第十二个demo\"></a>第十二个demo</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../build/jquery.min.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\nvar RepoList = React.createClass({\n  getInitialState: function() {\n    return {\n      loading: true,\n      error: null,\n      data: null\n    };\n  },\n\n  componentDidMount() {\n    this.props.promise.then(\n      value =&gt; this.setState({loading: false, data: value}),\n      error =&gt; this.setState({loading: false, error: error}));\n  },\n\n  render: function() {\n    if (this.state.loading) {\n      return &lt;span&gt;Loading...&lt;/span&gt;;\n    }\n    else if (this.state.error !== null) {\n      return &lt;span&gt;Error: {this.state.error.message}&lt;/span&gt;;\n    }\n    else {\n      var repos = this.state.data.items;\n      var repoList = repos.map(function (repo, index) {\n        return (\n          &lt;li key={index}&gt;&lt;a href={repo.html_url}&gt;{repo.name}&lt;/a&gt; ({repo.stargazers_count} stars) &lt;br/&gt; {repo.description}&lt;/li&gt;\n        );\n      });\n      return (\n        &lt;main&gt;\n          &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt;\n          &lt;ol&gt;{repoList}&lt;/ol&gt;\n        &lt;/main&gt;\n      );\n    }\n  }\n});\n\nReactDOM.render(\n  &lt;RepoList promise={$.getJSON(&#39;https://api.github.com/search/repositories?q=javascript&amp;sort=stars&#39;)} /&gt;,\n  document.getElementById(&#39;example&#39;)\n);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ol>\n<li><p>数据传来后赋值</p>\n<pre><code>componentDidMount() {\n  this.props.promise.then(\n    value =&gt; this.setState({loading: false, data: value}),\n    error =&gt; this.setState({loading: false, error: error}));\n},\n</code></pre><p>如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。</p>\n<pre><code>getInitialState: function() {\n  return {\n    loading: true,\n    error: null,\n    data: null\n  };\n},\n</code></pre><p>Promise对象正在抓取数据（pending状态），组件显示”正在加载”</p>\n</li>\n</ol>\n<h2 id=\"第十三个demo\"><a href=\"#第十三个demo\" class=\"headerlink\" title=\"第十三个demo\"></a>第十三个demo</h2><ul>\n<li><p>这里不贴代码</p>\n</li>\n<li><p>这是一个 React 的服务器渲染</p>\n</li>\n<li><p>根据 readme.md 的提示，我们搞好依赖，<code>node server.js</code> 来监听 <a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener\">http://localhost:3000</a> <img src=\"http://upload-images.jianshu.io/upload_images/3191557-888bf6bd6f540557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>这看着是非常像手写服务器的方法，如果有 JavaScript权威指南 这本书，我建议你看看 P302 如何手写服务器。<img src=\"http://upload-images.jianshu.io/upload_images/3191557-bc51896f11363644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</li>\n<li><p>这里推荐一篇文章 <a href=\"http://www.alloyteam.com/2017/01/react-from-scratch-server-render/\" target=\"_blank\" rel=\"noopener\">从零开始 React 服务器渲染</a></p>\n</li>\n</ul>\n"},{"title":"摸到 TypeScript 的门把手","date":"2017-10-13T16:06:12.000Z","_content":"# 摸到 TypeScript 的门把手\n\n[TypeScript](https://github.com/Microsoft/TypeScript)\n\n## Basic Types（原始数据类型）\n\n```\nlet a: boolean = false;\na = 'hello'\n//这样是错的\n//因为类型不兼容 要 a = true\nlet b: number = 1;\nlet c: string = '1';\nlet e: number[] = [1,2,3];\n//number[] 等于 Array<number>\n\n//这里有一个新类型 Tuple\n//有限长度的有限列表\nlet f: [string, number] = ['1',2];\n\n//Enum 一个数字的集合\nenum g {\n  hello = 0,\n  world = 1,\n}\nenum g1 {\n  hello,\n  world,\n}\n//是默认012345这样赋值\n//转成 JS\n(function (g) {\n    g[g[\"hello\"] = 0] = \"hello\";\n    g[g[\"world\"] = 1] = \"world\";\n})(g || (g = {}));\nvar g1;\n(function (g1) {\n    g1[g1[\"hello\"] = 0] = \"hello\";\n    g1[g1[\"world\"] = 1] = \"world\";\n})(g1 || (g1 = {}));\n//TS2.4后可以赋值 string\nenum g {\n  hello = '0',\n  world = '1',\n}\n\n//Any\n//let the values pass through compile-time checks\nlet notSure:any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false;\n\n//Void\nfunction a(): void {\n  alert('hello world')\n}\n\n//Never\nfunction never1(): never {\n  throw Error('Something failed')\n}\n\n//assert 断言\n//Type assertion\nlet someValue1: any = \"this is a string\";\nlet strLength1: number = (<string>someValue).length;\n//让 String 具有 Number 的办法\n```\n\n## Variable Declarations\n\n```\nvar s = 1;\nlet s1 = 2;\nconst s2 = 3;\nfunction s3 () {\n  return 4;\n} \nconst s4 = () => {\n  return 5；\n}\n```\n\n## Interfaces（接口）\n\n```\ninterface IMap {\n  a: string;\n}\n//type contract\nlet obj1: IMap = {\n  a: '1',\n  b: 2,   //error 一定要 string\n}\nfunction sss (a: IMap): IMap{\n  return a;\n}\n\n//Optional Properties\ninterface IOptional1 {\n  a: number;\n  b?: string;\n}\n// arg.b 有可能 undefined\nfunction sss1(arg: IOptional1): string{\n  return arg.b + ''\n}\n\n//Readonly properties\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\nlet point: IPoint = {\n  x: 1, \n  y: 2,\n}\n//point.x = 23;\n//只读属性没法定义\n\n//Function Types\ninterface ISearchFunc {\n    (source: string, subString: string): boolean;\n}\n//function(source, subString) 没有必要再定义\nlet mySearch: ISearchFunc = function(source: string, subString: string) {\n    let result = source.search(subString);\n    return result > -1;\n}\n//Indexable Types\ninterface IndexType {\n  [key:string]:number\n}\nlet inst1: IndexType {\n  a: '1',     //error\n}\n\n//type\ntype aType = IndexType;\n//比如说是let啊，就是类型声明对吧 type 就类似\n\ntype aaaaa = string;\nlet ssss: aaaaa = '1'\n\ninterface IPeople {\n  eyes: number;\n}\nenum LapTopEnum {\n  haiwei,\n  lenovo,\n  apple,\n  IBM,\n}\ninterface ImonkeyProgramer extends IPeople {\n  laptop: LapTopEnum\n}\nlet tangkalun: ImonkeyProgramer = {\n  laptop: LapTopEnum.apple,\n  eyes: 2,\n}\n```\n\n> In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.\n\n## Classes（类）\n\n```\nclass A {\n    a:string\n    constructor() {\n        this.a = '1'\n    }\n    hello(): string {\n        return '1';\n    }\n}\nlet instA = new A();\ninstA.a\n//转换成 JS\nvar A = (function () {\n    function A() {\n        this.a = '1';\n    }\n    A.prototype.hello = function () {\n        return '1';\n    };\n    return A;\n}());\nvar instA = new A();\ninstA.a;\n//注意 private public protect\n\n//Inheritance\nclass People {\n    name: string\n    constructor(name: string) {\n        this.name = name;\n    }\n}\nclass A extends People {\n    a: string;\n    constructor() {\n        super('tangkalun');\n        this.a = '1';\n    }\n    hello(): string {\n        return this.a;\n    }\n}\n// class 不仅可以描述数据结构,同时他还有方法、属性等等的封装\nlet instA = new A();\ninstA.a;\ninstA.name;\n//关于super()这个问题，是调用父类的构造函数\n```\n\n## Generics（泛型）\n\n```\ninterface SillyBoy<T> {\n  skills: T\n}\nconst tangkalun: SillyBoy<['string','string','string']> = {\n  skills: ['eat','fuck','sleep']\n}\nconst frankie: SillyBoy<[string]> = {\n  skills: ['fuck'],\n}\nconst tang: SillyBoy<[undefined]> = {\n  skills: undefined,\n}\nconst kalun: SillyBoy<string> = {\n    skills: 'sleep',\n}\n```\n\n先到这里吧，我太菜了。","source":"_posts/摸到 TypeScript 的门把手.md","raw":"---\ntitle: 摸到 TypeScript 的门把手\ndate: 2017-10-14 00:06:12\ntags: [TypeScript,Black History]\n---\n# 摸到 TypeScript 的门把手\n\n[TypeScript](https://github.com/Microsoft/TypeScript)\n\n## Basic Types（原始数据类型）\n\n```\nlet a: boolean = false;\na = 'hello'\n//这样是错的\n//因为类型不兼容 要 a = true\nlet b: number = 1;\nlet c: string = '1';\nlet e: number[] = [1,2,3];\n//number[] 等于 Array<number>\n\n//这里有一个新类型 Tuple\n//有限长度的有限列表\nlet f: [string, number] = ['1',2];\n\n//Enum 一个数字的集合\nenum g {\n  hello = 0,\n  world = 1,\n}\nenum g1 {\n  hello,\n  world,\n}\n//是默认012345这样赋值\n//转成 JS\n(function (g) {\n    g[g[\"hello\"] = 0] = \"hello\";\n    g[g[\"world\"] = 1] = \"world\";\n})(g || (g = {}));\nvar g1;\n(function (g1) {\n    g1[g1[\"hello\"] = 0] = \"hello\";\n    g1[g1[\"world\"] = 1] = \"world\";\n})(g1 || (g1 = {}));\n//TS2.4后可以赋值 string\nenum g {\n  hello = '0',\n  world = '1',\n}\n\n//Any\n//let the values pass through compile-time checks\nlet notSure:any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false;\n\n//Void\nfunction a(): void {\n  alert('hello world')\n}\n\n//Never\nfunction never1(): never {\n  throw Error('Something failed')\n}\n\n//assert 断言\n//Type assertion\nlet someValue1: any = \"this is a string\";\nlet strLength1: number = (<string>someValue).length;\n//让 String 具有 Number 的办法\n```\n\n## Variable Declarations\n\n```\nvar s = 1;\nlet s1 = 2;\nconst s2 = 3;\nfunction s3 () {\n  return 4;\n} \nconst s4 = () => {\n  return 5；\n}\n```\n\n## Interfaces（接口）\n\n```\ninterface IMap {\n  a: string;\n}\n//type contract\nlet obj1: IMap = {\n  a: '1',\n  b: 2,   //error 一定要 string\n}\nfunction sss (a: IMap): IMap{\n  return a;\n}\n\n//Optional Properties\ninterface IOptional1 {\n  a: number;\n  b?: string;\n}\n// arg.b 有可能 undefined\nfunction sss1(arg: IOptional1): string{\n  return arg.b + ''\n}\n\n//Readonly properties\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\nlet point: IPoint = {\n  x: 1, \n  y: 2,\n}\n//point.x = 23;\n//只读属性没法定义\n\n//Function Types\ninterface ISearchFunc {\n    (source: string, subString: string): boolean;\n}\n//function(source, subString) 没有必要再定义\nlet mySearch: ISearchFunc = function(source: string, subString: string) {\n    let result = source.search(subString);\n    return result > -1;\n}\n//Indexable Types\ninterface IndexType {\n  [key:string]:number\n}\nlet inst1: IndexType {\n  a: '1',     //error\n}\n\n//type\ntype aType = IndexType;\n//比如说是let啊，就是类型声明对吧 type 就类似\n\ntype aaaaa = string;\nlet ssss: aaaaa = '1'\n\ninterface IPeople {\n  eyes: number;\n}\nenum LapTopEnum {\n  haiwei,\n  lenovo,\n  apple,\n  IBM,\n}\ninterface ImonkeyProgramer extends IPeople {\n  laptop: LapTopEnum\n}\nlet tangkalun: ImonkeyProgramer = {\n  laptop: LapTopEnum.apple,\n  eyes: 2,\n}\n```\n\n> In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.\n\n## Classes（类）\n\n```\nclass A {\n    a:string\n    constructor() {\n        this.a = '1'\n    }\n    hello(): string {\n        return '1';\n    }\n}\nlet instA = new A();\ninstA.a\n//转换成 JS\nvar A = (function () {\n    function A() {\n        this.a = '1';\n    }\n    A.prototype.hello = function () {\n        return '1';\n    };\n    return A;\n}());\nvar instA = new A();\ninstA.a;\n//注意 private public protect\n\n//Inheritance\nclass People {\n    name: string\n    constructor(name: string) {\n        this.name = name;\n    }\n}\nclass A extends People {\n    a: string;\n    constructor() {\n        super('tangkalun');\n        this.a = '1';\n    }\n    hello(): string {\n        return this.a;\n    }\n}\n// class 不仅可以描述数据结构,同时他还有方法、属性等等的封装\nlet instA = new A();\ninstA.a;\ninstA.name;\n//关于super()这个问题，是调用父类的构造函数\n```\n\n## Generics（泛型）\n\n```\ninterface SillyBoy<T> {\n  skills: T\n}\nconst tangkalun: SillyBoy<['string','string','string']> = {\n  skills: ['eat','fuck','sleep']\n}\nconst frankie: SillyBoy<[string]> = {\n  skills: ['fuck'],\n}\nconst tang: SillyBoy<[undefined]> = {\n  skills: undefined,\n}\nconst kalun: SillyBoy<string> = {\n    skills: 'sleep',\n}\n```\n\n先到这里吧，我太菜了。","slug":"摸到 TypeScript 的门把手","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8q000sf1xhzkeubous","content":"<h1 id=\"摸到-TypeScript-的门把手\"><a href=\"#摸到-TypeScript-的门把手\" class=\"headerlink\" title=\"摸到 TypeScript 的门把手\"></a>摸到 TypeScript 的门把手</h1><p><a href=\"https://github.com/Microsoft/TypeScript\" target=\"_blank\" rel=\"noopener\">TypeScript</a></p>\n<h2 id=\"Basic-Types（原始数据类型）\"><a href=\"#Basic-Types（原始数据类型）\" class=\"headerlink\" title=\"Basic Types（原始数据类型）\"></a>Basic Types（原始数据类型）</h2><pre><code>let a: boolean = false;\na = &#39;hello&#39;\n//这样是错的\n//因为类型不兼容 要 a = true\nlet b: number = 1;\nlet c: string = &#39;1&#39;;\nlet e: number[] = [1,2,3];\n//number[] 等于 Array&lt;number&gt;\n\n//这里有一个新类型 Tuple\n//有限长度的有限列表\nlet f: [string, number] = [&#39;1&#39;,2];\n\n//Enum 一个数字的集合\nenum g {\n  hello = 0,\n  world = 1,\n}\nenum g1 {\n  hello,\n  world,\n}\n//是默认012345这样赋值\n//转成 JS\n(function (g) {\n    g[g[&quot;hello&quot;] = 0] = &quot;hello&quot;;\n    g[g[&quot;world&quot;] = 1] = &quot;world&quot;;\n})(g || (g = {}));\nvar g1;\n(function (g1) {\n    g1[g1[&quot;hello&quot;] = 0] = &quot;hello&quot;;\n    g1[g1[&quot;world&quot;] = 1] = &quot;world&quot;;\n})(g1 || (g1 = {}));\n//TS2.4后可以赋值 string\nenum g {\n  hello = &#39;0&#39;,\n  world = &#39;1&#39;,\n}\n\n//Any\n//let the values pass through compile-time checks\nlet notSure:any = 4;\nnotSure = &quot;maybe a string instead&quot;;\nnotSure = false;\n\n//Void\nfunction a(): void {\n  alert(&#39;hello world&#39;)\n}\n\n//Never\nfunction never1(): never {\n  throw Error(&#39;Something failed&#39;)\n}\n\n//assert 断言\n//Type assertion\nlet someValue1: any = &quot;this is a string&quot;;\nlet strLength1: number = (&lt;string&gt;someValue).length;\n//让 String 具有 Number 的办法\n</code></pre><h2 id=\"Variable-Declarations\"><a href=\"#Variable-Declarations\" class=\"headerlink\" title=\"Variable Declarations\"></a>Variable Declarations</h2><pre><code>var s = 1;\nlet s1 = 2;\nconst s2 = 3;\nfunction s3 () {\n  return 4;\n} \nconst s4 = () =&gt; {\n  return 5；\n}\n</code></pre><h2 id=\"Interfaces（接口）\"><a href=\"#Interfaces（接口）\" class=\"headerlink\" title=\"Interfaces（接口）\"></a>Interfaces（接口）</h2><pre><code>interface IMap {\n  a: string;\n}\n//type contract\nlet obj1: IMap = {\n  a: &#39;1&#39;,\n  b: 2,   //error 一定要 string\n}\nfunction sss (a: IMap): IMap{\n  return a;\n}\n\n//Optional Properties\ninterface IOptional1 {\n  a: number;\n  b?: string;\n}\n// arg.b 有可能 undefined\nfunction sss1(arg: IOptional1): string{\n  return arg.b + &#39;&#39;\n}\n\n//Readonly properties\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\nlet point: IPoint = {\n  x: 1, \n  y: 2,\n}\n//point.x = 23;\n//只读属性没法定义\n\n//Function Types\ninterface ISearchFunc {\n    (source: string, subString: string): boolean;\n}\n//function(source, subString) 没有必要再定义\nlet mySearch: ISearchFunc = function(source: string, subString: string) {\n    let result = source.search(subString);\n    return result &gt; -1;\n}\n//Indexable Types\ninterface IndexType {\n  [key:string]:number\n}\nlet inst1: IndexType {\n  a: &#39;1&#39;,     //error\n}\n\n//type\ntype aType = IndexType;\n//比如说是let啊，就是类型声明对吧 type 就类似\n\ntype aaaaa = string;\nlet ssss: aaaaa = &#39;1&#39;\n\ninterface IPeople {\n  eyes: number;\n}\nenum LapTopEnum {\n  haiwei,\n  lenovo,\n  apple,\n  IBM,\n}\ninterface ImonkeyProgramer extends IPeople {\n  laptop: LapTopEnum\n}\nlet tangkalun: ImonkeyProgramer = {\n  laptop: LapTopEnum.apple,\n  eyes: 2,\n}\n</code></pre><blockquote>\n<p>In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</p>\n</blockquote>\n<h2 id=\"Classes（类）\"><a href=\"#Classes（类）\" class=\"headerlink\" title=\"Classes（类）\"></a>Classes（类）</h2><pre><code>class A {\n    a:string\n    constructor() {\n        this.a = &#39;1&#39;\n    }\n    hello(): string {\n        return &#39;1&#39;;\n    }\n}\nlet instA = new A();\ninstA.a\n//转换成 JS\nvar A = (function () {\n    function A() {\n        this.a = &#39;1&#39;;\n    }\n    A.prototype.hello = function () {\n        return &#39;1&#39;;\n    };\n    return A;\n}());\nvar instA = new A();\ninstA.a;\n//注意 private public protect\n\n//Inheritance\nclass People {\n    name: string\n    constructor(name: string) {\n        this.name = name;\n    }\n}\nclass A extends People {\n    a: string;\n    constructor() {\n        super(&#39;tangkalun&#39;);\n        this.a = &#39;1&#39;;\n    }\n    hello(): string {\n        return this.a;\n    }\n}\n// class 不仅可以描述数据结构,同时他还有方法、属性等等的封装\nlet instA = new A();\ninstA.a;\ninstA.name;\n//关于super()这个问题，是调用父类的构造函数\n</code></pre><h2 id=\"Generics（泛型）\"><a href=\"#Generics（泛型）\" class=\"headerlink\" title=\"Generics（泛型）\"></a>Generics（泛型）</h2><pre><code>interface SillyBoy&lt;T&gt; {\n  skills: T\n}\nconst tangkalun: SillyBoy&lt;[&#39;string&#39;,&#39;string&#39;,&#39;string&#39;]&gt; = {\n  skills: [&#39;eat&#39;,&#39;fuck&#39;,&#39;sleep&#39;]\n}\nconst frankie: SillyBoy&lt;[string]&gt; = {\n  skills: [&#39;fuck&#39;],\n}\nconst tang: SillyBoy&lt;[undefined]&gt; = {\n  skills: undefined,\n}\nconst kalun: SillyBoy&lt;string&gt; = {\n    skills: &#39;sleep&#39;,\n}\n</code></pre><p>先到这里吧，我太菜了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-TypeScript-的门把手\"><a href=\"#摸到-TypeScript-的门把手\" class=\"headerlink\" title=\"摸到 TypeScript 的门把手\"></a>摸到 TypeScript 的门把手</h1><p><a href=\"https://github.com/Microsoft/TypeScript\" target=\"_blank\" rel=\"noopener\">TypeScript</a></p>\n<h2 id=\"Basic-Types（原始数据类型）\"><a href=\"#Basic-Types（原始数据类型）\" class=\"headerlink\" title=\"Basic Types（原始数据类型）\"></a>Basic Types（原始数据类型）</h2><pre><code>let a: boolean = false;\na = &#39;hello&#39;\n//这样是错的\n//因为类型不兼容 要 a = true\nlet b: number = 1;\nlet c: string = &#39;1&#39;;\nlet e: number[] = [1,2,3];\n//number[] 等于 Array&lt;number&gt;\n\n//这里有一个新类型 Tuple\n//有限长度的有限列表\nlet f: [string, number] = [&#39;1&#39;,2];\n\n//Enum 一个数字的集合\nenum g {\n  hello = 0,\n  world = 1,\n}\nenum g1 {\n  hello,\n  world,\n}\n//是默认012345这样赋值\n//转成 JS\n(function (g) {\n    g[g[&quot;hello&quot;] = 0] = &quot;hello&quot;;\n    g[g[&quot;world&quot;] = 1] = &quot;world&quot;;\n})(g || (g = {}));\nvar g1;\n(function (g1) {\n    g1[g1[&quot;hello&quot;] = 0] = &quot;hello&quot;;\n    g1[g1[&quot;world&quot;] = 1] = &quot;world&quot;;\n})(g1 || (g1 = {}));\n//TS2.4后可以赋值 string\nenum g {\n  hello = &#39;0&#39;,\n  world = &#39;1&#39;,\n}\n\n//Any\n//let the values pass through compile-time checks\nlet notSure:any = 4;\nnotSure = &quot;maybe a string instead&quot;;\nnotSure = false;\n\n//Void\nfunction a(): void {\n  alert(&#39;hello world&#39;)\n}\n\n//Never\nfunction never1(): never {\n  throw Error(&#39;Something failed&#39;)\n}\n\n//assert 断言\n//Type assertion\nlet someValue1: any = &quot;this is a string&quot;;\nlet strLength1: number = (&lt;string&gt;someValue).length;\n//让 String 具有 Number 的办法\n</code></pre><h2 id=\"Variable-Declarations\"><a href=\"#Variable-Declarations\" class=\"headerlink\" title=\"Variable Declarations\"></a>Variable Declarations</h2><pre><code>var s = 1;\nlet s1 = 2;\nconst s2 = 3;\nfunction s3 () {\n  return 4;\n} \nconst s4 = () =&gt; {\n  return 5；\n}\n</code></pre><h2 id=\"Interfaces（接口）\"><a href=\"#Interfaces（接口）\" class=\"headerlink\" title=\"Interfaces（接口）\"></a>Interfaces（接口）</h2><pre><code>interface IMap {\n  a: string;\n}\n//type contract\nlet obj1: IMap = {\n  a: &#39;1&#39;,\n  b: 2,   //error 一定要 string\n}\nfunction sss (a: IMap): IMap{\n  return a;\n}\n\n//Optional Properties\ninterface IOptional1 {\n  a: number;\n  b?: string;\n}\n// arg.b 有可能 undefined\nfunction sss1(arg: IOptional1): string{\n  return arg.b + &#39;&#39;\n}\n\n//Readonly properties\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\nlet point: IPoint = {\n  x: 1, \n  y: 2,\n}\n//point.x = 23;\n//只读属性没法定义\n\n//Function Types\ninterface ISearchFunc {\n    (source: string, subString: string): boolean;\n}\n//function(source, subString) 没有必要再定义\nlet mySearch: ISearchFunc = function(source: string, subString: string) {\n    let result = source.search(subString);\n    return result &gt; -1;\n}\n//Indexable Types\ninterface IndexType {\n  [key:string]:number\n}\nlet inst1: IndexType {\n  a: &#39;1&#39;,     //error\n}\n\n//type\ntype aType = IndexType;\n//比如说是let啊，就是类型声明对吧 type 就类似\n\ntype aaaaa = string;\nlet ssss: aaaaa = &#39;1&#39;\n\ninterface IPeople {\n  eyes: number;\n}\nenum LapTopEnum {\n  haiwei,\n  lenovo,\n  apple,\n  IBM,\n}\ninterface ImonkeyProgramer extends IPeople {\n  laptop: LapTopEnum\n}\nlet tangkalun: ImonkeyProgramer = {\n  laptop: LapTopEnum.apple,\n  eyes: 2,\n}\n</code></pre><blockquote>\n<p>In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</p>\n</blockquote>\n<h2 id=\"Classes（类）\"><a href=\"#Classes（类）\" class=\"headerlink\" title=\"Classes（类）\"></a>Classes（类）</h2><pre><code>class A {\n    a:string\n    constructor() {\n        this.a = &#39;1&#39;\n    }\n    hello(): string {\n        return &#39;1&#39;;\n    }\n}\nlet instA = new A();\ninstA.a\n//转换成 JS\nvar A = (function () {\n    function A() {\n        this.a = &#39;1&#39;;\n    }\n    A.prototype.hello = function () {\n        return &#39;1&#39;;\n    };\n    return A;\n}());\nvar instA = new A();\ninstA.a;\n//注意 private public protect\n\n//Inheritance\nclass People {\n    name: string\n    constructor(name: string) {\n        this.name = name;\n    }\n}\nclass A extends People {\n    a: string;\n    constructor() {\n        super(&#39;tangkalun&#39;);\n        this.a = &#39;1&#39;;\n    }\n    hello(): string {\n        return this.a;\n    }\n}\n// class 不仅可以描述数据结构,同时他还有方法、属性等等的封装\nlet instA = new A();\ninstA.a;\ninstA.name;\n//关于super()这个问题，是调用父类的构造函数\n</code></pre><h2 id=\"Generics（泛型）\"><a href=\"#Generics（泛型）\" class=\"headerlink\" title=\"Generics（泛型）\"></a>Generics（泛型）</h2><pre><code>interface SillyBoy&lt;T&gt; {\n  skills: T\n}\nconst tangkalun: SillyBoy&lt;[&#39;string&#39;,&#39;string&#39;,&#39;string&#39;]&gt; = {\n  skills: [&#39;eat&#39;,&#39;fuck&#39;,&#39;sleep&#39;]\n}\nconst frankie: SillyBoy&lt;[string]&gt; = {\n  skills: [&#39;fuck&#39;],\n}\nconst tang: SillyBoy&lt;[undefined]&gt; = {\n  skills: undefined,\n}\nconst kalun: SillyBoy&lt;string&gt; = {\n    skills: &#39;sleep&#39;,\n}\n</code></pre><p>先到这里吧，我太菜了。</p>\n"},{"title":"摸到 Vue.js 的门把手","date":"2017-10-13T16:11:47.000Z","_content":"# 摸到 Vue.js 的门把手\n\n文档那么多中文多和谐啊是不是？[Vue.js](https://cn.vuejs.org/)\n\n## 起步\n\n先把 webpack 给配好。\n\n接下来我们输入 Vue.js 测试代码给我们的代码\n\n```\n//index.html\n      <div id=\"app\">\n          {{ message }}\n      </div> \n//index.js\nimport Vue from 'vue'\n\nvar app = new Vue({\n    el: '#app',\n    data: {\n      message: 'Hello Vue!'\n    }\n  })\n```\n\n真的是非常的和谐，很像 React \n\n![](http://upload-images.jianshu.io/upload_images/3191557-19472a5df4b492fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 双向绑定\n\n```\n//index.html\n<div class=\"newTask\">\n\t<input type=\"text\" v-model=\"newTodo\">\n</div>\n//index.js\nvar app = new Vue({\n    el: '#app',\n    data: {\n        newTodo: '',\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=>{\n            this.newTodo = i\n            i += 1\n        },1000)\n    }\n})\n```\n\n只要 data.newTodo 被 JS 改了，input.value 就会变成一样的值。\n\n```\n//index.html\n<div class=\"newTask\">\n\t<input type=\"text\" v-model=\"newTodo\">\n</div>\n//index.js\nvar app = new Vue({\n    el: '#app',\n    data: {\n        newTodo: '',\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=>{\n            console.log(this.newTodo)\n            i += 1\n        },1000)\n    }\n})\n```\n\n只要 input.value 被用户改了，data.newTodo 就会变成一样的值；\n\n## 绑定事件\n\n```\n//index.html\n<input type=\"text\" v-model=\"newTodo\" @keypress.enter=\"addTodo\">\n//index.js\nmethods: {\n    addTodo: function(){\n        this.todoList.push({\n            title: this.newTodo,\n            createdAt: new Date()\n        })\n        console.log(this.todoList)\n    }\n}\n```\n\n## 输入东西在页面展示\n\n```\n<li v-for=\"todo in todoList\">\n  {{ todo.title }}\n</li>\n```\n\n## 复选框\n\n```\n//index.html\n<input type=\"checkbox\" v-model=\"todo.done\">{{ todo.title }}\n<span v-if=\"todo.done\">已完成</span>\n<span v-else>未完成</span>\n//index.js\naddTodo: function(){\n    this.todoList.push({\n        title: this.newTodo,\n        createdAt: new Date(),\n        done: false\n    })\n    this.newTodo = \"\" //input 框变成空的\n}\n```\n\n## localStorage 保存数据\n\n```\ncreated: function() {\n  window.onbeforeunload = () =>{\n    let dataString = JSON.stringify(this.todoList)\n    window.localStorage.setItem('myTodos', dataString)\n  }\n  let oldDataString = window.localStorage.getItem('myTodos')\n  let oldData = JSON.parse(oldDataString)\n  this.todoList = oldData || []\n},\n```\n\n[onbeforeunload - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload) 当窗口即将被[`卸载`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload)时,会触发该事件.此时页面文档依然可见,且该事件的默认动作可以被[`取消`](https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault).\n\n[JSON - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON) 简单深拷贝\n\n[localStorage - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage) `localStorage` 属性允许你访问一个 local [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象。存储在 localStorage 里面的数据没有过期时间（expiration time）。\n\n## 数据存储选 leancloud\n\n[JavaScript SDK 安装指南](https://leancloud.cn/docs/start.html)\n\n[数据存储开发指南 · JavaScript](https://leancloud.cn/docs/leanstorage_guide-js.html#数据存储开发指南___JavaScript)\n\n之前有一个没有注意到的东西，就是利用这一段代码的时候打印出来的东西\n\n```\n    signUp: function () {\n      let user = new AV.User();\n      user.setUsername(this.formData.username);\n      user.setPassword(this.formData.password);\n      user.signUp().then(function (loginedUser) {\n        console.log(loginedUser);\n      }, function (error) {\n      });\n    }\n```\n\n> 注意打印出来的三个属性：attributes, createdAt, id。\n>\n> 其中 attributes 就是我们传给数据库的 username（我们不是还传了一个 password 吗？服务器是不会把 password 传给前端的）\n>\n> createdAt 是这个数据创建的时间，id 是用户的 id，也是我们区别用户的唯一凭据。\n\n## Vue 的切换 Tab\n\n在 React 中是这样切换的\n\n```\n{ this.state.selectedTab === 'signInOrSignUp' ? <SignIn />  : <SignUp /> }\n```\n\n而 Vue 是这样\n\n```\n<div class=\"signUp\" v-if=\"actionType === 'signUp'\">\n<div class=\"logIn\" v-if=\"actionType === 'logIn'\">\n```\n\n## 可注册 / 可登入 / 可登出 功能\n\n这个和我之前 React 没什么区别了\n\n就是看 leancloud 的文档抄抄\n\n注意 `v-if` 的使用技巧\n\n## 保存数据功能\n\n[保存数据](https://leancloud.cn/docs/leanstorage_guide-js.html#保存对象)\n\n```\n  // 声明类型\n  var TodoFolder = AV.Object.extend('TodoFolder');\n  // 新建对象\n  var todoFolder = new TodoFolder();\n  // 设置名称\n  todoFolder.set('name','工作');\n  // 设置优先级\n  todoFolder.set('priority',1);\n  todoFolder.save().then(function (todo) {\n    console.log('objectId is ' + todo.id);\n  }, function (error) {\n    console.error(error);\n  });\n```\n\n照着抄\n\n注意不可以把代码放在 `window.onbeforeunload` 里，请求发出页面就刷新了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-509e312e01c9434c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>从结果可以看到，AllTodos 保存请求失败了，被 `canceled` 了。\n>\n>如果一个页面就要死了（刷新就表示不要当前页面了，当前页面可以死了），那么这个页面发出的请求其实就没有任何意义了。既然没有意义，浏览器为什么浪费时间去发这个页面里的请求呢？所以浏览器直接取消了这个请求。\n>\n>简单来说，那就是：beforeunload 事件里面的所有请求都发不出去，会被取消！\n>我还从来没有在哪一本书里看到过这个知识点。所以说「实践」是非常重要的。\n\n这样就应该把上面那一段代码封装成一个函数调用。\n\n## 角色权限管理\n\n[角色的创建](https://leancloud.cn/docs/acl-guide.html#角色的创建)\n\n```\n  // 创建一个针对 User 的查询\n  var query = new AV.Query(AV.User);\n  query.get('55f1572460b2ce30e8b7afde').then(function(otherUser) {\n    var post = new AV.Object('Post');\n    post.set('title', '这是我的第二条发言，谢谢大家！');\n    post.set('content','我最近喜欢看足球和篮球了。');\n\n    // 新建一个 ACL 实例\n    var acl = new AV.ACL();\n    acl.setPublicReadAccess(true);\n    acl.setWriteAccess(AV.User.current(), true);\n    acl.setWriteAccess(otherUser, true);\n\n    // 将 ACL 实例赋予 Post 对象\n    post.setACL(acl);\n\n    // 保存到云端\n    return post.save();\n  }).then(function() {\n    // 保存成功\n  }).catch(function(error) {\n    // 错误信息\n    console.log(error);\n  });\n```\n\n## 居然有 React 一样的 BUG\n\n就是 logout 之后 再 login 别的账号会没有数据\n\n和 React 的解决方法一样封装成一个函数放在 `methods` 里。\n\n## 遇到奇怪的 BUG\n\n```\nrm -rf node_modules/\nnpm install\n```","source":"_posts/摸到 Vue.js 的门把手.md","raw":"---\ntitle: 摸到 Vue.js 的门把手\ndate: 2017-10-14 00:11:47\ntags: [Vue,Black History]\n---\n# 摸到 Vue.js 的门把手\n\n文档那么多中文多和谐啊是不是？[Vue.js](https://cn.vuejs.org/)\n\n## 起步\n\n先把 webpack 给配好。\n\n接下来我们输入 Vue.js 测试代码给我们的代码\n\n```\n//index.html\n      <div id=\"app\">\n          {{ message }}\n      </div> \n//index.js\nimport Vue from 'vue'\n\nvar app = new Vue({\n    el: '#app',\n    data: {\n      message: 'Hello Vue!'\n    }\n  })\n```\n\n真的是非常的和谐，很像 React \n\n![](http://upload-images.jianshu.io/upload_images/3191557-19472a5df4b492fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 双向绑定\n\n```\n//index.html\n<div class=\"newTask\">\n\t<input type=\"text\" v-model=\"newTodo\">\n</div>\n//index.js\nvar app = new Vue({\n    el: '#app',\n    data: {\n        newTodo: '',\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=>{\n            this.newTodo = i\n            i += 1\n        },1000)\n    }\n})\n```\n\n只要 data.newTodo 被 JS 改了，input.value 就会变成一样的值。\n\n```\n//index.html\n<div class=\"newTask\">\n\t<input type=\"text\" v-model=\"newTodo\">\n</div>\n//index.js\nvar app = new Vue({\n    el: '#app',\n    data: {\n        newTodo: '',\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=>{\n            console.log(this.newTodo)\n            i += 1\n        },1000)\n    }\n})\n```\n\n只要 input.value 被用户改了，data.newTodo 就会变成一样的值；\n\n## 绑定事件\n\n```\n//index.html\n<input type=\"text\" v-model=\"newTodo\" @keypress.enter=\"addTodo\">\n//index.js\nmethods: {\n    addTodo: function(){\n        this.todoList.push({\n            title: this.newTodo,\n            createdAt: new Date()\n        })\n        console.log(this.todoList)\n    }\n}\n```\n\n## 输入东西在页面展示\n\n```\n<li v-for=\"todo in todoList\">\n  {{ todo.title }}\n</li>\n```\n\n## 复选框\n\n```\n//index.html\n<input type=\"checkbox\" v-model=\"todo.done\">{{ todo.title }}\n<span v-if=\"todo.done\">已完成</span>\n<span v-else>未完成</span>\n//index.js\naddTodo: function(){\n    this.todoList.push({\n        title: this.newTodo,\n        createdAt: new Date(),\n        done: false\n    })\n    this.newTodo = \"\" //input 框变成空的\n}\n```\n\n## localStorage 保存数据\n\n```\ncreated: function() {\n  window.onbeforeunload = () =>{\n    let dataString = JSON.stringify(this.todoList)\n    window.localStorage.setItem('myTodos', dataString)\n  }\n  let oldDataString = window.localStorage.getItem('myTodos')\n  let oldData = JSON.parse(oldDataString)\n  this.todoList = oldData || []\n},\n```\n\n[onbeforeunload - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload) 当窗口即将被[`卸载`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload)时,会触发该事件.此时页面文档依然可见,且该事件的默认动作可以被[`取消`](https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault).\n\n[JSON - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON) 简单深拷贝\n\n[localStorage - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage) `localStorage` 属性允许你访问一个 local [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象。存储在 localStorage 里面的数据没有过期时间（expiration time）。\n\n## 数据存储选 leancloud\n\n[JavaScript SDK 安装指南](https://leancloud.cn/docs/start.html)\n\n[数据存储开发指南 · JavaScript](https://leancloud.cn/docs/leanstorage_guide-js.html#数据存储开发指南___JavaScript)\n\n之前有一个没有注意到的东西，就是利用这一段代码的时候打印出来的东西\n\n```\n    signUp: function () {\n      let user = new AV.User();\n      user.setUsername(this.formData.username);\n      user.setPassword(this.formData.password);\n      user.signUp().then(function (loginedUser) {\n        console.log(loginedUser);\n      }, function (error) {\n      });\n    }\n```\n\n> 注意打印出来的三个属性：attributes, createdAt, id。\n>\n> 其中 attributes 就是我们传给数据库的 username（我们不是还传了一个 password 吗？服务器是不会把 password 传给前端的）\n>\n> createdAt 是这个数据创建的时间，id 是用户的 id，也是我们区别用户的唯一凭据。\n\n## Vue 的切换 Tab\n\n在 React 中是这样切换的\n\n```\n{ this.state.selectedTab === 'signInOrSignUp' ? <SignIn />  : <SignUp /> }\n```\n\n而 Vue 是这样\n\n```\n<div class=\"signUp\" v-if=\"actionType === 'signUp'\">\n<div class=\"logIn\" v-if=\"actionType === 'logIn'\">\n```\n\n## 可注册 / 可登入 / 可登出 功能\n\n这个和我之前 React 没什么区别了\n\n就是看 leancloud 的文档抄抄\n\n注意 `v-if` 的使用技巧\n\n## 保存数据功能\n\n[保存数据](https://leancloud.cn/docs/leanstorage_guide-js.html#保存对象)\n\n```\n  // 声明类型\n  var TodoFolder = AV.Object.extend('TodoFolder');\n  // 新建对象\n  var todoFolder = new TodoFolder();\n  // 设置名称\n  todoFolder.set('name','工作');\n  // 设置优先级\n  todoFolder.set('priority',1);\n  todoFolder.save().then(function (todo) {\n    console.log('objectId is ' + todo.id);\n  }, function (error) {\n    console.error(error);\n  });\n```\n\n照着抄\n\n注意不可以把代码放在 `window.onbeforeunload` 里，请求发出页面就刷新了\n\n![](http://upload-images.jianshu.io/upload_images/3191557-509e312e01c9434c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>从结果可以看到，AllTodos 保存请求失败了，被 `canceled` 了。\n>\n>如果一个页面就要死了（刷新就表示不要当前页面了，当前页面可以死了），那么这个页面发出的请求其实就没有任何意义了。既然没有意义，浏览器为什么浪费时间去发这个页面里的请求呢？所以浏览器直接取消了这个请求。\n>\n>简单来说，那就是：beforeunload 事件里面的所有请求都发不出去，会被取消！\n>我还从来没有在哪一本书里看到过这个知识点。所以说「实践」是非常重要的。\n\n这样就应该把上面那一段代码封装成一个函数调用。\n\n## 角色权限管理\n\n[角色的创建](https://leancloud.cn/docs/acl-guide.html#角色的创建)\n\n```\n  // 创建一个针对 User 的查询\n  var query = new AV.Query(AV.User);\n  query.get('55f1572460b2ce30e8b7afde').then(function(otherUser) {\n    var post = new AV.Object('Post');\n    post.set('title', '这是我的第二条发言，谢谢大家！');\n    post.set('content','我最近喜欢看足球和篮球了。');\n\n    // 新建一个 ACL 实例\n    var acl = new AV.ACL();\n    acl.setPublicReadAccess(true);\n    acl.setWriteAccess(AV.User.current(), true);\n    acl.setWriteAccess(otherUser, true);\n\n    // 将 ACL 实例赋予 Post 对象\n    post.setACL(acl);\n\n    // 保存到云端\n    return post.save();\n  }).then(function() {\n    // 保存成功\n  }).catch(function(error) {\n    // 错误信息\n    console.log(error);\n  });\n```\n\n## 居然有 React 一样的 BUG\n\n就是 logout 之后 再 login 别的账号会没有数据\n\n和 React 的解决方法一样封装成一个函数放在 `methods` 里。\n\n## 遇到奇怪的 BUG\n\n```\nrm -rf node_modules/\nnpm install\n```","slug":"摸到 Vue.js 的门把手","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8s000tf1xh8tfrp4e9","content":"<h1 id=\"摸到-Vue-js-的门把手\"><a href=\"#摸到-Vue-js-的门把手\" class=\"headerlink\" title=\"摸到 Vue.js 的门把手\"></a>摸到 Vue.js 的门把手</h1><p>文档那么多中文多和谐啊是不是？<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue.js</a></p>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><p>先把 webpack 给配好。</p>\n<p>接下来我们输入 Vue.js 测试代码给我们的代码</p>\n<pre><code>//index.html\n      &lt;div id=&quot;app&quot;&gt;\n          {{ message }}\n      &lt;/div&gt; \n//index.js\nimport Vue from &#39;vue&#39;\n\nvar app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n      message: &#39;Hello Vue!&#39;\n    }\n  })\n</code></pre><p>真的是非常的和谐，很像 React </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-19472a5df4b492fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h2><pre><code>//index.html\n&lt;div class=&quot;newTask&quot;&gt;\n    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;\n&lt;/div&gt;\n//index.js\nvar app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        newTodo: &#39;&#39;,\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=&gt;{\n            this.newTodo = i\n            i += 1\n        },1000)\n    }\n})\n</code></pre><p>只要 data.newTodo 被 JS 改了，input.value 就会变成一样的值。</p>\n<pre><code>//index.html\n&lt;div class=&quot;newTask&quot;&gt;\n    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;\n&lt;/div&gt;\n//index.js\nvar app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        newTodo: &#39;&#39;,\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=&gt;{\n            console.log(this.newTodo)\n            i += 1\n        },1000)\n    }\n})\n</code></pre><p>只要 input.value 被用户改了，data.newTodo 就会变成一样的值；</p>\n<h2 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h2><pre><code>//index.html\n&lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot; @keypress.enter=&quot;addTodo&quot;&gt;\n//index.js\nmethods: {\n    addTodo: function(){\n        this.todoList.push({\n            title: this.newTodo,\n            createdAt: new Date()\n        })\n        console.log(this.todoList)\n    }\n}\n</code></pre><h2 id=\"输入东西在页面展示\"><a href=\"#输入东西在页面展示\" class=\"headerlink\" title=\"输入东西在页面展示\"></a>输入东西在页面展示</h2><pre><code>&lt;li v-for=&quot;todo in todoList&quot;&gt;\n  {{ todo.title }}\n&lt;/li&gt;\n</code></pre><h2 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h2><pre><code>//index.html\n&lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;{{ todo.title }}\n&lt;span v-if=&quot;todo.done&quot;&gt;已完成&lt;/span&gt;\n&lt;span v-else&gt;未完成&lt;/span&gt;\n//index.js\naddTodo: function(){\n    this.todoList.push({\n        title: this.newTodo,\n        createdAt: new Date(),\n        done: false\n    })\n    this.newTodo = &quot;&quot; //input 框变成空的\n}\n</code></pre><h2 id=\"localStorage-保存数据\"><a href=\"#localStorage-保存数据\" class=\"headerlink\" title=\"localStorage 保存数据\"></a>localStorage 保存数据</h2><pre><code>created: function() {\n  window.onbeforeunload = () =&gt;{\n    let dataString = JSON.stringify(this.todoList)\n    window.localStorage.setItem(&#39;myTodos&#39;, dataString)\n  }\n  let oldDataString = window.localStorage.getItem(&#39;myTodos&#39;)\n  let oldData = JSON.parse(oldDataString)\n  this.todoList = oldData || []\n},\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload\" target=\"_blank\" rel=\"noopener\">onbeforeunload - MDN</a> 当窗口即将被<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload\" target=\"_blank\" rel=\"noopener\"><code>卸载</code></a>时,会触发该事件.此时页面文档依然可见,且该事件的默认动作可以被<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault\" target=\"_blank\" rel=\"noopener\"><code>取消</code></a>.</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON\" target=\"_blank\" rel=\"noopener\">JSON - MDN</a> 简单深拷贝</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage\" target=\"_blank\" rel=\"noopener\">localStorage - MDN</a> <code>localStorage</code> 属性允许你访问一个 local <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Storage\" target=\"_blank\" rel=\"noopener\"><code>Storage</code></a> 对象。存储在 localStorage 里面的数据没有过期时间（expiration time）。</p>\n<h2 id=\"数据存储选-leancloud\"><a href=\"#数据存储选-leancloud\" class=\"headerlink\" title=\"数据存储选 leancloud\"></a>数据存储选 leancloud</h2><p><a href=\"https://leancloud.cn/docs/start.html\" target=\"_blank\" rel=\"noopener\">JavaScript SDK 安装指南</a></p>\n<p><a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#数据存储开发指南___JavaScript\" target=\"_blank\" rel=\"noopener\">数据存储开发指南 · JavaScript</a></p>\n<p>之前有一个没有注意到的东西，就是利用这一段代码的时候打印出来的东西</p>\n<pre><code>    signUp: function () {\n      let user = new AV.User();\n      user.setUsername(this.formData.username);\n      user.setPassword(this.formData.password);\n      user.signUp().then(function (loginedUser) {\n        console.log(loginedUser);\n      }, function (error) {\n      });\n    }\n</code></pre><blockquote>\n<p>注意打印出来的三个属性：attributes, createdAt, id。</p>\n<p>其中 attributes 就是我们传给数据库的 username（我们不是还传了一个 password 吗？服务器是不会把 password 传给前端的）</p>\n<p>createdAt 是这个数据创建的时间，id 是用户的 id，也是我们区别用户的唯一凭据。</p>\n</blockquote>\n<h2 id=\"Vue-的切换-Tab\"><a href=\"#Vue-的切换-Tab\" class=\"headerlink\" title=\"Vue 的切换 Tab\"></a>Vue 的切换 Tab</h2><p>在 React 中是这样切换的</p>\n<pre><code>{ this.state.selectedTab === &#39;signInOrSignUp&#39; ? &lt;SignIn /&gt;  : &lt;SignUp /&gt; }\n</code></pre><p>而 Vue 是这样</p>\n<pre><code>&lt;div class=&quot;signUp&quot; v-if=&quot;actionType === &#39;signUp&#39;&quot;&gt;\n&lt;div class=&quot;logIn&quot; v-if=&quot;actionType === &#39;logIn&#39;&quot;&gt;\n</code></pre><h2 id=\"可注册-可登入-可登出-功能\"><a href=\"#可注册-可登入-可登出-功能\" class=\"headerlink\" title=\"可注册 / 可登入 / 可登出 功能\"></a>可注册 / 可登入 / 可登出 功能</h2><p>这个和我之前 React 没什么区别了</p>\n<p>就是看 leancloud 的文档抄抄</p>\n<p>注意 <code>v-if</code> 的使用技巧</p>\n<h2 id=\"保存数据功能\"><a href=\"#保存数据功能\" class=\"headerlink\" title=\"保存数据功能\"></a>保存数据功能</h2><p><a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#保存对象\" target=\"_blank\" rel=\"noopener\">保存数据</a></p>\n<pre><code>  // 声明类型\n  var TodoFolder = AV.Object.extend(&#39;TodoFolder&#39;);\n  // 新建对象\n  var todoFolder = new TodoFolder();\n  // 设置名称\n  todoFolder.set(&#39;name&#39;,&#39;工作&#39;);\n  // 设置优先级\n  todoFolder.set(&#39;priority&#39;,1);\n  todoFolder.save().then(function (todo) {\n    console.log(&#39;objectId is &#39; + todo.id);\n  }, function (error) {\n    console.error(error);\n  });\n</code></pre><p>照着抄</p>\n<p>注意不可以把代码放在 <code>window.onbeforeunload</code> 里，请求发出页面就刷新了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-509e312e01c9434c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>从结果可以看到，AllTodos 保存请求失败了，被 <code>canceled</code> 了。</p>\n<p>如果一个页面就要死了（刷新就表示不要当前页面了，当前页面可以死了），那么这个页面发出的请求其实就没有任何意义了。既然没有意义，浏览器为什么浪费时间去发这个页面里的请求呢？所以浏览器直接取消了这个请求。</p>\n<p>简单来说，那就是：beforeunload 事件里面的所有请求都发不出去，会被取消！<br>我还从来没有在哪一本书里看到过这个知识点。所以说「实践」是非常重要的。</p>\n</blockquote>\n<p>这样就应该把上面那一段代码封装成一个函数调用。</p>\n<h2 id=\"角色权限管理\"><a href=\"#角色权限管理\" class=\"headerlink\" title=\"角色权限管理\"></a>角色权限管理</h2><p><a href=\"https://leancloud.cn/docs/acl-guide.html#角色的创建\" target=\"_blank\" rel=\"noopener\">角色的创建</a></p>\n<pre><code>  // 创建一个针对 User 的查询\n  var query = new AV.Query(AV.User);\n  query.get(&#39;55f1572460b2ce30e8b7afde&#39;).then(function(otherUser) {\n    var post = new AV.Object(&#39;Post&#39;);\n    post.set(&#39;title&#39;, &#39;这是我的第二条发言，谢谢大家！&#39;);\n    post.set(&#39;content&#39;,&#39;我最近喜欢看足球和篮球了。&#39;);\n\n    // 新建一个 ACL 实例\n    var acl = new AV.ACL();\n    acl.setPublicReadAccess(true);\n    acl.setWriteAccess(AV.User.current(), true);\n    acl.setWriteAccess(otherUser, true);\n\n    // 将 ACL 实例赋予 Post 对象\n    post.setACL(acl);\n\n    // 保存到云端\n    return post.save();\n  }).then(function() {\n    // 保存成功\n  }).catch(function(error) {\n    // 错误信息\n    console.log(error);\n  });\n</code></pre><h2 id=\"居然有-React-一样的-BUG\"><a href=\"#居然有-React-一样的-BUG\" class=\"headerlink\" title=\"居然有 React 一样的 BUG\"></a>居然有 React 一样的 BUG</h2><p>就是 logout 之后 再 login 别的账号会没有数据</p>\n<p>和 React 的解决方法一样封装成一个函数放在 <code>methods</code> 里。</p>\n<h2 id=\"遇到奇怪的-BUG\"><a href=\"#遇到奇怪的-BUG\" class=\"headerlink\" title=\"遇到奇怪的 BUG\"></a>遇到奇怪的 BUG</h2><pre><code>rm -rf node_modules/\nnpm install\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-Vue-js-的门把手\"><a href=\"#摸到-Vue-js-的门把手\" class=\"headerlink\" title=\"摸到 Vue.js 的门把手\"></a>摸到 Vue.js 的门把手</h1><p>文档那么多中文多和谐啊是不是？<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue.js</a></p>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><p>先把 webpack 给配好。</p>\n<p>接下来我们输入 Vue.js 测试代码给我们的代码</p>\n<pre><code>//index.html\n      &lt;div id=&quot;app&quot;&gt;\n          {{ message }}\n      &lt;/div&gt; \n//index.js\nimport Vue from &#39;vue&#39;\n\nvar app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n      message: &#39;Hello Vue!&#39;\n    }\n  })\n</code></pre><p>真的是非常的和谐，很像 React </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-19472a5df4b492fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h2><pre><code>//index.html\n&lt;div class=&quot;newTask&quot;&gt;\n    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;\n&lt;/div&gt;\n//index.js\nvar app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        newTodo: &#39;&#39;,\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=&gt;{\n            this.newTodo = i\n            i += 1\n        },1000)\n    }\n})\n</code></pre><p>只要 data.newTodo 被 JS 改了，input.value 就会变成一样的值。</p>\n<pre><code>//index.html\n&lt;div class=&quot;newTask&quot;&gt;\n    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;\n&lt;/div&gt;\n//index.js\nvar app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        newTodo: &#39;&#39;,\n        todoList: []\n    },\n    created: function(){\n        let i = 0\n        setInterval(()=&gt;{\n            console.log(this.newTodo)\n            i += 1\n        },1000)\n    }\n})\n</code></pre><p>只要 input.value 被用户改了，data.newTodo 就会变成一样的值；</p>\n<h2 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h2><pre><code>//index.html\n&lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot; @keypress.enter=&quot;addTodo&quot;&gt;\n//index.js\nmethods: {\n    addTodo: function(){\n        this.todoList.push({\n            title: this.newTodo,\n            createdAt: new Date()\n        })\n        console.log(this.todoList)\n    }\n}\n</code></pre><h2 id=\"输入东西在页面展示\"><a href=\"#输入东西在页面展示\" class=\"headerlink\" title=\"输入东西在页面展示\"></a>输入东西在页面展示</h2><pre><code>&lt;li v-for=&quot;todo in todoList&quot;&gt;\n  {{ todo.title }}\n&lt;/li&gt;\n</code></pre><h2 id=\"复选框\"><a href=\"#复选框\" class=\"headerlink\" title=\"复选框\"></a>复选框</h2><pre><code>//index.html\n&lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;{{ todo.title }}\n&lt;span v-if=&quot;todo.done&quot;&gt;已完成&lt;/span&gt;\n&lt;span v-else&gt;未完成&lt;/span&gt;\n//index.js\naddTodo: function(){\n    this.todoList.push({\n        title: this.newTodo,\n        createdAt: new Date(),\n        done: false\n    })\n    this.newTodo = &quot;&quot; //input 框变成空的\n}\n</code></pre><h2 id=\"localStorage-保存数据\"><a href=\"#localStorage-保存数据\" class=\"headerlink\" title=\"localStorage 保存数据\"></a>localStorage 保存数据</h2><pre><code>created: function() {\n  window.onbeforeunload = () =&gt;{\n    let dataString = JSON.stringify(this.todoList)\n    window.localStorage.setItem(&#39;myTodos&#39;, dataString)\n  }\n  let oldDataString = window.localStorage.getItem(&#39;myTodos&#39;)\n  let oldData = JSON.parse(oldDataString)\n  this.todoList = oldData || []\n},\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload\" target=\"_blank\" rel=\"noopener\">onbeforeunload - MDN</a> 当窗口即将被<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload\" target=\"_blank\" rel=\"noopener\"><code>卸载</code></a>时,会触发该事件.此时页面文档依然可见,且该事件的默认动作可以被<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault\" target=\"_blank\" rel=\"noopener\"><code>取消</code></a>.</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON\" target=\"_blank\" rel=\"noopener\">JSON - MDN</a> 简单深拷贝</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage\" target=\"_blank\" rel=\"noopener\">localStorage - MDN</a> <code>localStorage</code> 属性允许你访问一个 local <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Storage\" target=\"_blank\" rel=\"noopener\"><code>Storage</code></a> 对象。存储在 localStorage 里面的数据没有过期时间（expiration time）。</p>\n<h2 id=\"数据存储选-leancloud\"><a href=\"#数据存储选-leancloud\" class=\"headerlink\" title=\"数据存储选 leancloud\"></a>数据存储选 leancloud</h2><p><a href=\"https://leancloud.cn/docs/start.html\" target=\"_blank\" rel=\"noopener\">JavaScript SDK 安装指南</a></p>\n<p><a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#数据存储开发指南___JavaScript\" target=\"_blank\" rel=\"noopener\">数据存储开发指南 · JavaScript</a></p>\n<p>之前有一个没有注意到的东西，就是利用这一段代码的时候打印出来的东西</p>\n<pre><code>    signUp: function () {\n      let user = new AV.User();\n      user.setUsername(this.formData.username);\n      user.setPassword(this.formData.password);\n      user.signUp().then(function (loginedUser) {\n        console.log(loginedUser);\n      }, function (error) {\n      });\n    }\n</code></pre><blockquote>\n<p>注意打印出来的三个属性：attributes, createdAt, id。</p>\n<p>其中 attributes 就是我们传给数据库的 username（我们不是还传了一个 password 吗？服务器是不会把 password 传给前端的）</p>\n<p>createdAt 是这个数据创建的时间，id 是用户的 id，也是我们区别用户的唯一凭据。</p>\n</blockquote>\n<h2 id=\"Vue-的切换-Tab\"><a href=\"#Vue-的切换-Tab\" class=\"headerlink\" title=\"Vue 的切换 Tab\"></a>Vue 的切换 Tab</h2><p>在 React 中是这样切换的</p>\n<pre><code>{ this.state.selectedTab === &#39;signInOrSignUp&#39; ? &lt;SignIn /&gt;  : &lt;SignUp /&gt; }\n</code></pre><p>而 Vue 是这样</p>\n<pre><code>&lt;div class=&quot;signUp&quot; v-if=&quot;actionType === &#39;signUp&#39;&quot;&gt;\n&lt;div class=&quot;logIn&quot; v-if=&quot;actionType === &#39;logIn&#39;&quot;&gt;\n</code></pre><h2 id=\"可注册-可登入-可登出-功能\"><a href=\"#可注册-可登入-可登出-功能\" class=\"headerlink\" title=\"可注册 / 可登入 / 可登出 功能\"></a>可注册 / 可登入 / 可登出 功能</h2><p>这个和我之前 React 没什么区别了</p>\n<p>就是看 leancloud 的文档抄抄</p>\n<p>注意 <code>v-if</code> 的使用技巧</p>\n<h2 id=\"保存数据功能\"><a href=\"#保存数据功能\" class=\"headerlink\" title=\"保存数据功能\"></a>保存数据功能</h2><p><a href=\"https://leancloud.cn/docs/leanstorage_guide-js.html#保存对象\" target=\"_blank\" rel=\"noopener\">保存数据</a></p>\n<pre><code>  // 声明类型\n  var TodoFolder = AV.Object.extend(&#39;TodoFolder&#39;);\n  // 新建对象\n  var todoFolder = new TodoFolder();\n  // 设置名称\n  todoFolder.set(&#39;name&#39;,&#39;工作&#39;);\n  // 设置优先级\n  todoFolder.set(&#39;priority&#39;,1);\n  todoFolder.save().then(function (todo) {\n    console.log(&#39;objectId is &#39; + todo.id);\n  }, function (error) {\n    console.error(error);\n  });\n</code></pre><p>照着抄</p>\n<p>注意不可以把代码放在 <code>window.onbeforeunload</code> 里，请求发出页面就刷新了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-509e312e01c9434c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>从结果可以看到，AllTodos 保存请求失败了，被 <code>canceled</code> 了。</p>\n<p>如果一个页面就要死了（刷新就表示不要当前页面了，当前页面可以死了），那么这个页面发出的请求其实就没有任何意义了。既然没有意义，浏览器为什么浪费时间去发这个页面里的请求呢？所以浏览器直接取消了这个请求。</p>\n<p>简单来说，那就是：beforeunload 事件里面的所有请求都发不出去，会被取消！<br>我还从来没有在哪一本书里看到过这个知识点。所以说「实践」是非常重要的。</p>\n</blockquote>\n<p>这样就应该把上面那一段代码封装成一个函数调用。</p>\n<h2 id=\"角色权限管理\"><a href=\"#角色权限管理\" class=\"headerlink\" title=\"角色权限管理\"></a>角色权限管理</h2><p><a href=\"https://leancloud.cn/docs/acl-guide.html#角色的创建\" target=\"_blank\" rel=\"noopener\">角色的创建</a></p>\n<pre><code>  // 创建一个针对 User 的查询\n  var query = new AV.Query(AV.User);\n  query.get(&#39;55f1572460b2ce30e8b7afde&#39;).then(function(otherUser) {\n    var post = new AV.Object(&#39;Post&#39;);\n    post.set(&#39;title&#39;, &#39;这是我的第二条发言，谢谢大家！&#39;);\n    post.set(&#39;content&#39;,&#39;我最近喜欢看足球和篮球了。&#39;);\n\n    // 新建一个 ACL 实例\n    var acl = new AV.ACL();\n    acl.setPublicReadAccess(true);\n    acl.setWriteAccess(AV.User.current(), true);\n    acl.setWriteAccess(otherUser, true);\n\n    // 将 ACL 实例赋予 Post 对象\n    post.setACL(acl);\n\n    // 保存到云端\n    return post.save();\n  }).then(function() {\n    // 保存成功\n  }).catch(function(error) {\n    // 错误信息\n    console.log(error);\n  });\n</code></pre><h2 id=\"居然有-React-一样的-BUG\"><a href=\"#居然有-React-一样的-BUG\" class=\"headerlink\" title=\"居然有 React 一样的 BUG\"></a>居然有 React 一样的 BUG</h2><p>就是 logout 之后 再 login 别的账号会没有数据</p>\n<p>和 React 的解决方法一样封装成一个函数放在 <code>methods</code> 里。</p>\n<h2 id=\"遇到奇怪的-BUG\"><a href=\"#遇到奇怪的-BUG\" class=\"headerlink\" title=\"遇到奇怪的 BUG\"></a>遇到奇怪的 BUG</h2><pre><code>rm -rf node_modules/\nnpm install\n</code></pre>"},{"title":"摸到 Vue.js 的门把手（2）","date":"2017-10-13T16:12:40.000Z","_content":"# 摸到 Vue.js 的门把手（2）\n\n用 vue-cli 快速搭建\n\n```\nnpm init -y\nnpm install -g vue-cli\nvue init webpack .\n//全部回车\nnpm i\nnpm run dev\n```\n\n## 项目分三组件\n\n`<Topbar/>` / `<ResumeEditor/>` / `<ResumePreview/>`\n\n## 禁用 ESLint \n\n```\n//build/webpack.base.conf.js\n  module: {\n    rules: [\n      //{\n        //test: /\\.(js|vue)$/,\n        //loader: 'eslint-loader',\n        //enforce: \"pre\",\n        //include: [resolve('src'), resolve('test')],\n        //options: {\n          //formatter: eslintFriendlyFormatter\n        //}\n      //},\n```\n\n## GitHub 预览\n\n```\n//config/index.js\nassetsPublicPath: '/vue-resume/dist',\n```\n\n`npm run build`\n\n`https://frankietang.github.io/vue-resume/dist/#/`\n\n## 使用 SCSS\n\n`npm install --save  sass-loader node-sass`\n\n## SVG 合并和使用方法\n\n- [使用脚本将所有 svg 拼成一个 svg，原来的多个 svg 变成了多个 symbol](https://github.com/FRANKIETANG/vue-resume/commit/a112088f1c0bc772813f855139fcdd4cdeeea380)\n- [运行 node build/svg-symbol.js](https://github.com/FRANKIETANG/vue-resume/commit/78556c0f7cb18d20e078f3abbbb85fd9b4c8ed43)\n- [将 SVG 插入 body 中](https://github.com/FRANKIETANG/vue-resume/commit/476cec015bbea1e7fc55bbfb33ba627c68353084)\n\n```\n//任意地方\n<svg>\n  <use xlink:href=\"#icon-xxx\"></use>\n</svg>\n```\n\n**值得注意的是，之前的 ResumeEditor 中的 data 是对象，对象是无序的，应该用数组让项目有一个完整的顺序**\n\n## 填写区核心代码\n\n```\n        <ol class=\"panels\">\n            <li v-for=\"item in resume.config\" \n            v-show=\"item.field === selected\">\n                <div v-if=\"resume[item.field] instanceof Array\">\n                    <div class=\"subitem\" v-for=\"subitem in resume[item.field]\">\n                        <div class=\"resumeField\" v-for=\"(value,key) in subitem\">\n                            <label>{{key}}</label>\n                            <input type=\"text\" :value=\"value\">                            \n                        </div>\n                        <hr>\n                    </div>\n                </div>\n                <div v-else class=\"resumeField\" \n                v-for=\"(value,key) in resume[item.field]\">\n                    <label>{{key}}</label>\n                    <input type=\"text\" \n                    v-model=\"resume[item.field][key]\">\n                </div>\n            </li>\n        </ol>\n```\n\n## 如何把填进去的数据放到预览页面呢？\n\n可以做一个公共数据储存区域\n\n填写区填进去的数据先放到公共数据再传到预览区\n\n## Vuex\n\n[最基本的 Vuex 记数应用](https://jsfiddle.net/n9jmu5v7/1269/)\n\n## getter 与 setter\n\n```\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n\n## 提交载荷（Payload）\n\n你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n\n```\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n\nstore.commit('increment', 10)\n```\n\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\n\n```\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n## $store\n\n这个 `$` 在 Vue 里是代表全局的意思\n\n## 多次 import 同一个文件\n\nNode对引入的模块都会进行缓存（缓存的是编译和执行后的对象），减少二次引入开销；\n在Node的加载机制中，缓存的优先级是最高的；\n这一点同时适用于不同的模块加载机制，无论ES2015的import还是CommonJS的require；\n\n## CSS white-space: pre-line\n\n去除一行文本中的空格，但是保留一行的换行符，作用是防止用户在输入框输入空格而产生对用户不友好显示效果\n\n## Object-Path\n\n[object-path](https://github.com/mariocasciaro/object-path)\n\n[Object-Path 源码解读](https://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/)\n\n## Object.assign()\n\n`Object.assign()` 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n\n[Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\n## ES6\n\n```\n//旧版本\ncomponents: {\n  'MyDialog': MyDialog\n}\n//ES6\ncomponents: {\n  MyDialog\n}\n```","source":"_posts/摸到 Vue.js 的门把手（2）.md","raw":"---\ntitle: 摸到 Vue.js 的门把手（2）\ndate: 2017-10-14 00:12:40\ntags: [Vue,Black History]\n---\n# 摸到 Vue.js 的门把手（2）\n\n用 vue-cli 快速搭建\n\n```\nnpm init -y\nnpm install -g vue-cli\nvue init webpack .\n//全部回车\nnpm i\nnpm run dev\n```\n\n## 项目分三组件\n\n`<Topbar/>` / `<ResumeEditor/>` / `<ResumePreview/>`\n\n## 禁用 ESLint \n\n```\n//build/webpack.base.conf.js\n  module: {\n    rules: [\n      //{\n        //test: /\\.(js|vue)$/,\n        //loader: 'eslint-loader',\n        //enforce: \"pre\",\n        //include: [resolve('src'), resolve('test')],\n        //options: {\n          //formatter: eslintFriendlyFormatter\n        //}\n      //},\n```\n\n## GitHub 预览\n\n```\n//config/index.js\nassetsPublicPath: '/vue-resume/dist',\n```\n\n`npm run build`\n\n`https://frankietang.github.io/vue-resume/dist/#/`\n\n## 使用 SCSS\n\n`npm install --save  sass-loader node-sass`\n\n## SVG 合并和使用方法\n\n- [使用脚本将所有 svg 拼成一个 svg，原来的多个 svg 变成了多个 symbol](https://github.com/FRANKIETANG/vue-resume/commit/a112088f1c0bc772813f855139fcdd4cdeeea380)\n- [运行 node build/svg-symbol.js](https://github.com/FRANKIETANG/vue-resume/commit/78556c0f7cb18d20e078f3abbbb85fd9b4c8ed43)\n- [将 SVG 插入 body 中](https://github.com/FRANKIETANG/vue-resume/commit/476cec015bbea1e7fc55bbfb33ba627c68353084)\n\n```\n//任意地方\n<svg>\n  <use xlink:href=\"#icon-xxx\"></use>\n</svg>\n```\n\n**值得注意的是，之前的 ResumeEditor 中的 data 是对象，对象是无序的，应该用数组让项目有一个完整的顺序**\n\n## 填写区核心代码\n\n```\n        <ol class=\"panels\">\n            <li v-for=\"item in resume.config\" \n            v-show=\"item.field === selected\">\n                <div v-if=\"resume[item.field] instanceof Array\">\n                    <div class=\"subitem\" v-for=\"subitem in resume[item.field]\">\n                        <div class=\"resumeField\" v-for=\"(value,key) in subitem\">\n                            <label>{{key}}</label>\n                            <input type=\"text\" :value=\"value\">                            \n                        </div>\n                        <hr>\n                    </div>\n                </div>\n                <div v-else class=\"resumeField\" \n                v-for=\"(value,key) in resume[item.field]\">\n                    <label>{{key}}</label>\n                    <input type=\"text\" \n                    v-model=\"resume[item.field][key]\">\n                </div>\n            </li>\n        </ol>\n```\n\n## 如何把填进去的数据放到预览页面呢？\n\n可以做一个公共数据储存区域\n\n填写区填进去的数据先放到公共数据再传到预览区\n\n## Vuex\n\n[最基本的 Vuex 记数应用](https://jsfiddle.net/n9jmu5v7/1269/)\n\n## getter 与 setter\n\n```\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n\n## 提交载荷（Payload）\n\n你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n\n```\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n\nstore.commit('increment', 10)\n```\n\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\n\n```\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n## $store\n\n这个 `$` 在 Vue 里是代表全局的意思\n\n## 多次 import 同一个文件\n\nNode对引入的模块都会进行缓存（缓存的是编译和执行后的对象），减少二次引入开销；\n在Node的加载机制中，缓存的优先级是最高的；\n这一点同时适用于不同的模块加载机制，无论ES2015的import还是CommonJS的require；\n\n## CSS white-space: pre-line\n\n去除一行文本中的空格，但是保留一行的换行符，作用是防止用户在输入框输入空格而产生对用户不友好显示效果\n\n## Object-Path\n\n[object-path](https://github.com/mariocasciaro/object-path)\n\n[Object-Path 源码解读](https://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/)\n\n## Object.assign()\n\n`Object.assign()` 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n\n[Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\n## ES6\n\n```\n//旧版本\ncomponents: {\n  'MyDialog': MyDialog\n}\n//ES6\ncomponents: {\n  MyDialog\n}\n```","slug":"摸到 Vue.js 的门把手（2）","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8u000wf1xh1nfg3c9b","content":"<h1 id=\"摸到-Vue-js-的门把手（2）\"><a href=\"#摸到-Vue-js-的门把手（2）\" class=\"headerlink\" title=\"摸到 Vue.js 的门把手（2）\"></a>摸到 Vue.js 的门把手（2）</h1><p>用 vue-cli 快速搭建</p>\n<pre><code>npm init -y\nnpm install -g vue-cli\nvue init webpack .\n//全部回车\nnpm i\nnpm run dev\n</code></pre><h2 id=\"项目分三组件\"><a href=\"#项目分三组件\" class=\"headerlink\" title=\"项目分三组件\"></a>项目分三组件</h2><p><code>&lt;Topbar/&gt;</code> / <code>&lt;ResumeEditor/&gt;</code> / <code>&lt;ResumePreview/&gt;</code></p>\n<h2 id=\"禁用-ESLint\"><a href=\"#禁用-ESLint\" class=\"headerlink\" title=\"禁用 ESLint\"></a>禁用 ESLint</h2><pre><code>//build/webpack.base.conf.js\n  module: {\n    rules: [\n      //{\n        //test: /\\.(js|vue)$/,\n        //loader: &#39;eslint-loader&#39;,\n        //enforce: &quot;pre&quot;,\n        //include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],\n        //options: {\n          //formatter: eslintFriendlyFormatter\n        //}\n      //},\n</code></pre><h2 id=\"GitHub-预览\"><a href=\"#GitHub-预览\" class=\"headerlink\" title=\"GitHub 预览\"></a>GitHub 预览</h2><pre><code>//config/index.js\nassetsPublicPath: &#39;/vue-resume/dist&#39;,\n</code></pre><p><code>npm run build</code></p>\n<p><code>https://frankietang.github.io/vue-resume/dist/#/</code></p>\n<h2 id=\"使用-SCSS\"><a href=\"#使用-SCSS\" class=\"headerlink\" title=\"使用 SCSS\"></a>使用 SCSS</h2><p><code>npm install --save  sass-loader node-sass</code></p>\n<h2 id=\"SVG-合并和使用方法\"><a href=\"#SVG-合并和使用方法\" class=\"headerlink\" title=\"SVG 合并和使用方法\"></a>SVG 合并和使用方法</h2><ul>\n<li><a href=\"https://github.com/FRANKIETANG/vue-resume/commit/a112088f1c0bc772813f855139fcdd4cdeeea380\" target=\"_blank\" rel=\"noopener\">使用脚本将所有 svg 拼成一个 svg，原来的多个 svg 变成了多个 symbol</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/vue-resume/commit/78556c0f7cb18d20e078f3abbbb85fd9b4c8ed43\" target=\"_blank\" rel=\"noopener\">运行 node build/svg-symbol.js</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/vue-resume/commit/476cec015bbea1e7fc55bbfb33ba627c68353084\" target=\"_blank\" rel=\"noopener\">将 SVG 插入 body 中</a></li>\n</ul>\n<pre><code>//任意地方\n&lt;svg&gt;\n  &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n</code></pre><p><strong>值得注意的是，之前的 ResumeEditor 中的 data 是对象，对象是无序的，应该用数组让项目有一个完整的顺序</strong></p>\n<h2 id=\"填写区核心代码\"><a href=\"#填写区核心代码\" class=\"headerlink\" title=\"填写区核心代码\"></a>填写区核心代码</h2><pre><code>        &lt;ol class=&quot;panels&quot;&gt;\n            &lt;li v-for=&quot;item in resume.config&quot; \n            v-show=&quot;item.field === selected&quot;&gt;\n                &lt;div v-if=&quot;resume[item.field] instanceof Array&quot;&gt;\n                    &lt;div class=&quot;subitem&quot; v-for=&quot;subitem in resume[item.field]&quot;&gt;\n                        &lt;div class=&quot;resumeField&quot; v-for=&quot;(value,key) in subitem&quot;&gt;\n                            &lt;label&gt;{{key}}&lt;/label&gt;\n                            &lt;input type=&quot;text&quot; :value=&quot;value&quot;&gt;                            \n                        &lt;/div&gt;\n                        &lt;hr&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div v-else class=&quot;resumeField&quot; \n                v-for=&quot;(value,key) in resume[item.field]&quot;&gt;\n                    &lt;label&gt;{{key}}&lt;/label&gt;\n                    &lt;input type=&quot;text&quot; \n                    v-model=&quot;resume[item.field][key]&quot;&gt;\n                &lt;/div&gt;\n            &lt;/li&gt;\n        &lt;/ol&gt;\n</code></pre><h2 id=\"如何把填进去的数据放到预览页面呢？\"><a href=\"#如何把填进去的数据放到预览页面呢？\" class=\"headerlink\" title=\"如何把填进去的数据放到预览页面呢？\"></a>如何把填进去的数据放到预览页面呢？</h2><p>可以做一个公共数据储存区域</p>\n<p>填写区填进去的数据先放到公共数据再传到预览区</p>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p><a href=\"https://jsfiddle.net/n9jmu5v7/1269/\" target=\"_blank\" rel=\"noopener\">最基本的 Vuex 记数应用</a></p>\n<h2 id=\"getter-与-setter\"><a href=\"#getter-与-setter\" class=\"headerlink\" title=\"getter 与 setter\"></a>getter 与 setter</h2><pre><code>computed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + &#39; &#39; + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(&#39; &#39;)\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n</code></pre><h2 id=\"提交载荷（Payload）\"><a href=\"#提交载荷（Payload）\" class=\"headerlink\" title=\"提交载荷（Payload）\"></a>提交载荷（Payload）</h2><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>\n<pre><code>// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n\nstore.commit(&#39;increment&#39;, 10)\n</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>\n<pre><code>// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n\nstore.commit(&#39;increment&#39;, {\n  amount: 10\n})\n</code></pre><h2 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"$store\"></a>$store</h2><p>这个 <code>$</code> 在 Vue 里是代表全局的意思</p>\n<h2 id=\"多次-import-同一个文件\"><a href=\"#多次-import-同一个文件\" class=\"headerlink\" title=\"多次 import 同一个文件\"></a>多次 import 同一个文件</h2><p>Node对引入的模块都会进行缓存（缓存的是编译和执行后的对象），减少二次引入开销；<br>在Node的加载机制中，缓存的优先级是最高的；<br>这一点同时适用于不同的模块加载机制，无论ES2015的import还是CommonJS的require；</p>\n<h2 id=\"CSS-white-space-pre-line\"><a href=\"#CSS-white-space-pre-line\" class=\"headerlink\" title=\"CSS white-space: pre-line\"></a>CSS white-space: pre-line</h2><p>去除一行文本中的空格，但是保留一行的换行符，作用是防止用户在输入框输入空格而产生对用户不友好显示效果</p>\n<h2 id=\"Object-Path\"><a href=\"#Object-Path\" class=\"headerlink\" title=\"Object-Path\"></a>Object-Path</h2><p><a href=\"https://github.com/mariocasciaro/object-path\" target=\"_blank\" rel=\"noopener\">object-path</a></p>\n<p><a href=\"https://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/\" target=\"_blank\" rel=\"noopener\">Object-Path 源码解读</a></p>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h2><p><code>Object.assign()</code> 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">Object.assign()</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><pre><code>//旧版本\ncomponents: {\n  &#39;MyDialog&#39;: MyDialog\n}\n//ES6\ncomponents: {\n  MyDialog\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-Vue-js-的门把手（2）\"><a href=\"#摸到-Vue-js-的门把手（2）\" class=\"headerlink\" title=\"摸到 Vue.js 的门把手（2）\"></a>摸到 Vue.js 的门把手（2）</h1><p>用 vue-cli 快速搭建</p>\n<pre><code>npm init -y\nnpm install -g vue-cli\nvue init webpack .\n//全部回车\nnpm i\nnpm run dev\n</code></pre><h2 id=\"项目分三组件\"><a href=\"#项目分三组件\" class=\"headerlink\" title=\"项目分三组件\"></a>项目分三组件</h2><p><code>&lt;Topbar/&gt;</code> / <code>&lt;ResumeEditor/&gt;</code> / <code>&lt;ResumePreview/&gt;</code></p>\n<h2 id=\"禁用-ESLint\"><a href=\"#禁用-ESLint\" class=\"headerlink\" title=\"禁用 ESLint\"></a>禁用 ESLint</h2><pre><code>//build/webpack.base.conf.js\n  module: {\n    rules: [\n      //{\n        //test: /\\.(js|vue)$/,\n        //loader: &#39;eslint-loader&#39;,\n        //enforce: &quot;pre&quot;,\n        //include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],\n        //options: {\n          //formatter: eslintFriendlyFormatter\n        //}\n      //},\n</code></pre><h2 id=\"GitHub-预览\"><a href=\"#GitHub-预览\" class=\"headerlink\" title=\"GitHub 预览\"></a>GitHub 预览</h2><pre><code>//config/index.js\nassetsPublicPath: &#39;/vue-resume/dist&#39;,\n</code></pre><p><code>npm run build</code></p>\n<p><code>https://frankietang.github.io/vue-resume/dist/#/</code></p>\n<h2 id=\"使用-SCSS\"><a href=\"#使用-SCSS\" class=\"headerlink\" title=\"使用 SCSS\"></a>使用 SCSS</h2><p><code>npm install --save  sass-loader node-sass</code></p>\n<h2 id=\"SVG-合并和使用方法\"><a href=\"#SVG-合并和使用方法\" class=\"headerlink\" title=\"SVG 合并和使用方法\"></a>SVG 合并和使用方法</h2><ul>\n<li><a href=\"https://github.com/FRANKIETANG/vue-resume/commit/a112088f1c0bc772813f855139fcdd4cdeeea380\" target=\"_blank\" rel=\"noopener\">使用脚本将所有 svg 拼成一个 svg，原来的多个 svg 变成了多个 symbol</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/vue-resume/commit/78556c0f7cb18d20e078f3abbbb85fd9b4c8ed43\" target=\"_blank\" rel=\"noopener\">运行 node build/svg-symbol.js</a></li>\n<li><a href=\"https://github.com/FRANKIETANG/vue-resume/commit/476cec015bbea1e7fc55bbfb33ba627c68353084\" target=\"_blank\" rel=\"noopener\">将 SVG 插入 body 中</a></li>\n</ul>\n<pre><code>//任意地方\n&lt;svg&gt;\n  &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n</code></pre><p><strong>值得注意的是，之前的 ResumeEditor 中的 data 是对象，对象是无序的，应该用数组让项目有一个完整的顺序</strong></p>\n<h2 id=\"填写区核心代码\"><a href=\"#填写区核心代码\" class=\"headerlink\" title=\"填写区核心代码\"></a>填写区核心代码</h2><pre><code>        &lt;ol class=&quot;panels&quot;&gt;\n            &lt;li v-for=&quot;item in resume.config&quot; \n            v-show=&quot;item.field === selected&quot;&gt;\n                &lt;div v-if=&quot;resume[item.field] instanceof Array&quot;&gt;\n                    &lt;div class=&quot;subitem&quot; v-for=&quot;subitem in resume[item.field]&quot;&gt;\n                        &lt;div class=&quot;resumeField&quot; v-for=&quot;(value,key) in subitem&quot;&gt;\n                            &lt;label&gt;{{key}}&lt;/label&gt;\n                            &lt;input type=&quot;text&quot; :value=&quot;value&quot;&gt;                            \n                        &lt;/div&gt;\n                        &lt;hr&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div v-else class=&quot;resumeField&quot; \n                v-for=&quot;(value,key) in resume[item.field]&quot;&gt;\n                    &lt;label&gt;{{key}}&lt;/label&gt;\n                    &lt;input type=&quot;text&quot; \n                    v-model=&quot;resume[item.field][key]&quot;&gt;\n                &lt;/div&gt;\n            &lt;/li&gt;\n        &lt;/ol&gt;\n</code></pre><h2 id=\"如何把填进去的数据放到预览页面呢？\"><a href=\"#如何把填进去的数据放到预览页面呢？\" class=\"headerlink\" title=\"如何把填进去的数据放到预览页面呢？\"></a>如何把填进去的数据放到预览页面呢？</h2><p>可以做一个公共数据储存区域</p>\n<p>填写区填进去的数据先放到公共数据再传到预览区</p>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p><a href=\"https://jsfiddle.net/n9jmu5v7/1269/\" target=\"_blank\" rel=\"noopener\">最基本的 Vuex 记数应用</a></p>\n<h2 id=\"getter-与-setter\"><a href=\"#getter-与-setter\" class=\"headerlink\" title=\"getter 与 setter\"></a>getter 与 setter</h2><pre><code>computed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + &#39; &#39; + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(&#39; &#39;)\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n</code></pre><h2 id=\"提交载荷（Payload）\"><a href=\"#提交载荷（Payload）\" class=\"headerlink\" title=\"提交载荷（Payload）\"></a>提交载荷（Payload）</h2><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>\n<pre><code>// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n\nstore.commit(&#39;increment&#39;, 10)\n</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>\n<pre><code>// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n\nstore.commit(&#39;increment&#39;, {\n  amount: 10\n})\n</code></pre><h2 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"$store\"></a>$store</h2><p>这个 <code>$</code> 在 Vue 里是代表全局的意思</p>\n<h2 id=\"多次-import-同一个文件\"><a href=\"#多次-import-同一个文件\" class=\"headerlink\" title=\"多次 import 同一个文件\"></a>多次 import 同一个文件</h2><p>Node对引入的模块都会进行缓存（缓存的是编译和执行后的对象），减少二次引入开销；<br>在Node的加载机制中，缓存的优先级是最高的；<br>这一点同时适用于不同的模块加载机制，无论ES2015的import还是CommonJS的require；</p>\n<h2 id=\"CSS-white-space-pre-line\"><a href=\"#CSS-white-space-pre-line\" class=\"headerlink\" title=\"CSS white-space: pre-line\"></a>CSS white-space: pre-line</h2><p>去除一行文本中的空格，但是保留一行的换行符，作用是防止用户在输入框输入空格而产生对用户不友好显示效果</p>\n<h2 id=\"Object-Path\"><a href=\"#Object-Path\" class=\"headerlink\" title=\"Object-Path\"></a>Object-Path</h2><p><a href=\"https://github.com/mariocasciaro/object-path\" target=\"_blank\" rel=\"noopener\">object-path</a></p>\n<p><a href=\"https://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/\" target=\"_blank\" rel=\"noopener\">Object-Path 源码解读</a></p>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h2><p><code>Object.assign()</code> 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">Object.assign()</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><pre><code>//旧版本\ncomponents: {\n  &#39;MyDialog&#39;: MyDialog\n}\n//ES6\ncomponents: {\n  MyDialog\n}\n</code></pre>"},{"title":"摸到 Vue.js 的门把手（3）","date":"2017-10-13T16:13:11.000Z","_content":"# 摸到 Vue.js 的门把手（3）\n\n回炉重造\n\n## 重看 `vue init webpack` 的选项\n\n```\n? Generate project in current directory? Yes\n? Project name vue-resume\n? Project description A Vue.js project\n? Author FRANKIETANG <350558468@qq.com>\n? Vue build standalone\n//可以以后再装\n? Install vue-router? No\n//这东西很烦，不要\n? Use ESLint to lint your code? No\n//不需要单元测试\n? Setup unit tests with Karma + Mocha? No\n//不用管\n? Setup e2e tests with Nightwatch? No\n```\n\n## 升级了 NPM 之后居然装不了 SCSS ？\n\n会有一个奇怪的 `user \"root\" does not have permission to access the dev dir \"/home/tangkalun/Desktop/vue-resume/node_modules/node-sass/.node-gyp/6.3.1\"`\n\n那就用 `sudo SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install --save --unsafe-perm`\n\n不行就用 `export SASS_BINARY_SITE=\"https://npm.taobao.org/mirrors/node-sass\"`\n\n`npm install --save  sass-loader node-sass`\n\n又不行？\n\n`sudo npm install -g cnpm --registry=https://registry.npm.taobao.org`\n\n`sudo cnpm install --save  sass-loader node-sass --unsafe-perm`\n\n不要加 `--unsafe-perm`\n\n在 linux 下有可能循环安装...\n\n用这句 `rm -rf node_modules/ && npm install && npm rebuild`\n\n不用想那么多。人生苦短，能用就行。\n\n## 程序构想\n\n和之前一样分为导航栏，侧栏编写区，预览区\n\n## iconfont 的善用\n\n生成 `<script>` 标签直接用...不用像之前写个脚本来搞一大堆\n\n## element-ui\n\n`npm i element-ui -S`\n\n[文档](http://element.eleme.io/#/zh-CN/component/installation)\n\n## 数据绑定语法为`:value.sync`\n\n[点击这里](https://vuxjs.gitbooks.io/vux/content/form/x-input.html)\n\n## slot 分發內容\n\n[Vue – 如何理解「使用 slot 分發內容」](http://jsnwork.kiiuo.com/archives/2645/vue-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E3%80%8C%E4%BD%BF%E7%94%A8-slot-%E5%88%86%E7%99%BC%E5%85%A7%E5%AE%B9%E3%80%8D)\n\n## 完。\n\n[预览](https://frankietang.github.io/vue-resume/dist/index.html)","source":"_posts/摸到 Vue.js 的门把手（3）.md","raw":"---\ntitle: 摸到 Vue.js 的门把手（3）\ndate: 2017-10-14 00:13:11\ntags: [Vue,Black History]\n---\n# 摸到 Vue.js 的门把手（3）\n\n回炉重造\n\n## 重看 `vue init webpack` 的选项\n\n```\n? Generate project in current directory? Yes\n? Project name vue-resume\n? Project description A Vue.js project\n? Author FRANKIETANG <350558468@qq.com>\n? Vue build standalone\n//可以以后再装\n? Install vue-router? No\n//这东西很烦，不要\n? Use ESLint to lint your code? No\n//不需要单元测试\n? Setup unit tests with Karma + Mocha? No\n//不用管\n? Setup e2e tests with Nightwatch? No\n```\n\n## 升级了 NPM 之后居然装不了 SCSS ？\n\n会有一个奇怪的 `user \"root\" does not have permission to access the dev dir \"/home/tangkalun/Desktop/vue-resume/node_modules/node-sass/.node-gyp/6.3.1\"`\n\n那就用 `sudo SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install --save --unsafe-perm`\n\n不行就用 `export SASS_BINARY_SITE=\"https://npm.taobao.org/mirrors/node-sass\"`\n\n`npm install --save  sass-loader node-sass`\n\n又不行？\n\n`sudo npm install -g cnpm --registry=https://registry.npm.taobao.org`\n\n`sudo cnpm install --save  sass-loader node-sass --unsafe-perm`\n\n不要加 `--unsafe-perm`\n\n在 linux 下有可能循环安装...\n\n用这句 `rm -rf node_modules/ && npm install && npm rebuild`\n\n不用想那么多。人生苦短，能用就行。\n\n## 程序构想\n\n和之前一样分为导航栏，侧栏编写区，预览区\n\n## iconfont 的善用\n\n生成 `<script>` 标签直接用...不用像之前写个脚本来搞一大堆\n\n## element-ui\n\n`npm i element-ui -S`\n\n[文档](http://element.eleme.io/#/zh-CN/component/installation)\n\n## 数据绑定语法为`:value.sync`\n\n[点击这里](https://vuxjs.gitbooks.io/vux/content/form/x-input.html)\n\n## slot 分發內容\n\n[Vue – 如何理解「使用 slot 分發內容」](http://jsnwork.kiiuo.com/archives/2645/vue-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E3%80%8C%E4%BD%BF%E7%94%A8-slot-%E5%88%86%E7%99%BC%E5%85%A7%E5%AE%B9%E3%80%8D)\n\n## 完。\n\n[预览](https://frankietang.github.io/vue-resume/dist/index.html)","slug":"摸到 Vue.js 的门把手（3）","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8w000xf1xhs3pyl1t8","content":"<h1 id=\"摸到-Vue-js-的门把手（3）\"><a href=\"#摸到-Vue-js-的门把手（3）\" class=\"headerlink\" title=\"摸到 Vue.js 的门把手（3）\"></a>摸到 Vue.js 的门把手（3）</h1><p>回炉重造</p>\n<h2 id=\"重看-vue-init-webpack-的选项\"><a href=\"#重看-vue-init-webpack-的选项\" class=\"headerlink\" title=\"重看 vue init webpack 的选项\"></a>重看 <code>vue init webpack</code> 的选项</h2><pre><code>? Generate project in current directory? Yes\n? Project name vue-resume\n? Project description A Vue.js project\n? Author FRANKIETANG &lt;350558468@qq.com&gt;\n? Vue build standalone\n//可以以后再装\n? Install vue-router? No\n//这东西很烦，不要\n? Use ESLint to lint your code? No\n//不需要单元测试\n? Setup unit tests with Karma + Mocha? No\n//不用管\n? Setup e2e tests with Nightwatch? No\n</code></pre><h2 id=\"升级了-NPM-之后居然装不了-SCSS-？\"><a href=\"#升级了-NPM-之后居然装不了-SCSS-？\" class=\"headerlink\" title=\"升级了 NPM 之后居然装不了 SCSS ？\"></a>升级了 NPM 之后居然装不了 SCSS ？</h2><p>会有一个奇怪的 <code>user &quot;root&quot; does not have permission to access the dev dir &quot;/home/tangkalun/Desktop/vue-resume/node_modules/node-sass/.node-gyp/6.3.1&quot;</code></p>\n<p>那就用 <code>sudo SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install --save --unsafe-perm</code></p>\n<p>不行就用 <code>export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;</code></p>\n<p><code>npm install --save  sass-loader node-sass</code></p>\n<p>又不行？</p>\n<p><code>sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>\n<p><code>sudo cnpm install --save  sass-loader node-sass --unsafe-perm</code></p>\n<p>不要加 <code>--unsafe-perm</code></p>\n<p>在 linux 下有可能循环安装…</p>\n<p>用这句 <code>rm -rf node_modules/ &amp;&amp; npm install &amp;&amp; npm rebuild</code></p>\n<p>不用想那么多。人生苦短，能用就行。</p>\n<h2 id=\"程序构想\"><a href=\"#程序构想\" class=\"headerlink\" title=\"程序构想\"></a>程序构想</h2><p>和之前一样分为导航栏，侧栏编写区，预览区</p>\n<h2 id=\"iconfont-的善用\"><a href=\"#iconfont-的善用\" class=\"headerlink\" title=\"iconfont 的善用\"></a>iconfont 的善用</h2><p>生成 <code>&lt;script&gt;</code> 标签直接用…不用像之前写个脚本来搞一大堆</p>\n<h2 id=\"element-ui\"><a href=\"#element-ui\" class=\"headerlink\" title=\"element-ui\"></a>element-ui</h2><p><code>npm i element-ui -S</code></p>\n<p><a href=\"http://element.eleme.io/#/zh-CN/component/installation\" target=\"_blank\" rel=\"noopener\">文档</a></p>\n<h2 id=\"数据绑定语法为-value-sync\"><a href=\"#数据绑定语法为-value-sync\" class=\"headerlink\" title=\"数据绑定语法为:value.sync\"></a>数据绑定语法为<code>:value.sync</code></h2><p><a href=\"https://vuxjs.gitbooks.io/vux/content/form/x-input.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h2 id=\"slot-分發內容\"><a href=\"#slot-分發內容\" class=\"headerlink\" title=\"slot 分發內容\"></a>slot 分發內容</h2><p><a href=\"http://jsnwork.kiiuo.com/archives/2645/vue-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E3%80%8C%E4%BD%BF%E7%94%A8-slot-%E5%88%86%E7%99%BC%E5%85%A7%E5%AE%B9%E3%80%8D\" target=\"_blank\" rel=\"noopener\">Vue – 如何理解「使用 slot 分發內容」</a></p>\n<h2 id=\"完。\"><a href=\"#完。\" class=\"headerlink\" title=\"完。\"></a>完。</h2><p><a href=\"https://frankietang.github.io/vue-resume/dist/index.html\" target=\"_blank\" rel=\"noopener\">预览</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-Vue-js-的门把手（3）\"><a href=\"#摸到-Vue-js-的门把手（3）\" class=\"headerlink\" title=\"摸到 Vue.js 的门把手（3）\"></a>摸到 Vue.js 的门把手（3）</h1><p>回炉重造</p>\n<h2 id=\"重看-vue-init-webpack-的选项\"><a href=\"#重看-vue-init-webpack-的选项\" class=\"headerlink\" title=\"重看 vue init webpack 的选项\"></a>重看 <code>vue init webpack</code> 的选项</h2><pre><code>? Generate project in current directory? Yes\n? Project name vue-resume\n? Project description A Vue.js project\n? Author FRANKIETANG &lt;350558468@qq.com&gt;\n? Vue build standalone\n//可以以后再装\n? Install vue-router? No\n//这东西很烦，不要\n? Use ESLint to lint your code? No\n//不需要单元测试\n? Setup unit tests with Karma + Mocha? No\n//不用管\n? Setup e2e tests with Nightwatch? No\n</code></pre><h2 id=\"升级了-NPM-之后居然装不了-SCSS-？\"><a href=\"#升级了-NPM-之后居然装不了-SCSS-？\" class=\"headerlink\" title=\"升级了 NPM 之后居然装不了 SCSS ？\"></a>升级了 NPM 之后居然装不了 SCSS ？</h2><p>会有一个奇怪的 <code>user &quot;root&quot; does not have permission to access the dev dir &quot;/home/tangkalun/Desktop/vue-resume/node_modules/node-sass/.node-gyp/6.3.1&quot;</code></p>\n<p>那就用 <code>sudo SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install --save --unsafe-perm</code></p>\n<p>不行就用 <code>export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;</code></p>\n<p><code>npm install --save  sass-loader node-sass</code></p>\n<p>又不行？</p>\n<p><code>sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>\n<p><code>sudo cnpm install --save  sass-loader node-sass --unsafe-perm</code></p>\n<p>不要加 <code>--unsafe-perm</code></p>\n<p>在 linux 下有可能循环安装…</p>\n<p>用这句 <code>rm -rf node_modules/ &amp;&amp; npm install &amp;&amp; npm rebuild</code></p>\n<p>不用想那么多。人生苦短，能用就行。</p>\n<h2 id=\"程序构想\"><a href=\"#程序构想\" class=\"headerlink\" title=\"程序构想\"></a>程序构想</h2><p>和之前一样分为导航栏，侧栏编写区，预览区</p>\n<h2 id=\"iconfont-的善用\"><a href=\"#iconfont-的善用\" class=\"headerlink\" title=\"iconfont 的善用\"></a>iconfont 的善用</h2><p>生成 <code>&lt;script&gt;</code> 标签直接用…不用像之前写个脚本来搞一大堆</p>\n<h2 id=\"element-ui\"><a href=\"#element-ui\" class=\"headerlink\" title=\"element-ui\"></a>element-ui</h2><p><code>npm i element-ui -S</code></p>\n<p><a href=\"http://element.eleme.io/#/zh-CN/component/installation\" target=\"_blank\" rel=\"noopener\">文档</a></p>\n<h2 id=\"数据绑定语法为-value-sync\"><a href=\"#数据绑定语法为-value-sync\" class=\"headerlink\" title=\"数据绑定语法为:value.sync\"></a>数据绑定语法为<code>:value.sync</code></h2><p><a href=\"https://vuxjs.gitbooks.io/vux/content/form/x-input.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<h2 id=\"slot-分發內容\"><a href=\"#slot-分發內容\" class=\"headerlink\" title=\"slot 分發內容\"></a>slot 分發內容</h2><p><a href=\"http://jsnwork.kiiuo.com/archives/2645/vue-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E3%80%8C%E4%BD%BF%E7%94%A8-slot-%E5%88%86%E7%99%BC%E5%85%A7%E5%AE%B9%E3%80%8D\" target=\"_blank\" rel=\"noopener\">Vue – 如何理解「使用 slot 分發內容」</a></p>\n<h2 id=\"完。\"><a href=\"#完。\" class=\"headerlink\" title=\"完。\"></a>完。</h2><p><a href=\"https://frankietang.github.io/vue-resume/dist/index.html\" target=\"_blank\" rel=\"noopener\">预览</a></p>\n"},{"title":"摸到 webpack 的门把手 (2)","date":"2017-10-13T16:05:14.000Z","_content":"\n# 摸到 webpack 的门把手 (2)\n\n经过了上一篇 [摸到 webpack 的门把手](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) 的踩坑，我们大概知道了 webpack 是用 loader 加载不同的资源，把大东西压成小东西。大不一定能满足，小也有小的优点嘛。对吧，有的时候大家就喜欢小。\n\n## webpack 到底干了什么\n\nbundle.js 把每一个每一个模块都 call 一下，然后把模块存到 installedModules 里，方便其他模块使用。有空填坑分析代码。\n\n## 压缩代码的一些问题\n\n我们会发现 jQuery 的代码并没有压缩，其实我们可以使用 `webpack -p`，webpack 给出的解释是\n`shortcut for --optimize-minimize --define process.env.NODE_ENV=\"production\"`\n\n运行 `-p` ，实际执行\n\n-  使用UglifyJsPlugin进行 JS文件压缩,webpack 自带的压缩插件\n-  运行[LoaderOptionsPlugin](https://webpack.js.org/plugins/loader-options-plugin/#components/sidebar/sidebar.jsx)\n-  设置Node环境变量\n\n```\n//运行 webpack -p 会通过如下方式调用 DefinePlugin\nvar webpack=require('webpack');\n\nmodule.exports={\n  plugins:[\n    new webpack DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    })\n  ]\n}\n```\n\n`DefinePlugin` 在原始的源码中执行查找和替换操作. 在导入的代码中,任何出现 `process.env.NODE_ENV`的地方都会被替换为`”production”`. 因此, 形如`if (process.env.NODE_ENV !== ‘production’) console.log(‘…’)` 的代码就会等价于 `if (false) console.log(‘…’)` 并且最终通过`UglifyJS`等价替换掉.\n\n[webpack - public-path](https://webpack.js.org/guides/public-path/)\n\n## watch\n\n每次写完代码都要 npm run webpack ，很麻烦，那我们需要 `webpack --progress --watch` 监听文件变动，只要我们保存了文件就会自动编译代码。\n\n在 npm script 加一句 `\"watch\": \"webpack --progress --watch\"`，然后 npm run watch 试试\n\n![](http://upload-images.jianshu.io/upload_images/3191557-f654ac96a8135f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不但能刷新代码，还能刷新浏览器\n\n看到 Using webpack-dev-server 那里，它叫我们在根目录跑这句话\n\n```\nnpm install --save-dev webpack-dev-server\n```\n\n在 webpack.config.js 加点东西\n\n```\ndevServer: {\n    contentBase: './dist'\n},\n```\n\n在 package.json 的 npm script 加点东西\n\n```\n\"start\": \"webpack-dev-server --open\"\n```\n\n成了，看下图。\n![](http://upload-images.jianshu.io/upload_images/3191557-494866b6ba1c3ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果我们改一下 src/bundle.js 就会发现\n\n- bundle.js 自动打包\n- [http://localhost:8080/](http://localhost:8080/) 自动刷新\n\n![](http://upload-images.jianshu.io/upload_images/3191557-c12e95d7cc12d8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意，我们就不能再直接打开 index.html 了，因为它引用的是 /bundle.js，用 file:// 协议打开 index.html 的话，会请求 file:///bundle.js，显然这个文件不存在。\n\n[webpack - development](https://webpack.js.org/guides/development/)\n\n## [查看成果](https://github.com/FRANKIETANG/webpack-demo)","source":"_posts/摸到 webpack 的门把手 (2).md","raw":"---\ntitle: 摸到 webpack 的门把手 (2)\ndate: 2017-10-14 00:05:14\ntags: [webpack,Black History]\n---\n\n# 摸到 webpack 的门把手 (2)\n\n经过了上一篇 [摸到 webpack 的门把手](https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/) 的踩坑，我们大概知道了 webpack 是用 loader 加载不同的资源，把大东西压成小东西。大不一定能满足，小也有小的优点嘛。对吧，有的时候大家就喜欢小。\n\n## webpack 到底干了什么\n\nbundle.js 把每一个每一个模块都 call 一下，然后把模块存到 installedModules 里，方便其他模块使用。有空填坑分析代码。\n\n## 压缩代码的一些问题\n\n我们会发现 jQuery 的代码并没有压缩，其实我们可以使用 `webpack -p`，webpack 给出的解释是\n`shortcut for --optimize-minimize --define process.env.NODE_ENV=\"production\"`\n\n运行 `-p` ，实际执行\n\n-  使用UglifyJsPlugin进行 JS文件压缩,webpack 自带的压缩插件\n-  运行[LoaderOptionsPlugin](https://webpack.js.org/plugins/loader-options-plugin/#components/sidebar/sidebar.jsx)\n-  设置Node环境变量\n\n```\n//运行 webpack -p 会通过如下方式调用 DefinePlugin\nvar webpack=require('webpack');\n\nmodule.exports={\n  plugins:[\n    new webpack DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    })\n  ]\n}\n```\n\n`DefinePlugin` 在原始的源码中执行查找和替换操作. 在导入的代码中,任何出现 `process.env.NODE_ENV`的地方都会被替换为`”production”`. 因此, 形如`if (process.env.NODE_ENV !== ‘production’) console.log(‘…’)` 的代码就会等价于 `if (false) console.log(‘…’)` 并且最终通过`UglifyJS`等价替换掉.\n\n[webpack - public-path](https://webpack.js.org/guides/public-path/)\n\n## watch\n\n每次写完代码都要 npm run webpack ，很麻烦，那我们需要 `webpack --progress --watch` 监听文件变动，只要我们保存了文件就会自动编译代码。\n\n在 npm script 加一句 `\"watch\": \"webpack --progress --watch\"`，然后 npm run watch 试试\n\n![](http://upload-images.jianshu.io/upload_images/3191557-f654ac96a8135f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不但能刷新代码，还能刷新浏览器\n\n看到 Using webpack-dev-server 那里，它叫我们在根目录跑这句话\n\n```\nnpm install --save-dev webpack-dev-server\n```\n\n在 webpack.config.js 加点东西\n\n```\ndevServer: {\n    contentBase: './dist'\n},\n```\n\n在 package.json 的 npm script 加点东西\n\n```\n\"start\": \"webpack-dev-server --open\"\n```\n\n成了，看下图。\n![](http://upload-images.jianshu.io/upload_images/3191557-494866b6ba1c3ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果我们改一下 src/bundle.js 就会发现\n\n- bundle.js 自动打包\n- [http://localhost:8080/](http://localhost:8080/) 自动刷新\n\n![](http://upload-images.jianshu.io/upload_images/3191557-c12e95d7cc12d8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意，我们就不能再直接打开 index.html 了，因为它引用的是 /bundle.js，用 file:// 协议打开 index.html 的话，会请求 file:///bundle.js，显然这个文件不存在。\n\n[webpack - development](https://webpack.js.org/guides/development/)\n\n## [查看成果](https://github.com/FRANKIETANG/webpack-demo)","slug":"摸到 webpack 的门把手 (2)","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8x000zf1xhhys0yugk","content":"<h1 id=\"摸到-webpack-的门把手-2\"><a href=\"#摸到-webpack-的门把手-2\" class=\"headerlink\" title=\"摸到 webpack 的门把手 (2)\"></a>摸到 webpack 的门把手 (2)</h1><p>经过了上一篇 <a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 webpack 的门把手</a> 的踩坑，我们大概知道了 webpack 是用 loader 加载不同的资源，把大东西压成小东西。大不一定能满足，小也有小的优点嘛。对吧，有的时候大家就喜欢小。</p>\n<h2 id=\"webpack-到底干了什么\"><a href=\"#webpack-到底干了什么\" class=\"headerlink\" title=\"webpack 到底干了什么\"></a>webpack 到底干了什么</h2><p>bundle.js 把每一个每一个模块都 call 一下，然后把模块存到 installedModules 里，方便其他模块使用。有空填坑分析代码。</p>\n<h2 id=\"压缩代码的一些问题\"><a href=\"#压缩代码的一些问题\" class=\"headerlink\" title=\"压缩代码的一些问题\"></a>压缩代码的一些问题</h2><p>我们会发现 jQuery 的代码并没有压缩，其实我们可以使用 <code>webpack -p</code>，webpack 给出的解释是<br><code>shortcut for --optimize-minimize --define process.env.NODE_ENV=&quot;production&quot;</code></p>\n<p>运行 <code>-p</code> ，实际执行</p>\n<ul>\n<li>使用UglifyJsPlugin进行 JS文件压缩,webpack 自带的压缩插件</li>\n<li>运行<a href=\"https://webpack.js.org/plugins/loader-options-plugin/#components/sidebar/sidebar.jsx\" target=\"_blank\" rel=\"noopener\">LoaderOptionsPlugin</a></li>\n<li>设置Node环境变量</li>\n</ul>\n<pre><code>//运行 webpack -p 会通过如下方式调用 DefinePlugin\nvar webpack=require(&#39;webpack&#39;);\n\nmodule.exports={\n  plugins:[\n    new webpack DefinePlugin({\n      &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)\n    })\n  ]\n}\n</code></pre><p><code>DefinePlugin</code> 在原始的源码中执行查找和替换操作. 在导入的代码中,任何出现 <code>process.env.NODE_ENV</code>的地方都会被替换为<code>”production”</code>. 因此, 形如<code>if (process.env.NODE_ENV !== ‘production’) console.log(‘…’)</code> 的代码就会等价于 <code>if (false) console.log(‘…’)</code> 并且最终通过<code>UglifyJS</code>等价替换掉.</p>\n<p><a href=\"https://webpack.js.org/guides/public-path/\" target=\"_blank\" rel=\"noopener\">webpack - public-path</a></p>\n<h2 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h2><p>每次写完代码都要 npm run webpack ，很麻烦，那我们需要 <code>webpack --progress --watch</code> 监听文件变动，只要我们保存了文件就会自动编译代码。</p>\n<p>在 npm script 加一句 <code>&quot;watch&quot;: &quot;webpack --progress --watch&quot;</code>，然后 npm run watch 试试</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-f654ac96a8135f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>不但能刷新代码，还能刷新浏览器</p>\n<p>看到 Using webpack-dev-server 那里，它叫我们在根目录跑这句话</p>\n<pre><code>npm install --save-dev webpack-dev-server\n</code></pre><p>在 webpack.config.js 加点东西</p>\n<pre><code>devServer: {\n    contentBase: &#39;./dist&#39;\n},\n</code></pre><p>在 package.json 的 npm script 加点东西</p>\n<pre><code>&quot;start&quot;: &quot;webpack-dev-server --open&quot;\n</code></pre><p>成了，看下图。<br><img src=\"http://upload-images.jianshu.io/upload_images/3191557-494866b6ba1c3ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>如果我们改一下 src/bundle.js 就会发现</p>\n<ul>\n<li>bundle.js 自动打包</li>\n<li><a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/</a> 自动刷新</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c12e95d7cc12d8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>注意，我们就不能再直接打开 index.html 了，因为它引用的是 /bundle.js，用 file:// 协议打开 index.html 的话，会请求 file:///bundle.js，显然这个文件不存在。</p>\n<p><a href=\"https://webpack.js.org/guides/development/\" target=\"_blank\" rel=\"noopener\">webpack - development</a></p>\n<h2 id=\"查看成果\"><a href=\"#查看成果\" class=\"headerlink\" title=\"查看成果\"></a><a href=\"https://github.com/FRANKIETANG/webpack-demo\" target=\"_blank\" rel=\"noopener\">查看成果</a></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-webpack-的门把手-2\"><a href=\"#摸到-webpack-的门把手-2\" class=\"headerlink\" title=\"摸到 webpack 的门把手 (2)\"></a>摸到 webpack 的门把手 (2)</h1><p>经过了上一篇 <a href=\"https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 webpack 的门把手</a> 的踩坑，我们大概知道了 webpack 是用 loader 加载不同的资源，把大东西压成小东西。大不一定能满足，小也有小的优点嘛。对吧，有的时候大家就喜欢小。</p>\n<h2 id=\"webpack-到底干了什么\"><a href=\"#webpack-到底干了什么\" class=\"headerlink\" title=\"webpack 到底干了什么\"></a>webpack 到底干了什么</h2><p>bundle.js 把每一个每一个模块都 call 一下，然后把模块存到 installedModules 里，方便其他模块使用。有空填坑分析代码。</p>\n<h2 id=\"压缩代码的一些问题\"><a href=\"#压缩代码的一些问题\" class=\"headerlink\" title=\"压缩代码的一些问题\"></a>压缩代码的一些问题</h2><p>我们会发现 jQuery 的代码并没有压缩，其实我们可以使用 <code>webpack -p</code>，webpack 给出的解释是<br><code>shortcut for --optimize-minimize --define process.env.NODE_ENV=&quot;production&quot;</code></p>\n<p>运行 <code>-p</code> ，实际执行</p>\n<ul>\n<li>使用UglifyJsPlugin进行 JS文件压缩,webpack 自带的压缩插件</li>\n<li>运行<a href=\"https://webpack.js.org/plugins/loader-options-plugin/#components/sidebar/sidebar.jsx\" target=\"_blank\" rel=\"noopener\">LoaderOptionsPlugin</a></li>\n<li>设置Node环境变量</li>\n</ul>\n<pre><code>//运行 webpack -p 会通过如下方式调用 DefinePlugin\nvar webpack=require(&#39;webpack&#39;);\n\nmodule.exports={\n  plugins:[\n    new webpack DefinePlugin({\n      &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)\n    })\n  ]\n}\n</code></pre><p><code>DefinePlugin</code> 在原始的源码中执行查找和替换操作. 在导入的代码中,任何出现 <code>process.env.NODE_ENV</code>的地方都会被替换为<code>”production”</code>. 因此, 形如<code>if (process.env.NODE_ENV !== ‘production’) console.log(‘…’)</code> 的代码就会等价于 <code>if (false) console.log(‘…’)</code> 并且最终通过<code>UglifyJS</code>等价替换掉.</p>\n<p><a href=\"https://webpack.js.org/guides/public-path/\" target=\"_blank\" rel=\"noopener\">webpack - public-path</a></p>\n<h2 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h2><p>每次写完代码都要 npm run webpack ，很麻烦，那我们需要 <code>webpack --progress --watch</code> 监听文件变动，只要我们保存了文件就会自动编译代码。</p>\n<p>在 npm script 加一句 <code>&quot;watch&quot;: &quot;webpack --progress --watch&quot;</code>，然后 npm run watch 试试</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-f654ac96a8135f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>不但能刷新代码，还能刷新浏览器</p>\n<p>看到 Using webpack-dev-server 那里，它叫我们在根目录跑这句话</p>\n<pre><code>npm install --save-dev webpack-dev-server\n</code></pre><p>在 webpack.config.js 加点东西</p>\n<pre><code>devServer: {\n    contentBase: &#39;./dist&#39;\n},\n</code></pre><p>在 package.json 的 npm script 加点东西</p>\n<pre><code>&quot;start&quot;: &quot;webpack-dev-server --open&quot;\n</code></pre><p>成了，看下图。<br><img src=\"http://upload-images.jianshu.io/upload_images/3191557-494866b6ba1c3ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>如果我们改一下 src/bundle.js 就会发现</p>\n<ul>\n<li>bundle.js 自动打包</li>\n<li><a href=\"http://localhost:8080/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/</a> 自动刷新</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c12e95d7cc12d8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>注意，我们就不能再直接打开 index.html 了，因为它引用的是 /bundle.js，用 file:// 协议打开 index.html 的话，会请求 file:///bundle.js，显然这个文件不存在。</p>\n<p><a href=\"https://webpack.js.org/guides/development/\" target=\"_blank\" rel=\"noopener\">webpack - development</a></p>\n<h2 id=\"查看成果\"><a href=\"#查看成果\" class=\"headerlink\" title=\"查看成果\"></a><a href=\"https://github.com/FRANKIETANG/webpack-demo\" target=\"_blank\" rel=\"noopener\">查看成果</a></h2>"},{"title":"摸到 webpack 的门把手","date":"2017-10-13T16:04:38.000Z","_content":"# 摸到 webpack 的门把手\n\n之前接触过一阵子 webpack ，想了一下还是写篇博客吧。要不然又忘掉怎么配置了。\n\n## 怎么安装？\n\n[来，我们先看 webpack 的官网](https://webpack.js.org/)\n\n点击到 guides ，我们直接抄，抄完我们就知道 webpack 的流程了\n\n不过有几点我们是要注意的\n\n- 注意 index.js 中的 `_.join`，这个 _ 实际上是 lodash 暴露的全局变量。\n- 为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。可以用 npm 装回来 `npm install --save lodash`\n- 尽量运行 `./node_modules/.bin/webpack` \n\n## 看看文件结构\n\n- `./node_modules/.bin/webpack src/index.js dist/bundle.js` 将 src/index.js 变成 dist/bundle.js\n- index.html 引用的是 dist/bundle.js\n- lodash 被安装在 node_modules 里\n- webpack 也被安装在 node_modules里，`./node_modules/.bin/webpack` 就是一个可执行文件\n- webpack、lodash 的版本号都被写在 package.json 里了\n\n[读懂diff - 阮一峰](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)\n\n## 引用 jQuery\n\n- `npm i -S jquery`\n\n  ```\n   import _ from 'lodash'\n  +import j from 'jquery'\n\n   function component () {\n  -  var element = document.createElement('div');\n  +  var element = j('<div></div>');\n\n     /* lodash is required for the next line to work */\n  -  element.innerHTML = _.join(['Hello','webpack'], ' ');\n  +  element.html(_.join(['Hello','webpack'], ' '))\n\n  -  return element;\n  +  return element.get(0);\n   }\n\n   document.body.appendChild(component());\n  ```\n\n-  `./node_modules/.bin/webpack src/index.js dist/bundle.js` 跑这句话\n\n- 点击 commits 看看有什么变化\n\n- 建议 index.js 改成 `console.log(1)` 然后运行 `./node_modules/.bin/webpack src/index.js dist/bundle.js`，看看 bundle.js 和 index.js 的区别\n\n## 做一点改良\n\n- 我们可以在根目录搞一个 `webpack.config.js`，在里面写上一点代码。\n\n  ```\n  var path = require('path')\n\n  module.exports = {\n      entry: './src/index.js',\n      output: {\n          filename: 'bundle.js',\n          path: path.resolve(__dirname, 'dist')\n      }\n  }\n  ```\n\n  重点是这三个玩意 src/index.js 、dist 和 bundle.js 在哪就行，方便我们后面改。\n\n- 然后我们就可以用上这句 `./node_modules/.bin/webpack --config webpack.config.js`\n\n- 或者我们可以进行下面的改良\n\n  ```\n    \"scripts\": {\n      \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n      \"webpack\": \"webpack\"\n    },\n    \"keywords\": [],\n  ```\n\n  然后运行 npm run webpack\n\n## 尝试 import 一个自己的文件\n\n- 创建一个 `foo.js`\n\n  ```\n  export default function(){\n      return 'tangkalun'\n  }\n  ```\n\n- 然后在 `index.js` 加上 `import foo from './foo'`，顺便 `console.log` 一下\n\n- `npm run webpack`\n\n## 利用 webpack 压缩 JS 文件\n\n- [webpack 自带的](https://webpack.js.org/guides/production/) 支持所有 [UglifyJS 选项](https://github.com/mishoo/UglifyJS2#usage)\n\n- 在 `webpack.config.js` 加上这样一句话，UglifyJS 的选项可以一个都不加\n\n  ```\n  var webpack = require('webpack');\n\n  module.exports = {\n    /*...*/\n    plugins:[\n      new webpack.optimize.UglifyJsPlugin()\n    ]\n  };\n  ```\n\n- `npm run webpack`\n\n- 压完了\n\n## 看看成果 \n\n[点击这里](https://github.com/FRANKIETANG/webpack-demo)","source":"_posts/摸到 webpack 的门把手.md","raw":"---\ntitle: 摸到 webpack 的门把手\ndate: 2017-10-14 00:04:38\ntags: [webpack,Black History]\n---\n# 摸到 webpack 的门把手\n\n之前接触过一阵子 webpack ，想了一下还是写篇博客吧。要不然又忘掉怎么配置了。\n\n## 怎么安装？\n\n[来，我们先看 webpack 的官网](https://webpack.js.org/)\n\n点击到 guides ，我们直接抄，抄完我们就知道 webpack 的流程了\n\n不过有几点我们是要注意的\n\n- 注意 index.js 中的 `_.join`，这个 _ 实际上是 lodash 暴露的全局变量。\n- 为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。可以用 npm 装回来 `npm install --save lodash`\n- 尽量运行 `./node_modules/.bin/webpack` \n\n## 看看文件结构\n\n- `./node_modules/.bin/webpack src/index.js dist/bundle.js` 将 src/index.js 变成 dist/bundle.js\n- index.html 引用的是 dist/bundle.js\n- lodash 被安装在 node_modules 里\n- webpack 也被安装在 node_modules里，`./node_modules/.bin/webpack` 就是一个可执行文件\n- webpack、lodash 的版本号都被写在 package.json 里了\n\n[读懂diff - 阮一峰](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)\n\n## 引用 jQuery\n\n- `npm i -S jquery`\n\n  ```\n   import _ from 'lodash'\n  +import j from 'jquery'\n\n   function component () {\n  -  var element = document.createElement('div');\n  +  var element = j('<div></div>');\n\n     /* lodash is required for the next line to work */\n  -  element.innerHTML = _.join(['Hello','webpack'], ' ');\n  +  element.html(_.join(['Hello','webpack'], ' '))\n\n  -  return element;\n  +  return element.get(0);\n   }\n\n   document.body.appendChild(component());\n  ```\n\n-  `./node_modules/.bin/webpack src/index.js dist/bundle.js` 跑这句话\n\n- 点击 commits 看看有什么变化\n\n- 建议 index.js 改成 `console.log(1)` 然后运行 `./node_modules/.bin/webpack src/index.js dist/bundle.js`，看看 bundle.js 和 index.js 的区别\n\n## 做一点改良\n\n- 我们可以在根目录搞一个 `webpack.config.js`，在里面写上一点代码。\n\n  ```\n  var path = require('path')\n\n  module.exports = {\n      entry: './src/index.js',\n      output: {\n          filename: 'bundle.js',\n          path: path.resolve(__dirname, 'dist')\n      }\n  }\n  ```\n\n  重点是这三个玩意 src/index.js 、dist 和 bundle.js 在哪就行，方便我们后面改。\n\n- 然后我们就可以用上这句 `./node_modules/.bin/webpack --config webpack.config.js`\n\n- 或者我们可以进行下面的改良\n\n  ```\n    \"scripts\": {\n      \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n      \"webpack\": \"webpack\"\n    },\n    \"keywords\": [],\n  ```\n\n  然后运行 npm run webpack\n\n## 尝试 import 一个自己的文件\n\n- 创建一个 `foo.js`\n\n  ```\n  export default function(){\n      return 'tangkalun'\n  }\n  ```\n\n- 然后在 `index.js` 加上 `import foo from './foo'`，顺便 `console.log` 一下\n\n- `npm run webpack`\n\n## 利用 webpack 压缩 JS 文件\n\n- [webpack 自带的](https://webpack.js.org/guides/production/) 支持所有 [UglifyJS 选项](https://github.com/mishoo/UglifyJS2#usage)\n\n- 在 `webpack.config.js` 加上这样一句话，UglifyJS 的选项可以一个都不加\n\n  ```\n  var webpack = require('webpack');\n\n  module.exports = {\n    /*...*/\n    plugins:[\n      new webpack.optimize.UglifyJsPlugin()\n    ]\n  };\n  ```\n\n- `npm run webpack`\n\n- 压完了\n\n## 看看成果 \n\n[点击这里](https://github.com/FRANKIETANG/webpack-demo)","slug":"摸到 webpack 的门把手","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d8y0010f1xhudtmgse1","content":"<h1 id=\"摸到-webpack-的门把手\"><a href=\"#摸到-webpack-的门把手\" class=\"headerlink\" title=\"摸到 webpack 的门把手\"></a>摸到 webpack 的门把手</h1><p>之前接触过一阵子 webpack ，想了一下还是写篇博客吧。要不然又忘掉怎么配置了。</p>\n<h2 id=\"怎么安装？\"><a href=\"#怎么安装？\" class=\"headerlink\" title=\"怎么安装？\"></a>怎么安装？</h2><p><a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">来，我们先看 webpack 的官网</a></p>\n<p>点击到 guides ，我们直接抄，抄完我们就知道 webpack 的流程了</p>\n<p>不过有几点我们是要注意的</p>\n<ul>\n<li>注意 index.js 中的 <code>_.join</code>，这个 _ 实际上是 lodash 暴露的全局变量。</li>\n<li>为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。可以用 npm 装回来 <code>npm install --save lodash</code></li>\n<li>尽量运行 <code>./node_modules/.bin/webpack</code> </li>\n</ul>\n<h2 id=\"看看文件结构\"><a href=\"#看看文件结构\" class=\"headerlink\" title=\"看看文件结构\"></a>看看文件结构</h2><ul>\n<li><code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code> 将 src/index.js 变成 dist/bundle.js</li>\n<li>index.html 引用的是 dist/bundle.js</li>\n<li>lodash 被安装在 node_modules 里</li>\n<li>webpack 也被安装在 node_modules里，<code>./node_modules/.bin/webpack</code> 就是一个可执行文件</li>\n<li>webpack、lodash 的版本号都被写在 package.json 里了</li>\n</ul>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html\" target=\"_blank\" rel=\"noopener\">读懂diff - 阮一峰</a></p>\n<h2 id=\"引用-jQuery\"><a href=\"#引用-jQuery\" class=\"headerlink\" title=\"引用 jQuery\"></a>引用 jQuery</h2><ul>\n<li><p><code>npm i -S jquery</code></p>\n<pre><code> import _ from &#39;lodash&#39;\n+import j from &#39;jquery&#39;\n\n function component () {\n-  var element = document.createElement(&#39;div&#39;);\n+  var element = j(&#39;&lt;div&gt;&lt;/div&gt;&#39;);\n\n   /* lodash is required for the next line to work */\n-  element.innerHTML = _.join([&#39;Hello&#39;,&#39;webpack&#39;], &#39; &#39;);\n+  element.html(_.join([&#39;Hello&#39;,&#39;webpack&#39;], &#39; &#39;))\n\n-  return element;\n+  return element.get(0);\n }\n\n document.body.appendChild(component());\n</code></pre></li>\n<li><p><code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code> 跑这句话</p>\n</li>\n<li><p>点击 commits 看看有什么变化</p>\n</li>\n<li><p>建议 index.js 改成 <code>console.log(1)</code> 然后运行 <code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code>，看看 bundle.js 和 index.js 的区别</p>\n</li>\n</ul>\n<h2 id=\"做一点改良\"><a href=\"#做一点改良\" class=\"headerlink\" title=\"做一点改良\"></a>做一点改良</h2><ul>\n<li><p>我们可以在根目录搞一个 <code>webpack.config.js</code>，在里面写上一点代码。</p>\n<pre><code>var path = require(&#39;path&#39;)\n\nmodule.exports = {\n    entry: &#39;./src/index.js&#39;,\n    output: {\n        filename: &#39;bundle.js&#39;,\n        path: path.resolve(__dirname, &#39;dist&#39;)\n    }\n}\n</code></pre><p>重点是这三个玩意 src/index.js 、dist 和 bundle.js 在哪就行，方便我们后面改。</p>\n</li>\n<li><p>然后我们就可以用上这句 <code>./node_modules/.bin/webpack --config webpack.config.js</code></p>\n</li>\n<li><p>或者我们可以进行下面的改良</p>\n<pre><code>  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;webpack&quot;: &quot;webpack&quot;\n  },\n  &quot;keywords&quot;: [],\n</code></pre><p>然后运行 npm run webpack</p>\n</li>\n</ul>\n<h2 id=\"尝试-import-一个自己的文件\"><a href=\"#尝试-import-一个自己的文件\" class=\"headerlink\" title=\"尝试 import 一个自己的文件\"></a>尝试 import 一个自己的文件</h2><ul>\n<li><p>创建一个 <code>foo.js</code></p>\n<pre><code>export default function(){\n    return &#39;tangkalun&#39;\n}\n</code></pre></li>\n<li><p>然后在 <code>index.js</code> 加上 <code>import foo from &#39;./foo&#39;</code>，顺便 <code>console.log</code> 一下</p>\n</li>\n<li><p><code>npm run webpack</code></p>\n</li>\n</ul>\n<h2 id=\"利用-webpack-压缩-JS-文件\"><a href=\"#利用-webpack-压缩-JS-文件\" class=\"headerlink\" title=\"利用 webpack 压缩 JS 文件\"></a>利用 webpack 压缩 JS 文件</h2><ul>\n<li><p><a href=\"https://webpack.js.org/guides/production/\" target=\"_blank\" rel=\"noopener\">webpack 自带的</a> 支持所有 <a href=\"https://github.com/mishoo/UglifyJS2#usage\" target=\"_blank\" rel=\"noopener\">UglifyJS 选项</a></p>\n</li>\n<li><p>在 <code>webpack.config.js</code> 加上这样一句话，UglifyJS 的选项可以一个都不加</p>\n<pre><code>var webpack = require(&#39;webpack&#39;);\n\nmodule.exports = {\n  /*...*/\n  plugins:[\n    new webpack.optimize.UglifyJsPlugin()\n  ]\n};\n</code></pre></li>\n<li><p><code>npm run webpack</code></p>\n</li>\n<li><p>压完了</p>\n</li>\n</ul>\n<h2 id=\"看看成果\"><a href=\"#看看成果\" class=\"headerlink\" title=\"看看成果\"></a>看看成果</h2><p><a href=\"https://github.com/FRANKIETANG/webpack-demo\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"摸到-webpack-的门把手\"><a href=\"#摸到-webpack-的门把手\" class=\"headerlink\" title=\"摸到 webpack 的门把手\"></a>摸到 webpack 的门把手</h1><p>之前接触过一阵子 webpack ，想了一下还是写篇博客吧。要不然又忘掉怎么配置了。</p>\n<h2 id=\"怎么安装？\"><a href=\"#怎么安装？\" class=\"headerlink\" title=\"怎么安装？\"></a>怎么安装？</h2><p><a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">来，我们先看 webpack 的官网</a></p>\n<p>点击到 guides ，我们直接抄，抄完我们就知道 webpack 的流程了</p>\n<p>不过有几点我们是要注意的</p>\n<ul>\n<li>注意 index.js 中的 <code>_.join</code>，这个 _ 实际上是 lodash 暴露的全局变量。</li>\n<li>为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。可以用 npm 装回来 <code>npm install --save lodash</code></li>\n<li>尽量运行 <code>./node_modules/.bin/webpack</code> </li>\n</ul>\n<h2 id=\"看看文件结构\"><a href=\"#看看文件结构\" class=\"headerlink\" title=\"看看文件结构\"></a>看看文件结构</h2><ul>\n<li><code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code> 将 src/index.js 变成 dist/bundle.js</li>\n<li>index.html 引用的是 dist/bundle.js</li>\n<li>lodash 被安装在 node_modules 里</li>\n<li>webpack 也被安装在 node_modules里，<code>./node_modules/.bin/webpack</code> 就是一个可执行文件</li>\n<li>webpack、lodash 的版本号都被写在 package.json 里了</li>\n</ul>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html\" target=\"_blank\" rel=\"noopener\">读懂diff - 阮一峰</a></p>\n<h2 id=\"引用-jQuery\"><a href=\"#引用-jQuery\" class=\"headerlink\" title=\"引用 jQuery\"></a>引用 jQuery</h2><ul>\n<li><p><code>npm i -S jquery</code></p>\n<pre><code> import _ from &#39;lodash&#39;\n+import j from &#39;jquery&#39;\n\n function component () {\n-  var element = document.createElement(&#39;div&#39;);\n+  var element = j(&#39;&lt;div&gt;&lt;/div&gt;&#39;);\n\n   /* lodash is required for the next line to work */\n-  element.innerHTML = _.join([&#39;Hello&#39;,&#39;webpack&#39;], &#39; &#39;);\n+  element.html(_.join([&#39;Hello&#39;,&#39;webpack&#39;], &#39; &#39;))\n\n-  return element;\n+  return element.get(0);\n }\n\n document.body.appendChild(component());\n</code></pre></li>\n<li><p><code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code> 跑这句话</p>\n</li>\n<li><p>点击 commits 看看有什么变化</p>\n</li>\n<li><p>建议 index.js 改成 <code>console.log(1)</code> 然后运行 <code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code>，看看 bundle.js 和 index.js 的区别</p>\n</li>\n</ul>\n<h2 id=\"做一点改良\"><a href=\"#做一点改良\" class=\"headerlink\" title=\"做一点改良\"></a>做一点改良</h2><ul>\n<li><p>我们可以在根目录搞一个 <code>webpack.config.js</code>，在里面写上一点代码。</p>\n<pre><code>var path = require(&#39;path&#39;)\n\nmodule.exports = {\n    entry: &#39;./src/index.js&#39;,\n    output: {\n        filename: &#39;bundle.js&#39;,\n        path: path.resolve(__dirname, &#39;dist&#39;)\n    }\n}\n</code></pre><p>重点是这三个玩意 src/index.js 、dist 和 bundle.js 在哪就行，方便我们后面改。</p>\n</li>\n<li><p>然后我们就可以用上这句 <code>./node_modules/.bin/webpack --config webpack.config.js</code></p>\n</li>\n<li><p>或者我们可以进行下面的改良</p>\n<pre><code>  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;webpack&quot;: &quot;webpack&quot;\n  },\n  &quot;keywords&quot;: [],\n</code></pre><p>然后运行 npm run webpack</p>\n</li>\n</ul>\n<h2 id=\"尝试-import-一个自己的文件\"><a href=\"#尝试-import-一个自己的文件\" class=\"headerlink\" title=\"尝试 import 一个自己的文件\"></a>尝试 import 一个自己的文件</h2><ul>\n<li><p>创建一个 <code>foo.js</code></p>\n<pre><code>export default function(){\n    return &#39;tangkalun&#39;\n}\n</code></pre></li>\n<li><p>然后在 <code>index.js</code> 加上 <code>import foo from &#39;./foo&#39;</code>，顺便 <code>console.log</code> 一下</p>\n</li>\n<li><p><code>npm run webpack</code></p>\n</li>\n</ul>\n<h2 id=\"利用-webpack-压缩-JS-文件\"><a href=\"#利用-webpack-压缩-JS-文件\" class=\"headerlink\" title=\"利用 webpack 压缩 JS 文件\"></a>利用 webpack 压缩 JS 文件</h2><ul>\n<li><p><a href=\"https://webpack.js.org/guides/production/\" target=\"_blank\" rel=\"noopener\">webpack 自带的</a> 支持所有 <a href=\"https://github.com/mishoo/UglifyJS2#usage\" target=\"_blank\" rel=\"noopener\">UglifyJS 选项</a></p>\n</li>\n<li><p>在 <code>webpack.config.js</code> 加上这样一句话，UglifyJS 的选项可以一个都不加</p>\n<pre><code>var webpack = require(&#39;webpack&#39;);\n\nmodule.exports = {\n  /*...*/\n  plugins:[\n    new webpack.optimize.UglifyJsPlugin()\n  ]\n};\n</code></pre></li>\n<li><p><code>npm run webpack</code></p>\n</li>\n<li><p>压完了</p>\n</li>\n</ul>\n<h2 id=\"看看成果\"><a href=\"#看看成果\" class=\"headerlink\" title=\"看看成果\"></a>看看成果</h2><p><a href=\"https://github.com/FRANKIETANG/webpack-demo\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n"},{"title":"用 Node 来搭建 HTTP 服务器","date":"2017-12-01T15:03:36.000Z","_content":"# 用 Node 来搭建 HTTP 服务器\n\nhttps://github.com/FRANKIETANG/simple-http-server\n\n可以点进去看 [commit](https://github.com/FRANKIETANG/simple-http-server/commits/master)\n\n## URL\n\n全称是 Uniform Resource Locator （唯一的资源定位器？），相当于一个地址。\n\n`Schema://Host:Port/Path?query#hash`\n\n> Schema => 协议\n>\n> Host => 主姓名\n>\n> Port => 端口号，比如 22 -> ssh | 80 -> http | 443 -> https | mongodb -> 27017\n>\n> Path => 路径\n>\n> query => 查询字符串\n>\n> hash => 哈希\n\n``` \n// 举个例子\nconst url = `address://nanshan.shenzhen.china/shennandadao/10869`\n// 地址是://南山.深圳.中国/深南大道/10869号\n// Host:Port 可以写 IP 地址或者域名\n// 域名 -> DNS (去 google)\n```\n\n### 举一个简单的例子\n\n[vscode 断点调试](https://segmentfault.com/a/1190000009084576)\n\n最好用 **postman**，浏览器好像只支持 get 请求。\n\n```\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n\n    // console.log(url)\n\n    let responseStr // 定义返回字符串，收到 url 做出不同的返回值\n\n    if (url.indexOf('/hello') > -1) { // 记得加前缀 /\n        responseStr = 'hi there'\n        if (query.i_need_money === 'true' && Number(query.how_much) > 500) {  // 这里做一个判断他是不是要钱，值得一提的是这里这个 'true'，因为这里是没有类型的所以要用这个 'true'\n            responseStr = 'go away'\n        } else {\n            responseStr = 'ok, here you are'\n        }\n    } else if (url.indexOf('/bye') > -1) {  // 也可以用正则，不过如果写不好就会比 indexOf 要慢很多很多...\n        responseStr = 'see ya next time'\n    } else {\n        responseStr = 'i cant understand what you are saying'\n    }\n\n    response.statusCode = 200\n    response.end(responseStr)\n    // response.end('this is my first http server')\n})\n```\n\n```\n// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/hello  // GET hi there | 后台 /hello\nlocalhost:8282/bye  // GET see ya next time | 后台 /bye\nlocalhost:8282/  // GET i cant understand what you are saying | 后台 /\n\n// 加上 query\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 /hello?i_need_money=true\n\n// 引入 querystring 模块后再打印\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 { i_need_money: 'true' }\nlocalhost:8282/hello?i_need_money=true&how_much=1000  // GET i cant understand what you are saying | 后台 { i_need_money: 'true', how_much: '1000' }\n\n// hello 模块做好判断后\nlocalhost:8282/hello?i_need_money=true&how_much=1000  // GET go away | 后台 { i_need_money: 'true', how_much: '1000' }\nlocalhost:8282/hello?i_need_money=true&how_much=300  // GET ok, here you are | 后台 { i_need_money: 'true', how_much: '300' }\n```\n\n## HTTP\n\n以百度为例子\n\n![](https://us1.myximage.com/2017/11/30/10814fc32bca783917e30c6f8245b5e5.png)\n\n>HTTP 请求第一部分（第一行）  `GET /index/ HTTP/1.1`  什么方法 | 什么路径 | 什么 HTTP 版本 \n>\n>- HTTP 方法 => GET POST PATCH PUT DELETE OPTIONS HEAD\n>- 比如 `path: /user get:获取所有用户 | post:创建用户 | patch:修改用户信息 | put:创建 | delete:删除 | options:列举可进行的操作 | head:返回 head 信息 `\n>\n>HTTP 请求头 第二行到空行之前 重要的键值对有 Content-Type: 请求体的类型（编码、格式）Content-Length: 请求体的长度  Accept: 能够接收的返回体类型  Cookie: cookie 有多个键值对，中间有个等号，以分号为分隔符\n>\n>HTTP 请求体和请求头以一个空行作为分隔符\n>\n>HTTP 第三部分  请求体 http-request / response-body\n\n### 举一个简单的例子\n\n[vscode 断点调试](https://segmentfault.com/a/1190000009084576)\n\n最好用 **postman**，浏览器好像只支持 get 请求。\n\n```\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    // console.log(query)\n    // console.log(url)\n    // console.log(path)\n\n    // 做一个请求例子\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n```\n// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/user?frankie=1  // GET [] 因为是第一次请求所以user什么都没有\n\n// 文字太难表达了...看下面动图吧\n// 也就是通过post创建的用户\n```\n\n![](https://us1.myximage.com/2017/11/30/07c50f626d106f548a94d6a079a69ac6.gif)\n\n```\n// 通过发送 json 定义用户\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n                    const contentType = request.headers['content-type']  // 看请求头的属性\n\n                    if (contentType !== 'application/json') {  // 不是json就400\n                        response.statusCode = 400\n                        response.end('error')\n                    }\n\n                    let requestBodyStr = ''\n                    request.on('data', (data) => {\n                        requestBodyStr += data.toString()  // 把json变成字符串\n                    })\n                    request.on('end', () => {\n                        const user = JSON.parse(requestBodyStr)  // 解析josn字符串\n                        users.push(user)\n                        response.statusCode = 200\n                        response.end(JSON.stringify(user))\n                    })\n\n                    // const user = { name: Math.floor(Math.random() * 100) }\n                    // users.push(user)\n                    // response.statusCode = 200\n                    // response.end(JSON.stringify(user))\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n![](https://us1.myximage.com/2017/11/30/f0f0708a615d98816c5dfac1a6188a49.gif)\n\n### 请求体\n\n请求体的格式、编码通常由请求头里的 Content-type 指定，可能会很大（例如 form 格式可以请求 flie，分分钟 几十兆几百兆）（关键词 Buffer，一次吃不下我就一口一口吃）\n\n```\n// 把上面那段代码改一下\n\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n                    const contentType = request.headers['content-type'] // 看请求头的属性\n\n                    if (contentType !== 'application/json') { // 不是json就400\n                        response.statusCode = 400\n                        response.end('error')\n                    }\n\n                    let requestBodyStr = ''\n                    request.on('data', (data) => { // 当这个请求收到数据的时候\n                        console.log(data) // 看看 data \n                    })\n                    request.on('end', () => { // 当发过来的这个请求体已经结束的时候\n                        response.end('done')\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n然后发点数据\n\n![](https://us1.myximage.com/2017/12/01/e73caf3a3b4d360703165be09147afea.gif)\n\n可以看到是一个 `<Buffer>` 这个其实相当于吃了一小口，那我试试传个大家伙\n\n```\n// 再修改一下代码\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n                    const contentType = request.headers['content-type'] // 看请求头的属性\n\n                    // if (contentType !== 'application/json') { // 不是json就400\n                    //     response.statusCode = 400\n                    //     response.end('error')\n                    // }\n\n                    let dataCount = 0\n                    let requestBodyStr = ''\n                    request.on('data', (data) => { // 当这个请求收到数据的时候\n                        dataCount++\n                        console.log(data)\n                    })\n                    request.on('end', () => { // 当发过来的这个请求体已经结束的时候\n                        console.log(dataCount) // 看看一个文件要吃多少口\n                        response.end(dataCount + '')\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n然后发个算大的文件（48M）\n\n![](https://us1.myximage.com/2017/12/01/fcc0ec6f09967d75f4e2fdfdd6475138.gif)\n\n也就是说这个大东西吃了 873 口\n\n## 假如用 Express 搭服务器\n\n先看看 bin/www 的代码\n\n```\n// 7行和9行\nvar app = require('../app');  // 定义各种路由\nvar http = require('http');  // 引入http模块\n\n// 28行\nserver.listen(port);  // 定义端口号\n```\n\n怎么把刚刚我上面实现的效果用 Express 框架做出来呢？\n\n```\n// app.js 26行改成\napp.use('/user', users);\n\n// 打开 routes 的 users.js，修改成\nvar express = require('express')\nvar router = express.Router()\n\nconst users = []\n\n/* GET users listing. */\nrouter.route('/')\n  .get((req, res, next) => {\n    res.json(users)\n  })\n  .post((req, res)=>{\n    const user = req.body\n    users.push(user)\n    res.json(user)\n  })\n\nmodule.exports = router\n```\n\n![](https://us1.myximage.com/2017/12/01/0eda1fdee399f2d5f16acd525d5f469a.gif)\n\n其实框架还是解决了很多自己写东西的细节，像什么判断啊，转码啊啥的。那就可以不用管那么多直接写业务逻辑。\n\n## 彩蛋\n\n### 命令行神器\n\n又发现了个命令行神器..\n\n[oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n\n### 前端发送表单发送的数据-后端处理的方式\n\n[commit - form data](https://github.com/FRANKIETANG/simple-http-server/commit/4366e9a1cc5506c7291b3550aa1ec2843644e817)\n\n![](https://us1.myximage.com/2017/12/01/ca7f44d9c3c761bca5d419204b5a5ff0.gif)\n\n拿到数据了...（请忽略我的 JSON 报错）\n\n[commit - querystring replace JSON](https://github.com/FRANKIETANG/simple-http-server/commit/1fdc106bf64cb242d53008b4f93b5c86b53af408)\n\n![](https://us1.myximage.com/2017/12/01/6a58999accae3fe5bcac42cb90ce1400.gif)\n\n### 如何做请求缓存\n\n就是收到第二次同样的请求返回一样的内容（先留个坑吧...）\n\n- 浏览器缓存\n- 服务端缓存","source":"_posts/用 Node 来搭建 HTTP 服务器.md","raw":"---\ntitle: 用 Node 来搭建 HTTP 服务器\ndate: 2017-12-01 23:03:36\ntags: [Node,HTTP]\n---\n# 用 Node 来搭建 HTTP 服务器\n\nhttps://github.com/FRANKIETANG/simple-http-server\n\n可以点进去看 [commit](https://github.com/FRANKIETANG/simple-http-server/commits/master)\n\n## URL\n\n全称是 Uniform Resource Locator （唯一的资源定位器？），相当于一个地址。\n\n`Schema://Host:Port/Path?query#hash`\n\n> Schema => 协议\n>\n> Host => 主姓名\n>\n> Port => 端口号，比如 22 -> ssh | 80 -> http | 443 -> https | mongodb -> 27017\n>\n> Path => 路径\n>\n> query => 查询字符串\n>\n> hash => 哈希\n\n``` \n// 举个例子\nconst url = `address://nanshan.shenzhen.china/shennandadao/10869`\n// 地址是://南山.深圳.中国/深南大道/10869号\n// Host:Port 可以写 IP 地址或者域名\n// 域名 -> DNS (去 google)\n```\n\n### 举一个简单的例子\n\n[vscode 断点调试](https://segmentfault.com/a/1190000009084576)\n\n最好用 **postman**，浏览器好像只支持 get 请求。\n\n```\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n\n    // console.log(url)\n\n    let responseStr // 定义返回字符串，收到 url 做出不同的返回值\n\n    if (url.indexOf('/hello') > -1) { // 记得加前缀 /\n        responseStr = 'hi there'\n        if (query.i_need_money === 'true' && Number(query.how_much) > 500) {  // 这里做一个判断他是不是要钱，值得一提的是这里这个 'true'，因为这里是没有类型的所以要用这个 'true'\n            responseStr = 'go away'\n        } else {\n            responseStr = 'ok, here you are'\n        }\n    } else if (url.indexOf('/bye') > -1) {  // 也可以用正则，不过如果写不好就会比 indexOf 要慢很多很多...\n        responseStr = 'see ya next time'\n    } else {\n        responseStr = 'i cant understand what you are saying'\n    }\n\n    response.statusCode = 200\n    response.end(responseStr)\n    // response.end('this is my first http server')\n})\n```\n\n```\n// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/hello  // GET hi there | 后台 /hello\nlocalhost:8282/bye  // GET see ya next time | 后台 /bye\nlocalhost:8282/  // GET i cant understand what you are saying | 后台 /\n\n// 加上 query\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 /hello?i_need_money=true\n\n// 引入 querystring 模块后再打印\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 { i_need_money: 'true' }\nlocalhost:8282/hello?i_need_money=true&how_much=1000  // GET i cant understand what you are saying | 后台 { i_need_money: 'true', how_much: '1000' }\n\n// hello 模块做好判断后\nlocalhost:8282/hello?i_need_money=true&how_much=1000  // GET go away | 后台 { i_need_money: 'true', how_much: '1000' }\nlocalhost:8282/hello?i_need_money=true&how_much=300  // GET ok, here you are | 后台 { i_need_money: 'true', how_much: '300' }\n```\n\n## HTTP\n\n以百度为例子\n\n![](https://us1.myximage.com/2017/11/30/10814fc32bca783917e30c6f8245b5e5.png)\n\n>HTTP 请求第一部分（第一行）  `GET /index/ HTTP/1.1`  什么方法 | 什么路径 | 什么 HTTP 版本 \n>\n>- HTTP 方法 => GET POST PATCH PUT DELETE OPTIONS HEAD\n>- 比如 `path: /user get:获取所有用户 | post:创建用户 | patch:修改用户信息 | put:创建 | delete:删除 | options:列举可进行的操作 | head:返回 head 信息 `\n>\n>HTTP 请求头 第二行到空行之前 重要的键值对有 Content-Type: 请求体的类型（编码、格式）Content-Length: 请求体的长度  Accept: 能够接收的返回体类型  Cookie: cookie 有多个键值对，中间有个等号，以分号为分隔符\n>\n>HTTP 请求体和请求头以一个空行作为分隔符\n>\n>HTTP 第三部分  请求体 http-request / response-body\n\n### 举一个简单的例子\n\n[vscode 断点调试](https://segmentfault.com/a/1190000009084576)\n\n最好用 **postman**，浏览器好像只支持 get 请求。\n\n```\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    // console.log(query)\n    // console.log(url)\n    // console.log(path)\n\n    // 做一个请求例子\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n```\n// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/user?frankie=1  // GET [] 因为是第一次请求所以user什么都没有\n\n// 文字太难表达了...看下面动图吧\n// 也就是通过post创建的用户\n```\n\n![](https://us1.myximage.com/2017/11/30/07c50f626d106f548a94d6a079a69ac6.gif)\n\n```\n// 通过发送 json 定义用户\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n                    const contentType = request.headers['content-type']  // 看请求头的属性\n\n                    if (contentType !== 'application/json') {  // 不是json就400\n                        response.statusCode = 400\n                        response.end('error')\n                    }\n\n                    let requestBodyStr = ''\n                    request.on('data', (data) => {\n                        requestBodyStr += data.toString()  // 把json变成字符串\n                    })\n                    request.on('end', () => {\n                        const user = JSON.parse(requestBodyStr)  // 解析josn字符串\n                        users.push(user)\n                        response.statusCode = 200\n                        response.end(JSON.stringify(user))\n                    })\n\n                    // const user = { name: Math.floor(Math.random() * 100) }\n                    // users.push(user)\n                    // response.statusCode = 200\n                    // response.end(JSON.stringify(user))\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n![](https://us1.myximage.com/2017/11/30/f0f0708a615d98816c5dfac1a6188a49.gif)\n\n### 请求体\n\n请求体的格式、编码通常由请求头里的 Content-type 指定，可能会很大（例如 form 格式可以请求 flie，分分钟 几十兆几百兆）（关键词 Buffer，一次吃不下我就一口一口吃）\n\n```\n// 把上面那段代码改一下\n\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n                    const contentType = request.headers['content-type'] // 看请求头的属性\n\n                    if (contentType !== 'application/json') { // 不是json就400\n                        response.statusCode = 400\n                        response.end('error')\n                    }\n\n                    let requestBodyStr = ''\n                    request.on('data', (data) => { // 当这个请求收到数据的时候\n                        console.log(data) // 看看 data \n                    })\n                    request.on('end', () => { // 当发过来的这个请求体已经结束的时候\n                        response.end('done')\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n然后发点数据\n\n![](https://us1.myximage.com/2017/12/01/e73caf3a3b4d360703165be09147afea.gif)\n\n可以看到是一个 `<Buffer>` 这个其实相当于吃了一小口，那我试试传个大家伙\n\n```\n// 再修改一下代码\nconst http = require('http') // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require('querystring') // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on('request', (request, response) => { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf('?'))\n\n    const queryString = url.substr(url.indexOf('?') + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case '/user':\n            switch (request.method) {\n                case 'GET':\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case 'POST':\n                    const contentType = request.headers['content-type'] // 看请求头的属性\n\n                    // if (contentType !== 'application/json') { // 不是json就400\n                    //     response.statusCode = 400\n                    //     response.end('error')\n                    // }\n\n                    let dataCount = 0\n                    let requestBodyStr = ''\n                    request.on('data', (data) => { // 当这个请求收到数据的时候\n                        dataCount++\n                        console.log(data)\n                    })\n                    request.on('end', () => { // 当发过来的这个请求体已经结束的时候\n                        console.log(dataCount) // 看看一个文件要吃多少口\n                        response.end(dataCount + '')\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end('NOT_FOUND')\n            break\n    }\n\n})\n```\n\n然后发个算大的文件（48M）\n\n![](https://us1.myximage.com/2017/12/01/fcc0ec6f09967d75f4e2fdfdd6475138.gif)\n\n也就是说这个大东西吃了 873 口\n\n## 假如用 Express 搭服务器\n\n先看看 bin/www 的代码\n\n```\n// 7行和9行\nvar app = require('../app');  // 定义各种路由\nvar http = require('http');  // 引入http模块\n\n// 28行\nserver.listen(port);  // 定义端口号\n```\n\n怎么把刚刚我上面实现的效果用 Express 框架做出来呢？\n\n```\n// app.js 26行改成\napp.use('/user', users);\n\n// 打开 routes 的 users.js，修改成\nvar express = require('express')\nvar router = express.Router()\n\nconst users = []\n\n/* GET users listing. */\nrouter.route('/')\n  .get((req, res, next) => {\n    res.json(users)\n  })\n  .post((req, res)=>{\n    const user = req.body\n    users.push(user)\n    res.json(user)\n  })\n\nmodule.exports = router\n```\n\n![](https://us1.myximage.com/2017/12/01/0eda1fdee399f2d5f16acd525d5f469a.gif)\n\n其实框架还是解决了很多自己写东西的细节，像什么判断啊，转码啊啥的。那就可以不用管那么多直接写业务逻辑。\n\n## 彩蛋\n\n### 命令行神器\n\n又发现了个命令行神器..\n\n[oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n\n### 前端发送表单发送的数据-后端处理的方式\n\n[commit - form data](https://github.com/FRANKIETANG/simple-http-server/commit/4366e9a1cc5506c7291b3550aa1ec2843644e817)\n\n![](https://us1.myximage.com/2017/12/01/ca7f44d9c3c761bca5d419204b5a5ff0.gif)\n\n拿到数据了...（请忽略我的 JSON 报错）\n\n[commit - querystring replace JSON](https://github.com/FRANKIETANG/simple-http-server/commit/1fdc106bf64cb242d53008b4f93b5c86b53af408)\n\n![](https://us1.myximage.com/2017/12/01/6a58999accae3fe5bcac42cb90ce1400.gif)\n\n### 如何做请求缓存\n\n就是收到第二次同样的请求返回一样的内容（先留个坑吧...）\n\n- 浏览器缓存\n- 服务端缓存","slug":"用 Node 来搭建 HTTP 服务器","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d900012f1xhaeg4kdak","content":"<h1 id=\"用-Node-来搭建-HTTP-服务器\"><a href=\"#用-Node-来搭建-HTTP-服务器\" class=\"headerlink\" title=\"用 Node 来搭建 HTTP 服务器\"></a>用 Node 来搭建 HTTP 服务器</h1><p><a href=\"https://github.com/FRANKIETANG/simple-http-server\" target=\"_blank\" rel=\"noopener\">https://github.com/FRANKIETANG/simple-http-server</a></p>\n<p>可以点进去看 <a href=\"https://github.com/FRANKIETANG/simple-http-server/commits/master\" target=\"_blank\" rel=\"noopener\">commit</a></p>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>全称是 Uniform Resource Locator （唯一的资源定位器？），相当于一个地址。</p>\n<p><code>Schema://Host:Port/Path?query#hash</code></p>\n<blockquote>\n<p>Schema =&gt; 协议</p>\n<p>Host =&gt; 主姓名</p>\n<p>Port =&gt; 端口号，比如 22 -&gt; ssh | 80 -&gt; http | 443 -&gt; https | mongodb -&gt; 27017</p>\n<p>Path =&gt; 路径</p>\n<p>query =&gt; 查询字符串</p>\n<p>hash =&gt; 哈希</p>\n</blockquote>\n<pre><code>// 举个例子\nconst url = `address://nanshan.shenzhen.china/shennandadao/10869`\n// 地址是://南山.深圳.中国/深南大道/10869号\n// Host:Port 可以写 IP 地址或者域名\n// 域名 -&gt; DNS (去 google)\n</code></pre><h3 id=\"举一个简单的例子\"><a href=\"#举一个简单的例子\" class=\"headerlink\" title=\"举一个简单的例子\"></a>举一个简单的例子</h3><p><a href=\"https://segmentfault.com/a/1190000009084576\" target=\"_blank\" rel=\"noopener\">vscode 断点调试</a></p>\n<p>最好用 <strong>postman</strong>，浏览器好像只支持 get 请求。</p>\n<pre><code>const http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n\n    // console.log(url)\n\n    let responseStr // 定义返回字符串，收到 url 做出不同的返回值\n\n    if (url.indexOf(&#39;/hello&#39;) &gt; -1) { // 记得加前缀 /\n        responseStr = &#39;hi there&#39;\n        if (query.i_need_money === &#39;true&#39; &amp;&amp; Number(query.how_much) &gt; 500) {  // 这里做一个判断他是不是要钱，值得一提的是这里这个 &#39;true&#39;，因为这里是没有类型的所以要用这个 &#39;true&#39;\n            responseStr = &#39;go away&#39;\n        } else {\n            responseStr = &#39;ok, here you are&#39;\n        }\n    } else if (url.indexOf(&#39;/bye&#39;) &gt; -1) {  // 也可以用正则，不过如果写不好就会比 indexOf 要慢很多很多...\n        responseStr = &#39;see ya next time&#39;\n    } else {\n        responseStr = &#39;i cant understand what you are saying&#39;\n    }\n\n    response.statusCode = 200\n    response.end(responseStr)\n    // response.end(&#39;this is my first http server&#39;)\n})\n</code></pre><pre><code>// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/hello  // GET hi there | 后台 /hello\nlocalhost:8282/bye  // GET see ya next time | 后台 /bye\nlocalhost:8282/  // GET i cant understand what you are saying | 后台 /\n\n// 加上 query\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 /hello?i_need_money=true\n\n// 引入 querystring 模块后再打印\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 { i_need_money: &#39;true&#39; }\nlocalhost:8282/hello?i_need_money=true&amp;how_much=1000  // GET i cant understand what you are saying | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;1000&#39; }\n\n// hello 模块做好判断后\nlocalhost:8282/hello?i_need_money=true&amp;how_much=1000  // GET go away | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;1000&#39; }\nlocalhost:8282/hello?i_need_money=true&amp;how_much=300  // GET ok, here you are | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;300&#39; }\n</code></pre><h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p>以百度为例子</p>\n<p><img src=\"https://us1.myximage.com/2017/11/30/10814fc32bca783917e30c6f8245b5e5.png\" alt=\"\"></p>\n<blockquote>\n<p>HTTP 请求第一部分（第一行）  <code>GET /index/ HTTP/1.1</code>  什么方法 | 什么路径 | 什么 HTTP 版本 </p>\n<ul>\n<li>HTTP 方法 =&gt; GET POST PATCH PUT DELETE OPTIONS HEAD</li>\n<li>比如 <code>path: /user get:获取所有用户 | post:创建用户 | patch:修改用户信息 | put:创建 | delete:删除 | options:列举可进行的操作 | head:返回 head 信息</code></li>\n</ul>\n<p>HTTP 请求头 第二行到空行之前 重要的键值对有 Content-Type: 请求体的类型（编码、格式）Content-Length: 请求体的长度  Accept: 能够接收的返回体类型  Cookie: cookie 有多个键值对，中间有个等号，以分号为分隔符</p>\n<p>HTTP 请求体和请求头以一个空行作为分隔符</p>\n<p>HTTP 第三部分  请求体 http-request / response-body</p>\n</blockquote>\n<h3 id=\"举一个简单的例子-1\"><a href=\"#举一个简单的例子-1\" class=\"headerlink\" title=\"举一个简单的例子\"></a>举一个简单的例子</h3><p><a href=\"https://segmentfault.com/a/1190000009084576\" target=\"_blank\" rel=\"noopener\">vscode 断点调试</a></p>\n<p>最好用 <strong>postman</strong>，浏览器好像只支持 get 请求。</p>\n<pre><code>const http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    // console.log(query)\n    // console.log(url)\n    // console.log(path)\n\n    // 做一个请求例子\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><pre><code>// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/user?frankie=1  // GET [] 因为是第一次请求所以user什么都没有\n\n// 文字太难表达了...看下面动图吧\n// 也就是通过post创建的用户\n</code></pre><p><img src=\"https://us1.myximage.com/2017/11/30/07c50f626d106f548a94d6a079a69ac6.gif\" alt=\"\"></p>\n<pre><code>// 通过发送 json 定义用户\nconst http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n                    const contentType = request.headers[&#39;content-type&#39;]  // 看请求头的属性\n\n                    if (contentType !== &#39;application/json&#39;) {  // 不是json就400\n                        response.statusCode = 400\n                        response.end(&#39;error&#39;)\n                    }\n\n                    let requestBodyStr = &#39;&#39;\n                    request.on(&#39;data&#39;, (data) =&gt; {\n                        requestBodyStr += data.toString()  // 把json变成字符串\n                    })\n                    request.on(&#39;end&#39;, () =&gt; {\n                        const user = JSON.parse(requestBodyStr)  // 解析josn字符串\n                        users.push(user)\n                        response.statusCode = 200\n                        response.end(JSON.stringify(user))\n                    })\n\n                    // const user = { name: Math.floor(Math.random() * 100) }\n                    // users.push(user)\n                    // response.statusCode = 200\n                    // response.end(JSON.stringify(user))\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/11/30/f0f0708a615d98816c5dfac1a6188a49.gif\" alt=\"\"></p>\n<h3 id=\"请求体\"><a href=\"#请求体\" class=\"headerlink\" title=\"请求体\"></a>请求体</h3><p>请求体的格式、编码通常由请求头里的 Content-type 指定，可能会很大（例如 form 格式可以请求 flie，分分钟 几十兆几百兆）（关键词 Buffer，一次吃不下我就一口一口吃）</p>\n<pre><code>// 把上面那段代码改一下\n\nconst http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n                    const contentType = request.headers[&#39;content-type&#39;] // 看请求头的属性\n\n                    if (contentType !== &#39;application/json&#39;) { // 不是json就400\n                        response.statusCode = 400\n                        response.end(&#39;error&#39;)\n                    }\n\n                    let requestBodyStr = &#39;&#39;\n                    request.on(&#39;data&#39;, (data) =&gt; { // 当这个请求收到数据的时候\n                        console.log(data) // 看看 data \n                    })\n                    request.on(&#39;end&#39;, () =&gt; { // 当发过来的这个请求体已经结束的时候\n                        response.end(&#39;done&#39;)\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><p>然后发点数据</p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/e73caf3a3b4d360703165be09147afea.gif\" alt=\"\"></p>\n<p>可以看到是一个 <code>&lt;Buffer&gt;</code> 这个其实相当于吃了一小口，那我试试传个大家伙</p>\n<pre><code>// 再修改一下代码\nconst http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n                    const contentType = request.headers[&#39;content-type&#39;] // 看请求头的属性\n\n                    // if (contentType !== &#39;application/json&#39;) { // 不是json就400\n                    //     response.statusCode = 400\n                    //     response.end(&#39;error&#39;)\n                    // }\n\n                    let dataCount = 0\n                    let requestBodyStr = &#39;&#39;\n                    request.on(&#39;data&#39;, (data) =&gt; { // 当这个请求收到数据的时候\n                        dataCount++\n                        console.log(data)\n                    })\n                    request.on(&#39;end&#39;, () =&gt; { // 当发过来的这个请求体已经结束的时候\n                        console.log(dataCount) // 看看一个文件要吃多少口\n                        response.end(dataCount + &#39;&#39;)\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><p>然后发个算大的文件（48M）</p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/fcc0ec6f09967d75f4e2fdfdd6475138.gif\" alt=\"\"></p>\n<p>也就是说这个大东西吃了 873 口</p>\n<h2 id=\"假如用-Express-搭服务器\"><a href=\"#假如用-Express-搭服务器\" class=\"headerlink\" title=\"假如用 Express 搭服务器\"></a>假如用 Express 搭服务器</h2><p>先看看 bin/www 的代码</p>\n<pre><code>// 7行和9行\nvar app = require(&#39;../app&#39;);  // 定义各种路由\nvar http = require(&#39;http&#39;);  // 引入http模块\n\n// 28行\nserver.listen(port);  // 定义端口号\n</code></pre><p>怎么把刚刚我上面实现的效果用 Express 框架做出来呢？</p>\n<pre><code>// app.js 26行改成\napp.use(&#39;/user&#39;, users);\n\n// 打开 routes 的 users.js，修改成\nvar express = require(&#39;express&#39;)\nvar router = express.Router()\n\nconst users = []\n\n/* GET users listing. */\nrouter.route(&#39;/&#39;)\n  .get((req, res, next) =&gt; {\n    res.json(users)\n  })\n  .post((req, res)=&gt;{\n    const user = req.body\n    users.push(user)\n    res.json(user)\n  })\n\nmodule.exports = router\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/01/0eda1fdee399f2d5f16acd525d5f469a.gif\" alt=\"\"></p>\n<p>其实框架还是解决了很多自己写东西的细节，像什么判断啊，转码啊啥的。那就可以不用管那么多直接写业务逻辑。</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><h3 id=\"命令行神器\"><a href=\"#命令行神器\" class=\"headerlink\" title=\"命令行神器\"></a>命令行神器</h3><p>又发现了个命令行神器..</p>\n<p><a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">oh-my-zsh</a></p>\n<h3 id=\"前端发送表单发送的数据-后端处理的方式\"><a href=\"#前端发送表单发送的数据-后端处理的方式\" class=\"headerlink\" title=\"前端发送表单发送的数据-后端处理的方式\"></a>前端发送表单发送的数据-后端处理的方式</h3><p><a href=\"https://github.com/FRANKIETANG/simple-http-server/commit/4366e9a1cc5506c7291b3550aa1ec2843644e817\" target=\"_blank\" rel=\"noopener\">commit - form data</a></p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/ca7f44d9c3c761bca5d419204b5a5ff0.gif\" alt=\"\"></p>\n<p>拿到数据了…（请忽略我的 JSON 报错）</p>\n<p><a href=\"https://github.com/FRANKIETANG/simple-http-server/commit/1fdc106bf64cb242d53008b4f93b5c86b53af408\" target=\"_blank\" rel=\"noopener\">commit - querystring replace JSON</a></p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/6a58999accae3fe5bcac42cb90ce1400.gif\" alt=\"\"></p>\n<h3 id=\"如何做请求缓存\"><a href=\"#如何做请求缓存\" class=\"headerlink\" title=\"如何做请求缓存\"></a>如何做请求缓存</h3><p>就是收到第二次同样的请求返回一样的内容（先留个坑吧…）</p>\n<ul>\n<li>浏览器缓存</li>\n<li>服务端缓存</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"用-Node-来搭建-HTTP-服务器\"><a href=\"#用-Node-来搭建-HTTP-服务器\" class=\"headerlink\" title=\"用 Node 来搭建 HTTP 服务器\"></a>用 Node 来搭建 HTTP 服务器</h1><p><a href=\"https://github.com/FRANKIETANG/simple-http-server\" target=\"_blank\" rel=\"noopener\">https://github.com/FRANKIETANG/simple-http-server</a></p>\n<p>可以点进去看 <a href=\"https://github.com/FRANKIETANG/simple-http-server/commits/master\" target=\"_blank\" rel=\"noopener\">commit</a></p>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>全称是 Uniform Resource Locator （唯一的资源定位器？），相当于一个地址。</p>\n<p><code>Schema://Host:Port/Path?query#hash</code></p>\n<blockquote>\n<p>Schema =&gt; 协议</p>\n<p>Host =&gt; 主姓名</p>\n<p>Port =&gt; 端口号，比如 22 -&gt; ssh | 80 -&gt; http | 443 -&gt; https | mongodb -&gt; 27017</p>\n<p>Path =&gt; 路径</p>\n<p>query =&gt; 查询字符串</p>\n<p>hash =&gt; 哈希</p>\n</blockquote>\n<pre><code>// 举个例子\nconst url = `address://nanshan.shenzhen.china/shennandadao/10869`\n// 地址是://南山.深圳.中国/深南大道/10869号\n// Host:Port 可以写 IP 地址或者域名\n// 域名 -&gt; DNS (去 google)\n</code></pre><h3 id=\"举一个简单的例子\"><a href=\"#举一个简单的例子\" class=\"headerlink\" title=\"举一个简单的例子\"></a>举一个简单的例子</h3><p><a href=\"https://segmentfault.com/a/1190000009084576\" target=\"_blank\" rel=\"noopener\">vscode 断点调试</a></p>\n<p>最好用 <strong>postman</strong>，浏览器好像只支持 get 请求。</p>\n<pre><code>const http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n\n    // console.log(url)\n\n    let responseStr // 定义返回字符串，收到 url 做出不同的返回值\n\n    if (url.indexOf(&#39;/hello&#39;) &gt; -1) { // 记得加前缀 /\n        responseStr = &#39;hi there&#39;\n        if (query.i_need_money === &#39;true&#39; &amp;&amp; Number(query.how_much) &gt; 500) {  // 这里做一个判断他是不是要钱，值得一提的是这里这个 &#39;true&#39;，因为这里是没有类型的所以要用这个 &#39;true&#39;\n            responseStr = &#39;go away&#39;\n        } else {\n            responseStr = &#39;ok, here you are&#39;\n        }\n    } else if (url.indexOf(&#39;/bye&#39;) &gt; -1) {  // 也可以用正则，不过如果写不好就会比 indexOf 要慢很多很多...\n        responseStr = &#39;see ya next time&#39;\n    } else {\n        responseStr = &#39;i cant understand what you are saying&#39;\n    }\n\n    response.statusCode = 200\n    response.end(responseStr)\n    // response.end(&#39;this is my first http server&#39;)\n})\n</code></pre><pre><code>// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/hello  // GET hi there | 后台 /hello\nlocalhost:8282/bye  // GET see ya next time | 后台 /bye\nlocalhost:8282/  // GET i cant understand what you are saying | 后台 /\n\n// 加上 query\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 /hello?i_need_money=true\n\n// 引入 querystring 模块后再打印\nlocalhost:8282/hello?i_need_money=true  // GET i cant understand what you are saying | 后台 { i_need_money: &#39;true&#39; }\nlocalhost:8282/hello?i_need_money=true&amp;how_much=1000  // GET i cant understand what you are saying | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;1000&#39; }\n\n// hello 模块做好判断后\nlocalhost:8282/hello?i_need_money=true&amp;how_much=1000  // GET go away | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;1000&#39; }\nlocalhost:8282/hello?i_need_money=true&amp;how_much=300  // GET ok, here you are | 后台 { i_need_money: &#39;true&#39;, how_much: &#39;300&#39; }\n</code></pre><h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p>以百度为例子</p>\n<p><img src=\"https://us1.myximage.com/2017/11/30/10814fc32bca783917e30c6f8245b5e5.png\" alt=\"\"></p>\n<blockquote>\n<p>HTTP 请求第一部分（第一行）  <code>GET /index/ HTTP/1.1</code>  什么方法 | 什么路径 | 什么 HTTP 版本 </p>\n<ul>\n<li>HTTP 方法 =&gt; GET POST PATCH PUT DELETE OPTIONS HEAD</li>\n<li>比如 <code>path: /user get:获取所有用户 | post:创建用户 | patch:修改用户信息 | put:创建 | delete:删除 | options:列举可进行的操作 | head:返回 head 信息</code></li>\n</ul>\n<p>HTTP 请求头 第二行到空行之前 重要的键值对有 Content-Type: 请求体的类型（编码、格式）Content-Length: 请求体的长度  Accept: 能够接收的返回体类型  Cookie: cookie 有多个键值对，中间有个等号，以分号为分隔符</p>\n<p>HTTP 请求体和请求头以一个空行作为分隔符</p>\n<p>HTTP 第三部分  请求体 http-request / response-body</p>\n</blockquote>\n<h3 id=\"举一个简单的例子-1\"><a href=\"#举一个简单的例子-1\" class=\"headerlink\" title=\"举一个简单的例子\"></a>举一个简单的例子</h3><p><a href=\"https://segmentfault.com/a/1190000009084576\" target=\"_blank\" rel=\"noopener\">vscode 断点调试</a></p>\n<p>最好用 <strong>postman</strong>，浏览器好像只支持 get 请求。</p>\n<pre><code>const http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    // console.log(query)\n    // console.log(url)\n    // console.log(path)\n\n    // 做一个请求例子\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><pre><code>// postman 的操作\n// 后台信息都是靠 console.log\n\nlocalhost:8282/user?frankie=1  // GET [] 因为是第一次请求所以user什么都没有\n\n// 文字太难表达了...看下面动图吧\n// 也就是通过post创建的用户\n</code></pre><p><img src=\"https://us1.myximage.com/2017/11/30/07c50f626d106f548a94d6a079a69ac6.gif\" alt=\"\"></p>\n<pre><code>// 通过发送 json 定义用户\nconst http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = [];  // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n                    const contentType = request.headers[&#39;content-type&#39;]  // 看请求头的属性\n\n                    if (contentType !== &#39;application/json&#39;) {  // 不是json就400\n                        response.statusCode = 400\n                        response.end(&#39;error&#39;)\n                    }\n\n                    let requestBodyStr = &#39;&#39;\n                    request.on(&#39;data&#39;, (data) =&gt; {\n                        requestBodyStr += data.toString()  // 把json变成字符串\n                    })\n                    request.on(&#39;end&#39;, () =&gt; {\n                        const user = JSON.parse(requestBodyStr)  // 解析josn字符串\n                        users.push(user)\n                        response.statusCode = 200\n                        response.end(JSON.stringify(user))\n                    })\n\n                    // const user = { name: Math.floor(Math.random() * 100) }\n                    // users.push(user)\n                    // response.statusCode = 200\n                    // response.end(JSON.stringify(user))\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><p><img src=\"https://us1.myximage.com/2017/11/30/f0f0708a615d98816c5dfac1a6188a49.gif\" alt=\"\"></p>\n<h3 id=\"请求体\"><a href=\"#请求体\" class=\"headerlink\" title=\"请求体\"></a>请求体</h3><p>请求体的格式、编码通常由请求头里的 Content-type 指定，可能会很大（例如 form 格式可以请求 flie，分分钟 几十兆几百兆）（关键词 Buffer，一次吃不下我就一口一口吃）</p>\n<pre><code>// 把上面那段代码改一下\n\nconst http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n                    const contentType = request.headers[&#39;content-type&#39;] // 看请求头的属性\n\n                    if (contentType !== &#39;application/json&#39;) { // 不是json就400\n                        response.statusCode = 400\n                        response.end(&#39;error&#39;)\n                    }\n\n                    let requestBodyStr = &#39;&#39;\n                    request.on(&#39;data&#39;, (data) =&gt; { // 当这个请求收到数据的时候\n                        console.log(data) // 看看 data \n                    })\n                    request.on(&#39;end&#39;, () =&gt; { // 当发过来的这个请求体已经结束的时候\n                        response.end(&#39;done&#39;)\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><p>然后发点数据</p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/e73caf3a3b4d360703165be09147afea.gif\" alt=\"\"></p>\n<p>可以看到是一个 <code>&lt;Buffer&gt;</code> 这个其实相当于吃了一小口，那我试试传个大家伙</p>\n<pre><code>// 再修改一下代码\nconst http = require(&#39;http&#39;) // http 模块是一定的\nconst server = http.createServer()\nserver.listen(8282)\nconst querystring = require(&#39;querystring&#39;) // 引入 querystring 模块用来看 url 的 query\n\nconst users = []; // 做一个全局数组\n\nserver.on(&#39;request&#39;, (request, response) =&gt; { // 受到请求后调用一次\n    // console.log(request.url)  // 这里会打印出 /，实际上是 url Path 后的东西，如果我在 loaclhost:8282 后面写上 show-me-something，后台就会返回 /show-me-something，再加点东西也是同理的\n    const url = request.url\n\n    const path = url.substr(0, url.indexOf(&#39;?&#39;))\n\n    const queryString = url.substr(url.indexOf(&#39;?&#39;) + 1, url.length)\n\n    const query = querystring.parse(queryString)\n\n    console.log(query)\n    console.log(url)\n    console.log(path)\n\n    // 做一个请求例子\n    // 其他方法也是一样的\n    switch (path) {\n        case &#39;/user&#39;:\n            switch (request.method) {\n                case &#39;GET&#39;:\n                    response.statusCode = 200\n                    response.end(JSON.stringify(users))\n                    break;\n                case &#39;POST&#39;:\n                    const contentType = request.headers[&#39;content-type&#39;] // 看请求头的属性\n\n                    // if (contentType !== &#39;application/json&#39;) { // 不是json就400\n                    //     response.statusCode = 400\n                    //     response.end(&#39;error&#39;)\n                    // }\n\n                    let dataCount = 0\n                    let requestBodyStr = &#39;&#39;\n                    request.on(&#39;data&#39;, (data) =&gt; { // 当这个请求收到数据的时候\n                        dataCount++\n                        console.log(data)\n                    })\n                    request.on(&#39;end&#39;, () =&gt; { // 当发过来的这个请求体已经结束的时候\n                        console.log(dataCount) // 看看一个文件要吃多少口\n                        response.end(dataCount + &#39;&#39;)\n                    })\n                    break\n            }\n            break\n        default:\n            response.statusCode = 404\n            response.end(&#39;NOT_FOUND&#39;)\n            break\n    }\n\n})\n</code></pre><p>然后发个算大的文件（48M）</p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/fcc0ec6f09967d75f4e2fdfdd6475138.gif\" alt=\"\"></p>\n<p>也就是说这个大东西吃了 873 口</p>\n<h2 id=\"假如用-Express-搭服务器\"><a href=\"#假如用-Express-搭服务器\" class=\"headerlink\" title=\"假如用 Express 搭服务器\"></a>假如用 Express 搭服务器</h2><p>先看看 bin/www 的代码</p>\n<pre><code>// 7行和9行\nvar app = require(&#39;../app&#39;);  // 定义各种路由\nvar http = require(&#39;http&#39;);  // 引入http模块\n\n// 28行\nserver.listen(port);  // 定义端口号\n</code></pre><p>怎么把刚刚我上面实现的效果用 Express 框架做出来呢？</p>\n<pre><code>// app.js 26行改成\napp.use(&#39;/user&#39;, users);\n\n// 打开 routes 的 users.js，修改成\nvar express = require(&#39;express&#39;)\nvar router = express.Router()\n\nconst users = []\n\n/* GET users listing. */\nrouter.route(&#39;/&#39;)\n  .get((req, res, next) =&gt; {\n    res.json(users)\n  })\n  .post((req, res)=&gt;{\n    const user = req.body\n    users.push(user)\n    res.json(user)\n  })\n\nmodule.exports = router\n</code></pre><p><img src=\"https://us1.myximage.com/2017/12/01/0eda1fdee399f2d5f16acd525d5f469a.gif\" alt=\"\"></p>\n<p>其实框架还是解决了很多自己写东西的细节，像什么判断啊，转码啊啥的。那就可以不用管那么多直接写业务逻辑。</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><h3 id=\"命令行神器\"><a href=\"#命令行神器\" class=\"headerlink\" title=\"命令行神器\"></a>命令行神器</h3><p>又发现了个命令行神器..</p>\n<p><a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">oh-my-zsh</a></p>\n<h3 id=\"前端发送表单发送的数据-后端处理的方式\"><a href=\"#前端发送表单发送的数据-后端处理的方式\" class=\"headerlink\" title=\"前端发送表单发送的数据-后端处理的方式\"></a>前端发送表单发送的数据-后端处理的方式</h3><p><a href=\"https://github.com/FRANKIETANG/simple-http-server/commit/4366e9a1cc5506c7291b3550aa1ec2843644e817\" target=\"_blank\" rel=\"noopener\">commit - form data</a></p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/ca7f44d9c3c761bca5d419204b5a5ff0.gif\" alt=\"\"></p>\n<p>拿到数据了…（请忽略我的 JSON 报错）</p>\n<p><a href=\"https://github.com/FRANKIETANG/simple-http-server/commit/1fdc106bf64cb242d53008b4f93b5c86b53af408\" target=\"_blank\" rel=\"noopener\">commit - querystring replace JSON</a></p>\n<p><img src=\"https://us1.myximage.com/2017/12/01/6a58999accae3fe5bcac42cb90ce1400.gif\" alt=\"\"></p>\n<h3 id=\"如何做请求缓存\"><a href=\"#如何做请求缓存\" class=\"headerlink\" title=\"如何做请求缓存\"></a>如何做请求缓存</h3><p>就是收到第二次同样的请求返回一样的内容（先留个坑吧…）</p>\n<ul>\n<li>浏览器缓存</li>\n<li>服务端缓存</li>\n</ul>\n"},{"title":"看点面试题","date":"2017-11-15T14:58:52.000Z","_content":"# 看点面试题\n\n## http\n\n[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) --- 解决状态码和请求方式\n\n### 状态码\n\n- 2xx成功\n- 3xx重定向\n- 4xx客户端错误\n- 5xx服务器错误（流量大啥的）\n\n3xx 重定向：比如访问网站 A，结果重新打到网站 B 上。怎么从 A 导到 B。\n\n比如输入一个 http://www.baidu.com，它会自动转到 https://www.baidu.com，状态码是 307，因为在 Response Headers 有一个 Location\n\n还有一些缓存相关的\n\n>304：当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候,就会发送一个条件请求.在Fiddler中,你可以在**Headers Inspector**查找相关请求头,这样就可以辨别出一个请求是否是条件请求.\n>\n>在进行条件请求时,客户端会提供给服务器一个**If-Modified-Since**请求头,其值为服务器上次返回的**Last-Modified**响应头中的日期值,还会提供一个**If-None-Match**请求头,值为服务器上次返回的**ETag**响应头的值:\n>\n>![Fiddler Request Headers Inspector screenshot](http://pic002.cnblogs.com/images/2012/116671/2012111610163856.jpg)\n>\n>服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回**HTTP/304 Not Modified**响应,但没有响应体.客户端收到304响应后,就会从缓存中读取对应的资源.\n>\n>另一种情况是,如果服务器认为客户端缓存的资源已经过期了,那么服务器就会返回**HTTP/200 OK**响应,响应体就是该资源当前最新的内容.客户端收到200响应后,就会用新的响应体覆盖掉旧的缓存资源.\n>\n>只有在客户端缓存了对应资源且该资源的响应头中包含了**Last-Modified**或**ETag**的情况下,才可能发送条件请求.如果这两个头都不存在,则必须无条件(**unconditionally**)请求该资源,服务器也就必须返回完整的资源数据.\n\n4xx客户端错误：\n\n- 404 就是页面不存在\n- 403 Forbidden 服务器上文件或目录的权限设置导致，就是登录了但是没有权限修改就会返回403\n- 401 Unanthorized 完全没有登录，比如说进入了一个系统看系统里的东西但是没登录就会返回401\n\n\nCache-Control Expires 其实是一个同样的功能\n\n> **Expires**\n>\n> 给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT\n>\n> 需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。\n>\n> **关于 Cache-Control: max-age=秒 和 Expires**\n>\n> Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）\n> max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。\n> 如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。\n>\n> Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。\n>\n> **Expires = max-age +   “每次下载时的当前的request时间”**\n>\n> 所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 \n\n不受系统时间的影响\n\n### 请求方式\n\n比如一些常见的 get post delete put 这些\n\nget 和 post 的区别是？[HTTP协议中GET和POST方法的区别](https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/)\n\nput 和 patch 的区别？[HTTP Verbs: 談 POST, PUT 和 PATCH 的應用](https://ihower.tw/blog/archives/6483)\n\n### 数据发送\n\n- [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files)\n- [form](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form)\n\n```\n// 假设发送的字符串里有 & 和 = 怎么转译\n\nname: '&=xiaohong'\n\nencodeURIComponent('&=xiaohong')  // %26%3Dxiaohong\ndecodeURIComponent('%26%3Dxiaohong')  // &=xiaohong\n```\n\n[FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)\n\napplication/json `JSON.parse(JSON.stringify(obj))`\n\n发数据的时候记得设置 content-type\n\n### 请求头\n\n[HTTP 请求头与请求体](https://segmentfault.com/a/1190000006689767)\n\n### 响应头\n\n[HTTP 响应头与状态码](https://segmentfault.com/a/1190000006689786)\n\n## JavaScript\n\n### 实参 - Array.prototype.push\n\n```\n// 实现一个 _push() 方法\n// 一顿操作\nArray.prototype._push = function() {\n  // todo..\n  for(let i = 0; i < arguments.length; i++) {\n    this.splice(this.length, 0, arguments[i]);\n  }\n}\n\nvar arr = [1,2,3]\narr._push(4,5)\nconsole.log(arr)  // [1,2,3,4,5]\narr._push([1,2], 6)\nconsole.log(arr)  // [1,2,3,4,5,[1,2],6]\n```\n\n### call&apply&bind - 把一个数组的元素添加到另一个数组\n\n```\nArray.prototype._concat = function () {\n    // todo...\n    let arr = this.slice(0);\n    arguments.length && [].forEach.call(arguments, (value) => {\n        if (Array.isArray(value)) {\n            value.forEach(val => {\n                arr.push(val);\n            })\n        } else {\n            arr.push(value);\n        }\n    })\n    return arr;\n}\n\nlet arr = [1, 2, 3]\narr._concat([4, 5])\nconsole.log(arr) // [1,2,3,4,5]\n```\n\n利用 `[].forEach.call` 调用数组的 `forEach` 方法（arguments 是类数组没有 forEach 方法）\n\n### 原型 - extend(parentConstructor, childConstructor)\n\n实现 extend 方法让子构造函数继承父构造函数的方法。\n\n```\nfunction extend(parentConstructor, childConstructor) {\n  var prototype = Object.create(parentConstructor.prototype);\n  prototype.constructor = childConstructor;\n  childConstructor.prototype = prototype;\n}\n\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n  console.log(`hi I'm ${this.name}`);\n}\n\nvar frankie = new Person('frankie');\nfrankie.sayHi();\n\nfunction Student(name) {\n  Person.call(this, name);\n}\n\n// 实现 extend 方法让 xiaoming 有问候大家的技能\nextend(Person,Student);  //  extend 要挂在这里，如果挂在下面会有可能冲掉 student 的 prototype 属性\nStudent.prototype.study = function() {\n  console.log(`hi I'm ${this.name}. I'm studying`);\n}\n\nvar xiaoming = new Student('xiaoming');\nxiaoming.study()  // hi I'm xiaoming. I'm studying\nxiaoming.sayHi()  // hi I'm xiaoming\n```\n\n","source":"_posts/看点面试题.md","raw":"---\ntitle: 看点面试题\ndate: 2017-11-15 22:58:52\ntags: [Interview]\n---\n# 看点面试题\n\n## http\n\n[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html) --- 解决状态码和请求方式\n\n### 状态码\n\n- 2xx成功\n- 3xx重定向\n- 4xx客户端错误\n- 5xx服务器错误（流量大啥的）\n\n3xx 重定向：比如访问网站 A，结果重新打到网站 B 上。怎么从 A 导到 B。\n\n比如输入一个 http://www.baidu.com，它会自动转到 https://www.baidu.com，状态码是 307，因为在 Response Headers 有一个 Location\n\n还有一些缓存相关的\n\n>304：当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候,就会发送一个条件请求.在Fiddler中,你可以在**Headers Inspector**查找相关请求头,这样就可以辨别出一个请求是否是条件请求.\n>\n>在进行条件请求时,客户端会提供给服务器一个**If-Modified-Since**请求头,其值为服务器上次返回的**Last-Modified**响应头中的日期值,还会提供一个**If-None-Match**请求头,值为服务器上次返回的**ETag**响应头的值:\n>\n>![Fiddler Request Headers Inspector screenshot](http://pic002.cnblogs.com/images/2012/116671/2012111610163856.jpg)\n>\n>服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回**HTTP/304 Not Modified**响应,但没有响应体.客户端收到304响应后,就会从缓存中读取对应的资源.\n>\n>另一种情况是,如果服务器认为客户端缓存的资源已经过期了,那么服务器就会返回**HTTP/200 OK**响应,响应体就是该资源当前最新的内容.客户端收到200响应后,就会用新的响应体覆盖掉旧的缓存资源.\n>\n>只有在客户端缓存了对应资源且该资源的响应头中包含了**Last-Modified**或**ETag**的情况下,才可能发送条件请求.如果这两个头都不存在,则必须无条件(**unconditionally**)请求该资源,服务器也就必须返回完整的资源数据.\n\n4xx客户端错误：\n\n- 404 就是页面不存在\n- 403 Forbidden 服务器上文件或目录的权限设置导致，就是登录了但是没有权限修改就会返回403\n- 401 Unanthorized 完全没有登录，比如说进入了一个系统看系统里的东西但是没登录就会返回401\n\n\nCache-Control Expires 其实是一个同样的功能\n\n> **Expires**\n>\n> 给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT\n>\n> 需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。\n>\n> **关于 Cache-Control: max-age=秒 和 Expires**\n>\n> Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）\n> max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。\n> 如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。\n>\n> Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。\n>\n> **Expires = max-age +   “每次下载时的当前的request时间”**\n>\n> 所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 \n\n不受系统时间的影响\n\n### 请求方式\n\n比如一些常见的 get post delete put 这些\n\nget 和 post 的区别是？[HTTP协议中GET和POST方法的区别](https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/)\n\nput 和 patch 的区别？[HTTP Verbs: 談 POST, PUT 和 PATCH 的應用](https://ihower.tw/blog/archives/6483)\n\n### 数据发送\n\n- [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files)\n- [form](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form)\n\n```\n// 假设发送的字符串里有 & 和 = 怎么转译\n\nname: '&=xiaohong'\n\nencodeURIComponent('&=xiaohong')  // %26%3Dxiaohong\ndecodeURIComponent('%26%3Dxiaohong')  // &=xiaohong\n```\n\n[FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)\n\napplication/json `JSON.parse(JSON.stringify(obj))`\n\n发数据的时候记得设置 content-type\n\n### 请求头\n\n[HTTP 请求头与请求体](https://segmentfault.com/a/1190000006689767)\n\n### 响应头\n\n[HTTP 响应头与状态码](https://segmentfault.com/a/1190000006689786)\n\n## JavaScript\n\n### 实参 - Array.prototype.push\n\n```\n// 实现一个 _push() 方法\n// 一顿操作\nArray.prototype._push = function() {\n  // todo..\n  for(let i = 0; i < arguments.length; i++) {\n    this.splice(this.length, 0, arguments[i]);\n  }\n}\n\nvar arr = [1,2,3]\narr._push(4,5)\nconsole.log(arr)  // [1,2,3,4,5]\narr._push([1,2], 6)\nconsole.log(arr)  // [1,2,3,4,5,[1,2],6]\n```\n\n### call&apply&bind - 把一个数组的元素添加到另一个数组\n\n```\nArray.prototype._concat = function () {\n    // todo...\n    let arr = this.slice(0);\n    arguments.length && [].forEach.call(arguments, (value) => {\n        if (Array.isArray(value)) {\n            value.forEach(val => {\n                arr.push(val);\n            })\n        } else {\n            arr.push(value);\n        }\n    })\n    return arr;\n}\n\nlet arr = [1, 2, 3]\narr._concat([4, 5])\nconsole.log(arr) // [1,2,3,4,5]\n```\n\n利用 `[].forEach.call` 调用数组的 `forEach` 方法（arguments 是类数组没有 forEach 方法）\n\n### 原型 - extend(parentConstructor, childConstructor)\n\n实现 extend 方法让子构造函数继承父构造函数的方法。\n\n```\nfunction extend(parentConstructor, childConstructor) {\n  var prototype = Object.create(parentConstructor.prototype);\n  prototype.constructor = childConstructor;\n  childConstructor.prototype = prototype;\n}\n\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n  console.log(`hi I'm ${this.name}`);\n}\n\nvar frankie = new Person('frankie');\nfrankie.sayHi();\n\nfunction Student(name) {\n  Person.call(this, name);\n}\n\n// 实现 extend 方法让 xiaoming 有问候大家的技能\nextend(Person,Student);  //  extend 要挂在这里，如果挂在下面会有可能冲掉 student 的 prototype 属性\nStudent.prototype.study = function() {\n  console.log(`hi I'm ${this.name}. I'm studying`);\n}\n\nvar xiaoming = new Student('xiaoming');\nxiaoming.study()  // hi I'm xiaoming. I'm studying\nxiaoming.sayHi()  // hi I'm xiaoming\n```\n\n","slug":"看点面试题","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d910013f1xh5r2ufqiy","content":"<h1 id=\"看点面试题\"><a href=\"#看点面试题\" class=\"headerlink\" title=\"看点面试题\"></a>看点面试题</h1><h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"noopener\">RESTful API 设计指南</a> — 解决状态码和请求方式</p>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><ul>\n<li>2xx成功</li>\n<li>3xx重定向</li>\n<li>4xx客户端错误</li>\n<li>5xx服务器错误（流量大啥的）</li>\n</ul>\n<p>3xx 重定向：比如访问网站 A，结果重新打到网站 B 上。怎么从 A 导到 B。</p>\n<p>比如输入一个 <a href=\"http://www.baidu.com，它会自动转到\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com，它会自动转到</a> <a href=\"https://www.baidu.com，状态码是\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com，状态码是</a> 307，因为在 Response Headers 有一个 Location</p>\n<p>还有一些缓存相关的</p>\n<blockquote>\n<p>304：当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候,就会发送一个条件请求.在Fiddler中,你可以在<strong>Headers Inspector</strong>查找相关请求头,这样就可以辨别出一个请求是否是条件请求.</p>\n<p>在进行条件请求时,客户端会提供给服务器一个<strong>If-Modified-Since</strong>请求头,其值为服务器上次返回的<strong>Last-Modified</strong>响应头中的日期值,还会提供一个<strong>If-None-Match</strong>请求头,值为服务器上次返回的<strong>ETag</strong>响应头的值:</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/116671/2012111610163856.jpg\" alt=\"Fiddler Request Headers Inspector screenshot\"></p>\n<p>服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回<strong>HTTP/304 Not Modified</strong>响应,但没有响应体.客户端收到304响应后,就会从缓存中读取对应的资源.</p>\n<p>另一种情况是,如果服务器认为客户端缓存的资源已经过期了,那么服务器就会返回<strong>HTTP/200 OK</strong>响应,响应体就是该资源当前最新的内容.客户端收到200响应后,就会用新的响应体覆盖掉旧的缓存资源.</p>\n<p>只有在客户端缓存了对应资源且该资源的响应头中包含了<strong>Last-Modified</strong>或<strong>ETag</strong>的情况下,才可能发送条件请求.如果这两个头都不存在,则必须无条件(<strong>unconditionally</strong>)请求该资源,服务器也就必须返回完整的资源数据.</p>\n</blockquote>\n<p>4xx客户端错误：</p>\n<ul>\n<li>404 就是页面不存在</li>\n<li>403 Forbidden 服务器上文件或目录的权限设置导致，就是登录了但是没有权限修改就会返回403</li>\n<li>401 Unanthorized 完全没有登录，比如说进入了一个系统看系统里的东西但是没登录就会返回401</li>\n</ul>\n<p>Cache-Control Expires 其实是一个同样的功能</p>\n<blockquote>\n<p><strong>Expires</strong></p>\n<p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT</p>\n<p>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。</p>\n<p><strong>关于 Cache-Control: max-age=秒 和 Expires</strong></p>\n<p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</p>\n<p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p>\n<p><strong>Expires = max-age +   “每次下载时的当前的request时间”</strong></p>\n<p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p>\n</blockquote>\n<p>不受系统时间的影响</p>\n<h3 id=\"请求方式\"><a href=\"#请求方式\" class=\"headerlink\" title=\"请求方式\"></a>请求方式</h3><p>比如一些常见的 get post delete put 这些</p>\n<p>get 和 post 的区别是？<a href=\"https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/\" target=\"_blank\" rel=\"noopener\">HTTP协议中GET和POST方法的区别</a></p>\n<p>put 和 patch 的区别？<a href=\"https://ihower.tw/blog/archives/6483\" target=\"_blank\" rel=\"noopener\">HTTP Verbs: 談 POST, PUT 和 PATCH 的應用</a></p>\n<h3 id=\"数据发送\"><a href=\"#数据发送\" class=\"headerlink\" title=\"数据发送\"></a>数据发送</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files\" target=\"_blank\" rel=\"noopener\">XMLHttpRequest</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form\" target=\"_blank\" rel=\"noopener\">form</a></li>\n</ul>\n<pre><code>// 假设发送的字符串里有 &amp; 和 = 怎么转译\n\nname: &#39;&amp;=xiaohong&#39;\n\nencodeURIComponent(&#39;&amp;=xiaohong&#39;)  // %26%3Dxiaohong\ndecodeURIComponent(&#39;%26%3Dxiaohong&#39;)  // &amp;=xiaohong\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\" target=\"_blank\" rel=\"noopener\">FormData</a></p>\n<p>application/json <code>JSON.parse(JSON.stringify(obj))</code></p>\n<p>发数据的时候记得设置 content-type</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p><a href=\"https://segmentfault.com/a/1190000006689767\" target=\"_blank\" rel=\"noopener\">HTTP 请求头与请求体</a></p>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><p><a href=\"https://segmentfault.com/a/1190000006689786\" target=\"_blank\" rel=\"noopener\">HTTP 响应头与状态码</a></p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h3 id=\"实参-Array-prototype-push\"><a href=\"#实参-Array-prototype-push\" class=\"headerlink\" title=\"实参 - Array.prototype.push\"></a>实参 - Array.prototype.push</h3><pre><code>// 实现一个 _push() 方法\n// 一顿操作\nArray.prototype._push = function() {\n  // todo..\n  for(let i = 0; i &lt; arguments.length; i++) {\n    this.splice(this.length, 0, arguments[i]);\n  }\n}\n\nvar arr = [1,2,3]\narr._push(4,5)\nconsole.log(arr)  // [1,2,3,4,5]\narr._push([1,2], 6)\nconsole.log(arr)  // [1,2,3,4,5,[1,2],6]\n</code></pre><h3 id=\"call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组\"><a href=\"#call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组\" class=\"headerlink\" title=\"call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组\"></a>call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组</h3><pre><code>Array.prototype._concat = function () {\n    // todo...\n    let arr = this.slice(0);\n    arguments.length &amp;&amp; [].forEach.call(arguments, (value) =&gt; {\n        if (Array.isArray(value)) {\n            value.forEach(val =&gt; {\n                arr.push(val);\n            })\n        } else {\n            arr.push(value);\n        }\n    })\n    return arr;\n}\n\nlet arr = [1, 2, 3]\narr._concat([4, 5])\nconsole.log(arr) // [1,2,3,4,5]\n</code></pre><p>利用 <code>[].forEach.call</code> 调用数组的 <code>forEach</code> 方法（arguments 是类数组没有 forEach 方法）</p>\n<h3 id=\"原型-extend-parentConstructor-childConstructor\"><a href=\"#原型-extend-parentConstructor-childConstructor\" class=\"headerlink\" title=\"原型 - extend(parentConstructor, childConstructor)\"></a>原型 - extend(parentConstructor, childConstructor)</h3><p>实现 extend 方法让子构造函数继承父构造函数的方法。</p>\n<pre><code>function extend(parentConstructor, childConstructor) {\n  var prototype = Object.create(parentConstructor.prototype);\n  prototype.constructor = childConstructor;\n  childConstructor.prototype = prototype;\n}\n\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n  console.log(`hi I&#39;m ${this.name}`);\n}\n\nvar frankie = new Person(&#39;frankie&#39;);\nfrankie.sayHi();\n\nfunction Student(name) {\n  Person.call(this, name);\n}\n\n// 实现 extend 方法让 xiaoming 有问候大家的技能\nextend(Person,Student);  //  extend 要挂在这里，如果挂在下面会有可能冲掉 student 的 prototype 属性\nStudent.prototype.study = function() {\n  console.log(`hi I&#39;m ${this.name}. I&#39;m studying`);\n}\n\nvar xiaoming = new Student(&#39;xiaoming&#39;);\nxiaoming.study()  // hi I&#39;m xiaoming. I&#39;m studying\nxiaoming.sayHi()  // hi I&#39;m xiaoming\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"看点面试题\"><a href=\"#看点面试题\" class=\"headerlink\" title=\"看点面试题\"></a>看点面试题</h1><h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"noopener\">RESTful API 设计指南</a> — 解决状态码和请求方式</p>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><ul>\n<li>2xx成功</li>\n<li>3xx重定向</li>\n<li>4xx客户端错误</li>\n<li>5xx服务器错误（流量大啥的）</li>\n</ul>\n<p>3xx 重定向：比如访问网站 A，结果重新打到网站 B 上。怎么从 A 导到 B。</p>\n<p>比如输入一个 <a href=\"http://www.baidu.com，它会自动转到\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com，它会自动转到</a> <a href=\"https://www.baidu.com，状态码是\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com，状态码是</a> 307，因为在 Response Headers 有一个 Location</p>\n<p>还有一些缓存相关的</p>\n<blockquote>\n<p>304：当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候,就会发送一个条件请求.在Fiddler中,你可以在<strong>Headers Inspector</strong>查找相关请求头,这样就可以辨别出一个请求是否是条件请求.</p>\n<p>在进行条件请求时,客户端会提供给服务器一个<strong>If-Modified-Since</strong>请求头,其值为服务器上次返回的<strong>Last-Modified</strong>响应头中的日期值,还会提供一个<strong>If-None-Match</strong>请求头,值为服务器上次返回的<strong>ETag</strong>响应头的值:</p>\n<p><img src=\"http://pic002.cnblogs.com/images/2012/116671/2012111610163856.jpg\" alt=\"Fiddler Request Headers Inspector screenshot\"></p>\n<p>服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回<strong>HTTP/304 Not Modified</strong>响应,但没有响应体.客户端收到304响应后,就会从缓存中读取对应的资源.</p>\n<p>另一种情况是,如果服务器认为客户端缓存的资源已经过期了,那么服务器就会返回<strong>HTTP/200 OK</strong>响应,响应体就是该资源当前最新的内容.客户端收到200响应后,就会用新的响应体覆盖掉旧的缓存资源.</p>\n<p>只有在客户端缓存了对应资源且该资源的响应头中包含了<strong>Last-Modified</strong>或<strong>ETag</strong>的情况下,才可能发送条件请求.如果这两个头都不存在,则必须无条件(<strong>unconditionally</strong>)请求该资源,服务器也就必须返回完整的资源数据.</p>\n</blockquote>\n<p>4xx客户端错误：</p>\n<ul>\n<li>404 就是页面不存在</li>\n<li>403 Forbidden 服务器上文件或目录的权限设置导致，就是登录了但是没有权限修改就会返回403</li>\n<li>401 Unanthorized 完全没有登录，比如说进入了一个系统看系统里的东西但是没登录就会返回401</li>\n</ul>\n<p>Cache-Control Expires 其实是一个同样的功能</p>\n<blockquote>\n<p><strong>Expires</strong></p>\n<p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT</p>\n<p>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。</p>\n<p><strong>关于 Cache-Control: max-age=秒 和 Expires</strong></p>\n<p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</p>\n<p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p>\n<p><strong>Expires = max-age +   “每次下载时的当前的request时间”</strong></p>\n<p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p>\n</blockquote>\n<p>不受系统时间的影响</p>\n<h3 id=\"请求方式\"><a href=\"#请求方式\" class=\"headerlink\" title=\"请求方式\"></a>请求方式</h3><p>比如一些常见的 get post delete put 这些</p>\n<p>get 和 post 的区别是？<a href=\"https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/\" target=\"_blank\" rel=\"noopener\">HTTP协议中GET和POST方法的区别</a></p>\n<p>put 和 patch 的区别？<a href=\"https://ihower.tw/blog/archives/6483\" target=\"_blank\" rel=\"noopener\">HTTP Verbs: 談 POST, PUT 和 PATCH 的應用</a></p>\n<h3 id=\"数据发送\"><a href=\"#数据发送\" class=\"headerlink\" title=\"数据发送\"></a>数据发送</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files\" target=\"_blank\" rel=\"noopener\">XMLHttpRequest</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form\" target=\"_blank\" rel=\"noopener\">form</a></li>\n</ul>\n<pre><code>// 假设发送的字符串里有 &amp; 和 = 怎么转译\n\nname: &#39;&amp;=xiaohong&#39;\n\nencodeURIComponent(&#39;&amp;=xiaohong&#39;)  // %26%3Dxiaohong\ndecodeURIComponent(&#39;%26%3Dxiaohong&#39;)  // &amp;=xiaohong\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\" target=\"_blank\" rel=\"noopener\">FormData</a></p>\n<p>application/json <code>JSON.parse(JSON.stringify(obj))</code></p>\n<p>发数据的时候记得设置 content-type</p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p><a href=\"https://segmentfault.com/a/1190000006689767\" target=\"_blank\" rel=\"noopener\">HTTP 请求头与请求体</a></p>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><p><a href=\"https://segmentfault.com/a/1190000006689786\" target=\"_blank\" rel=\"noopener\">HTTP 响应头与状态码</a></p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><h3 id=\"实参-Array-prototype-push\"><a href=\"#实参-Array-prototype-push\" class=\"headerlink\" title=\"实参 - Array.prototype.push\"></a>实参 - Array.prototype.push</h3><pre><code>// 实现一个 _push() 方法\n// 一顿操作\nArray.prototype._push = function() {\n  // todo..\n  for(let i = 0; i &lt; arguments.length; i++) {\n    this.splice(this.length, 0, arguments[i]);\n  }\n}\n\nvar arr = [1,2,3]\narr._push(4,5)\nconsole.log(arr)  // [1,2,3,4,5]\narr._push([1,2], 6)\nconsole.log(arr)  // [1,2,3,4,5,[1,2],6]\n</code></pre><h3 id=\"call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组\"><a href=\"#call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组\" class=\"headerlink\" title=\"call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组\"></a>call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组</h3><pre><code>Array.prototype._concat = function () {\n    // todo...\n    let arr = this.slice(0);\n    arguments.length &amp;&amp; [].forEach.call(arguments, (value) =&gt; {\n        if (Array.isArray(value)) {\n            value.forEach(val =&gt; {\n                arr.push(val);\n            })\n        } else {\n            arr.push(value);\n        }\n    })\n    return arr;\n}\n\nlet arr = [1, 2, 3]\narr._concat([4, 5])\nconsole.log(arr) // [1,2,3,4,5]\n</code></pre><p>利用 <code>[].forEach.call</code> 调用数组的 <code>forEach</code> 方法（arguments 是类数组没有 forEach 方法）</p>\n<h3 id=\"原型-extend-parentConstructor-childConstructor\"><a href=\"#原型-extend-parentConstructor-childConstructor\" class=\"headerlink\" title=\"原型 - extend(parentConstructor, childConstructor)\"></a>原型 - extend(parentConstructor, childConstructor)</h3><p>实现 extend 方法让子构造函数继承父构造函数的方法。</p>\n<pre><code>function extend(parentConstructor, childConstructor) {\n  var prototype = Object.create(parentConstructor.prototype);\n  prototype.constructor = childConstructor;\n  childConstructor.prototype = prototype;\n}\n\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n  console.log(`hi I&#39;m ${this.name}`);\n}\n\nvar frankie = new Person(&#39;frankie&#39;);\nfrankie.sayHi();\n\nfunction Student(name) {\n  Person.call(this, name);\n}\n\n// 实现 extend 方法让 xiaoming 有问候大家的技能\nextend(Person,Student);  //  extend 要挂在这里，如果挂在下面会有可能冲掉 student 的 prototype 属性\nStudent.prototype.study = function() {\n  console.log(`hi I&#39;m ${this.name}. I&#39;m studying`);\n}\n\nvar xiaoming = new Student(&#39;xiaoming&#39;);\nxiaoming.study()  // hi I&#39;m xiaoming. I&#39;m studying\nxiaoming.sayHi()  // hi I&#39;m xiaoming\n</code></pre>"},{"title":"简单走一遍 node","date":"2017-11-26T11:45:04.000Z","_content":"# 简单走一遍 node\n\n一个 Express 便利贴项目 | 预览 http://tangkalun.top 源码 https://github.com/FRANKIETANG/Express-node\n\n详情代码看我 [commit](https://github.com/FRANKIETANG/Express-node/commits/master) \n\nhttp://expressjs.com\n\n## Todo\n\n- 增删改查\n- 便利贴可拖动\n- GitHub 登录\n\n## 环境搭建\n\n### Express\n\n```\nnpm init -y\nnpm install express --save\n```\n\n老套路，先用 express 问候一下世界\n\n```\n// app.js\nconst express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => res.send('Hello World!'))\n\napp.listen(3000, () => console.log('Example app listening on port 3000!'))\n```\n\n用 `node app.js` 成功的问候了世界\n\n接下来安装 express-generator\n\n```\nnpm install express-generator --save-dev\n```\n\n`./node_modules/express-generator/bin/express-cli.js . -f -e` 自动生成\n\n```\n// 看看目录\ntangkalun@tangkalun-PC:~/Desktop/Express-node$ ls\napp.js  bin  node_modules  package.json  public  routes  views\n```\n\n```\n// 根据提示\nnpm i\nnpm start\n```\n\n换端口的方法是 `PORT=4000 node bin/www`\n\n### webpack 配置\n\n看以前写过的博客\n\n### onchange\n\nhttps://www.npmjs.com/package/onchange 查看当前文件状况\n\n```\n\"build\": \"webpack --config=src/webpack.config.js\",\n\"watch\": \"onchange 'src/**/*.js' 'src/**/*.less' -- npm run build\"\n```\n\n## **需要了解的内容有**\n\n- [middleware](http://expressjs.com/en/guide/using-middleware.html)\n- [template engines with Express](http://expressjs.com/en/guide/using-template-engines.html)\n- [Routing](http://expressjs.com/en/guide/routing.html)\n\n比如说一个简单的 middleware 可以这样子写\n\n```\napp.use('/student', function (req, res, next) {\n  res.send('hello frankie')\n})\n```\n\n我理解的话，大概是一个类似路由的东西\n\n模板引擎：https://www.npmjs.com/package/ejs\n\n有一句话是设置路径的，很重要。是用来设置是路由还是其他公共路径下的文件不会被当成路由加载\n\n```\napp.use(express.static(path.join(__dirname, 'public')));\n```\n\n## 组件\n\n没什么好说的都是以前做的轮子变形\n\n不过发布订阅的确写得简单了点...\n\n## API\n\n`crud` `restful`\n\n- 获取所有的 note `GET /api/notes  req:{}  res:{stauts: 0, data: [{},{}]} {status:1,errorMsg: '失败的原因'}`\n- 创建一个 note `POST /api/note/create  req:{note: 'hello world'}  res:{stauts: 0}  {status:1,errorMsg: '失败的原因'}`\n- 修改一个 note `POST /api/note/edit  req:{note: 'new note', id:100}`\n- 删除一个 note `POST /api/note/delete req:{id:100}`\n\n## 数据库\n\nhttps://www.npmjs.com/package/sequelize\n\nhttps://github.com/demopark/sequelize-docs-Zh-CN\n\n```\n// 用 n 模块降级到 6.10.3\n$ npm install --save sequelize\n$ npm install --save sqlite3\n```\n\n## 登录登出功能\n\n[理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\nhttps://www.npmjs.com/package/passport 注意文档中的 Sessions 和 Middleware\n\nhttps://www.npmjs.com/package/passport-github 注意文档中的 Configure Strategy 和 Authenticate Requests\n\nhttp://www.cnblogs.com/gabrielchen/p/5800225.html\n\nhttps://github.com/settings/applications/new\n\n[使用 GitHub OAuth 第三方验证登录](https://diamondfsd.com/article/7fc2b070-e238-4fbb-acaf-47f0e3fdaabc)\n\nhttp://www.open-open.com/lib/view/open1416812717570.html\n\n## 权限\n\n[permission - commit](https://github.com/FRANKIETANG/Express-node/commit/23e800fd0f76661225f5bae731cad4f22d302a6d)\n\n## 彩蛋\n\nnode 如何调试\n\n```\nnpm i -g node-inspector\nnode-inspector\n// 然后打开他指定的端口\n// 然后打开项目\nnode --debug bin/www\n```\n\n## 后话\n\n为了能让自己回想起自己的代码是啥意思，多看看自己的 commit\n\n过一段时间想个更有难度的项目吧... 不应该老是做这种像 demo 一样的东西","source":"_posts/简单走一遍 node.md","raw":"---\ntitle: 简单走一遍 node\ndate: 2017-11-26 19:45:04\ntags: [Node]\n---\n# 简单走一遍 node\n\n一个 Express 便利贴项目 | 预览 http://tangkalun.top 源码 https://github.com/FRANKIETANG/Express-node\n\n详情代码看我 [commit](https://github.com/FRANKIETANG/Express-node/commits/master) \n\nhttp://expressjs.com\n\n## Todo\n\n- 增删改查\n- 便利贴可拖动\n- GitHub 登录\n\n## 环境搭建\n\n### Express\n\n```\nnpm init -y\nnpm install express --save\n```\n\n老套路，先用 express 问候一下世界\n\n```\n// app.js\nconst express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => res.send('Hello World!'))\n\napp.listen(3000, () => console.log('Example app listening on port 3000!'))\n```\n\n用 `node app.js` 成功的问候了世界\n\n接下来安装 express-generator\n\n```\nnpm install express-generator --save-dev\n```\n\n`./node_modules/express-generator/bin/express-cli.js . -f -e` 自动生成\n\n```\n// 看看目录\ntangkalun@tangkalun-PC:~/Desktop/Express-node$ ls\napp.js  bin  node_modules  package.json  public  routes  views\n```\n\n```\n// 根据提示\nnpm i\nnpm start\n```\n\n换端口的方法是 `PORT=4000 node bin/www`\n\n### webpack 配置\n\n看以前写过的博客\n\n### onchange\n\nhttps://www.npmjs.com/package/onchange 查看当前文件状况\n\n```\n\"build\": \"webpack --config=src/webpack.config.js\",\n\"watch\": \"onchange 'src/**/*.js' 'src/**/*.less' -- npm run build\"\n```\n\n## **需要了解的内容有**\n\n- [middleware](http://expressjs.com/en/guide/using-middleware.html)\n- [template engines with Express](http://expressjs.com/en/guide/using-template-engines.html)\n- [Routing](http://expressjs.com/en/guide/routing.html)\n\n比如说一个简单的 middleware 可以这样子写\n\n```\napp.use('/student', function (req, res, next) {\n  res.send('hello frankie')\n})\n```\n\n我理解的话，大概是一个类似路由的东西\n\n模板引擎：https://www.npmjs.com/package/ejs\n\n有一句话是设置路径的，很重要。是用来设置是路由还是其他公共路径下的文件不会被当成路由加载\n\n```\napp.use(express.static(path.join(__dirname, 'public')));\n```\n\n## 组件\n\n没什么好说的都是以前做的轮子变形\n\n不过发布订阅的确写得简单了点...\n\n## API\n\n`crud` `restful`\n\n- 获取所有的 note `GET /api/notes  req:{}  res:{stauts: 0, data: [{},{}]} {status:1,errorMsg: '失败的原因'}`\n- 创建一个 note `POST /api/note/create  req:{note: 'hello world'}  res:{stauts: 0}  {status:1,errorMsg: '失败的原因'}`\n- 修改一个 note `POST /api/note/edit  req:{note: 'new note', id:100}`\n- 删除一个 note `POST /api/note/delete req:{id:100}`\n\n## 数据库\n\nhttps://www.npmjs.com/package/sequelize\n\nhttps://github.com/demopark/sequelize-docs-Zh-CN\n\n```\n// 用 n 模块降级到 6.10.3\n$ npm install --save sequelize\n$ npm install --save sqlite3\n```\n\n## 登录登出功能\n\n[理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\nhttps://www.npmjs.com/package/passport 注意文档中的 Sessions 和 Middleware\n\nhttps://www.npmjs.com/package/passport-github 注意文档中的 Configure Strategy 和 Authenticate Requests\n\nhttp://www.cnblogs.com/gabrielchen/p/5800225.html\n\nhttps://github.com/settings/applications/new\n\n[使用 GitHub OAuth 第三方验证登录](https://diamondfsd.com/article/7fc2b070-e238-4fbb-acaf-47f0e3fdaabc)\n\nhttp://www.open-open.com/lib/view/open1416812717570.html\n\n## 权限\n\n[permission - commit](https://github.com/FRANKIETANG/Express-node/commit/23e800fd0f76661225f5bae731cad4f22d302a6d)\n\n## 彩蛋\n\nnode 如何调试\n\n```\nnpm i -g node-inspector\nnode-inspector\n// 然后打开他指定的端口\n// 然后打开项目\nnode --debug bin/www\n```\n\n## 后话\n\n为了能让自己回想起自己的代码是啥意思，多看看自己的 commit\n\n过一段时间想个更有难度的项目吧... 不应该老是做这种像 demo 一样的东西","slug":"简单走一遍 node","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d940015f1xhrfi2pgce","content":"<h1 id=\"简单走一遍-node\"><a href=\"#简单走一遍-node\" class=\"headerlink\" title=\"简单走一遍 node\"></a>简单走一遍 node</h1><p>一个 Express 便利贴项目 | 预览 <a href=\"http://tangkalun.top\" target=\"_blank\" rel=\"noopener\">http://tangkalun.top</a> 源码 <a href=\"https://github.com/FRANKIETANG/Express-node\" target=\"_blank\" rel=\"noopener\">https://github.com/FRANKIETANG/Express-node</a></p>\n<p>详情代码看我 <a href=\"https://github.com/FRANKIETANG/Express-node/commits/master\" target=\"_blank\" rel=\"noopener\">commit</a> </p>\n<p><a href=\"http://expressjs.com\" target=\"_blank\" rel=\"noopener\">http://expressjs.com</a></p>\n<h2 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h2><ul>\n<li>增删改查</li>\n<li>便利贴可拖动</li>\n<li>GitHub 登录</li>\n</ul>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><pre><code>npm init -y\nnpm install express --save\n</code></pre><p>老套路，先用 express 问候一下世界</p>\n<pre><code>// app.js\nconst express = require(&#39;express&#39;)\nconst app = express()\n\napp.get(&#39;/&#39;, (req, res) =&gt; res.send(&#39;Hello World!&#39;))\n\napp.listen(3000, () =&gt; console.log(&#39;Example app listening on port 3000!&#39;))\n</code></pre><p>用 <code>node app.js</code> 成功的问候了世界</p>\n<p>接下来安装 express-generator</p>\n<pre><code>npm install express-generator --save-dev\n</code></pre><p><code>./node_modules/express-generator/bin/express-cli.js . -f -e</code> 自动生成</p>\n<pre><code>// 看看目录\ntangkalun@tangkalun-PC:~/Desktop/Express-node$ ls\napp.js  bin  node_modules  package.json  public  routes  views\n</code></pre><pre><code>// 根据提示\nnpm i\nnpm start\n</code></pre><p>换端口的方法是 <code>PORT=4000 node bin/www</code></p>\n<h3 id=\"webpack-配置\"><a href=\"#webpack-配置\" class=\"headerlink\" title=\"webpack 配置\"></a>webpack 配置</h3><p>看以前写过的博客</p>\n<h3 id=\"onchange\"><a href=\"#onchange\" class=\"headerlink\" title=\"onchange\"></a>onchange</h3><p><a href=\"https://www.npmjs.com/package/onchange\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/onchange</a> 查看当前文件状况</p>\n<pre><code>&quot;build&quot;: &quot;webpack --config=src/webpack.config.js&quot;,\n&quot;watch&quot;: &quot;onchange &#39;src/**/*.js&#39; &#39;src/**/*.less&#39; -- npm run build&quot;\n</code></pre><h2 id=\"需要了解的内容有\"><a href=\"#需要了解的内容有\" class=\"headerlink\" title=\"需要了解的内容有\"></a><strong>需要了解的内容有</strong></h2><ul>\n<li><a href=\"http://expressjs.com/en/guide/using-middleware.html\" target=\"_blank\" rel=\"noopener\">middleware</a></li>\n<li><a href=\"http://expressjs.com/en/guide/using-template-engines.html\" target=\"_blank\" rel=\"noopener\">template engines with Express</a></li>\n<li><a href=\"http://expressjs.com/en/guide/routing.html\" target=\"_blank\" rel=\"noopener\">Routing</a></li>\n</ul>\n<p>比如说一个简单的 middleware 可以这样子写</p>\n<pre><code>app.use(&#39;/student&#39;, function (req, res, next) {\n  res.send(&#39;hello frankie&#39;)\n})\n</code></pre><p>我理解的话，大概是一个类似路由的东西</p>\n<p>模板引擎：<a href=\"https://www.npmjs.com/package/ejs\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/ejs</a></p>\n<p>有一句话是设置路径的，很重要。是用来设置是路由还是其他公共路径下的文件不会被当成路由加载</p>\n<pre><code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));\n</code></pre><h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>没什么好说的都是以前做的轮子变形</p>\n<p>不过发布订阅的确写得简单了点…</p>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p><code>crud</code> <code>restful</code></p>\n<ul>\n<li>获取所有的 note <code>GET /api/notes  req:{}  res:{stauts: 0, data: [{},{}]} {status:1,errorMsg: &#39;失败的原因&#39;}</code></li>\n<li>创建一个 note <code>POST /api/note/create  req:{note: &#39;hello world&#39;}  res:{stauts: 0}  {status:1,errorMsg: &#39;失败的原因&#39;}</code></li>\n<li>修改一个 note <code>POST /api/note/edit  req:{note: &#39;new note&#39;, id:100}</code></li>\n<li>删除一个 note <code>POST /api/note/delete req:{id:100}</code></li>\n</ul>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><p><a href=\"https://www.npmjs.com/package/sequelize\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/sequelize</a></p>\n<p><a href=\"https://github.com/demopark/sequelize-docs-Zh-CN\" target=\"_blank\" rel=\"noopener\">https://github.com/demopark/sequelize-docs-Zh-CN</a></p>\n<pre><code>// 用 n 模块降级到 6.10.3\n$ npm install --save sequelize\n$ npm install --save sqlite3\n</code></pre><h2 id=\"登录登出功能\"><a href=\"#登录登出功能\" class=\"headerlink\" title=\"登录登出功能\"></a>登录登出功能</h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解OAuth 2.0</a></p>\n<p><a href=\"https://www.npmjs.com/package/passport\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/passport</a> 注意文档中的 Sessions 和 Middleware</p>\n<p><a href=\"https://www.npmjs.com/package/passport-github\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/passport-github</a> 注意文档中的 Configure Strategy 和 Authenticate Requests</p>\n<p><a href=\"http://www.cnblogs.com/gabrielchen/p/5800225.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/gabrielchen/p/5800225.html</a></p>\n<p><a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">https://github.com/settings/applications/new</a></p>\n<p><a href=\"https://diamondfsd.com/article/7fc2b070-e238-4fbb-acaf-47f0e3fdaabc\" target=\"_blank\" rel=\"noopener\">使用 GitHub OAuth 第三方验证登录</a></p>\n<p><a href=\"http://www.open-open.com/lib/view/open1416812717570.html\" target=\"_blank\" rel=\"noopener\">http://www.open-open.com/lib/view/open1416812717570.html</a></p>\n<h2 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h2><p><a href=\"https://github.com/FRANKIETANG/Express-node/commit/23e800fd0f76661225f5bae731cad4f22d302a6d\" target=\"_blank\" rel=\"noopener\">permission - commit</a></p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>node 如何调试</p>\n<pre><code>npm i -g node-inspector\nnode-inspector\n// 然后打开他指定的端口\n// 然后打开项目\nnode --debug bin/www\n</code></pre><h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>为了能让自己回想起自己的代码是啥意思，多看看自己的 commit</p>\n<p>过一段时间想个更有难度的项目吧… 不应该老是做这种像 demo 一样的东西</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简单走一遍-node\"><a href=\"#简单走一遍-node\" class=\"headerlink\" title=\"简单走一遍 node\"></a>简单走一遍 node</h1><p>一个 Express 便利贴项目 | 预览 <a href=\"http://tangkalun.top\" target=\"_blank\" rel=\"noopener\">http://tangkalun.top</a> 源码 <a href=\"https://github.com/FRANKIETANG/Express-node\" target=\"_blank\" rel=\"noopener\">https://github.com/FRANKIETANG/Express-node</a></p>\n<p>详情代码看我 <a href=\"https://github.com/FRANKIETANG/Express-node/commits/master\" target=\"_blank\" rel=\"noopener\">commit</a> </p>\n<p><a href=\"http://expressjs.com\" target=\"_blank\" rel=\"noopener\">http://expressjs.com</a></p>\n<h2 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h2><ul>\n<li>增删改查</li>\n<li>便利贴可拖动</li>\n<li>GitHub 登录</li>\n</ul>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><pre><code>npm init -y\nnpm install express --save\n</code></pre><p>老套路，先用 express 问候一下世界</p>\n<pre><code>// app.js\nconst express = require(&#39;express&#39;)\nconst app = express()\n\napp.get(&#39;/&#39;, (req, res) =&gt; res.send(&#39;Hello World!&#39;))\n\napp.listen(3000, () =&gt; console.log(&#39;Example app listening on port 3000!&#39;))\n</code></pre><p>用 <code>node app.js</code> 成功的问候了世界</p>\n<p>接下来安装 express-generator</p>\n<pre><code>npm install express-generator --save-dev\n</code></pre><p><code>./node_modules/express-generator/bin/express-cli.js . -f -e</code> 自动生成</p>\n<pre><code>// 看看目录\ntangkalun@tangkalun-PC:~/Desktop/Express-node$ ls\napp.js  bin  node_modules  package.json  public  routes  views\n</code></pre><pre><code>// 根据提示\nnpm i\nnpm start\n</code></pre><p>换端口的方法是 <code>PORT=4000 node bin/www</code></p>\n<h3 id=\"webpack-配置\"><a href=\"#webpack-配置\" class=\"headerlink\" title=\"webpack 配置\"></a>webpack 配置</h3><p>看以前写过的博客</p>\n<h3 id=\"onchange\"><a href=\"#onchange\" class=\"headerlink\" title=\"onchange\"></a>onchange</h3><p><a href=\"https://www.npmjs.com/package/onchange\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/onchange</a> 查看当前文件状况</p>\n<pre><code>&quot;build&quot;: &quot;webpack --config=src/webpack.config.js&quot;,\n&quot;watch&quot;: &quot;onchange &#39;src/**/*.js&#39; &#39;src/**/*.less&#39; -- npm run build&quot;\n</code></pre><h2 id=\"需要了解的内容有\"><a href=\"#需要了解的内容有\" class=\"headerlink\" title=\"需要了解的内容有\"></a><strong>需要了解的内容有</strong></h2><ul>\n<li><a href=\"http://expressjs.com/en/guide/using-middleware.html\" target=\"_blank\" rel=\"noopener\">middleware</a></li>\n<li><a href=\"http://expressjs.com/en/guide/using-template-engines.html\" target=\"_blank\" rel=\"noopener\">template engines with Express</a></li>\n<li><a href=\"http://expressjs.com/en/guide/routing.html\" target=\"_blank\" rel=\"noopener\">Routing</a></li>\n</ul>\n<p>比如说一个简单的 middleware 可以这样子写</p>\n<pre><code>app.use(&#39;/student&#39;, function (req, res, next) {\n  res.send(&#39;hello frankie&#39;)\n})\n</code></pre><p>我理解的话，大概是一个类似路由的东西</p>\n<p>模板引擎：<a href=\"https://www.npmjs.com/package/ejs\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/ejs</a></p>\n<p>有一句话是设置路径的，很重要。是用来设置是路由还是其他公共路径下的文件不会被当成路由加载</p>\n<pre><code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));\n</code></pre><h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>没什么好说的都是以前做的轮子变形</p>\n<p>不过发布订阅的确写得简单了点…</p>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><p><code>crud</code> <code>restful</code></p>\n<ul>\n<li>获取所有的 note <code>GET /api/notes  req:{}  res:{stauts: 0, data: [{},{}]} {status:1,errorMsg: &#39;失败的原因&#39;}</code></li>\n<li>创建一个 note <code>POST /api/note/create  req:{note: &#39;hello world&#39;}  res:{stauts: 0}  {status:1,errorMsg: &#39;失败的原因&#39;}</code></li>\n<li>修改一个 note <code>POST /api/note/edit  req:{note: &#39;new note&#39;, id:100}</code></li>\n<li>删除一个 note <code>POST /api/note/delete req:{id:100}</code></li>\n</ul>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><p><a href=\"https://www.npmjs.com/package/sequelize\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/sequelize</a></p>\n<p><a href=\"https://github.com/demopark/sequelize-docs-Zh-CN\" target=\"_blank\" rel=\"noopener\">https://github.com/demopark/sequelize-docs-Zh-CN</a></p>\n<pre><code>// 用 n 模块降级到 6.10.3\n$ npm install --save sequelize\n$ npm install --save sqlite3\n</code></pre><h2 id=\"登录登出功能\"><a href=\"#登录登出功能\" class=\"headerlink\" title=\"登录登出功能\"></a>登录登出功能</h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">理解OAuth 2.0</a></p>\n<p><a href=\"https://www.npmjs.com/package/passport\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/passport</a> 注意文档中的 Sessions 和 Middleware</p>\n<p><a href=\"https://www.npmjs.com/package/passport-github\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/passport-github</a> 注意文档中的 Configure Strategy 和 Authenticate Requests</p>\n<p><a href=\"http://www.cnblogs.com/gabrielchen/p/5800225.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/gabrielchen/p/5800225.html</a></p>\n<p><a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">https://github.com/settings/applications/new</a></p>\n<p><a href=\"https://diamondfsd.com/article/7fc2b070-e238-4fbb-acaf-47f0e3fdaabc\" target=\"_blank\" rel=\"noopener\">使用 GitHub OAuth 第三方验证登录</a></p>\n<p><a href=\"http://www.open-open.com/lib/view/open1416812717570.html\" target=\"_blank\" rel=\"noopener\">http://www.open-open.com/lib/view/open1416812717570.html</a></p>\n<h2 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h2><p><a href=\"https://github.com/FRANKIETANG/Express-node/commit/23e800fd0f76661225f5bae731cad4f22d302a6d\" target=\"_blank\" rel=\"noopener\">permission - commit</a></p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>node 如何调试</p>\n<pre><code>npm i -g node-inspector\nnode-inspector\n// 然后打开他指定的端口\n// 然后打开项目\nnode --debug bin/www\n</code></pre><h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>为了能让自己回想起自己的代码是啥意思，多看看自己的 commit</p>\n<p>过一段时间想个更有难度的项目吧… 不应该老是做这种像 demo 一样的东西</p>\n"},{"title":"补基础：JS 单元测试","date":"2017-11-13T10:07:52.000Z","_content":"# 补基础：JS 单元测试\n\n## 单元测试有啥用？\n\n修改函数的实现方式难以保证输出的东西是自己想要的。\n\n比如 GitHub 上较大的开源项目在别人贡献代码的时候要保证输出的东西和原来的一样。\n\n单元测试就是保证这个。\n\n而且单元测试也是一个文档，告诉别人怎么使用这个文档。\n\n[教练我要写单元测试](https://github.com/n0ruSh/blogs/issues/2)\n\n[Mocha](http://mochajs.org/)\n\n[Should](http://shouldjs.github.io/)\n\n### 例子1\n\n现在做一个方法 `takeWhile` ，传一个数组和函数通过所有的 Mocha 测试\n\n```\n/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n\t// todo...\n\t/*\n\t第一个测试\n\treturn []\n\t*/\n}\n\nmodule.exports = takeWhile;\n```\n\n上面的 `@param` 看这个了解就好。[@param](http://www.css88.com/doc/jsdoc/tags-param.html)\n\nMocha 的测试写法\n\n```\nlet takeWhile = require('../../src/array/takeWhile'),\n    should = require('should');  // 比较库或者叫断言库，用来看输出后的东西是不是一样的。\n\ndescribe('array takeWhile', () => {  // describe 里面可以写一些小方法\n    it('should be okay with empty array', () => {  // it 接一些小的用例，后面最好就给一些描述啥的\n        let res = takeWhile([], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([]);  // 用 should 来比较是不是一个空数组\n    });\n\n    it('should be okay for normal array less than or equal 8', () => {\n        let res = takeWhile([1,2,3,8,10,6], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n    \n});\n```\n\n运行 `mocha takeWhile.js` 实现第一个测试 `return []` \n\n![image](http://upload-images.jianshu.io/upload_images/3191557-c3d18a2b8f498851.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第一个通过了，第二个没有通过并且提示给了我们要输出 `[1,2,3,8]`\n\n事实上测试用例越多，则说明这个方法越全面。\n\n```\n// 继续增加单元测试的用例\n\nlet takeWhile = require('../../src/array/takeWhile'),\n    should = require('should');\n\ndescribe('array takeWhile', () => {\n    it('should be okay with empty array', () => {\n        let res = takeWhile([], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([]);\n    });\n\n    it('should be okay for normal array less than or equal 8', () => {\n        let res = takeWhile([1,2,3,8,10,6], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n\n    it('should be okay for normal array greater than 3', () => {\n        let res = takeWhile([1,2,6], (it) => {\n            return it > 3;\n        });\n        res.should.be.eql([]);  // 第一个 1 就比 3 小直接返回空数组\n    });\n\n    it('should be okay for normal array greater than 3 with normal array', () => {\n        let res = takeWhile([4,2,6], (it) => {\n            return it > 3;\n        });\n        res.should.be.eql([4]);  // 第一个 4 就比 3 大直接返回 [4]\n    });\n\n    it('should be okay for normal array with objects', () => {\n        let res = takeWhile([{a: 3}, {a: 4}, {a: 5}], (it) => {\n            return it.a >= 3;\n        });\n        let obj = res[0];\n        obj.should.be.eql({a: 3});  // 看看第一个对象是不是 {a: 3}\n    });\n\n    it('should be okay for normal array with objects that has property a', () => {\n        let res = takeWhile([{a: 3}, {a: 4}, {c: 5}], (it) => {\n            return it.hasOwnProperty('a');\n        });\n        res.length.should.be.eql(2);  // 有 a 的数组是否长度是 2\n    });\n});\n```\n\n那现在就实现方法 `takeWhile` 通过所有的单元实例\n\n```\n/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n\t// todo...\n    let temp = [];\n    arr.some((it) => {\n        if(pred(it)) {\n            temp.push(it);\n        } else {\n            return true;\n        }\n    });\n    return temp;\n    /**\n     * let temp = [];\n     * for(let it of arr) {\n     *     if(pred(it)){\n     *         temp.push(it);\n     *     } else {\n     *         return temp;\n     *     }\n     * }\n     * return temp;\n     */\t\n}\n\nmodule.exports = takeWhile;\n```\n\n[Array.prototype.some()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some) [for...of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)\n\n```\n// 彩蛋 --- some() 的用法\nlet arr = [1,2,3]\narr.some(function(it) {return it < 4})  // true\narr.some(function(it) {return it === 3})  // true\narr.some(function(it) {return it > 5})  // false\n\narr.some(function(it) {console.log(it); return it < 4})  // 1 true\n// 只要有一个返回 true 就马上截止返回 true\n```\n\n### 例子2\n\n判断对象是不是空的对象（并不是指完全空的，原型上的东西还是要有的）\n\n```\nlet isEmptyObject = require('../../src/object/isEmptyObject'),\n    should = require('should');\n\ndescribe('isEmptyObject', () => {\n    it('empty object', () => {\n        isEmptyObject({}).should.eql(true);\n    });\n    \n    it('non-empty object', () => {\n        isEmptyObject({a: 'a'}).should.eql(false);\n    });\n\n    it('should be okay for array', () => {\n        isEmptyObject([]).should.eql(false);\n    });\n\n    it('should be okay for number', () => {\n        isEmptyObject(1).should.eql(false);\n    });\n\n    it('should be okay for string', () => {\n        isEmptyObject(\"abc\").should.eql(false);\n    });\n\n});\n```\n\n```\n/**\n * @param {Any} obj\n * @returns {Boolean}\n */\n\nfunction isEmptyObject(obj) {\n\t// todo...\n\t// Object.prototype.toString.call(obj).toLowerCase() === '[object object]'\n    return obj.constructor === Object && Object.keys(obj).length === 0;\n}\n\nmodule.exports = isEmptyObject;\n```\n\n[Object.prototype.constructor](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor)\n\n### 例子3\n\n实现一个 trim 方法去掉前后空格（单词中间的空格不能省略）\n\n```\nlet trim = require('../../src/string/trim'),\n    should = require('should');\n\ndescribe('string trim', () => {\n    it('trim string with no spaces at beginning and end', () => {\n        trim('hello world').should.eql('hello world');\n    });\n\n    it('trim string with space(s) at beginning', () => {\n        trim('  hello world').should.eql('hello world');\n    });\n\n    it('trim string with tab(s) at beginning', () => {\n        trim('\\thello world').should.eql('hello world');\n    });\n\n    it('trim string with new line(s) at beginning', () => {\n        trim('\\nhello world').should.eql('hello world');\n    });\n\n    it('trim string with space(s) at beginning', () => {\n        trim('hello world  ').should.eql('hello world');\n    });\n\n    it('trim string with tab(s) at beginning', () => {\n        trim('hello world\\t').should.eql('hello world');\n    });\n\n    it('trim string with new line(s) at beginning', () => {\n        trim('hello world\\n').should.eql('hello world');\n    });\n\n    it('trim string with spaces/tabs/new lines at beginning and end', () => {\n        trim(' \\t\\nhello world \\t\\n').should.eql('hello world');\n    });\n});\n```\n\n```\n/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\n\nmodule.exports = trim;\n```\n\n[String.prototype.trim()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim) 的 Polyfill 是 \n\n```\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n```\n\n### 例子4\n\n变成小驼峰\n\n```\nlet toCamel = require('../../src/string/toCamel'),\n    should = require('should');\n\ndescribe('string to camel case', () => {\n    it('empty string', () => {\n        toCamel('').should.eql('');\n    });\n\n    it('underscore string', () => {\n        toCamel('hello_world').should.eql('helloWorld');\n    });\n\n    it('underscore string', () => {\n        toCamel('hello_World').should.eql('helloWorld');\n    });\n\n    it('underscore string', () => {\n        toCamel('hello-world').should.eql('hello-world');\n    });\n\n    it('normal string', () => {\n        toCamel('helloWorld').should.eql('helloWorld');\n    });\n});\n```\n\n```\n/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction toCamel(str) {\n    return str.replace(/_(.)/,(whole, matched) => {  // whole 就是 _(.) matched 就是 (.) // 括号在正则表达式里就是一个捕获的关系\n        return matched.toUpperCase();\n    });\n}\n\nmodule.exports = toCamel;\n\nconsole.log(whole, matched)  // _w w _W W\n```\n\n## 怎么做集成\n\n相当于有中央服务器做集成，我提交代码，服务器自动帮我跑\n\n[Travis CI](https://www.travis-ci.org/)\n\n[Travis setup guide](http://blog.csdn.net/buptgshengod/article/details/39578353)\n\n可以在 github 上做一个仓库，我一提交代码就会自动帮忙跑。（这个了解就好，其实都差不多的，就是人工跑代码和机器跑代码的区别）","source":"_posts/补基础：JS 单元测试.md","raw":"---\ntitle: 补基础：JS 单元测试\ndate: 2017-11-13 18:07:52\ntags: [JavaScript]\n---\n# 补基础：JS 单元测试\n\n## 单元测试有啥用？\n\n修改函数的实现方式难以保证输出的东西是自己想要的。\n\n比如 GitHub 上较大的开源项目在别人贡献代码的时候要保证输出的东西和原来的一样。\n\n单元测试就是保证这个。\n\n而且单元测试也是一个文档，告诉别人怎么使用这个文档。\n\n[教练我要写单元测试](https://github.com/n0ruSh/blogs/issues/2)\n\n[Mocha](http://mochajs.org/)\n\n[Should](http://shouldjs.github.io/)\n\n### 例子1\n\n现在做一个方法 `takeWhile` ，传一个数组和函数通过所有的 Mocha 测试\n\n```\n/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n\t// todo...\n\t/*\n\t第一个测试\n\treturn []\n\t*/\n}\n\nmodule.exports = takeWhile;\n```\n\n上面的 `@param` 看这个了解就好。[@param](http://www.css88.com/doc/jsdoc/tags-param.html)\n\nMocha 的测试写法\n\n```\nlet takeWhile = require('../../src/array/takeWhile'),\n    should = require('should');  // 比较库或者叫断言库，用来看输出后的东西是不是一样的。\n\ndescribe('array takeWhile', () => {  // describe 里面可以写一些小方法\n    it('should be okay with empty array', () => {  // it 接一些小的用例，后面最好就给一些描述啥的\n        let res = takeWhile([], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([]);  // 用 should 来比较是不是一个空数组\n    });\n\n    it('should be okay for normal array less than or equal 8', () => {\n        let res = takeWhile([1,2,3,8,10,6], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n    \n});\n```\n\n运行 `mocha takeWhile.js` 实现第一个测试 `return []` \n\n![image](http://upload-images.jianshu.io/upload_images/3191557-c3d18a2b8f498851.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第一个通过了，第二个没有通过并且提示给了我们要输出 `[1,2,3,8]`\n\n事实上测试用例越多，则说明这个方法越全面。\n\n```\n// 继续增加单元测试的用例\n\nlet takeWhile = require('../../src/array/takeWhile'),\n    should = require('should');\n\ndescribe('array takeWhile', () => {\n    it('should be okay with empty array', () => {\n        let res = takeWhile([], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([]);\n    });\n\n    it('should be okay for normal array less than or equal 8', () => {\n        let res = takeWhile([1,2,3,8,10,6], (it) => {\n            return it <= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n\n    it('should be okay for normal array greater than 3', () => {\n        let res = takeWhile([1,2,6], (it) => {\n            return it > 3;\n        });\n        res.should.be.eql([]);  // 第一个 1 就比 3 小直接返回空数组\n    });\n\n    it('should be okay for normal array greater than 3 with normal array', () => {\n        let res = takeWhile([4,2,6], (it) => {\n            return it > 3;\n        });\n        res.should.be.eql([4]);  // 第一个 4 就比 3 大直接返回 [4]\n    });\n\n    it('should be okay for normal array with objects', () => {\n        let res = takeWhile([{a: 3}, {a: 4}, {a: 5}], (it) => {\n            return it.a >= 3;\n        });\n        let obj = res[0];\n        obj.should.be.eql({a: 3});  // 看看第一个对象是不是 {a: 3}\n    });\n\n    it('should be okay for normal array with objects that has property a', () => {\n        let res = takeWhile([{a: 3}, {a: 4}, {c: 5}], (it) => {\n            return it.hasOwnProperty('a');\n        });\n        res.length.should.be.eql(2);  // 有 a 的数组是否长度是 2\n    });\n});\n```\n\n那现在就实现方法 `takeWhile` 通过所有的单元实例\n\n```\n/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n\t// todo...\n    let temp = [];\n    arr.some((it) => {\n        if(pred(it)) {\n            temp.push(it);\n        } else {\n            return true;\n        }\n    });\n    return temp;\n    /**\n     * let temp = [];\n     * for(let it of arr) {\n     *     if(pred(it)){\n     *         temp.push(it);\n     *     } else {\n     *         return temp;\n     *     }\n     * }\n     * return temp;\n     */\t\n}\n\nmodule.exports = takeWhile;\n```\n\n[Array.prototype.some()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some) [for...of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)\n\n```\n// 彩蛋 --- some() 的用法\nlet arr = [1,2,3]\narr.some(function(it) {return it < 4})  // true\narr.some(function(it) {return it === 3})  // true\narr.some(function(it) {return it > 5})  // false\n\narr.some(function(it) {console.log(it); return it < 4})  // 1 true\n// 只要有一个返回 true 就马上截止返回 true\n```\n\n### 例子2\n\n判断对象是不是空的对象（并不是指完全空的，原型上的东西还是要有的）\n\n```\nlet isEmptyObject = require('../../src/object/isEmptyObject'),\n    should = require('should');\n\ndescribe('isEmptyObject', () => {\n    it('empty object', () => {\n        isEmptyObject({}).should.eql(true);\n    });\n    \n    it('non-empty object', () => {\n        isEmptyObject({a: 'a'}).should.eql(false);\n    });\n\n    it('should be okay for array', () => {\n        isEmptyObject([]).should.eql(false);\n    });\n\n    it('should be okay for number', () => {\n        isEmptyObject(1).should.eql(false);\n    });\n\n    it('should be okay for string', () => {\n        isEmptyObject(\"abc\").should.eql(false);\n    });\n\n});\n```\n\n```\n/**\n * @param {Any} obj\n * @returns {Boolean}\n */\n\nfunction isEmptyObject(obj) {\n\t// todo...\n\t// Object.prototype.toString.call(obj).toLowerCase() === '[object object]'\n    return obj.constructor === Object && Object.keys(obj).length === 0;\n}\n\nmodule.exports = isEmptyObject;\n```\n\n[Object.prototype.constructor](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor)\n\n### 例子3\n\n实现一个 trim 方法去掉前后空格（单词中间的空格不能省略）\n\n```\nlet trim = require('../../src/string/trim'),\n    should = require('should');\n\ndescribe('string trim', () => {\n    it('trim string with no spaces at beginning and end', () => {\n        trim('hello world').should.eql('hello world');\n    });\n\n    it('trim string with space(s) at beginning', () => {\n        trim('  hello world').should.eql('hello world');\n    });\n\n    it('trim string with tab(s) at beginning', () => {\n        trim('\\thello world').should.eql('hello world');\n    });\n\n    it('trim string with new line(s) at beginning', () => {\n        trim('\\nhello world').should.eql('hello world');\n    });\n\n    it('trim string with space(s) at beginning', () => {\n        trim('hello world  ').should.eql('hello world');\n    });\n\n    it('trim string with tab(s) at beginning', () => {\n        trim('hello world\\t').should.eql('hello world');\n    });\n\n    it('trim string with new line(s) at beginning', () => {\n        trim('hello world\\n').should.eql('hello world');\n    });\n\n    it('trim string with spaces/tabs/new lines at beginning and end', () => {\n        trim(' \\t\\nhello world \\t\\n').should.eql('hello world');\n    });\n});\n```\n\n```\n/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\n\nmodule.exports = trim;\n```\n\n[String.prototype.trim()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim) 的 Polyfill 是 \n\n```\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n```\n\n### 例子4\n\n变成小驼峰\n\n```\nlet toCamel = require('../../src/string/toCamel'),\n    should = require('should');\n\ndescribe('string to camel case', () => {\n    it('empty string', () => {\n        toCamel('').should.eql('');\n    });\n\n    it('underscore string', () => {\n        toCamel('hello_world').should.eql('helloWorld');\n    });\n\n    it('underscore string', () => {\n        toCamel('hello_World').should.eql('helloWorld');\n    });\n\n    it('underscore string', () => {\n        toCamel('hello-world').should.eql('hello-world');\n    });\n\n    it('normal string', () => {\n        toCamel('helloWorld').should.eql('helloWorld');\n    });\n});\n```\n\n```\n/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction toCamel(str) {\n    return str.replace(/_(.)/,(whole, matched) => {  // whole 就是 _(.) matched 就是 (.) // 括号在正则表达式里就是一个捕获的关系\n        return matched.toUpperCase();\n    });\n}\n\nmodule.exports = toCamel;\n\nconsole.log(whole, matched)  // _w w _W W\n```\n\n## 怎么做集成\n\n相当于有中央服务器做集成，我提交代码，服务器自动帮我跑\n\n[Travis CI](https://www.travis-ci.org/)\n\n[Travis setup guide](http://blog.csdn.net/buptgshengod/article/details/39578353)\n\n可以在 github 上做一个仓库，我一提交代码就会自动帮忙跑。（这个了解就好，其实都差不多的，就是人工跑代码和机器跑代码的区别）","slug":"补基础：JS 单元测试","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d950017f1xh5qaz5y67","content":"<h1 id=\"补基础：JS-单元测试\"><a href=\"#补基础：JS-单元测试\" class=\"headerlink\" title=\"补基础：JS 单元测试\"></a>补基础：JS 单元测试</h1><h2 id=\"单元测试有啥用？\"><a href=\"#单元测试有啥用？\" class=\"headerlink\" title=\"单元测试有啥用？\"></a>单元测试有啥用？</h2><p>修改函数的实现方式难以保证输出的东西是自己想要的。</p>\n<p>比如 GitHub 上较大的开源项目在别人贡献代码的时候要保证输出的东西和原来的一样。</p>\n<p>单元测试就是保证这个。</p>\n<p>而且单元测试也是一个文档，告诉别人怎么使用这个文档。</p>\n<p><a href=\"https://github.com/n0ruSh/blogs/issues/2\" target=\"_blank\" rel=\"noopener\">教练我要写单元测试</a></p>\n<p><a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a></p>\n<p><a href=\"http://shouldjs.github.io/\" target=\"_blank\" rel=\"noopener\">Should</a></p>\n<h3 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h3><p>现在做一个方法 <code>takeWhile</code> ，传一个数组和函数通过所有的 Mocha 测试</p>\n<pre><code>/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n    // todo...\n    /*\n    第一个测试\n    return []\n    */\n}\n\nmodule.exports = takeWhile;\n</code></pre><p>上面的 <code>@param</code> 看这个了解就好。<a href=\"http://www.css88.com/doc/jsdoc/tags-param.html\" target=\"_blank\" rel=\"noopener\">@param</a></p>\n<p>Mocha 的测试写法</p>\n<pre><code>let takeWhile = require(&#39;../../src/array/takeWhile&#39;),\n    should = require(&#39;should&#39;);  // 比较库或者叫断言库，用来看输出后的东西是不是一样的。\n\ndescribe(&#39;array takeWhile&#39;, () =&gt; {  // describe 里面可以写一些小方法\n    it(&#39;should be okay with empty array&#39;, () =&gt; {  // it 接一些小的用例，后面最好就给一些描述啥的\n        let res = takeWhile([], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([]);  // 用 should 来比较是不是一个空数组\n    });\n\n    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {\n        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n\n});\n</code></pre><p>运行 <code>mocha takeWhile.js</code> 实现第一个测试 <code>return []</code> </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c3d18a2b8f498851.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>第一个通过了，第二个没有通过并且提示给了我们要输出 <code>[1,2,3,8]</code></p>\n<p>事实上测试用例越多，则说明这个方法越全面。</p>\n<pre><code>// 继续增加单元测试的用例\n\nlet takeWhile = require(&#39;../../src/array/takeWhile&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;array takeWhile&#39;, () =&gt; {\n    it(&#39;should be okay with empty array&#39;, () =&gt; {\n        let res = takeWhile([], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([]);\n    });\n\n    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {\n        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n\n    it(&#39;should be okay for normal array greater than 3&#39;, () =&gt; {\n        let res = takeWhile([1,2,6], (it) =&gt; {\n            return it &gt; 3;\n        });\n        res.should.be.eql([]);  // 第一个 1 就比 3 小直接返回空数组\n    });\n\n    it(&#39;should be okay for normal array greater than 3 with normal array&#39;, () =&gt; {\n        let res = takeWhile([4,2,6], (it) =&gt; {\n            return it &gt; 3;\n        });\n        res.should.be.eql([4]);  // 第一个 4 就比 3 大直接返回 [4]\n    });\n\n    it(&#39;should be okay for normal array with objects&#39;, () =&gt; {\n        let res = takeWhile([{a: 3}, {a: 4}, {a: 5}], (it) =&gt; {\n            return it.a &gt;= 3;\n        });\n        let obj = res[0];\n        obj.should.be.eql({a: 3});  // 看看第一个对象是不是 {a: 3}\n    });\n\n    it(&#39;should be okay for normal array with objects that has property a&#39;, () =&gt; {\n        let res = takeWhile([{a: 3}, {a: 4}, {c: 5}], (it) =&gt; {\n            return it.hasOwnProperty(&#39;a&#39;);\n        });\n        res.length.should.be.eql(2);  // 有 a 的数组是否长度是 2\n    });\n});\n</code></pre><p>那现在就实现方法 <code>takeWhile</code> 通过所有的单元实例</p>\n<pre><code>/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n    // todo...\n    let temp = [];\n    arr.some((it) =&gt; {\n        if(pred(it)) {\n            temp.push(it);\n        } else {\n            return true;\n        }\n    });\n    return temp;\n    /**\n     * let temp = [];\n     * for(let it of arr) {\n     *     if(pred(it)){\n     *         temp.push(it);\n     *     } else {\n     *         return temp;\n     *     }\n     * }\n     * return temp;\n     */    \n}\n\nmodule.exports = takeWhile;\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some\" target=\"_blank\" rel=\"noopener\">Array.prototype.some()</a> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\" target=\"_blank\" rel=\"noopener\">for…of</a></p>\n<pre><code>// 彩蛋 --- some() 的用法\nlet arr = [1,2,3]\narr.some(function(it) {return it &lt; 4})  // true\narr.some(function(it) {return it === 3})  // true\narr.some(function(it) {return it &gt; 5})  // false\n\narr.some(function(it) {console.log(it); return it &lt; 4})  // 1 true\n// 只要有一个返回 true 就马上截止返回 true\n</code></pre><h3 id=\"例子2\"><a href=\"#例子2\" class=\"headerlink\" title=\"例子2\"></a>例子2</h3><p>判断对象是不是空的对象（并不是指完全空的，原型上的东西还是要有的）</p>\n<pre><code>let isEmptyObject = require(&#39;../../src/object/isEmptyObject&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;isEmptyObject&#39;, () =&gt; {\n    it(&#39;empty object&#39;, () =&gt; {\n        isEmptyObject({}).should.eql(true);\n    });\n\n    it(&#39;non-empty object&#39;, () =&gt; {\n        isEmptyObject({a: &#39;a&#39;}).should.eql(false);\n    });\n\n    it(&#39;should be okay for array&#39;, () =&gt; {\n        isEmptyObject([]).should.eql(false);\n    });\n\n    it(&#39;should be okay for number&#39;, () =&gt; {\n        isEmptyObject(1).should.eql(false);\n    });\n\n    it(&#39;should be okay for string&#39;, () =&gt; {\n        isEmptyObject(&quot;abc&quot;).should.eql(false);\n    });\n\n});\n</code></pre><pre><code>/**\n * @param {Any} obj\n * @returns {Boolean}\n */\n\nfunction isEmptyObject(obj) {\n    // todo...\n    // Object.prototype.toString.call(obj).toLowerCase() === &#39;[object object]&#39;\n    return obj.constructor === Object &amp;&amp; Object.keys(obj).length === 0;\n}\n\nmodule.exports = isEmptyObject;\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\" target=\"_blank\" rel=\"noopener\">Object.prototype.constructor</a></p>\n<h3 id=\"例子3\"><a href=\"#例子3\" class=\"headerlink\" title=\"例子3\"></a>例子3</h3><p>实现一个 trim 方法去掉前后空格（单词中间的空格不能省略）</p>\n<pre><code>let trim = require(&#39;../../src/string/trim&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;string trim&#39;, () =&gt; {\n    it(&#39;trim string with no spaces at beginning and end&#39;, () =&gt; {\n        trim(&#39;hello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {\n        trim(&#39;  hello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {\n        trim(&#39;\\thello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {\n        trim(&#39;\\nhello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {\n        trim(&#39;hello world  &#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {\n        trim(&#39;hello world\\t&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {\n        trim(&#39;hello world\\n&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with spaces/tabs/new lines at beginning and end&#39;, () =&gt; {\n        trim(&#39; \\t\\nhello world \\t\\n&#39;).should.eql(&#39;hello world&#39;);\n    });\n});\n</code></pre><pre><code>/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, &quot;&quot;);\n}\n\nmodule.exports = trim;\n</code></pre><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim\" target=\"_blank\" rel=\"noopener\">String.prototype.trim()</a> 的 Polyfill 是 </p>\n<pre><code>if (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#39;&#39;);\n  };\n}\n</code></pre><h3 id=\"例子4\"><a href=\"#例子4\" class=\"headerlink\" title=\"例子4\"></a>例子4</h3><p>变成小驼峰</p>\n<pre><code>let toCamel = require(&#39;../../src/string/toCamel&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;string to camel case&#39;, () =&gt; {\n    it(&#39;empty string&#39;, () =&gt; {\n        toCamel(&#39;&#39;).should.eql(&#39;&#39;);\n    });\n\n    it(&#39;underscore string&#39;, () =&gt; {\n        toCamel(&#39;hello_world&#39;).should.eql(&#39;helloWorld&#39;);\n    });\n\n    it(&#39;underscore string&#39;, () =&gt; {\n        toCamel(&#39;hello_World&#39;).should.eql(&#39;helloWorld&#39;);\n    });\n\n    it(&#39;underscore string&#39;, () =&gt; {\n        toCamel(&#39;hello-world&#39;).should.eql(&#39;hello-world&#39;);\n    });\n\n    it(&#39;normal string&#39;, () =&gt; {\n        toCamel(&#39;helloWorld&#39;).should.eql(&#39;helloWorld&#39;);\n    });\n});\n</code></pre><pre><code>/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction toCamel(str) {\n    return str.replace(/_(.)/,(whole, matched) =&gt; {  // whole 就是 _(.) matched 就是 (.) // 括号在正则表达式里就是一个捕获的关系\n        return matched.toUpperCase();\n    });\n}\n\nmodule.exports = toCamel;\n\nconsole.log(whole, matched)  // _w w _W W\n</code></pre><h2 id=\"怎么做集成\"><a href=\"#怎么做集成\" class=\"headerlink\" title=\"怎么做集成\"></a>怎么做集成</h2><p>相当于有中央服务器做集成，我提交代码，服务器自动帮我跑</p>\n<p><a href=\"https://www.travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI</a></p>\n<p><a href=\"http://blog.csdn.net/buptgshengod/article/details/39578353\" target=\"_blank\" rel=\"noopener\">Travis setup guide</a></p>\n<p>可以在 github 上做一个仓库，我一提交代码就会自动帮忙跑。（这个了解就好，其实都差不多的，就是人工跑代码和机器跑代码的区别）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：JS-单元测试\"><a href=\"#补基础：JS-单元测试\" class=\"headerlink\" title=\"补基础：JS 单元测试\"></a>补基础：JS 单元测试</h1><h2 id=\"单元测试有啥用？\"><a href=\"#单元测试有啥用？\" class=\"headerlink\" title=\"单元测试有啥用？\"></a>单元测试有啥用？</h2><p>修改函数的实现方式难以保证输出的东西是自己想要的。</p>\n<p>比如 GitHub 上较大的开源项目在别人贡献代码的时候要保证输出的东西和原来的一样。</p>\n<p>单元测试就是保证这个。</p>\n<p>而且单元测试也是一个文档，告诉别人怎么使用这个文档。</p>\n<p><a href=\"https://github.com/n0ruSh/blogs/issues/2\" target=\"_blank\" rel=\"noopener\">教练我要写单元测试</a></p>\n<p><a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a></p>\n<p><a href=\"http://shouldjs.github.io/\" target=\"_blank\" rel=\"noopener\">Should</a></p>\n<h3 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h3><p>现在做一个方法 <code>takeWhile</code> ，传一个数组和函数通过所有的 Mocha 测试</p>\n<pre><code>/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n    // todo...\n    /*\n    第一个测试\n    return []\n    */\n}\n\nmodule.exports = takeWhile;\n</code></pre><p>上面的 <code>@param</code> 看这个了解就好。<a href=\"http://www.css88.com/doc/jsdoc/tags-param.html\" target=\"_blank\" rel=\"noopener\">@param</a></p>\n<p>Mocha 的测试写法</p>\n<pre><code>let takeWhile = require(&#39;../../src/array/takeWhile&#39;),\n    should = require(&#39;should&#39;);  // 比较库或者叫断言库，用来看输出后的东西是不是一样的。\n\ndescribe(&#39;array takeWhile&#39;, () =&gt; {  // describe 里面可以写一些小方法\n    it(&#39;should be okay with empty array&#39;, () =&gt; {  // it 接一些小的用例，后面最好就给一些描述啥的\n        let res = takeWhile([], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([]);  // 用 should 来比较是不是一个空数组\n    });\n\n    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {\n        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n\n});\n</code></pre><p>运行 <code>mocha takeWhile.js</code> 实现第一个测试 <code>return []</code> </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3191557-c3d18a2b8f498851.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>第一个通过了，第二个没有通过并且提示给了我们要输出 <code>[1,2,3,8]</code></p>\n<p>事实上测试用例越多，则说明这个方法越全面。</p>\n<pre><code>// 继续增加单元测试的用例\n\nlet takeWhile = require(&#39;../../src/array/takeWhile&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;array takeWhile&#39;, () =&gt; {\n    it(&#39;should be okay with empty array&#39;, () =&gt; {\n        let res = takeWhile([], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([]);\n    });\n\n    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {\n        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {\n            return it &lt;= 8;\n        });\n        res.should.be.eql([1,2,3,8]);\n    });\n\n    it(&#39;should be okay for normal array greater than 3&#39;, () =&gt; {\n        let res = takeWhile([1,2,6], (it) =&gt; {\n            return it &gt; 3;\n        });\n        res.should.be.eql([]);  // 第一个 1 就比 3 小直接返回空数组\n    });\n\n    it(&#39;should be okay for normal array greater than 3 with normal array&#39;, () =&gt; {\n        let res = takeWhile([4,2,6], (it) =&gt; {\n            return it &gt; 3;\n        });\n        res.should.be.eql([4]);  // 第一个 4 就比 3 大直接返回 [4]\n    });\n\n    it(&#39;should be okay for normal array with objects&#39;, () =&gt; {\n        let res = takeWhile([{a: 3}, {a: 4}, {a: 5}], (it) =&gt; {\n            return it.a &gt;= 3;\n        });\n        let obj = res[0];\n        obj.should.be.eql({a: 3});  // 看看第一个对象是不是 {a: 3}\n    });\n\n    it(&#39;should be okay for normal array with objects that has property a&#39;, () =&gt; {\n        let res = takeWhile([{a: 3}, {a: 4}, {c: 5}], (it) =&gt; {\n            return it.hasOwnProperty(&#39;a&#39;);\n        });\n        res.length.should.be.eql(2);  // 有 a 的数组是否长度是 2\n    });\n});\n</code></pre><p>那现在就实现方法 <code>takeWhile</code> 通过所有的单元实例</p>\n<pre><code>/**\n * @param {Array} arr - base array\n * @param {Function} pred - predicate\n * @returns {Array}\n */\n\nfunction takeWhile(arr, pred) {\n    // todo...\n    let temp = [];\n    arr.some((it) =&gt; {\n        if(pred(it)) {\n            temp.push(it);\n        } else {\n            return true;\n        }\n    });\n    return temp;\n    /**\n     * let temp = [];\n     * for(let it of arr) {\n     *     if(pred(it)){\n     *         temp.push(it);\n     *     } else {\n     *         return temp;\n     *     }\n     * }\n     * return temp;\n     */    \n}\n\nmodule.exports = takeWhile;\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some\" target=\"_blank\" rel=\"noopener\">Array.prototype.some()</a> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\" target=\"_blank\" rel=\"noopener\">for…of</a></p>\n<pre><code>// 彩蛋 --- some() 的用法\nlet arr = [1,2,3]\narr.some(function(it) {return it &lt; 4})  // true\narr.some(function(it) {return it === 3})  // true\narr.some(function(it) {return it &gt; 5})  // false\n\narr.some(function(it) {console.log(it); return it &lt; 4})  // 1 true\n// 只要有一个返回 true 就马上截止返回 true\n</code></pre><h3 id=\"例子2\"><a href=\"#例子2\" class=\"headerlink\" title=\"例子2\"></a>例子2</h3><p>判断对象是不是空的对象（并不是指完全空的，原型上的东西还是要有的）</p>\n<pre><code>let isEmptyObject = require(&#39;../../src/object/isEmptyObject&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;isEmptyObject&#39;, () =&gt; {\n    it(&#39;empty object&#39;, () =&gt; {\n        isEmptyObject({}).should.eql(true);\n    });\n\n    it(&#39;non-empty object&#39;, () =&gt; {\n        isEmptyObject({a: &#39;a&#39;}).should.eql(false);\n    });\n\n    it(&#39;should be okay for array&#39;, () =&gt; {\n        isEmptyObject([]).should.eql(false);\n    });\n\n    it(&#39;should be okay for number&#39;, () =&gt; {\n        isEmptyObject(1).should.eql(false);\n    });\n\n    it(&#39;should be okay for string&#39;, () =&gt; {\n        isEmptyObject(&quot;abc&quot;).should.eql(false);\n    });\n\n});\n</code></pre><pre><code>/**\n * @param {Any} obj\n * @returns {Boolean}\n */\n\nfunction isEmptyObject(obj) {\n    // todo...\n    // Object.prototype.toString.call(obj).toLowerCase() === &#39;[object object]&#39;\n    return obj.constructor === Object &amp;&amp; Object.keys(obj).length === 0;\n}\n\nmodule.exports = isEmptyObject;\n</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\" target=\"_blank\" rel=\"noopener\">Object.prototype.constructor</a></p>\n<h3 id=\"例子3\"><a href=\"#例子3\" class=\"headerlink\" title=\"例子3\"></a>例子3</h3><p>实现一个 trim 方法去掉前后空格（单词中间的空格不能省略）</p>\n<pre><code>let trim = require(&#39;../../src/string/trim&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;string trim&#39;, () =&gt; {\n    it(&#39;trim string with no spaces at beginning and end&#39;, () =&gt; {\n        trim(&#39;hello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {\n        trim(&#39;  hello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {\n        trim(&#39;\\thello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {\n        trim(&#39;\\nhello world&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {\n        trim(&#39;hello world  &#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {\n        trim(&#39;hello world\\t&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {\n        trim(&#39;hello world\\n&#39;).should.eql(&#39;hello world&#39;);\n    });\n\n    it(&#39;trim string with spaces/tabs/new lines at beginning and end&#39;, () =&gt; {\n        trim(&#39; \\t\\nhello world \\t\\n&#39;).should.eql(&#39;hello world&#39;);\n    });\n});\n</code></pre><pre><code>/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, &quot;&quot;);\n}\n\nmodule.exports = trim;\n</code></pre><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim\" target=\"_blank\" rel=\"noopener\">String.prototype.trim()</a> 的 Polyfill 是 </p>\n<pre><code>if (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#39;&#39;);\n  };\n}\n</code></pre><h3 id=\"例子4\"><a href=\"#例子4\" class=\"headerlink\" title=\"例子4\"></a>例子4</h3><p>变成小驼峰</p>\n<pre><code>let toCamel = require(&#39;../../src/string/toCamel&#39;),\n    should = require(&#39;should&#39;);\n\ndescribe(&#39;string to camel case&#39;, () =&gt; {\n    it(&#39;empty string&#39;, () =&gt; {\n        toCamel(&#39;&#39;).should.eql(&#39;&#39;);\n    });\n\n    it(&#39;underscore string&#39;, () =&gt; {\n        toCamel(&#39;hello_world&#39;).should.eql(&#39;helloWorld&#39;);\n    });\n\n    it(&#39;underscore string&#39;, () =&gt; {\n        toCamel(&#39;hello_World&#39;).should.eql(&#39;helloWorld&#39;);\n    });\n\n    it(&#39;underscore string&#39;, () =&gt; {\n        toCamel(&#39;hello-world&#39;).should.eql(&#39;hello-world&#39;);\n    });\n\n    it(&#39;normal string&#39;, () =&gt; {\n        toCamel(&#39;helloWorld&#39;).should.eql(&#39;helloWorld&#39;);\n    });\n});\n</code></pre><pre><code>/**\n * @param {String} str\n * @returns {String}\n */\n\nfunction toCamel(str) {\n    return str.replace(/_(.)/,(whole, matched) =&gt; {  // whole 就是 _(.) matched 就是 (.) // 括号在正则表达式里就是一个捕获的关系\n        return matched.toUpperCase();\n    });\n}\n\nmodule.exports = toCamel;\n\nconsole.log(whole, matched)  // _w w _W W\n</code></pre><h2 id=\"怎么做集成\"><a href=\"#怎么做集成\" class=\"headerlink\" title=\"怎么做集成\"></a>怎么做集成</h2><p>相当于有中央服务器做集成，我提交代码，服务器自动帮我跑</p>\n<p><a href=\"https://www.travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI</a></p>\n<p><a href=\"http://blog.csdn.net/buptgshengod/article/details/39578353\" target=\"_blank\" rel=\"noopener\">Travis setup guide</a></p>\n<p>可以在 github 上做一个仓库，我一提交代码就会自动帮忙跑。（这个了解就好，其实都差不多的，就是人工跑代码和机器跑代码的区别）</p>\n"},{"title":"补基础：JS 模块化","date":"2017-12-08T11:59:10.000Z","_content":"# 补基础：JS 模块化\n\n为什么要用到模块化\n\n- 解耦\n- 复用\n\n先举一个简单的例子\n\n```\n// html\n<body>\n    <script src=\"./js/main.js\"></script>\n</body>\n\n// js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I'm ${this.name}`)\n    }\n}\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I'm working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\nfunction formatSalary(salary) {\n    return salary + ' RMB'\n}\n\nlet frankie = new Employee('frankie', 5000)\nfrankie.sayHi() // hello I'm frankie\nfrankie.work() // I'm working, My salary is 5000 RMB\n```\n\n如果像上面那么样引入会直接暴露所有接口，而且起名字也要很小心，如果使用模块化就可以解决这些问题。\n\n## namespace\n\n在没有 es6 的时代，用一种叫 namespace 的方法\n\n解决暴露接口的问题可以用 namespace ，创造一个命名空间\n\n```\n// html 注意顺序（JS 加载）\n<script src=\"./js/person.js\"></script>\n<script src=\"./js/util.js\"></script>\n<script src=\"./js/employee.js\"></script>\n<script src=\"./js/main.js\"></script>\n\n// person.js\n(function (global) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I'm ${this.name}`)\n        }\n    }\n\n    let namespace = global.MYAPP = global.MYAPP || {}  // 初始化\n    namespace.Person = Person  // 导出 Person\n\n})(window)\n\n// util.js\n(function (global) {\n    let namespace = global.MYAPP  // 因为 Person.js 是先引的所以页面上已经存在 global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + ' RMB'\n        }\n    }\n})(window)\n\n// employee.js\n(function (global) {\n\n    let namespace = global.MYAPP  // 同理\n    let Person = namespace.Person  // 引入 Person\n    let formatSalary = namespace.UTILS.formatSalary\n\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I'm working, My salary is ${formatSalary(this.salary)}`)\n        }\n    }\n\n    namespace.Employee = Employee  // 导出 Employee\n\n})(window)\n\n// main.js\n(function (global) {\n    let namespace = global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + ' RMB'\n        }\n    }\n})(window)\n```\n\n问题也是很明显的，JS 的执行顺序很让人头疼\n\n## AMD\n\n于是就有了新的规范 AMD -> [requirejs](http://requirejs.org/) [Javascript模块化编程（三）：require.js的用法](http://www.ruanyifeng.com/blog/2012/11/require_js.html)\n\n```\n// 举个例子\n// html 引入 requirejs\n<script src=\"../node_modules/requirejs/require.js\" data-main=\"./js/main.js\"></script>\n\n// person.js\ndefine(function () {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I'm ${this.name}`)\n        }\n    }\n    return Person  // 导出 Person 模块\n})\n\n// util.js\ndefine(function () {\n    return {  // 导出方法\n        formatSalary: function (salary) {\n            return salary + ' RMB'\n        }\n    }\n})\n\n// employee.js\ndefine(['./person', './util'], function (Person, UTILS) {  // 引入 Person 和 util 两个依赖，记住是异步加载\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I'm working, My salary is ${UTILS.formatSalary(this.salary)}`)  // 使用 UTILS 的 formatSalary 方法\n        }\n    }\n    return Employee  // 导出 Employee 模块\n})\n\n// main.js\nrequire(['./employee'], function (Employee) {  // 引入依赖 Employee\n    let frankie = new Employee('frankie', 5000)\n    frankie.sayHi() // hello I'm frankie\n    frankie.work() // I'm working, My salary is 5000 RMB\n})\n```\n\n上面这个例子全部是依赖于 requirejs 来实现模块化，requirejs 定义了两个方法，define 和 require。他们都可以传两个参数，第一个是依赖，用数组表示，而且是异步加载，加载完后当做参数传给你要写逻辑的函数。\n\nAMD -> Asynchronous Module Definition（异步的模块定义）\n\n## CommonJS\n\n是后端的模块化，主要是由 `require` 引入，`module.exports` 导出\n\n```\n// person.js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I'm ${this.name}`)\n    }\n}\nmodule.exports = Person  // 导出 Person\n\n// util.js\nmodule.exports = {  // 导出方法\n    formatSalary: function (salary) {\n        return salary + ' RMB'\n    }\n}\n\n// employee.js\nlet Person = require('./person.js')\n    UTILS = require('./util.js')  // 引入两个依赖\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I'm working, My salary is ${UTILS.formatSalary(this.salary)}`)\n    }\n}\nmodule.exports = Employee  // 导出 Employee\n\n// main.js\nlet Employee = require('./employee.js')  // 引入依赖\n\nlet frankie = new Employee('frankie', 5000)\nfrankie.sayHi() // hello I'm frankie\nfrankie.work() // I'm working, My salary is 5000 RMB\n```\n\nCommonJS 这个规范不用把模块用 `function` 包起来，因为 node.js 定义就是每个文件就是模块\n\n## UMD\n\n假如在 AMD 规范里加载 CommonJS 规范的模块肯定是不识别，在 CommonJS 规范里加载 AMD 规范也肯定不行\n\n那怎么 AMD 和 CommonJS 都通吃呢？\n\n```\n(function (gl) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I'm ${this.name}`)\n        }\n    }\n\n    // 这里是通用方法\n    if (gl.hasOwnProperty('define')) {  // 看全局变量有没有 define，有执行 amd 规范\n        define(function () {\n            return Person\n        })\n    } else if (module != null && typeof module.exports === 'object') {  // module 在不在 module.exports 在不在，在就执行 commonjs 规范\n        module.exports = Person\n    } else {\n        gl.Person = Person  // 如果都没有就挂到全局变量\n    }\n})(this)  // 传一个全局变量\n```\n\n[vue-class-components](https://github.com/vuejs/vue-class-component) 也有这种判断规范的方法\n\n![](https://us1.myximage.com/2017/12/08/f296231a6848467fa1ad1c777079553c.png)\n\n## es6 里的 import 和 export\n\n```\n<body>\n    <script src=\"./bundle.js\"></script>\n</body>\n\n// person.js\nexport default class Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I'm ${this.name}`)\n    }\n}\n\n// util.js\nexport default function formatSalary(salary) {\n    return salary + ' RMB'\n}\n\n// employee.js\nimport Person from './person.js'\nimport formatSalary from './util.js'\n\nexport default class Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I'm working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\n// main.js\nimport Employee from './employee.js'\n\nlet frankie = new Employee('frankie', 5000)\nfrankie.sayHi() // hello I'm frankie\nfrankie.work() // I'm working, My salary is 5000 RMB\n\n// 设置好 webpack 打包\n```\n\n值得一提的是，webpack 兼容所有模块规范的打包，各种规范混搭也可以。\n\n## 彩蛋\n\n### 做一个 require\n\n```\n// person.js\nfunction Person(name) {\n    this.name = name\n}\n\nPerson.prototype.sayHi = function () {\n    console.log(`hello I'm ${this.name}`)\n}\n\ntest.exports = Person  // 这里这个 test 要和下面一样\n\n// myrequire.js\nlet fs = require('fs')\n\nlet modul = (function () {\n    let mod = {\n        exports: {}\n    }\n    function myrequire(filePath) {\n        let fnInText = fs.readFileSync(filePath, 'utf8')\n        let fn = new Function('test', fnInText)\n        fn(mod)\n    }\n\n    myrequire('./person.js')\n\n    return mod\n})()\n\nlet Person = modul.exports\nlet frankie = new Person('frankie')\nfrankie.sayHi()\n```\n\n[exports 和 module.exports 的区别](https://cnodejs.org/topic/5231a630101e574521e45ef8)\n\n[代码](https://github.com/FRANKIETANG/module)","source":"_posts/补基础：JS 模块化.md","raw":"---\ntitle: 补基础：JS 模块化\ndate: 2017-12-08 19:59:10\ntags: [JavaScript]\n---\n# 补基础：JS 模块化\n\n为什么要用到模块化\n\n- 解耦\n- 复用\n\n先举一个简单的例子\n\n```\n// html\n<body>\n    <script src=\"./js/main.js\"></script>\n</body>\n\n// js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I'm ${this.name}`)\n    }\n}\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I'm working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\nfunction formatSalary(salary) {\n    return salary + ' RMB'\n}\n\nlet frankie = new Employee('frankie', 5000)\nfrankie.sayHi() // hello I'm frankie\nfrankie.work() // I'm working, My salary is 5000 RMB\n```\n\n如果像上面那么样引入会直接暴露所有接口，而且起名字也要很小心，如果使用模块化就可以解决这些问题。\n\n## namespace\n\n在没有 es6 的时代，用一种叫 namespace 的方法\n\n解决暴露接口的问题可以用 namespace ，创造一个命名空间\n\n```\n// html 注意顺序（JS 加载）\n<script src=\"./js/person.js\"></script>\n<script src=\"./js/util.js\"></script>\n<script src=\"./js/employee.js\"></script>\n<script src=\"./js/main.js\"></script>\n\n// person.js\n(function (global) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I'm ${this.name}`)\n        }\n    }\n\n    let namespace = global.MYAPP = global.MYAPP || {}  // 初始化\n    namespace.Person = Person  // 导出 Person\n\n})(window)\n\n// util.js\n(function (global) {\n    let namespace = global.MYAPP  // 因为 Person.js 是先引的所以页面上已经存在 global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + ' RMB'\n        }\n    }\n})(window)\n\n// employee.js\n(function (global) {\n\n    let namespace = global.MYAPP  // 同理\n    let Person = namespace.Person  // 引入 Person\n    let formatSalary = namespace.UTILS.formatSalary\n\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I'm working, My salary is ${formatSalary(this.salary)}`)\n        }\n    }\n\n    namespace.Employee = Employee  // 导出 Employee\n\n})(window)\n\n// main.js\n(function (global) {\n    let namespace = global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + ' RMB'\n        }\n    }\n})(window)\n```\n\n问题也是很明显的，JS 的执行顺序很让人头疼\n\n## AMD\n\n于是就有了新的规范 AMD -> [requirejs](http://requirejs.org/) [Javascript模块化编程（三）：require.js的用法](http://www.ruanyifeng.com/blog/2012/11/require_js.html)\n\n```\n// 举个例子\n// html 引入 requirejs\n<script src=\"../node_modules/requirejs/require.js\" data-main=\"./js/main.js\"></script>\n\n// person.js\ndefine(function () {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I'm ${this.name}`)\n        }\n    }\n    return Person  // 导出 Person 模块\n})\n\n// util.js\ndefine(function () {\n    return {  // 导出方法\n        formatSalary: function (salary) {\n            return salary + ' RMB'\n        }\n    }\n})\n\n// employee.js\ndefine(['./person', './util'], function (Person, UTILS) {  // 引入 Person 和 util 两个依赖，记住是异步加载\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I'm working, My salary is ${UTILS.formatSalary(this.salary)}`)  // 使用 UTILS 的 formatSalary 方法\n        }\n    }\n    return Employee  // 导出 Employee 模块\n})\n\n// main.js\nrequire(['./employee'], function (Employee) {  // 引入依赖 Employee\n    let frankie = new Employee('frankie', 5000)\n    frankie.sayHi() // hello I'm frankie\n    frankie.work() // I'm working, My salary is 5000 RMB\n})\n```\n\n上面这个例子全部是依赖于 requirejs 来实现模块化，requirejs 定义了两个方法，define 和 require。他们都可以传两个参数，第一个是依赖，用数组表示，而且是异步加载，加载完后当做参数传给你要写逻辑的函数。\n\nAMD -> Asynchronous Module Definition（异步的模块定义）\n\n## CommonJS\n\n是后端的模块化，主要是由 `require` 引入，`module.exports` 导出\n\n```\n// person.js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I'm ${this.name}`)\n    }\n}\nmodule.exports = Person  // 导出 Person\n\n// util.js\nmodule.exports = {  // 导出方法\n    formatSalary: function (salary) {\n        return salary + ' RMB'\n    }\n}\n\n// employee.js\nlet Person = require('./person.js')\n    UTILS = require('./util.js')  // 引入两个依赖\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I'm working, My salary is ${UTILS.formatSalary(this.salary)}`)\n    }\n}\nmodule.exports = Employee  // 导出 Employee\n\n// main.js\nlet Employee = require('./employee.js')  // 引入依赖\n\nlet frankie = new Employee('frankie', 5000)\nfrankie.sayHi() // hello I'm frankie\nfrankie.work() // I'm working, My salary is 5000 RMB\n```\n\nCommonJS 这个规范不用把模块用 `function` 包起来，因为 node.js 定义就是每个文件就是模块\n\n## UMD\n\n假如在 AMD 规范里加载 CommonJS 规范的模块肯定是不识别，在 CommonJS 规范里加载 AMD 规范也肯定不行\n\n那怎么 AMD 和 CommonJS 都通吃呢？\n\n```\n(function (gl) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I'm ${this.name}`)\n        }\n    }\n\n    // 这里是通用方法\n    if (gl.hasOwnProperty('define')) {  // 看全局变量有没有 define，有执行 amd 规范\n        define(function () {\n            return Person\n        })\n    } else if (module != null && typeof module.exports === 'object') {  // module 在不在 module.exports 在不在，在就执行 commonjs 规范\n        module.exports = Person\n    } else {\n        gl.Person = Person  // 如果都没有就挂到全局变量\n    }\n})(this)  // 传一个全局变量\n```\n\n[vue-class-components](https://github.com/vuejs/vue-class-component) 也有这种判断规范的方法\n\n![](https://us1.myximage.com/2017/12/08/f296231a6848467fa1ad1c777079553c.png)\n\n## es6 里的 import 和 export\n\n```\n<body>\n    <script src=\"./bundle.js\"></script>\n</body>\n\n// person.js\nexport default class Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I'm ${this.name}`)\n    }\n}\n\n// util.js\nexport default function formatSalary(salary) {\n    return salary + ' RMB'\n}\n\n// employee.js\nimport Person from './person.js'\nimport formatSalary from './util.js'\n\nexport default class Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I'm working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\n// main.js\nimport Employee from './employee.js'\n\nlet frankie = new Employee('frankie', 5000)\nfrankie.sayHi() // hello I'm frankie\nfrankie.work() // I'm working, My salary is 5000 RMB\n\n// 设置好 webpack 打包\n```\n\n值得一提的是，webpack 兼容所有模块规范的打包，各种规范混搭也可以。\n\n## 彩蛋\n\n### 做一个 require\n\n```\n// person.js\nfunction Person(name) {\n    this.name = name\n}\n\nPerson.prototype.sayHi = function () {\n    console.log(`hello I'm ${this.name}`)\n}\n\ntest.exports = Person  // 这里这个 test 要和下面一样\n\n// myrequire.js\nlet fs = require('fs')\n\nlet modul = (function () {\n    let mod = {\n        exports: {}\n    }\n    function myrequire(filePath) {\n        let fnInText = fs.readFileSync(filePath, 'utf8')\n        let fn = new Function('test', fnInText)\n        fn(mod)\n    }\n\n    myrequire('./person.js')\n\n    return mod\n})()\n\nlet Person = modul.exports\nlet frankie = new Person('frankie')\nfrankie.sayHi()\n```\n\n[exports 和 module.exports 的区别](https://cnodejs.org/topic/5231a630101e574521e45ef8)\n\n[代码](https://github.com/FRANKIETANG/module)","slug":"补基础：JS 模块化","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d98001af1xh7z1iya5l","content":"<h1 id=\"补基础：JS-模块化\"><a href=\"#补基础：JS-模块化\" class=\"headerlink\" title=\"补基础：JS 模块化\"></a>补基础：JS 模块化</h1><p>为什么要用到模块化</p>\n<ul>\n<li>解耦</li>\n<li>复用</li>\n</ul>\n<p>先举一个简单的例子</p>\n<pre><code>// html\n&lt;body&gt;\n    &lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n// js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I&#39;m ${this.name}`)\n    }\n}\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\nfunction formatSalary(salary) {\n    return salary + &#39; RMB&#39;\n}\n\nlet frankie = new Employee(&#39;frankie&#39;, 5000)\nfrankie.sayHi() // hello I&#39;m frankie\nfrankie.work() // I&#39;m working, My salary is 5000 RMB\n</code></pre><p>如果像上面那么样引入会直接暴露所有接口，而且起名字也要很小心，如果使用模块化就可以解决这些问题。</p>\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><p>在没有 es6 的时代，用一种叫 namespace 的方法</p>\n<p>解决暴露接口的问题可以用 namespace ，创造一个命名空间</p>\n<pre><code>// html 注意顺序（JS 加载）\n&lt;script src=&quot;./js/person.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;./js/util.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;./js/employee.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt;\n\n// person.js\n(function (global) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I&#39;m ${this.name}`)\n        }\n    }\n\n    let namespace = global.MYAPP = global.MYAPP || {}  // 初始化\n    namespace.Person = Person  // 导出 Person\n\n})(window)\n\n// util.js\n(function (global) {\n    let namespace = global.MYAPP  // 因为 Person.js 是先引的所以页面上已经存在 global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + &#39; RMB&#39;\n        }\n    }\n})(window)\n\n// employee.js\n(function (global) {\n\n    let namespace = global.MYAPP  // 同理\n    let Person = namespace.Person  // 引入 Person\n    let formatSalary = namespace.UTILS.formatSalary\n\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)\n        }\n    }\n\n    namespace.Employee = Employee  // 导出 Employee\n\n})(window)\n\n// main.js\n(function (global) {\n    let namespace = global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + &#39; RMB&#39;\n        }\n    }\n})(window)\n</code></pre><p>问题也是很明显的，JS 的执行顺序很让人头疼</p>\n<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><p>于是就有了新的规范 AMD -&gt; <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">requirejs</a> <a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\" target=\"_blank\" rel=\"noopener\">Javascript模块化编程（三）：require.js的用法</a></p>\n<pre><code>// 举个例子\n// html 引入 requirejs\n&lt;script src=&quot;../node_modules/requirejs/require.js&quot; data-main=&quot;./js/main.js&quot;&gt;&lt;/script&gt;\n\n// person.js\ndefine(function () {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I&#39;m ${this.name}`)\n        }\n    }\n    return Person  // 导出 Person 模块\n})\n\n// util.js\ndefine(function () {\n    return {  // 导出方法\n        formatSalary: function (salary) {\n            return salary + &#39; RMB&#39;\n        }\n    }\n})\n\n// employee.js\ndefine([&#39;./person&#39;, &#39;./util&#39;], function (Person, UTILS) {  // 引入 Person 和 util 两个依赖，记住是异步加载\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I&#39;m working, My salary is ${UTILS.formatSalary(this.salary)}`)  // 使用 UTILS 的 formatSalary 方法\n        }\n    }\n    return Employee  // 导出 Employee 模块\n})\n\n// main.js\nrequire([&#39;./employee&#39;], function (Employee) {  // 引入依赖 Employee\n    let frankie = new Employee(&#39;frankie&#39;, 5000)\n    frankie.sayHi() // hello I&#39;m frankie\n    frankie.work() // I&#39;m working, My salary is 5000 RMB\n})\n</code></pre><p>上面这个例子全部是依赖于 requirejs 来实现模块化，requirejs 定义了两个方法，define 和 require。他们都可以传两个参数，第一个是依赖，用数组表示，而且是异步加载，加载完后当做参数传给你要写逻辑的函数。</p>\n<p>AMD -&gt; Asynchronous Module Definition（异步的模块定义）</p>\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><p>是后端的模块化，主要是由 <code>require</code> 引入，<code>module.exports</code> 导出</p>\n<pre><code>// person.js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I&#39;m ${this.name}`)\n    }\n}\nmodule.exports = Person  // 导出 Person\n\n// util.js\nmodule.exports = {  // 导出方法\n    formatSalary: function (salary) {\n        return salary + &#39; RMB&#39;\n    }\n}\n\n// employee.js\nlet Person = require(&#39;./person.js&#39;)\n    UTILS = require(&#39;./util.js&#39;)  // 引入两个依赖\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I&#39;m working, My salary is ${UTILS.formatSalary(this.salary)}`)\n    }\n}\nmodule.exports = Employee  // 导出 Employee\n\n// main.js\nlet Employee = require(&#39;./employee.js&#39;)  // 引入依赖\n\nlet frankie = new Employee(&#39;frankie&#39;, 5000)\nfrankie.sayHi() // hello I&#39;m frankie\nfrankie.work() // I&#39;m working, My salary is 5000 RMB\n</code></pre><p>CommonJS 这个规范不用把模块用 <code>function</code> 包起来，因为 node.js 定义就是每个文件就是模块</p>\n<h2 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h2><p>假如在 AMD 规范里加载 CommonJS 规范的模块肯定是不识别，在 CommonJS 规范里加载 AMD 规范也肯定不行</p>\n<p>那怎么 AMD 和 CommonJS 都通吃呢？</p>\n<pre><code>(function (gl) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I&#39;m ${this.name}`)\n        }\n    }\n\n    // 这里是通用方法\n    if (gl.hasOwnProperty(&#39;define&#39;)) {  // 看全局变量有没有 define，有执行 amd 规范\n        define(function () {\n            return Person\n        })\n    } else if (module != null &amp;&amp; typeof module.exports === &#39;object&#39;) {  // module 在不在 module.exports 在不在，在就执行 commonjs 规范\n        module.exports = Person\n    } else {\n        gl.Person = Person  // 如果都没有就挂到全局变量\n    }\n})(this)  // 传一个全局变量\n</code></pre><p><a href=\"https://github.com/vuejs/vue-class-component\" target=\"_blank\" rel=\"noopener\">vue-class-components</a> 也有这种判断规范的方法</p>\n<p><img src=\"https://us1.myximage.com/2017/12/08/f296231a6848467fa1ad1c777079553c.png\" alt=\"\"></p>\n<h2 id=\"es6-里的-import-和-export\"><a href=\"#es6-里的-import-和-export\" class=\"headerlink\" title=\"es6 里的 import 和 export\"></a>es6 里的 import 和 export</h2><pre><code>&lt;body&gt;\n    &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n// person.js\nexport default class Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I&#39;m ${this.name}`)\n    }\n}\n\n// util.js\nexport default function formatSalary(salary) {\n    return salary + &#39; RMB&#39;\n}\n\n// employee.js\nimport Person from &#39;./person.js&#39;\nimport formatSalary from &#39;./util.js&#39;\n\nexport default class Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\n// main.js\nimport Employee from &#39;./employee.js&#39;\n\nlet frankie = new Employee(&#39;frankie&#39;, 5000)\nfrankie.sayHi() // hello I&#39;m frankie\nfrankie.work() // I&#39;m working, My salary is 5000 RMB\n\n// 设置好 webpack 打包\n</code></pre><p>值得一提的是，webpack 兼容所有模块规范的打包，各种规范混搭也可以。</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><h3 id=\"做一个-require\"><a href=\"#做一个-require\" class=\"headerlink\" title=\"做一个 require\"></a>做一个 require</h3><pre><code>// person.js\nfunction Person(name) {\n    this.name = name\n}\n\nPerson.prototype.sayHi = function () {\n    console.log(`hello I&#39;m ${this.name}`)\n}\n\ntest.exports = Person  // 这里这个 test 要和下面一样\n\n// myrequire.js\nlet fs = require(&#39;fs&#39;)\n\nlet modul = (function () {\n    let mod = {\n        exports: {}\n    }\n    function myrequire(filePath) {\n        let fnInText = fs.readFileSync(filePath, &#39;utf8&#39;)\n        let fn = new Function(&#39;test&#39;, fnInText)\n        fn(mod)\n    }\n\n    myrequire(&#39;./person.js&#39;)\n\n    return mod\n})()\n\nlet Person = modul.exports\nlet frankie = new Person(&#39;frankie&#39;)\nfrankie.sayHi()\n</code></pre><p><a href=\"https://cnodejs.org/topic/5231a630101e574521e45ef8\" target=\"_blank\" rel=\"noopener\">exports 和 module.exports 的区别</a></p>\n<p><a href=\"https://github.com/FRANKIETANG/module\" target=\"_blank\" rel=\"noopener\">代码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：JS-模块化\"><a href=\"#补基础：JS-模块化\" class=\"headerlink\" title=\"补基础：JS 模块化\"></a>补基础：JS 模块化</h1><p>为什么要用到模块化</p>\n<ul>\n<li>解耦</li>\n<li>复用</li>\n</ul>\n<p>先举一个简单的例子</p>\n<pre><code>// html\n&lt;body&gt;\n    &lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n// js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I&#39;m ${this.name}`)\n    }\n}\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\nfunction formatSalary(salary) {\n    return salary + &#39; RMB&#39;\n}\n\nlet frankie = new Employee(&#39;frankie&#39;, 5000)\nfrankie.sayHi() // hello I&#39;m frankie\nfrankie.work() // I&#39;m working, My salary is 5000 RMB\n</code></pre><p>如果像上面那么样引入会直接暴露所有接口，而且起名字也要很小心，如果使用模块化就可以解决这些问题。</p>\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><p>在没有 es6 的时代，用一种叫 namespace 的方法</p>\n<p>解决暴露接口的问题可以用 namespace ，创造一个命名空间</p>\n<pre><code>// html 注意顺序（JS 加载）\n&lt;script src=&quot;./js/person.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;./js/util.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;./js/employee.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt;\n\n// person.js\n(function (global) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I&#39;m ${this.name}`)\n        }\n    }\n\n    let namespace = global.MYAPP = global.MYAPP || {}  // 初始化\n    namespace.Person = Person  // 导出 Person\n\n})(window)\n\n// util.js\n(function (global) {\n    let namespace = global.MYAPP  // 因为 Person.js 是先引的所以页面上已经存在 global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + &#39; RMB&#39;\n        }\n    }\n})(window)\n\n// employee.js\n(function (global) {\n\n    let namespace = global.MYAPP  // 同理\n    let Person = namespace.Person  // 引入 Person\n    let formatSalary = namespace.UTILS.formatSalary\n\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)\n        }\n    }\n\n    namespace.Employee = Employee  // 导出 Employee\n\n})(window)\n\n// main.js\n(function (global) {\n    let namespace = global.MYAPP\n\n    namespace.UTILS = {  // 公有方法\n        formatSalary: function(salary) {\n            return salary + &#39; RMB&#39;\n        }\n    }\n})(window)\n</code></pre><p>问题也是很明显的，JS 的执行顺序很让人头疼</p>\n<h2 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h2><p>于是就有了新的规范 AMD -&gt; <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">requirejs</a> <a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\" target=\"_blank\" rel=\"noopener\">Javascript模块化编程（三）：require.js的用法</a></p>\n<pre><code>// 举个例子\n// html 引入 requirejs\n&lt;script src=&quot;../node_modules/requirejs/require.js&quot; data-main=&quot;./js/main.js&quot;&gt;&lt;/script&gt;\n\n// person.js\ndefine(function () {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I&#39;m ${this.name}`)\n        }\n    }\n    return Person  // 导出 Person 模块\n})\n\n// util.js\ndefine(function () {\n    return {  // 导出方法\n        formatSalary: function (salary) {\n            return salary + &#39; RMB&#39;\n        }\n    }\n})\n\n// employee.js\ndefine([&#39;./person&#39;, &#39;./util&#39;], function (Person, UTILS) {  // 引入 Person 和 util 两个依赖，记住是异步加载\n    class Employee extends Person {\n        constructor(name, salary) {\n            super(name)\n            this.salary = salary\n        }\n        work() {\n            console.log(`I&#39;m working, My salary is ${UTILS.formatSalary(this.salary)}`)  // 使用 UTILS 的 formatSalary 方法\n        }\n    }\n    return Employee  // 导出 Employee 模块\n})\n\n// main.js\nrequire([&#39;./employee&#39;], function (Employee) {  // 引入依赖 Employee\n    let frankie = new Employee(&#39;frankie&#39;, 5000)\n    frankie.sayHi() // hello I&#39;m frankie\n    frankie.work() // I&#39;m working, My salary is 5000 RMB\n})\n</code></pre><p>上面这个例子全部是依赖于 requirejs 来实现模块化，requirejs 定义了两个方法，define 和 require。他们都可以传两个参数，第一个是依赖，用数组表示，而且是异步加载，加载完后当做参数传给你要写逻辑的函数。</p>\n<p>AMD -&gt; Asynchronous Module Definition（异步的模块定义）</p>\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><p>是后端的模块化，主要是由 <code>require</code> 引入，<code>module.exports</code> 导出</p>\n<pre><code>// person.js\nclass Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I&#39;m ${this.name}`)\n    }\n}\nmodule.exports = Person  // 导出 Person\n\n// util.js\nmodule.exports = {  // 导出方法\n    formatSalary: function (salary) {\n        return salary + &#39; RMB&#39;\n    }\n}\n\n// employee.js\nlet Person = require(&#39;./person.js&#39;)\n    UTILS = require(&#39;./util.js&#39;)  // 引入两个依赖\n\nclass Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I&#39;m working, My salary is ${UTILS.formatSalary(this.salary)}`)\n    }\n}\nmodule.exports = Employee  // 导出 Employee\n\n// main.js\nlet Employee = require(&#39;./employee.js&#39;)  // 引入依赖\n\nlet frankie = new Employee(&#39;frankie&#39;, 5000)\nfrankie.sayHi() // hello I&#39;m frankie\nfrankie.work() // I&#39;m working, My salary is 5000 RMB\n</code></pre><p>CommonJS 这个规范不用把模块用 <code>function</code> 包起来，因为 node.js 定义就是每个文件就是模块</p>\n<h2 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h2><p>假如在 AMD 规范里加载 CommonJS 规范的模块肯定是不识别，在 CommonJS 规范里加载 AMD 规范也肯定不行</p>\n<p>那怎么 AMD 和 CommonJS 都通吃呢？</p>\n<pre><code>(function (gl) {\n    class Person {\n        constructor(name) {\n            this.name = name\n        }\n        sayHi() {\n            console.log(`hello I&#39;m ${this.name}`)\n        }\n    }\n\n    // 这里是通用方法\n    if (gl.hasOwnProperty(&#39;define&#39;)) {  // 看全局变量有没有 define，有执行 amd 规范\n        define(function () {\n            return Person\n        })\n    } else if (module != null &amp;&amp; typeof module.exports === &#39;object&#39;) {  // module 在不在 module.exports 在不在，在就执行 commonjs 规范\n        module.exports = Person\n    } else {\n        gl.Person = Person  // 如果都没有就挂到全局变量\n    }\n})(this)  // 传一个全局变量\n</code></pre><p><a href=\"https://github.com/vuejs/vue-class-component\" target=\"_blank\" rel=\"noopener\">vue-class-components</a> 也有这种判断规范的方法</p>\n<p><img src=\"https://us1.myximage.com/2017/12/08/f296231a6848467fa1ad1c777079553c.png\" alt=\"\"></p>\n<h2 id=\"es6-里的-import-和-export\"><a href=\"#es6-里的-import-和-export\" class=\"headerlink\" title=\"es6 里的 import 和 export\"></a>es6 里的 import 和 export</h2><pre><code>&lt;body&gt;\n    &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n// person.js\nexport default class Person {\n    constructor(name) {\n        this.name = name\n    }\n    sayHi() {\n        console.log(`hello I&#39;m ${this.name}`)\n    }\n}\n\n// util.js\nexport default function formatSalary(salary) {\n    return salary + &#39; RMB&#39;\n}\n\n// employee.js\nimport Person from &#39;./person.js&#39;\nimport formatSalary from &#39;./util.js&#39;\n\nexport default class Employee extends Person {\n    constructor(name, salary) {\n        super(name)\n        this.salary = salary\n    }\n    work() {\n        console.log(`I&#39;m working, My salary is ${formatSalary(this.salary)}`)\n    }\n}\n\n// main.js\nimport Employee from &#39;./employee.js&#39;\n\nlet frankie = new Employee(&#39;frankie&#39;, 5000)\nfrankie.sayHi() // hello I&#39;m frankie\nfrankie.work() // I&#39;m working, My salary is 5000 RMB\n\n// 设置好 webpack 打包\n</code></pre><p>值得一提的是，webpack 兼容所有模块规范的打包，各种规范混搭也可以。</p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><h3 id=\"做一个-require\"><a href=\"#做一个-require\" class=\"headerlink\" title=\"做一个 require\"></a>做一个 require</h3><pre><code>// person.js\nfunction Person(name) {\n    this.name = name\n}\n\nPerson.prototype.sayHi = function () {\n    console.log(`hello I&#39;m ${this.name}`)\n}\n\ntest.exports = Person  // 这里这个 test 要和下面一样\n\n// myrequire.js\nlet fs = require(&#39;fs&#39;)\n\nlet modul = (function () {\n    let mod = {\n        exports: {}\n    }\n    function myrequire(filePath) {\n        let fnInText = fs.readFileSync(filePath, &#39;utf8&#39;)\n        let fn = new Function(&#39;test&#39;, fnInText)\n        fn(mod)\n    }\n\n    myrequire(&#39;./person.js&#39;)\n\n    return mod\n})()\n\nlet Person = modul.exports\nlet frankie = new Person(&#39;frankie&#39;)\nfrankie.sayHi()\n</code></pre><p><a href=\"https://cnodejs.org/topic/5231a630101e574521e45ef8\" target=\"_blank\" rel=\"noopener\">exports 和 module.exports 的区别</a></p>\n<p><a href=\"https://github.com/FRANKIETANG/module\" target=\"_blank\" rel=\"noopener\">代码</a></p>\n"},{"title":"补基础：React-Redux-ES6-webpack-babel","date":"2017-11-05T13:19:16.000Z","_content":"# 补基础：React-Redux-ES6-webpack-babel\n\n[印记中文](https://www.docschina.org/)\n\n先看一遍中文文档，第二遍中英文对着看，第三遍才看英文文档\n\n## React\n\n[React 官方文档](https://facebook.github.io/react/)\n\n````\n/**\n * JSX : xml in JavaScript\n * 1、tagName\n * 2、attributes(props)\n * 3、children\n */\n/**\n * 组件化: \n * 1、函数式组件props => JSX ; \n * 2、类组件:class A extends Component;\n */ \n/**\n * 数据源 : state  + props\n * 更新数据: setState\n * 方案: 当数据越来越复杂的时候，我们需要一个数据解决方案 ==> redux\n * 发起数据变更(click etc.) ==> action\n * 生成新的数据结构(state[store])  ==> redux的reducer生成react的state\n * 渲染(render) ==> react来做\n */\n````\n\n### DOM 对比\n\n```\n// 传统方式\n<div data-id='1'>\n\thello world\n</div>\n\n// vue \n<div data-id={{id}}>\n\t{{name}}\n</div>\n{\n  \tdata: ()=> {\n      \treturn {\n          \tname: 'hello world',\n          \tid: 1\n      \t}\n  \t}\n}\n// 注意 vue 是一个 MVVM 框架\n// 特点就是数据和模板分离\n\n// 实际上 react 也可以认为是一个 MVVM 框架\nvar JSX = <div data-id='1'>\n\thello world\n</div>;\nrender(JSX,document.getElementById('root'));\n// 数据和模板绑定在一起\n\nVirtual dom\n\n<div width='100px'>a</div>\n==>\ntagname: div\nattributes:{width: '100px'}\nchildren: a\n\n==> IOS / Android\ntagname: UIButton\nattributes:{display: flex}\nchildren: ...\n```\n\n### 用 react 问候世界\n\n```\nimport react, { Component } from 'react' // 基础库\nimport { render } from 'react-dom'  // 平台库 这是 web 库\n// 为什么要引两个库呢？\n// 为了跨平台\n// 比如在 ios/android 用上 react-native\n// import from 'react-natiev'\nrender(\n\t<h1>Hello, world</h1>              // 要塞的代码\n\tdocument.getElementById('root')    // 容器\n)\n\n// 接下来看看用 webpack 编译后的代码\n_react2.default.createElement(\n  'h1',\n  null,\n  'Hello, world!'\n\n/*\n 也就是说 react 会把 JSX 分成三个部分\n * tagname\n * attributes\n * children\n*/\n```\n\n### JSX\n\n```\n// 这种模板语法就叫做 JSX\nimport React, { Component } from 'react'\nimport { render } from 'react-dom'\nconst RootDom = document.getElementById('root')\nlet JSX = <div name=\"frankie\">\n\tHello world<span>你好</span>\n</div>\nrender(JSX, RootDom)\n\n// 以下是编译出来的结果\n/*\nvar JSX = _react2.default.createElement(\n  'div',\n  { name: 'jirengu' },\n  'Hello world',\n  _react2.default.createElement(\n    'span',\n    null,\n    '\\u4F60\\u597D'\n  )\n);\n*/\n\n// 结构就相当于这个\n/*\ntagname: 'div'\nattributes: {\n  \tname: 'frankie'\n}\nchildren: 'hello world',{\n  \ttagname: 'span'\n  \tattributes: null\n  \tchildren: '你好'\n}\n*/\n```\n\n```\n// 值得注意的地方\n// JSX 可以防止 XSS 漏洞\n// 比如写在 JSX 里会直接输出，写在 HTML 会把 &gt; 转成 >\n\nrender() {\n  let b = 'First &gt; Second'\n  return (<div> {b} </div>)\n} \n\n// 如果要不转译该怎么办？\n/*\ndangerouslySetInnerHTML函数\ndangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。一般而言，使用JS代码设置HTML文档的内容是危险的，因为这样很容易把你的用户信息暴露给跨站脚本攻击.所以，你虽然可以直接在React中设置html的内容，但你要使用 dangerouslySetInnerHTML 并向该函数传递一个含有__html键的对象，用来提醒你自己这样做很危险。例如：\nfunction createMarkup() {\n  return {__html: 'First &middot; Second'};\n}\n\nfunction MyComponent() {\n  return <div dangerouslySetInnerHTML={createMarkup()} />;\n}\n*/\n\n// 实际上，JSX 里面输入 false ，null ，undefined 都是不渲染的\n\nrender() {\n  return (<div> {false} {null} {undefined} {0} </div>)\n} \n\n// 那如果有个空格在中间呢？\n\nrender() {\n  let b = 'First         Second'  // 这里这个空格会打印么？ 不会的\n  return (<div> {b} </div>)\n} \n\n// 还有一些属性啊，比如 onChange onClick 都要用驼峰命名\n```\n\n[XSS是什么](https://zhuanlan.zhihu.com/p/22500730?refer=study-fe) [CSRF是什么](https://zhuanlan.zhihu.com/p/22521378?refer=study-fe)\n\n### JS-in-JSX（动态化）\n\n```\n// 记住要用大括号来包裹变量\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\nlet a = 1;\nlet jsx1 = <div>{a}</div>;\nlet b = { id : 2 };\nlet jsx2 = <div>{b.id}</div>;\nlet jsx3 = ['i','love','react'].map((name) => {\n    return <div>{name}</div>\n});\nrender(<div>\n    {jsx1}{jsx2}{jsx3}\n    </div>, RootDom);\n// 事实上 render 还有第三个参数 callback\n```\n\n### Component\n\n```\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom = document.getElementById('root');\n\n/*\n * pure functional components \n * it must never modify its own props\n */\n \nconst A = (props) => {\n    return <div>{ props.gender } + { props.name }</div>\n};\nrender(<A gender='male name='frankie'/>,RootDom);\n\n// tagname  A, ==> 不是传统的html标签，而是个函数\n// attributes {   ==> 函数的情况下 attributes === props\n//     gender: 'male',\n//     name: \"frankie\"\n// }\n// children: null\n\n/*\n * class components\n * - Adding Local State to a Class\n * - Adding Lifecycle Methods to a Class\n */\n class FisstComponent extends Component{\n   \t constructor() {\n       \t super()\n       \t this.state = {\n           \t b: 1\n       \t }\n   \t }\n   \t render() {\n       \t return(\n       \t \t <div>\n       \t \t \t I am a component\n       \t \t \t {this.state.b}\n       \t \t </div>\n       \t )\n   \t }\n }\n render(<FirstComponent />,RootDom);\n \n // class 组件必须有 render 方法\n // class 组件必须继承 Component\n \n // 组件为什么要大写？区分 HTML 和 组件 \n```\n\n### life-cycle\n\nhttps://facebook.github.io/react/docs/state-and-lifecycle.html\n\n```\n// 写代码的时候更具有控制力\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\nclass FirstComponent extends Component{\n    constructor(){\n        super();\n        this.state = {\n            b:1\n        }\n    }\n    // shouldComponentUpdate / componentWillReceiveProps / componentDidMount 用得比较多\n\tshouldComponentUpdate(){   // 组件是不是应该被更新\n\t\tconsole.log('shouldComponentUpdate');\n        return true;\n\t}\n\tcomponentWillUnmount(){   // 组件将会移除\n\t\tconsole.log('componentWillUnmount')\n\t}\n\tcomponentDidUpdate(){   // 组件更新好了\n\t\tconsole.log('componentDidUpdate')\n\t}\n\tcomponentWillUpdate(){   // 组件将会更新\n\t\tconsole.log('componentWillUpdate')\n\t}\n\tcomponentWillReceiveProps(){   // 组件获得了新的 props\n\t\tconsole.log('componentWillReceiveProps')\n\t}\n\tcomponentWillMount(){   // 组件将被加载\n\t\tconsole.log('componentWillMount')\n\t}\n\tcomponentDidMount(){   // 组件加载完成\n        this.setState({b:1})\n\t\tconsole.log('componentDidMount')\n\t}\n    render(){   // 组件将被渲染\n    \tconsole.log('render')\n    \tlet a = '10/26'\n        return <div>\n           \tI am a component\n           \t\t{a }\n                {this.state.b}\n            </div>\n    }\n };\n\nrender(<FirstComponent />,RootDom);\n\n// componentWillMount\n// render\n// componentDidMount\n// shouldComponentUpdate\n// componentWillUpdate\n// render\n// componentDidUpdate\n```\n\n### props\n\n```\n// <A a='1'> ==> props = {a:'1'}\n\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\nclass Welcome extends Component {\n  render() {\n    return <div>{this.props.gender} + {this.props.name}</div>\n  }\n}\n/** props.children\n * React uses this.props.children to access a component's children nodes.\n * ==== ! props should be pure === // 不应该做任何修改\n */\nclass ChildComponent extends Component{\n    render(){\n        return (\n        <div>\n            {this.props.children}   // 如果 render 写成传统的 html 标签，那“我是个孩子”就是 {this.props.children}\n            <Welcome gender='male' name='frankie' />\n        </div>\n        );\n    }\n };\nrender(<ChildComponent>我是个孩子</ChildComponent>,RootDom);\n\n // 设置默认值 defaultProps\n // 方法 1\n Welcome.defaultProps = {\n  \tgender: 'male',\n  \tname: 'frankie'\n }\n // 方法 2\n class Welcome extends Component {\n\tstatic defaultProps = {\n       gender: 'male',\n  \t   name: 'frankie'\n\t}\n }\n```\n\n```\n // 类型检测\n import PropTypes from 'prop-types';\n \n class Welcome extends Component {\n\tstatic defaultProps = {\n       gender: PropTypes.string,\n  \t   name: PropTypes.string\n\t}\n\trender(){\n      \treturn <div>{this.props.gender} + {this.props.name}</div> \n\t}\n }\n \n // 假设这里传了数字怎么办？\n ReactDOM.render(<Welcome gender='0234' name='0234'/>,RootDom)\n```\n\nhttps://reactjs.org/docs/typechecking-with-proptypes.html\n\n### setState\n\n```\n// setState 是一个异步的操作\n// 改变数据只有一种方法 setState\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\n/**\n * 数据源: state + props\n * props: parent ==> child 【pure不能修改】\n * state: 自身维护的数据状态\n */\nclass PropState extends Component{\n    constructor(){\n        super();\n        this.state={a:'I am state'}\n    }\n    click(){\n        /**\n         * setState ==> 本组件重新render\n         */\n    \tthis.setState({\n    \t\ta:'我更新啦 哈哈哈'\n    \t})\n    }\n    render(){\n        return <div onClick={()=>this.click()}>\n                {this.state.a}\n                <A name= {this.state.a} />\n              </div>\n    }\n };\nconst A = (props) => {\n    return <div>{props.name}</div>\n}\nrender(<PropState/>,RootDom);\n```\n\n```\n// 定时器\n// 记住在 numount 要取消定时器，要不然很容易会造成内存泄露\nclass Timer extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tcount: 0,\n          \ttime: (new Date()).toLocaleTimeString()\n      \t}\n\t}\n\ttick() {\n        this.setState({\n            count: 1,\n            time: (new Date()).toLocaleTimeString()\n        })\n        console.log(this.state.count)  // 0,因为 setState() 是异步函数    \t\n\t}\n\tcomponentWillMount() {\n\t\tthis.interval = setInterval(() => this.tick(),1000)\n\t}\n\tcomponentWillUnmount() {\n      \tclearInterval(this.interval)\n\t}\n\tshouldComponentUpate(nextProps, nextState) {\n      \treturn true;\n\t}\n\trender() {\n      \treturn (<div>the time is {this.state.time}</div>)\n\t}\n}\n \nReactDOM.render(<Timer />,RootDom)\n```\n\n### 值得注意的地方\n\n```\n// 绑定 this 的方法\n// 箭头函数和 constructor 都可以\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tname: 'frankie'\n      \t}\n      \t// 构造函数绑 this\n      \t// this.handleClick = this.handleClick.bind(this)\n\t}\n\t// 箭头函数绑 this\n\thandleClick = () => {\n      \talert(this.state.name)\n\t}\n\trender() {\n      \treturn (<div>my name is {this.state.name}</div>)\n\t}\n}\n\n// 最后一种 ReactDOM.render(<Name onClick={this.handleClick.bind(this)}/>,RootDom)\n// 这种是不建议的，会触发 componentWillReceiveProps 和 shouldComponentUpdate，假如在定时器里，子组件就会一直 render\n// 也不能在 render 里用箭头函数\nReactDOM.render(<Name onClick={this.handleClick}/>,RootDom)\n```\n\n```\n// 阻止事件冒泡\n/*\n先考虑一个东西\n写在 React 的 div 和原生的 div 是不一样的\n那它们的 event 是一样的吗？\n// \n<div onclick=\"\"></div>\nfunction test(event){\n  return false\n}\n// react\nhandleClick = (event) => {\n  \n}\n\n其实是不一样的\nreact 的 event 是被封装过的，叫做 SyntheticEvent 能实现百分之九十的 event 原生事件 \n通过 ev.nativeEvent === event 封装\nev.nativeEvent.stopImmediatePropagation()\n\nhandleClick = (event) => {\n  setTimeout(()=> {\n    console.log(event.type)\n  })\n  console.log(event.type)\n}\n\nreact 的 event 是不能异步执行的\nreact 的 event 有一个事件值，触发完成之后就会销毁\n*/\n\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tname: 'frankie'\n      \t}\n\t}\n\thandleClick() {\n      \talert(this.state.name)\n      \t// 可以直接调用\n        // event.stopPropagation()\n        // event.preventDefault()\n\t}\t\n\trender() {\n      \treturn (<div>my name is {this.state.name}</div>)\n\t}\n}\n\nReactDOM.render(<Name onClick={this.handleClick.bind(this)}/>,RootDom)\n```\n\n### ref 和 DOM\n\nhttps://reactjs.org/docs/refs-and-the-dom.html\n\n```\n// 利用 ref 操作 DOM\n// react 不建议直接操作 DOM 元素，性能不好\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tname: 'frankie'\n      \t}\n\t}\n\thandleClick = (event) => {\n      \t// var el = document.getElementById('content')\n      \t// this.refs.style.color = 'red'  这是旧的\n      \tthis.contentRef.style.color = 'red'\n\t}\t\n\trender() {\n      \treturn (\n      \t// <div ref=\"content\">  这是旧的\n      \t<div onClick={this.handleClick}>\n            <div ref={(content) => {this.contentRef = content}}>\n            my name is {this.state.name}\n            </div>\n      \t</div>)\n\t}\n}\n\nReactDOM.render(<Name />,RootDom)\n\n/*\n其实上面这种做法 React 是不推荐的\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n      \t\tcolor: '',\n          \tname: 'frankie'\n      \t}\n\t}\n\thandleClick(event){\n\t\tthis.setState({\n          \tcolor: 'red'\n\t\t})\n\t}\t\n\trender() {\n      \treturn (\n      \t/*\n      \t直接在标签上使用style属性时，\n      \t要写成style={{}}是两个大括号，\n      \t外层大括号是告知jsx这里是js语法，\n      \t和真实DOM不同的是，属性值不能是字符串而必须为对象，\n      \t需要注意的是属性名同样需要驼峰命名法。即margin-top要写成marginTop。\n      \t*/\n      \t<div style={{color: this.state.color}} onClick={this.handleClick.bind(this)}>\n            <div ref={(content) => {this.contentRef = content}}>\n            my name is {this.state.name}\n            </div>\n      \t</div>)\n\t}\n}\n\nReactDOM.render(<Name />,RootDom)\n\n*/\n```\n\n### 渲染\n\n```\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n             let arr = [{\n              id: '1',\n              name: 'dalao1'\n            }, {\n              id: '2',\n              name: 'dalao2'\n            }, {\n              id: '3',\n              name: 'dalao3'\n            }]         \t\n      \t}\n\t}\n\trender() {\n      \treturn (\n      \t<div onClick={this.handleClick}>\n\t\t\t<ul>\n\t\t\t\t{arr.map((item, i) => {\n\t\t\t\t\t// return <li key={i}>{item.name}</li>\n\t\t\t\t\t// 这个 key 的作用是见下面\n                  \treturn <li>{item.name}</li>\n\t\t\t\t})}\n\t\t\t</ul>\n      \t</div>)\n\t}\n}\n\nReactDOM.render(<Name />,RootDom)\n\n/*\nkey 的作用 react 做 diff 算法的时候使用\n如果 key 能保持稳定，DOM 内容不变就可以避免重新渲染\nkey 不要用 index 不要用随机数\n\nclass Name extends React.Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n             people : [{\n              id: '1',\n              name: 'dalao1'\n            }, {\n              id: '2',\n              name: 'dalao2'\n            }, {\n              id: '3',\n              name: 'dalao3'\n            }]         \t\n      \t}\n\t}\n\thandleClick(event) {\n\t\t// 这里要用深拷贝\n\t\tlet people = this.state.people\n\t\tlet newPeople = people.map((person => {\n          \tlet newPerson = {...person}  // 这里相当于浅拷贝\n          \tif (newPerson.id == '2') {\n              \tnewPerson.name += 'haha'\n          \t}\n          \treturn newPeople  // 返回了新的地址相当于深拷贝\n\t\t}))\n\t\tthis.setState({\n\t\t\tpeople : newPeople\n\t\t})\n\t}\t\n\trender() {\n      \treturn (\n      \t<div onClick={this.handleClick.bind(this)}>\n\t\t\t<ul>\n\t\t\t\t{this.state.people.map((item, i) => {\n\t\t\t\t\t// return <Person key={Math.random() * 100} item={item}></Person>\n\t\t\t\t\t// 如果像上面一样，因为 key 是不一样的，所以 react 以为这个组件没有使用过，要重新构造一份\n\t\t\t\t\treturn <Person key={i} item={item}></Person>\n\t\t\t\t})}\n\t\t\t</ul>\n      \t</div>)\n\t}\n}\n\nclass Person extends React.Component{\n\tshouldComponentUpdate(nextProps, nextState) {\n      \treturn nextProps.item.name !== this.props.item.name\n      \t// 如果不用深拷贝，nextProps.item.name === this.props.item.name 是 true，相等的原因是因为 item 是引用类型\n\t}\n  \trender(){\n  \t\tconsole.log('render' + this.props.item.id)\n  \t\t/* \n  \t\t这里打印的是\n  \t\trender1\n  \t\trender2\n  \t\trender3\n  \t\t避免 1 3 渲染的方法是\n  \t\tkey 值要稳定\n  \t\t深拷贝\n  \t\t*/\n      \treturn <li>{this.props.item.name}</li>\n  \t}\n}\n\nReactDOM.render(<Name />,mountNode)\n*/\n```\n\n[JavaScript 深入了解基本类型和引用类型的值](https://segmentfault.com/a/1190000006752076)\n\n### 条件渲染\n\n```\n/*\n方法有：三元 if else 组件 方法 &&判断\n*/\n\nclass Name extends React.Component{\n  \trender(){\n  \t\tlet isLogin = this.props.isLogin\n  \t\tlet comp = null\n  \t\tif(isLogin){\n          comp = <Logout />\n  \t\t}else{\n          comp = <Login />\n  \t\t}\n      \treturn(<div>\n      \t\t{comp}\n      \t\t// {isLogin ? <Logout /> : <Login />}  // 主要用三元运算\n      \t</div>)\n  \t}\n}\n\nclass Login extends React.Component{\n  \trender(){\n      \treturn <div>login</div>\n  \t}\n}\n\nclass Logout extends React.Component{\n  \trender(){\n      \treturn <div>logout</div>\n  \t}\n}\n\nReactDOM.render(<Name isLogin={true}/>,mountNode)\n\n/*\n可以封装成一个组件\nfunction SignIn(isLogin) {\n  \tif(isLogin){\n      return <Logout/>\n  \t}else{\n      return <Login/>\n  \t}\n}\n\n// 在 render 写\nrender(){\n  return(<SignIn isLogin={isLogin}/>)\n}\n*/\n\n/*\n也可以做成一个方法\ngetLogIn(isLogin) {\n  if(isLogin){\n    return <Logout />\n  }else{\n    return <login/>\n  }\n}\n\nrender(){\n  return(<div>\n  \t{this.getLogin(isLogin)}\n  </div>)\n}\n*/\n\n/*\n还有一种用 && 判断\n{isLogin && <Logout/>}\n{isLogin && <LoginIn/>}\n*/\n```\n\n### HOC\n\n```\n/*\n传一个组件出一个组件\n其实可以理解为一个给基础组件加方法的处理器\n比如说有两个组件 Ad1 Ad2 他们有 abc 三个方法\n\nAd1Component{\n  a(){};b(){};c(){};\n}\nAd2Component{\n  a(){};b(){};c(){};\n}\n\n那我们可以把方法抽离出一个 Basic 组件\nBasicComponent{\n  a(){};b(){};c(){};\n}\n\n然后写到 HOC 转换\nfunction wrapper(WrapperComponent){\n  return BasicComponent{\n    a(){};b(){};c(){};\n    render(){\n      return <WrapperComponent />\n    }\n  }\n}\n*/\n\n// 写个例子\n// 在 input 组件的名字改变的时候加上一些日志的方法但是不能 input 组件上写（为什么会有这个需求？因为有可能这个组件不是你自己写的）\n/*\n想到一个方法用 prototype 但是会影响原型链\n function logProps(InputComponent) {\n    InputComponent.prototype.componentWillReceiveProps = function(nextProps, nextState) {\n      console.log('============')\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    };\n    return InputComponent;\n}\n*/\n\n// 正确的方法应该是利用 HOC 封装方法\n\nclass InputComponent extends React.Component{\n    componentWillReceiveProps() {\n\n    }\n    render() {\n        return <div>{this.props.name}</div>\n    }\n}\n\nfunction logProps(WrappedComponent) {\n    return class extends React.Component {  // 匿名组件，要实现的共有方法都在这里做\n      componentWillReceiveProps(nextProps) {    \n        console.log('Current props: ', this.props);\n        console.log('Next props: ', nextProps);\n      }\n      render() {\n        return <WrappedComponent {...this.props} />;\n      }\n    }\n}\n\nconst EnhancedComponent = logProps(InputComponent);\n\n let name = 'dalao';\n setInterval(() => {\n    name += ' hah';\n    ReactDOM.render(<EnhancedComponent name={name} />, document.getElementById('root'));\n }, 1000)\n```\n\n## Redux\n\n[Redux 官方文档](http://www.redux.org.cn/)\n\nhttps://github.com/slashhuang/redux-annotation\n\n![](https://ooo.0o0.ooo/2017/11/04/59fd9c6002509.jpg)\n\n### 第一个简单的例子\n\n[Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\n```\nimport { createStore } from 'redux'\nconst initState = {}\nconst reducer = (state, action) => {\n\treturn action\n}\nconst store = createStore(reducer, initState)\nstore.dispatch({\n\ttype: 'init',\n\tpayload: 'hello world'\n})\nconsole.log(store.getState())\n\n// redux 的整体架构\n// action (动作) ===> 发起 AJAX\n// reducer (Handler处理器) ===> JSON 处理\n// state (最后的状态) ===> JSON 保存起来\n\n// 通常从后端拉数据的流程是这样的\n// AJAX ===> JSON ===> UI\n\n// 所以上面这个代码拆分开来就是\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {  // state 是前一次保存的数据状态\n  \treturn Object.assign({}, state, action);  // 生成下一个数据状态\n}\nconst store = createStore(reducer, initState)\nstore.dispatch(action)\nconsole.log(store.getState())\n```\n\n### createStore 源码\n\n```\n// 需要注意的是第一个参数和第二个参数（reducer, 初始化的 state）\nexport default function createStore(reducer, preloadedState, enhancer)\n\n/*\n判断...\n*/\n\nvar currentReducer = reducer;  // 当前的处理器\nvar currentState = preloadedState;   // 当前的state ===> 初始化的 state\nvar currentListeners = []; \nvar nextListeners = currentListeners;\nvar isDispatching = false;  // 不执行\n\n/*\n往下看\n*/\n\nfunction getState() {\n\treturn currentState;  // 直接 return currentState\n}\n\n/*\n往下看\n*/\n\n  function dispatch(action) {\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);  \n      // 用当前的 reducer 处理当前的 state 和 action\n      // 只要 dispatch(action) 就会处理一遍生成一个 state\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;  // 返回一个 action\n  }\n  \n/*\n往下看\n*/\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n  // 最后也是返回出来\n```\n\n### 回看例子分析 createStore 源码\n\n```\nimport { createStore } from 'redux'\nconst initState = {}\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {   // currentState = currentReducer(currentState, action);  \n  \treturn Object.assign({}, state, action);  // 当前的数据状态\n}\ndebugger\nconst store = createStore(reducer, initState)  // reducer = (state, action) => {...}, initState = {}\ndebugger\nstore.dispatch(action)  // 所以 store 有 dispatch 方法\nconsole.log(store.getState())  // return currentState\n// Object {type: \"init\", payload: \"hello world\"}\n\n// debugger 看过程\n// var currentReducer = reducer;  // currentReducer = function reducer(state, action), reducer = function reducer(state, action)\n// var currentState = preloadedState;  // currentState = Object {}, preloadedState = Object {}\n  \n/*\n跳到 dispatch return 一个 API 集合\n*/\n\n/*\n下一个 debugger\ncurrentState = currentReducer(currentState, action); 进去看一下\nreturn Object.assign({}, state, action);  做一个覆盖\ncurrentState 变成了 Object {type: \"init\", payload: \"hello world\"}\n*/\n\n/*\n看一下 console.log(store.getState())\nfunction getState() {\n    return currentState; // 返回 currentState\n}\n*/\n\n--------------------------------------------------------------------\n\n// 修改一下代码\nimport { createStore } from 'redux'\nconst initState = {}\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {\n  \treturn Object.assign({}, state, action);\n}\nconst store = createStore(reducer, initState)\ndebugger\nstore.subscribe(() => {\n  \tconsole.log('我注册啦')\n})\nstore.dispatch(action)\nconsole.log(store.getState())\n\n// store.subscribe 进去看看\n/*\n  function subscribe(listener) {\n\t\n\t//...\n\t\n    nextListeners.push(listener);    // nextListeners 是一个长度为零的数组，把 listener push 进去\n    return function unsubscribe() {\n    \t// ...\n    };\n  }\n*/\n\n// store.dispatch(action) 进去看看\n/*\n  function dispatch(action) {\n    //...\n\t// 这里会读当前的观察者数组\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  \n  ---------------------\n  \n  在 console 打 listeners 会打印出 [function]\n  listeners[0] 是\n  function () {\n  \tconsole.log('我注册啦');\n  }\n*/\n\n/*\n需要注意的一点是\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT })\n  也就是说，每调用一遍 createStore 就会执行一遍 dispatch({ type: ActionTypes.INIT })\n  所以初始化的 action 是 type: \"@@redux/INIT\"\n*/\n```\n\n### 怎么改变 dom\n\n```\n// HTML\n    <div id='root'>\n        1\n    </div>\n// JS\nimport { createStore } from 'redux'\nconst ROOTDOM = document.getElementById('root')\nconst initState = {}\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {  \n  \treturn Object.assign({}, state, action); \n}\nconst store = createStore(reducer, initState) \nstore.subscribe(() => {\n  \tROOTDOM.innerHTML = JSON.stringify(store.getState())\n})\nlet counter = 0\nROOTDOM.addEventListener('click', () => {\n  \tcounter++\n  \tconst action = {\n      \ttype: 'click',\n      \tpayload: counter\n  \t}\n  \tstore.dispatch(action)\n})\n```\n\n### 实现一个MVVM\n\n```\n// HTML\n<input id=\"name\"/>\n数据预览区\n<div id=\"preview\"></div>\n<div id='root'>\n1\n</div>\n// JS\nimport { createStore } from 'redux';\nconst initState = {};\nconst action = {\n\ttype: 'init',\n\tpayload: 'hello world',\n};\nconst reducer = (state, action) => {\n\treturn Object.assign({}, state, action);\n};\nconst store = createStore(reducer, initState);\nconst INPUTDOM = document.getElementById('name');\nconst PREVIEWDOM = document.getElementById('preview');\nconst digestUI = () => {\n\tPREVIEWDOM.innerHTML = store.getState().payload;\n\tif (PREVIEWDOM.innerHTML.length > 20) {\n\t\talert('length is 20')\n\t}\n};\nconst inputChange = () =>{\n\tlet val = INPUTDOM.value;\n\tconst action = {\n\t\ttype: 'input_change',\n\t\tpayload: val,\n\t};\n\tstore.dispatch(action);\n};\nlet counter = 0;\nINPUTDOM.addEventListener('input', inputChange)\nstore.subscribe(digestUI);\n\n// 可以看出好处就是行为都是分离的\n```\n\n### 中间件\n\n```\n// redux中的applyMiddleware中间件\n// Middleware makes it easier for software developers\n// to implement 【communication and input/output】,\n// so they can focus on the 【specific purpose of their application】.\n// 更专注 service 服务 input/output service 输入和输出\n// ajax ==> json(乱得一笔) =service转换(中间件)=> UI(整理成好的)\n// express/Koa\n\n// 前端\n// ajax ==http==>\n// httpRequest(head,cookie,body)\n// middlewares(解析cookie, 拿到post请求的数据)\n// 数据就是好的一笔的数据\n// 后端(node.js)\n\n// 看一个例子\n// 注意下面这些很多箭头的叫做高阶函数\n// 例如 const highFunction = a => b => c => console.log(a+b+c); highFunction(1)(2)(3) // 6 // 一个函数执行完之后返回值是一个函数\n// 多参函数 ===> 单参函数\n\n// 如果在 createStore 用上 enhancer 逻辑就会被 applyMiddleware 控制\n// return enhancer(createStore)(reducer, preloadedState)\n\n// 前一个 next 指向下一个 action=> { next(action) }; 最后一个 next 指向 dispatch \n\n// 没有中间件 action ==> ==dispatch==> reducer ==> nextState;\n// 有中间件 action ==middlewares==> ==dispatch==> reducer ==> nextState;\n\n// applyMiddleware 的思想是把一堆函数封装成一个函数\n\nimport { createStore, applyMiddleware } from 'redux';\nconst logger1 = store => next => action => {\n    console.log('current dipatch' + JSON.stringify(action));\n    next(action);\n};\nconst logger2 = store => next => action=> {\n    next(action);\n};\nconst logger3 = store => next => action=> {\n    next(action);\n};\n\nconst enhancer = applyMiddleware(logger1, logger2, logger3);\nconst reducer = (state, action) => state;\nconst store = createStore(reducer, {}, enhancer);\nstore.dispatch({type:1});\nstore.dispatch({type:2});\nstore.dispatch({type:3});\n```\n\naction 的另一种写法 https://github.com/acdlite/flux-standard-action\n\n[What's the '@' (at symbol) in the Redux @connect decorator?](https://stackoverflow.com/questions/32646920/whats-the-at-symbol-in-the-redux-connect-decorator)\n\n[React 实践心得：react-redux 之 connect 方法详解](http://taobaofed.org/blog/2016/08/18/react-redux-connect/)\n\n## ES6\n\n[ES6 教程](http://es6.ruanyifeng.com/)\n\n[摸到 ES6 的门把手](https://frankietang.github.io/2017/10/14/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\nStage 0 - Strawman（展示阶段）\n\n- Stage 1 - Proposal（征求意见阶段）\n- Stage 2 - Draft（草案阶段）\n- Stage 3 - Candidate（候选人阶段）\n- Stage 4 - Finished（定案阶段）\n\n配 babel 的时候有用 \n\n### Set 和 Map 的数据结构\n\n[set-map](https://github.com/ruanyf/es6tutorial/blob/2ac6e76b38f117f2acf6c465ab70709275b4241a/docs/set-map.md)\n\n```\n// 向 Set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。\nlet s = new Set()\ns.size // 0\ns.add(1) // {1}\ns.size // 1\ns.add(1) // {1}\ns.size // 1\ns.add('1') // {1,'1'}\ns.size // 2\n\n// 如何快速去除数组里的重复元素\n[...new Set([1,2,3,4,5,4,3,2,1])]  // (5) [1, 2, 3, 4, 5]\n```\n\n### Decorators\n\n```\n// 对类做一个封装\n// 懂了，大概就是在 class 上面绑定方法可以直接调用\n\nfunction divide(target){\n  target.prototype.divide = function(a,b) {return a/b}\n  return target\n}\n\n@divide\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n\n// 再封装多一个判断\n\nfunction divide(needAdd){\n  return function(target){\n    if(needAdd){\n      target.prototype.divide = function(a,b) {return a/b}\n    }\n  }\n  return target\n}\n\n@divide(true)\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n```\n\n## webpack\n\n[webpack 官方文档](https://webpack.js.org/)\n\n### webpack 与 react\n\n```\n// 主要是配 loaders\n{\n    test: /\\.js[x]?$/,        // 符合 js 或者 jsx\n    loader: \"babel-loader\",   // 运行 babel-loader\n    exclude: /node_modules/\n},\n```\n\n说实话 webpack 这东西翻翻文档就好，不用死记硬背的。要什么功能直接 Google ，`npm i -D <package>`\n\n[webpack：从入门到真实项目配置](https://juejin.im/post/59bb37fa6fb9a00a554f89d2)\n\n## babel\n\n[babel 官方文档](http://babeljs.io/)\n\n### babel\n\n```\n// 因为 react 用的是 JSX 所以需要用到 babel\n// 不止 JSX 还有高阶组件(HOC) 要用到 es7 的 Decorator\n// 把这一堆代码转换成 JS\n// 以下是配法 \n{\n  \"presets\": [\n     \"stage-0\", // 草案 0\n     \"es2015\",  // es6\n     \"react\"    // react\n  ],\n   \"plugins\": [\"transform-decorators-legacy\"]  // 翻译 Decorator\n}\n```\n","source":"_posts/补基础：React-Redux-ES6-webpack-babel.md","raw":"---\ntitle: 补基础：React-Redux-ES6-webpack-babel\ndate: 2017-11-05 21:19:16\ntags: [React]\n---\n# 补基础：React-Redux-ES6-webpack-babel\n\n[印记中文](https://www.docschina.org/)\n\n先看一遍中文文档，第二遍中英文对着看，第三遍才看英文文档\n\n## React\n\n[React 官方文档](https://facebook.github.io/react/)\n\n````\n/**\n * JSX : xml in JavaScript\n * 1、tagName\n * 2、attributes(props)\n * 3、children\n */\n/**\n * 组件化: \n * 1、函数式组件props => JSX ; \n * 2、类组件:class A extends Component;\n */ \n/**\n * 数据源 : state  + props\n * 更新数据: setState\n * 方案: 当数据越来越复杂的时候，我们需要一个数据解决方案 ==> redux\n * 发起数据变更(click etc.) ==> action\n * 生成新的数据结构(state[store])  ==> redux的reducer生成react的state\n * 渲染(render) ==> react来做\n */\n````\n\n### DOM 对比\n\n```\n// 传统方式\n<div data-id='1'>\n\thello world\n</div>\n\n// vue \n<div data-id={{id}}>\n\t{{name}}\n</div>\n{\n  \tdata: ()=> {\n      \treturn {\n          \tname: 'hello world',\n          \tid: 1\n      \t}\n  \t}\n}\n// 注意 vue 是一个 MVVM 框架\n// 特点就是数据和模板分离\n\n// 实际上 react 也可以认为是一个 MVVM 框架\nvar JSX = <div data-id='1'>\n\thello world\n</div>;\nrender(JSX,document.getElementById('root'));\n// 数据和模板绑定在一起\n\nVirtual dom\n\n<div width='100px'>a</div>\n==>\ntagname: div\nattributes:{width: '100px'}\nchildren: a\n\n==> IOS / Android\ntagname: UIButton\nattributes:{display: flex}\nchildren: ...\n```\n\n### 用 react 问候世界\n\n```\nimport react, { Component } from 'react' // 基础库\nimport { render } from 'react-dom'  // 平台库 这是 web 库\n// 为什么要引两个库呢？\n// 为了跨平台\n// 比如在 ios/android 用上 react-native\n// import from 'react-natiev'\nrender(\n\t<h1>Hello, world</h1>              // 要塞的代码\n\tdocument.getElementById('root')    // 容器\n)\n\n// 接下来看看用 webpack 编译后的代码\n_react2.default.createElement(\n  'h1',\n  null,\n  'Hello, world!'\n\n/*\n 也就是说 react 会把 JSX 分成三个部分\n * tagname\n * attributes\n * children\n*/\n```\n\n### JSX\n\n```\n// 这种模板语法就叫做 JSX\nimport React, { Component } from 'react'\nimport { render } from 'react-dom'\nconst RootDom = document.getElementById('root')\nlet JSX = <div name=\"frankie\">\n\tHello world<span>你好</span>\n</div>\nrender(JSX, RootDom)\n\n// 以下是编译出来的结果\n/*\nvar JSX = _react2.default.createElement(\n  'div',\n  { name: 'jirengu' },\n  'Hello world',\n  _react2.default.createElement(\n    'span',\n    null,\n    '\\u4F60\\u597D'\n  )\n);\n*/\n\n// 结构就相当于这个\n/*\ntagname: 'div'\nattributes: {\n  \tname: 'frankie'\n}\nchildren: 'hello world',{\n  \ttagname: 'span'\n  \tattributes: null\n  \tchildren: '你好'\n}\n*/\n```\n\n```\n// 值得注意的地方\n// JSX 可以防止 XSS 漏洞\n// 比如写在 JSX 里会直接输出，写在 HTML 会把 &gt; 转成 >\n\nrender() {\n  let b = 'First &gt; Second'\n  return (<div> {b} </div>)\n} \n\n// 如果要不转译该怎么办？\n/*\ndangerouslySetInnerHTML函数\ndangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。一般而言，使用JS代码设置HTML文档的内容是危险的，因为这样很容易把你的用户信息暴露给跨站脚本攻击.所以，你虽然可以直接在React中设置html的内容，但你要使用 dangerouslySetInnerHTML 并向该函数传递一个含有__html键的对象，用来提醒你自己这样做很危险。例如：\nfunction createMarkup() {\n  return {__html: 'First &middot; Second'};\n}\n\nfunction MyComponent() {\n  return <div dangerouslySetInnerHTML={createMarkup()} />;\n}\n*/\n\n// 实际上，JSX 里面输入 false ，null ，undefined 都是不渲染的\n\nrender() {\n  return (<div> {false} {null} {undefined} {0} </div>)\n} \n\n// 那如果有个空格在中间呢？\n\nrender() {\n  let b = 'First         Second'  // 这里这个空格会打印么？ 不会的\n  return (<div> {b} </div>)\n} \n\n// 还有一些属性啊，比如 onChange onClick 都要用驼峰命名\n```\n\n[XSS是什么](https://zhuanlan.zhihu.com/p/22500730?refer=study-fe) [CSRF是什么](https://zhuanlan.zhihu.com/p/22521378?refer=study-fe)\n\n### JS-in-JSX（动态化）\n\n```\n// 记住要用大括号来包裹变量\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\nlet a = 1;\nlet jsx1 = <div>{a}</div>;\nlet b = { id : 2 };\nlet jsx2 = <div>{b.id}</div>;\nlet jsx3 = ['i','love','react'].map((name) => {\n    return <div>{name}</div>\n});\nrender(<div>\n    {jsx1}{jsx2}{jsx3}\n    </div>, RootDom);\n// 事实上 render 还有第三个参数 callback\n```\n\n### Component\n\n```\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom = document.getElementById('root');\n\n/*\n * pure functional components \n * it must never modify its own props\n */\n \nconst A = (props) => {\n    return <div>{ props.gender } + { props.name }</div>\n};\nrender(<A gender='male name='frankie'/>,RootDom);\n\n// tagname  A, ==> 不是传统的html标签，而是个函数\n// attributes {   ==> 函数的情况下 attributes === props\n//     gender: 'male',\n//     name: \"frankie\"\n// }\n// children: null\n\n/*\n * class components\n * - Adding Local State to a Class\n * - Adding Lifecycle Methods to a Class\n */\n class FisstComponent extends Component{\n   \t constructor() {\n       \t super()\n       \t this.state = {\n           \t b: 1\n       \t }\n   \t }\n   \t render() {\n       \t return(\n       \t \t <div>\n       \t \t \t I am a component\n       \t \t \t {this.state.b}\n       \t \t </div>\n       \t )\n   \t }\n }\n render(<FirstComponent />,RootDom);\n \n // class 组件必须有 render 方法\n // class 组件必须继承 Component\n \n // 组件为什么要大写？区分 HTML 和 组件 \n```\n\n### life-cycle\n\nhttps://facebook.github.io/react/docs/state-and-lifecycle.html\n\n```\n// 写代码的时候更具有控制力\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\nclass FirstComponent extends Component{\n    constructor(){\n        super();\n        this.state = {\n            b:1\n        }\n    }\n    // shouldComponentUpdate / componentWillReceiveProps / componentDidMount 用得比较多\n\tshouldComponentUpdate(){   // 组件是不是应该被更新\n\t\tconsole.log('shouldComponentUpdate');\n        return true;\n\t}\n\tcomponentWillUnmount(){   // 组件将会移除\n\t\tconsole.log('componentWillUnmount')\n\t}\n\tcomponentDidUpdate(){   // 组件更新好了\n\t\tconsole.log('componentDidUpdate')\n\t}\n\tcomponentWillUpdate(){   // 组件将会更新\n\t\tconsole.log('componentWillUpdate')\n\t}\n\tcomponentWillReceiveProps(){   // 组件获得了新的 props\n\t\tconsole.log('componentWillReceiveProps')\n\t}\n\tcomponentWillMount(){   // 组件将被加载\n\t\tconsole.log('componentWillMount')\n\t}\n\tcomponentDidMount(){   // 组件加载完成\n        this.setState({b:1})\n\t\tconsole.log('componentDidMount')\n\t}\n    render(){   // 组件将被渲染\n    \tconsole.log('render')\n    \tlet a = '10/26'\n        return <div>\n           \tI am a component\n           \t\t{a }\n                {this.state.b}\n            </div>\n    }\n };\n\nrender(<FirstComponent />,RootDom);\n\n// componentWillMount\n// render\n// componentDidMount\n// shouldComponentUpdate\n// componentWillUpdate\n// render\n// componentDidUpdate\n```\n\n### props\n\n```\n// <A a='1'> ==> props = {a:'1'}\n\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\nclass Welcome extends Component {\n  render() {\n    return <div>{this.props.gender} + {this.props.name}</div>\n  }\n}\n/** props.children\n * React uses this.props.children to access a component's children nodes.\n * ==== ! props should be pure === // 不应该做任何修改\n */\nclass ChildComponent extends Component{\n    render(){\n        return (\n        <div>\n            {this.props.children}   // 如果 render 写成传统的 html 标签，那“我是个孩子”就是 {this.props.children}\n            <Welcome gender='male' name='frankie' />\n        </div>\n        );\n    }\n };\nrender(<ChildComponent>我是个孩子</ChildComponent>,RootDom);\n\n // 设置默认值 defaultProps\n // 方法 1\n Welcome.defaultProps = {\n  \tgender: 'male',\n  \tname: 'frankie'\n }\n // 方法 2\n class Welcome extends Component {\n\tstatic defaultProps = {\n       gender: 'male',\n  \t   name: 'frankie'\n\t}\n }\n```\n\n```\n // 类型检测\n import PropTypes from 'prop-types';\n \n class Welcome extends Component {\n\tstatic defaultProps = {\n       gender: PropTypes.string,\n  \t   name: PropTypes.string\n\t}\n\trender(){\n      \treturn <div>{this.props.gender} + {this.props.name}</div> \n\t}\n }\n \n // 假设这里传了数字怎么办？\n ReactDOM.render(<Welcome gender='0234' name='0234'/>,RootDom)\n```\n\nhttps://reactjs.org/docs/typechecking-with-proptypes.html\n\n### setState\n\n```\n// setState 是一个异步的操作\n// 改变数据只有一种方法 setState\nimport React,{Component} from 'react';\nimport {render} from 'react-dom';\nconst RootDom= document.getElementById('root');\n/**\n * 数据源: state + props\n * props: parent ==> child 【pure不能修改】\n * state: 自身维护的数据状态\n */\nclass PropState extends Component{\n    constructor(){\n        super();\n        this.state={a:'I am state'}\n    }\n    click(){\n        /**\n         * setState ==> 本组件重新render\n         */\n    \tthis.setState({\n    \t\ta:'我更新啦 哈哈哈'\n    \t})\n    }\n    render(){\n        return <div onClick={()=>this.click()}>\n                {this.state.a}\n                <A name= {this.state.a} />\n              </div>\n    }\n };\nconst A = (props) => {\n    return <div>{props.name}</div>\n}\nrender(<PropState/>,RootDom);\n```\n\n```\n// 定时器\n// 记住在 numount 要取消定时器，要不然很容易会造成内存泄露\nclass Timer extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tcount: 0,\n          \ttime: (new Date()).toLocaleTimeString()\n      \t}\n\t}\n\ttick() {\n        this.setState({\n            count: 1,\n            time: (new Date()).toLocaleTimeString()\n        })\n        console.log(this.state.count)  // 0,因为 setState() 是异步函数    \t\n\t}\n\tcomponentWillMount() {\n\t\tthis.interval = setInterval(() => this.tick(),1000)\n\t}\n\tcomponentWillUnmount() {\n      \tclearInterval(this.interval)\n\t}\n\tshouldComponentUpate(nextProps, nextState) {\n      \treturn true;\n\t}\n\trender() {\n      \treturn (<div>the time is {this.state.time}</div>)\n\t}\n}\n \nReactDOM.render(<Timer />,RootDom)\n```\n\n### 值得注意的地方\n\n```\n// 绑定 this 的方法\n// 箭头函数和 constructor 都可以\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tname: 'frankie'\n      \t}\n      \t// 构造函数绑 this\n      \t// this.handleClick = this.handleClick.bind(this)\n\t}\n\t// 箭头函数绑 this\n\thandleClick = () => {\n      \talert(this.state.name)\n\t}\n\trender() {\n      \treturn (<div>my name is {this.state.name}</div>)\n\t}\n}\n\n// 最后一种 ReactDOM.render(<Name onClick={this.handleClick.bind(this)}/>,RootDom)\n// 这种是不建议的，会触发 componentWillReceiveProps 和 shouldComponentUpdate，假如在定时器里，子组件就会一直 render\n// 也不能在 render 里用箭头函数\nReactDOM.render(<Name onClick={this.handleClick}/>,RootDom)\n```\n\n```\n// 阻止事件冒泡\n/*\n先考虑一个东西\n写在 React 的 div 和原生的 div 是不一样的\n那它们的 event 是一样的吗？\n// \n<div onclick=\"\"></div>\nfunction test(event){\n  return false\n}\n// react\nhandleClick = (event) => {\n  \n}\n\n其实是不一样的\nreact 的 event 是被封装过的，叫做 SyntheticEvent 能实现百分之九十的 event 原生事件 \n通过 ev.nativeEvent === event 封装\nev.nativeEvent.stopImmediatePropagation()\n\nhandleClick = (event) => {\n  setTimeout(()=> {\n    console.log(event.type)\n  })\n  console.log(event.type)\n}\n\nreact 的 event 是不能异步执行的\nreact 的 event 有一个事件值，触发完成之后就会销毁\n*/\n\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tname: 'frankie'\n      \t}\n\t}\n\thandleClick() {\n      \talert(this.state.name)\n      \t// 可以直接调用\n        // event.stopPropagation()\n        // event.preventDefault()\n\t}\t\n\trender() {\n      \treturn (<div>my name is {this.state.name}</div>)\n\t}\n}\n\nReactDOM.render(<Name onClick={this.handleClick.bind(this)}/>,RootDom)\n```\n\n### ref 和 DOM\n\nhttps://reactjs.org/docs/refs-and-the-dom.html\n\n```\n// 利用 ref 操作 DOM\n// react 不建议直接操作 DOM 元素，性能不好\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n          \tname: 'frankie'\n      \t}\n\t}\n\thandleClick = (event) => {\n      \t// var el = document.getElementById('content')\n      \t// this.refs.style.color = 'red'  这是旧的\n      \tthis.contentRef.style.color = 'red'\n\t}\t\n\trender() {\n      \treturn (\n      \t// <div ref=\"content\">  这是旧的\n      \t<div onClick={this.handleClick}>\n            <div ref={(content) => {this.contentRef = content}}>\n            my name is {this.state.name}\n            </div>\n      \t</div>)\n\t}\n}\n\nReactDOM.render(<Name />,RootDom)\n\n/*\n其实上面这种做法 React 是不推荐的\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n      \t\tcolor: '',\n          \tname: 'frankie'\n      \t}\n\t}\n\thandleClick(event){\n\t\tthis.setState({\n          \tcolor: 'red'\n\t\t})\n\t}\t\n\trender() {\n      \treturn (\n      \t/*\n      \t直接在标签上使用style属性时，\n      \t要写成style={{}}是两个大括号，\n      \t外层大括号是告知jsx这里是js语法，\n      \t和真实DOM不同的是，属性值不能是字符串而必须为对象，\n      \t需要注意的是属性名同样需要驼峰命名法。即margin-top要写成marginTop。\n      \t*/\n      \t<div style={{color: this.state.color}} onClick={this.handleClick.bind(this)}>\n            <div ref={(content) => {this.contentRef = content}}>\n            my name is {this.state.name}\n            </div>\n      \t</div>)\n\t}\n}\n\nReactDOM.render(<Name />,RootDom)\n\n*/\n```\n\n### 渲染\n\n```\nclass Name extends Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n             let arr = [{\n              id: '1',\n              name: 'dalao1'\n            }, {\n              id: '2',\n              name: 'dalao2'\n            }, {\n              id: '3',\n              name: 'dalao3'\n            }]         \t\n      \t}\n\t}\n\trender() {\n      \treturn (\n      \t<div onClick={this.handleClick}>\n\t\t\t<ul>\n\t\t\t\t{arr.map((item, i) => {\n\t\t\t\t\t// return <li key={i}>{item.name}</li>\n\t\t\t\t\t// 这个 key 的作用是见下面\n                  \treturn <li>{item.name}</li>\n\t\t\t\t})}\n\t\t\t</ul>\n      \t</div>)\n\t}\n}\n\nReactDOM.render(<Name />,RootDom)\n\n/*\nkey 的作用 react 做 diff 算法的时候使用\n如果 key 能保持稳定，DOM 内容不变就可以避免重新渲染\nkey 不要用 index 不要用随机数\n\nclass Name extends React.Component {\n\tconstructor() {\n      \tsuper()\n      \tthis.state = {\n             people : [{\n              id: '1',\n              name: 'dalao1'\n            }, {\n              id: '2',\n              name: 'dalao2'\n            }, {\n              id: '3',\n              name: 'dalao3'\n            }]         \t\n      \t}\n\t}\n\thandleClick(event) {\n\t\t// 这里要用深拷贝\n\t\tlet people = this.state.people\n\t\tlet newPeople = people.map((person => {\n          \tlet newPerson = {...person}  // 这里相当于浅拷贝\n          \tif (newPerson.id == '2') {\n              \tnewPerson.name += 'haha'\n          \t}\n          \treturn newPeople  // 返回了新的地址相当于深拷贝\n\t\t}))\n\t\tthis.setState({\n\t\t\tpeople : newPeople\n\t\t})\n\t}\t\n\trender() {\n      \treturn (\n      \t<div onClick={this.handleClick.bind(this)}>\n\t\t\t<ul>\n\t\t\t\t{this.state.people.map((item, i) => {\n\t\t\t\t\t// return <Person key={Math.random() * 100} item={item}></Person>\n\t\t\t\t\t// 如果像上面一样，因为 key 是不一样的，所以 react 以为这个组件没有使用过，要重新构造一份\n\t\t\t\t\treturn <Person key={i} item={item}></Person>\n\t\t\t\t})}\n\t\t\t</ul>\n      \t</div>)\n\t}\n}\n\nclass Person extends React.Component{\n\tshouldComponentUpdate(nextProps, nextState) {\n      \treturn nextProps.item.name !== this.props.item.name\n      \t// 如果不用深拷贝，nextProps.item.name === this.props.item.name 是 true，相等的原因是因为 item 是引用类型\n\t}\n  \trender(){\n  \t\tconsole.log('render' + this.props.item.id)\n  \t\t/* \n  \t\t这里打印的是\n  \t\trender1\n  \t\trender2\n  \t\trender3\n  \t\t避免 1 3 渲染的方法是\n  \t\tkey 值要稳定\n  \t\t深拷贝\n  \t\t*/\n      \treturn <li>{this.props.item.name}</li>\n  \t}\n}\n\nReactDOM.render(<Name />,mountNode)\n*/\n```\n\n[JavaScript 深入了解基本类型和引用类型的值](https://segmentfault.com/a/1190000006752076)\n\n### 条件渲染\n\n```\n/*\n方法有：三元 if else 组件 方法 &&判断\n*/\n\nclass Name extends React.Component{\n  \trender(){\n  \t\tlet isLogin = this.props.isLogin\n  \t\tlet comp = null\n  \t\tif(isLogin){\n          comp = <Logout />\n  \t\t}else{\n          comp = <Login />\n  \t\t}\n      \treturn(<div>\n      \t\t{comp}\n      \t\t// {isLogin ? <Logout /> : <Login />}  // 主要用三元运算\n      \t</div>)\n  \t}\n}\n\nclass Login extends React.Component{\n  \trender(){\n      \treturn <div>login</div>\n  \t}\n}\n\nclass Logout extends React.Component{\n  \trender(){\n      \treturn <div>logout</div>\n  \t}\n}\n\nReactDOM.render(<Name isLogin={true}/>,mountNode)\n\n/*\n可以封装成一个组件\nfunction SignIn(isLogin) {\n  \tif(isLogin){\n      return <Logout/>\n  \t}else{\n      return <Login/>\n  \t}\n}\n\n// 在 render 写\nrender(){\n  return(<SignIn isLogin={isLogin}/>)\n}\n*/\n\n/*\n也可以做成一个方法\ngetLogIn(isLogin) {\n  if(isLogin){\n    return <Logout />\n  }else{\n    return <login/>\n  }\n}\n\nrender(){\n  return(<div>\n  \t{this.getLogin(isLogin)}\n  </div>)\n}\n*/\n\n/*\n还有一种用 && 判断\n{isLogin && <Logout/>}\n{isLogin && <LoginIn/>}\n*/\n```\n\n### HOC\n\n```\n/*\n传一个组件出一个组件\n其实可以理解为一个给基础组件加方法的处理器\n比如说有两个组件 Ad1 Ad2 他们有 abc 三个方法\n\nAd1Component{\n  a(){};b(){};c(){};\n}\nAd2Component{\n  a(){};b(){};c(){};\n}\n\n那我们可以把方法抽离出一个 Basic 组件\nBasicComponent{\n  a(){};b(){};c(){};\n}\n\n然后写到 HOC 转换\nfunction wrapper(WrapperComponent){\n  return BasicComponent{\n    a(){};b(){};c(){};\n    render(){\n      return <WrapperComponent />\n    }\n  }\n}\n*/\n\n// 写个例子\n// 在 input 组件的名字改变的时候加上一些日志的方法但是不能 input 组件上写（为什么会有这个需求？因为有可能这个组件不是你自己写的）\n/*\n想到一个方法用 prototype 但是会影响原型链\n function logProps(InputComponent) {\n    InputComponent.prototype.componentWillReceiveProps = function(nextProps, nextState) {\n      console.log('============')\n      console.log('Current props: ', this.props);\n      console.log('Next props: ', nextProps);\n    };\n    return InputComponent;\n}\n*/\n\n// 正确的方法应该是利用 HOC 封装方法\n\nclass InputComponent extends React.Component{\n    componentWillReceiveProps() {\n\n    }\n    render() {\n        return <div>{this.props.name}</div>\n    }\n}\n\nfunction logProps(WrappedComponent) {\n    return class extends React.Component {  // 匿名组件，要实现的共有方法都在这里做\n      componentWillReceiveProps(nextProps) {    \n        console.log('Current props: ', this.props);\n        console.log('Next props: ', nextProps);\n      }\n      render() {\n        return <WrappedComponent {...this.props} />;\n      }\n    }\n}\n\nconst EnhancedComponent = logProps(InputComponent);\n\n let name = 'dalao';\n setInterval(() => {\n    name += ' hah';\n    ReactDOM.render(<EnhancedComponent name={name} />, document.getElementById('root'));\n }, 1000)\n```\n\n## Redux\n\n[Redux 官方文档](http://www.redux.org.cn/)\n\nhttps://github.com/slashhuang/redux-annotation\n\n![](https://ooo.0o0.ooo/2017/11/04/59fd9c6002509.jpg)\n\n### 第一个简单的例子\n\n[Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\n```\nimport { createStore } from 'redux'\nconst initState = {}\nconst reducer = (state, action) => {\n\treturn action\n}\nconst store = createStore(reducer, initState)\nstore.dispatch({\n\ttype: 'init',\n\tpayload: 'hello world'\n})\nconsole.log(store.getState())\n\n// redux 的整体架构\n// action (动作) ===> 发起 AJAX\n// reducer (Handler处理器) ===> JSON 处理\n// state (最后的状态) ===> JSON 保存起来\n\n// 通常从后端拉数据的流程是这样的\n// AJAX ===> JSON ===> UI\n\n// 所以上面这个代码拆分开来就是\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {  // state 是前一次保存的数据状态\n  \treturn Object.assign({}, state, action);  // 生成下一个数据状态\n}\nconst store = createStore(reducer, initState)\nstore.dispatch(action)\nconsole.log(store.getState())\n```\n\n### createStore 源码\n\n```\n// 需要注意的是第一个参数和第二个参数（reducer, 初始化的 state）\nexport default function createStore(reducer, preloadedState, enhancer)\n\n/*\n判断...\n*/\n\nvar currentReducer = reducer;  // 当前的处理器\nvar currentState = preloadedState;   // 当前的state ===> 初始化的 state\nvar currentListeners = []; \nvar nextListeners = currentListeners;\nvar isDispatching = false;  // 不执行\n\n/*\n往下看\n*/\n\nfunction getState() {\n\treturn currentState;  // 直接 return currentState\n}\n\n/*\n往下看\n*/\n\n  function dispatch(action) {\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);  \n      // 用当前的 reducer 处理当前的 state 和 action\n      // 只要 dispatch(action) 就会处理一遍生成一个 state\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;  // 返回一个 action\n  }\n  \n/*\n往下看\n*/\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n  // 最后也是返回出来\n```\n\n### 回看例子分析 createStore 源码\n\n```\nimport { createStore } from 'redux'\nconst initState = {}\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {   // currentState = currentReducer(currentState, action);  \n  \treturn Object.assign({}, state, action);  // 当前的数据状态\n}\ndebugger\nconst store = createStore(reducer, initState)  // reducer = (state, action) => {...}, initState = {}\ndebugger\nstore.dispatch(action)  // 所以 store 有 dispatch 方法\nconsole.log(store.getState())  // return currentState\n// Object {type: \"init\", payload: \"hello world\"}\n\n// debugger 看过程\n// var currentReducer = reducer;  // currentReducer = function reducer(state, action), reducer = function reducer(state, action)\n// var currentState = preloadedState;  // currentState = Object {}, preloadedState = Object {}\n  \n/*\n跳到 dispatch return 一个 API 集合\n*/\n\n/*\n下一个 debugger\ncurrentState = currentReducer(currentState, action); 进去看一下\nreturn Object.assign({}, state, action);  做一个覆盖\ncurrentState 变成了 Object {type: \"init\", payload: \"hello world\"}\n*/\n\n/*\n看一下 console.log(store.getState())\nfunction getState() {\n    return currentState; // 返回 currentState\n}\n*/\n\n--------------------------------------------------------------------\n\n// 修改一下代码\nimport { createStore } from 'redux'\nconst initState = {}\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {\n  \treturn Object.assign({}, state, action);\n}\nconst store = createStore(reducer, initState)\ndebugger\nstore.subscribe(() => {\n  \tconsole.log('我注册啦')\n})\nstore.dispatch(action)\nconsole.log(store.getState())\n\n// store.subscribe 进去看看\n/*\n  function subscribe(listener) {\n\t\n\t//...\n\t\n    nextListeners.push(listener);    // nextListeners 是一个长度为零的数组，把 listener push 进去\n    return function unsubscribe() {\n    \t// ...\n    };\n  }\n*/\n\n// store.dispatch(action) 进去看看\n/*\n  function dispatch(action) {\n    //...\n\t// 这里会读当前的观察者数组\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  \n  ---------------------\n  \n  在 console 打 listeners 会打印出 [function]\n  listeners[0] 是\n  function () {\n  \tconsole.log('我注册啦');\n  }\n*/\n\n/*\n需要注意的一点是\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT })\n  也就是说，每调用一遍 createStore 就会执行一遍 dispatch({ type: ActionTypes.INIT })\n  所以初始化的 action 是 type: \"@@redux/INIT\"\n*/\n```\n\n### 怎么改变 dom\n\n```\n// HTML\n    <div id='root'>\n        1\n    </div>\n// JS\nimport { createStore } from 'redux'\nconst ROOTDOM = document.getElementById('root')\nconst initState = {}\nconst action = {\n  \ttype: 'init',\n  \tpayload: 'hello world',\n}\nconst reducer = (state, action) => {  \n  \treturn Object.assign({}, state, action); \n}\nconst store = createStore(reducer, initState) \nstore.subscribe(() => {\n  \tROOTDOM.innerHTML = JSON.stringify(store.getState())\n})\nlet counter = 0\nROOTDOM.addEventListener('click', () => {\n  \tcounter++\n  \tconst action = {\n      \ttype: 'click',\n      \tpayload: counter\n  \t}\n  \tstore.dispatch(action)\n})\n```\n\n### 实现一个MVVM\n\n```\n// HTML\n<input id=\"name\"/>\n数据预览区\n<div id=\"preview\"></div>\n<div id='root'>\n1\n</div>\n// JS\nimport { createStore } from 'redux';\nconst initState = {};\nconst action = {\n\ttype: 'init',\n\tpayload: 'hello world',\n};\nconst reducer = (state, action) => {\n\treturn Object.assign({}, state, action);\n};\nconst store = createStore(reducer, initState);\nconst INPUTDOM = document.getElementById('name');\nconst PREVIEWDOM = document.getElementById('preview');\nconst digestUI = () => {\n\tPREVIEWDOM.innerHTML = store.getState().payload;\n\tif (PREVIEWDOM.innerHTML.length > 20) {\n\t\talert('length is 20')\n\t}\n};\nconst inputChange = () =>{\n\tlet val = INPUTDOM.value;\n\tconst action = {\n\t\ttype: 'input_change',\n\t\tpayload: val,\n\t};\n\tstore.dispatch(action);\n};\nlet counter = 0;\nINPUTDOM.addEventListener('input', inputChange)\nstore.subscribe(digestUI);\n\n// 可以看出好处就是行为都是分离的\n```\n\n### 中间件\n\n```\n// redux中的applyMiddleware中间件\n// Middleware makes it easier for software developers\n// to implement 【communication and input/output】,\n// so they can focus on the 【specific purpose of their application】.\n// 更专注 service 服务 input/output service 输入和输出\n// ajax ==> json(乱得一笔) =service转换(中间件)=> UI(整理成好的)\n// express/Koa\n\n// 前端\n// ajax ==http==>\n// httpRequest(head,cookie,body)\n// middlewares(解析cookie, 拿到post请求的数据)\n// 数据就是好的一笔的数据\n// 后端(node.js)\n\n// 看一个例子\n// 注意下面这些很多箭头的叫做高阶函数\n// 例如 const highFunction = a => b => c => console.log(a+b+c); highFunction(1)(2)(3) // 6 // 一个函数执行完之后返回值是一个函数\n// 多参函数 ===> 单参函数\n\n// 如果在 createStore 用上 enhancer 逻辑就会被 applyMiddleware 控制\n// return enhancer(createStore)(reducer, preloadedState)\n\n// 前一个 next 指向下一个 action=> { next(action) }; 最后一个 next 指向 dispatch \n\n// 没有中间件 action ==> ==dispatch==> reducer ==> nextState;\n// 有中间件 action ==middlewares==> ==dispatch==> reducer ==> nextState;\n\n// applyMiddleware 的思想是把一堆函数封装成一个函数\n\nimport { createStore, applyMiddleware } from 'redux';\nconst logger1 = store => next => action => {\n    console.log('current dipatch' + JSON.stringify(action));\n    next(action);\n};\nconst logger2 = store => next => action=> {\n    next(action);\n};\nconst logger3 = store => next => action=> {\n    next(action);\n};\n\nconst enhancer = applyMiddleware(logger1, logger2, logger3);\nconst reducer = (state, action) => state;\nconst store = createStore(reducer, {}, enhancer);\nstore.dispatch({type:1});\nstore.dispatch({type:2});\nstore.dispatch({type:3});\n```\n\naction 的另一种写法 https://github.com/acdlite/flux-standard-action\n\n[What's the '@' (at symbol) in the Redux @connect decorator?](https://stackoverflow.com/questions/32646920/whats-the-at-symbol-in-the-redux-connect-decorator)\n\n[React 实践心得：react-redux 之 connect 方法详解](http://taobaofed.org/blog/2016/08/18/react-redux-connect/)\n\n## ES6\n\n[ES6 教程](http://es6.ruanyifeng.com/)\n\n[摸到 ES6 的门把手](https://frankietang.github.io/2017/10/14/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/)\n\nStage 0 - Strawman（展示阶段）\n\n- Stage 1 - Proposal（征求意见阶段）\n- Stage 2 - Draft（草案阶段）\n- Stage 3 - Candidate（候选人阶段）\n- Stage 4 - Finished（定案阶段）\n\n配 babel 的时候有用 \n\n### Set 和 Map 的数据结构\n\n[set-map](https://github.com/ruanyf/es6tutorial/blob/2ac6e76b38f117f2acf6c465ab70709275b4241a/docs/set-map.md)\n\n```\n// 向 Set 加入值的时候，不会发生类型转换，所以5和\"5\"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。\nlet s = new Set()\ns.size // 0\ns.add(1) // {1}\ns.size // 1\ns.add(1) // {1}\ns.size // 1\ns.add('1') // {1,'1'}\ns.size // 2\n\n// 如何快速去除数组里的重复元素\n[...new Set([1,2,3,4,5,4,3,2,1])]  // (5) [1, 2, 3, 4, 5]\n```\n\n### Decorators\n\n```\n// 对类做一个封装\n// 懂了，大概就是在 class 上面绑定方法可以直接调用\n\nfunction divide(target){\n  target.prototype.divide = function(a,b) {return a/b}\n  return target\n}\n\n@divide\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n\n// 再封装多一个判断\n\nfunction divide(needAdd){\n  return function(target){\n    if(needAdd){\n      target.prototype.divide = function(a,b) {return a/b}\n    }\n  }\n  return target\n}\n\n@divide(true)\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n```\n\n## webpack\n\n[webpack 官方文档](https://webpack.js.org/)\n\n### webpack 与 react\n\n```\n// 主要是配 loaders\n{\n    test: /\\.js[x]?$/,        // 符合 js 或者 jsx\n    loader: \"babel-loader\",   // 运行 babel-loader\n    exclude: /node_modules/\n},\n```\n\n说实话 webpack 这东西翻翻文档就好，不用死记硬背的。要什么功能直接 Google ，`npm i -D <package>`\n\n[webpack：从入门到真实项目配置](https://juejin.im/post/59bb37fa6fb9a00a554f89d2)\n\n## babel\n\n[babel 官方文档](http://babeljs.io/)\n\n### babel\n\n```\n// 因为 react 用的是 JSX 所以需要用到 babel\n// 不止 JSX 还有高阶组件(HOC) 要用到 es7 的 Decorator\n// 把这一堆代码转换成 JS\n// 以下是配法 \n{\n  \"presets\": [\n     \"stage-0\", // 草案 0\n     \"es2015\",  // es6\n     \"react\"    // react\n  ],\n   \"plugins\": [\"transform-decorators-legacy\"]  // 翻译 Decorator\n}\n```\n","slug":"补基础：React-Redux-ES6-webpack-babel","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d99001cf1xhbhrezk17","content":"<h1 id=\"补基础：React-Redux-ES6-webpack-babel\"><a href=\"#补基础：React-Redux-ES6-webpack-babel\" class=\"headerlink\" title=\"补基础：React-Redux-ES6-webpack-babel\"></a>补基础：React-Redux-ES6-webpack-babel</h1><p><a href=\"https://www.docschina.org/\" target=\"_blank\" rel=\"noopener\">印记中文</a></p>\n<p>先看一遍中文文档，第二遍中英文对着看，第三遍才看英文文档</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p><a href=\"https://facebook.github.io/react/\" target=\"_blank\" rel=\"noopener\">React 官方文档</a></p>\n<pre><code>/**\n * JSX : xml in JavaScript\n * 1、tagName\n * 2、attributes(props)\n * 3、children\n */\n/**\n * 组件化: \n * 1、函数式组件props =&gt; JSX ; \n * 2、类组件:class A extends Component;\n */ \n/**\n * 数据源 : state  + props\n * 更新数据: setState\n * 方案: 当数据越来越复杂的时候，我们需要一个数据解决方案 ==&gt; redux\n * 发起数据变更(click etc.) ==&gt; action\n * 生成新的数据结构(state[store])  ==&gt; redux的reducer生成react的state\n * 渲染(render) ==&gt; react来做\n */\n</code></pre><h3 id=\"DOM-对比\"><a href=\"#DOM-对比\" class=\"headerlink\" title=\"DOM 对比\"></a>DOM 对比</h3><pre><code>// 传统方式\n&lt;div data-id=&#39;1&#39;&gt;\n    hello world\n&lt;/div&gt;\n\n// vue \n&lt;div data-id={{id}}&gt;\n    {{name}}\n&lt;/div&gt;\n{\n      data: ()=&gt; {\n          return {\n              name: &#39;hello world&#39;,\n              id: 1\n          }\n      }\n}\n// 注意 vue 是一个 MVVM 框架\n// 特点就是数据和模板分离\n\n// 实际上 react 也可以认为是一个 MVVM 框架\nvar JSX = &lt;div data-id=&#39;1&#39;&gt;\n    hello world\n&lt;/div&gt;;\nrender(JSX,document.getElementById(&#39;root&#39;));\n// 数据和模板绑定在一起\n\nVirtual dom\n\n&lt;div width=&#39;100px&#39;&gt;a&lt;/div&gt;\n==&gt;\ntagname: div\nattributes:{width: &#39;100px&#39;}\nchildren: a\n\n==&gt; IOS / Android\ntagname: UIButton\nattributes:{display: flex}\nchildren: ...\n</code></pre><h3 id=\"用-react-问候世界\"><a href=\"#用-react-问候世界\" class=\"headerlink\" title=\"用 react 问候世界\"></a>用 react 问候世界</h3><pre><code>import react, { Component } from &#39;react&#39; // 基础库\nimport { render } from &#39;react-dom&#39;  // 平台库 这是 web 库\n// 为什么要引两个库呢？\n// 为了跨平台\n// 比如在 ios/android 用上 react-native\n// import from &#39;react-natiev&#39;\nrender(\n    &lt;h1&gt;Hello, world&lt;/h1&gt;              // 要塞的代码\n    document.getElementById(&#39;root&#39;)    // 容器\n)\n\n// 接下来看看用 webpack 编译后的代码\n_react2.default.createElement(\n  &#39;h1&#39;,\n  null,\n  &#39;Hello, world!&#39;\n\n/*\n 也就是说 react 会把 JSX 分成三个部分\n * tagname\n * attributes\n * children\n*/\n</code></pre><h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><pre><code>// 这种模板语法就叫做 JSX\nimport React, { Component } from &#39;react&#39;\nimport { render } from &#39;react-dom&#39;\nconst RootDom = document.getElementById(&#39;root&#39;)\nlet JSX = &lt;div name=&quot;frankie&quot;&gt;\n    Hello world&lt;span&gt;你好&lt;/span&gt;\n&lt;/div&gt;\nrender(JSX, RootDom)\n\n// 以下是编译出来的结果\n/*\nvar JSX = _react2.default.createElement(\n  &#39;div&#39;,\n  { name: &#39;jirengu&#39; },\n  &#39;Hello world&#39;,\n  _react2.default.createElement(\n    &#39;span&#39;,\n    null,\n    &#39;\\u4F60\\u597D&#39;\n  )\n);\n*/\n\n// 结构就相当于这个\n/*\ntagname: &#39;div&#39;\nattributes: {\n      name: &#39;frankie&#39;\n}\nchildren: &#39;hello world&#39;,{\n      tagname: &#39;span&#39;\n      attributes: null\n      children: &#39;你好&#39;\n}\n*/\n</code></pre><pre><code>// 值得注意的地方\n// JSX 可以防止 XSS 漏洞\n// 比如写在 JSX 里会直接输出，写在 HTML 会把 &amp;gt; 转成 &gt;\n\nrender() {\n  let b = &#39;First &amp;gt; Second&#39;\n  return (&lt;div&gt; {b} &lt;/div&gt;)\n} \n\n// 如果要不转译该怎么办？\n/*\ndangerouslySetInnerHTML函数\ndangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。一般而言，使用JS代码设置HTML文档的内容是危险的，因为这样很容易把你的用户信息暴露给跨站脚本攻击.所以，你虽然可以直接在React中设置html的内容，但你要使用 dangerouslySetInnerHTML 并向该函数传递一个含有__html键的对象，用来提醒你自己这样做很危险。例如：\nfunction createMarkup() {\n  return {__html: &#39;First &amp;middot; Second&#39;};\n}\n\nfunction MyComponent() {\n  return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;\n}\n*/\n\n// 实际上，JSX 里面输入 false ，null ，undefined 都是不渲染的\n\nrender() {\n  return (&lt;div&gt; {false} {null} {undefined} {0} &lt;/div&gt;)\n} \n\n// 那如果有个空格在中间呢？\n\nrender() {\n  let b = &#39;First         Second&#39;  // 这里这个空格会打印么？ 不会的\n  return (&lt;div&gt; {b} &lt;/div&gt;)\n} \n\n// 还有一些属性啊，比如 onChange onClick 都要用驼峰命名\n</code></pre><p><a href=\"https://zhuanlan.zhihu.com/p/22500730?refer=study-fe\" target=\"_blank\" rel=\"noopener\">XSS是什么</a> <a href=\"https://zhuanlan.zhihu.com/p/22521378?refer=study-fe\" target=\"_blank\" rel=\"noopener\">CSRF是什么</a></p>\n<h3 id=\"JS-in-JSX（动态化）\"><a href=\"#JS-in-JSX（动态化）\" class=\"headerlink\" title=\"JS-in-JSX（动态化）\"></a>JS-in-JSX（动态化）</h3><pre><code>// 记住要用大括号来包裹变量\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\nlet a = 1;\nlet jsx1 = &lt;div&gt;{a}&lt;/div&gt;;\nlet b = { id : 2 };\nlet jsx2 = &lt;div&gt;{b.id}&lt;/div&gt;;\nlet jsx3 = [&#39;i&#39;,&#39;love&#39;,&#39;react&#39;].map((name) =&gt; {\n    return &lt;div&gt;{name}&lt;/div&gt;\n});\nrender(&lt;div&gt;\n    {jsx1}{jsx2}{jsx3}\n    &lt;/div&gt;, RootDom);\n// 事实上 render 还有第三个参数 callback\n</code></pre><h3 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"Component\"></a>Component</h3><pre><code>import React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom = document.getElementById(&#39;root&#39;);\n\n/*\n * pure functional components \n * it must never modify its own props\n */\n\nconst A = (props) =&gt; {\n    return &lt;div&gt;{ props.gender } + { props.name }&lt;/div&gt;\n};\nrender(&lt;A gender=&#39;male name=&#39;frankie&#39;/&gt;,RootDom);\n\n// tagname  A, ==&gt; 不是传统的html标签，而是个函数\n// attributes {   ==&gt; 函数的情况下 attributes === props\n//     gender: &#39;male&#39;,\n//     name: &quot;frankie&quot;\n// }\n// children: null\n\n/*\n * class components\n * - Adding Local State to a Class\n * - Adding Lifecycle Methods to a Class\n */\n class FisstComponent extends Component{\n        constructor() {\n            super()\n            this.state = {\n                b: 1\n            }\n        }\n        render() {\n            return(\n                 &lt;div&gt;\n                      I am a component\n                      {this.state.b}\n                 &lt;/div&gt;\n            )\n        }\n }\n render(&lt;FirstComponent /&gt;,RootDom);\n\n // class 组件必须有 render 方法\n // class 组件必须继承 Component\n\n // 组件为什么要大写？区分 HTML 和 组件\n</code></pre><h3 id=\"life-cycle\"><a href=\"#life-cycle\" class=\"headerlink\" title=\"life-cycle\"></a>life-cycle</h3><p><a href=\"https://facebook.github.io/react/docs/state-and-lifecycle.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react/docs/state-and-lifecycle.html</a></p>\n<pre><code>// 写代码的时候更具有控制力\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\nclass FirstComponent extends Component{\n    constructor(){\n        super();\n        this.state = {\n            b:1\n        }\n    }\n    // shouldComponentUpdate / componentWillReceiveProps / componentDidMount 用得比较多\n    shouldComponentUpdate(){   // 组件是不是应该被更新\n        console.log(&#39;shouldComponentUpdate&#39;);\n        return true;\n    }\n    componentWillUnmount(){   // 组件将会移除\n        console.log(&#39;componentWillUnmount&#39;)\n    }\n    componentDidUpdate(){   // 组件更新好了\n        console.log(&#39;componentDidUpdate&#39;)\n    }\n    componentWillUpdate(){   // 组件将会更新\n        console.log(&#39;componentWillUpdate&#39;)\n    }\n    componentWillReceiveProps(){   // 组件获得了新的 props\n        console.log(&#39;componentWillReceiveProps&#39;)\n    }\n    componentWillMount(){   // 组件将被加载\n        console.log(&#39;componentWillMount&#39;)\n    }\n    componentDidMount(){   // 组件加载完成\n        this.setState({b:1})\n        console.log(&#39;componentDidMount&#39;)\n    }\n    render(){   // 组件将被渲染\n        console.log(&#39;render&#39;)\n        let a = &#39;10/26&#39;\n        return &lt;div&gt;\n               I am a component\n                   {a }\n                {this.state.b}\n            &lt;/div&gt;\n    }\n };\n\nrender(&lt;FirstComponent /&gt;,RootDom);\n\n// componentWillMount\n// render\n// componentDidMount\n// shouldComponentUpdate\n// componentWillUpdate\n// render\n// componentDidUpdate\n</code></pre><h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><pre><code>// &lt;A a=&#39;1&#39;&gt; ==&gt; props = {a:&#39;1&#39;}\n\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\nclass Welcome extends Component {\n  render() {\n    return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt;\n  }\n}\n/** props.children\n * React uses this.props.children to access a component&#39;s children nodes.\n * ==== ! props should be pure === // 不应该做任何修改\n */\nclass ChildComponent extends Component{\n    render(){\n        return (\n        &lt;div&gt;\n            {this.props.children}   // 如果 render 写成传统的 html 标签，那“我是个孩子”就是 {this.props.children}\n            &lt;Welcome gender=&#39;male&#39; name=&#39;frankie&#39; /&gt;\n        &lt;/div&gt;\n        );\n    }\n };\nrender(&lt;ChildComponent&gt;我是个孩子&lt;/ChildComponent&gt;,RootDom);\n\n // 设置默认值 defaultProps\n // 方法 1\n Welcome.defaultProps = {\n      gender: &#39;male&#39;,\n      name: &#39;frankie&#39;\n }\n // 方法 2\n class Welcome extends Component {\n    static defaultProps = {\n       gender: &#39;male&#39;,\n         name: &#39;frankie&#39;\n    }\n }\n</code></pre><pre><code> // 类型检测\n import PropTypes from &#39;prop-types&#39;;\n\n class Welcome extends Component {\n    static defaultProps = {\n       gender: PropTypes.string,\n         name: PropTypes.string\n    }\n    render(){\n          return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt; \n    }\n }\n\n // 假设这里传了数字怎么办？\n ReactDOM.render(&lt;Welcome gender=&#39;0234&#39; name=&#39;0234&#39;/&gt;,RootDom)\n</code></pre><p><a href=\"https://reactjs.org/docs/typechecking-with-proptypes.html\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/typechecking-with-proptypes.html</a></p>\n<h3 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h3><pre><code>// setState 是一个异步的操作\n// 改变数据只有一种方法 setState\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\n/**\n * 数据源: state + props\n * props: parent ==&gt; child 【pure不能修改】\n * state: 自身维护的数据状态\n */\nclass PropState extends Component{\n    constructor(){\n        super();\n        this.state={a:&#39;I am state&#39;}\n    }\n    click(){\n        /**\n         * setState ==&gt; 本组件重新render\n         */\n        this.setState({\n            a:&#39;我更新啦 哈哈哈&#39;\n        })\n    }\n    render(){\n        return &lt;div onClick={()=&gt;this.click()}&gt;\n                {this.state.a}\n                &lt;A name= {this.state.a} /&gt;\n              &lt;/div&gt;\n    }\n };\nconst A = (props) =&gt; {\n    return &lt;div&gt;{props.name}&lt;/div&gt;\n}\nrender(&lt;PropState/&gt;,RootDom);\n</code></pre><pre><code>// 定时器\n// 记住在 numount 要取消定时器，要不然很容易会造成内存泄露\nclass Timer extends Component {\n    constructor() {\n          super()\n          this.state = {\n              count: 0,\n              time: (new Date()).toLocaleTimeString()\n          }\n    }\n    tick() {\n        this.setState({\n            count: 1,\n            time: (new Date()).toLocaleTimeString()\n        })\n        console.log(this.state.count)  // 0,因为 setState() 是异步函数        \n    }\n    componentWillMount() {\n        this.interval = setInterval(() =&gt; this.tick(),1000)\n    }\n    componentWillUnmount() {\n          clearInterval(this.interval)\n    }\n    shouldComponentUpate(nextProps, nextState) {\n          return true;\n    }\n    render() {\n          return (&lt;div&gt;the time is {this.state.time}&lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Timer /&gt;,RootDom)\n</code></pre><h3 id=\"值得注意的地方\"><a href=\"#值得注意的地方\" class=\"headerlink\" title=\"值得注意的地方\"></a>值得注意的地方</h3><pre><code>// 绑定 this 的方法\n// 箭头函数和 constructor 都可以\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              name: &#39;frankie&#39;\n          }\n          // 构造函数绑 this\n          // this.handleClick = this.handleClick.bind(this)\n    }\n    // 箭头函数绑 this\n    handleClick = () =&gt; {\n          alert(this.state.name)\n    }\n    render() {\n          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)\n    }\n}\n\n// 最后一种 ReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)\n// 这种是不建议的，会触发 componentWillReceiveProps 和 shouldComponentUpdate，假如在定时器里，子组件就会一直 render\n// 也不能在 render 里用箭头函数\nReactDOM.render(&lt;Name onClick={this.handleClick}/&gt;,RootDom)\n</code></pre><pre><code>// 阻止事件冒泡\n/*\n先考虑一个东西\n写在 React 的 div 和原生的 div 是不一样的\n那它们的 event 是一样的吗？\n// \n&lt;div onclick=&quot;&quot;&gt;&lt;/div&gt;\nfunction test(event){\n  return false\n}\n// react\nhandleClick = (event) =&gt; {\n\n}\n\n其实是不一样的\nreact 的 event 是被封装过的，叫做 SyntheticEvent 能实现百分之九十的 event 原生事件 \n通过 ev.nativeEvent === event 封装\nev.nativeEvent.stopImmediatePropagation()\n\nhandleClick = (event) =&gt; {\n  setTimeout(()=&gt; {\n    console.log(event.type)\n  })\n  console.log(event.type)\n}\n\nreact 的 event 是不能异步执行的\nreact 的 event 有一个事件值，触发完成之后就会销毁\n*/\n\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              name: &#39;frankie&#39;\n          }\n    }\n    handleClick() {\n          alert(this.state.name)\n          // 可以直接调用\n        // event.stopPropagation()\n        // event.preventDefault()\n    }    \n    render() {\n          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)\n</code></pre><h3 id=\"ref-和-DOM\"><a href=\"#ref-和-DOM\" class=\"headerlink\" title=\"ref 和 DOM\"></a>ref 和 DOM</h3><p><a href=\"https://reactjs.org/docs/refs-and-the-dom.html\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/refs-and-the-dom.html</a></p>\n<pre><code>// 利用 ref 操作 DOM\n// react 不建议直接操作 DOM 元素，性能不好\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              name: &#39;frankie&#39;\n          }\n    }\n    handleClick = (event) =&gt; {\n          // var el = document.getElementById(&#39;content&#39;)\n          // this.refs.style.color = &#39;red&#39;  这是旧的\n          this.contentRef.style.color = &#39;red&#39;\n    }    \n    render() {\n          return (\n          // &lt;div ref=&quot;content&quot;&gt;  这是旧的\n          &lt;div onClick={this.handleClick}&gt;\n            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;\n            my name is {this.state.name}\n            &lt;/div&gt;\n          &lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name /&gt;,RootDom)\n\n/*\n其实上面这种做法 React 是不推荐的\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              color: &#39;&#39;,\n              name: &#39;frankie&#39;\n          }\n    }\n    handleClick(event){\n        this.setState({\n              color: &#39;red&#39;\n        })\n    }    \n    render() {\n          return (\n          /*\n          直接在标签上使用style属性时，\n          要写成style={{}}是两个大括号，\n          外层大括号是告知jsx这里是js语法，\n          和真实DOM不同的是，属性值不能是字符串而必须为对象，\n          需要注意的是属性名同样需要驼峰命名法。即margin-top要写成marginTop。\n          */\n          &lt;div style={{color: this.state.color}} onClick={this.handleClick.bind(this)}&gt;\n            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;\n            my name is {this.state.name}\n            &lt;/div&gt;\n          &lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name /&gt;,RootDom)\n\n*/\n</code></pre><h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><pre><code>class Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n             let arr = [{\n              id: &#39;1&#39;,\n              name: &#39;dalao1&#39;\n            }, {\n              id: &#39;2&#39;,\n              name: &#39;dalao2&#39;\n            }, {\n              id: &#39;3&#39;,\n              name: &#39;dalao3&#39;\n            }]             \n          }\n    }\n    render() {\n          return (\n          &lt;div onClick={this.handleClick}&gt;\n            &lt;ul&gt;\n                {arr.map((item, i) =&gt; {\n                    // return &lt;li key={i}&gt;{item.name}&lt;/li&gt;\n                    // 这个 key 的作用是见下面\n                      return &lt;li&gt;{item.name}&lt;/li&gt;\n                })}\n            &lt;/ul&gt;\n          &lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name /&gt;,RootDom)\n\n/*\nkey 的作用 react 做 diff 算法的时候使用\n如果 key 能保持稳定，DOM 内容不变就可以避免重新渲染\nkey 不要用 index 不要用随机数\n\nclass Name extends React.Component {\n    constructor() {\n          super()\n          this.state = {\n             people : [{\n              id: &#39;1&#39;,\n              name: &#39;dalao1&#39;\n            }, {\n              id: &#39;2&#39;,\n              name: &#39;dalao2&#39;\n            }, {\n              id: &#39;3&#39;,\n              name: &#39;dalao3&#39;\n            }]             \n          }\n    }\n    handleClick(event) {\n        // 这里要用深拷贝\n        let people = this.state.people\n        let newPeople = people.map((person =&gt; {\n              let newPerson = {...person}  // 这里相当于浅拷贝\n              if (newPerson.id == &#39;2&#39;) {\n                  newPerson.name += &#39;haha&#39;\n              }\n              return newPeople  // 返回了新的地址相当于深拷贝\n        }))\n        this.setState({\n            people : newPeople\n        })\n    }    \n    render() {\n          return (\n          &lt;div onClick={this.handleClick.bind(this)}&gt;\n            &lt;ul&gt;\n                {this.state.people.map((item, i) =&gt; {\n                    // return &lt;Person key={Math.random() * 100} item={item}&gt;&lt;/Person&gt;\n                    // 如果像上面一样，因为 key 是不一样的，所以 react 以为这个组件没有使用过，要重新构造一份\n                    return &lt;Person key={i} item={item}&gt;&lt;/Person&gt;\n                })}\n            &lt;/ul&gt;\n          &lt;/div&gt;)\n    }\n}\n\nclass Person extends React.Component{\n    shouldComponentUpdate(nextProps, nextState) {\n          return nextProps.item.name !== this.props.item.name\n          // 如果不用深拷贝，nextProps.item.name === this.props.item.name 是 true，相等的原因是因为 item 是引用类型\n    }\n      render(){\n          console.log(&#39;render&#39; + this.props.item.id)\n          /* \n          这里打印的是\n          render1\n          render2\n          render3\n          避免 1 3 渲染的方法是\n          key 值要稳定\n          深拷贝\n          */\n          return &lt;li&gt;{this.props.item.name}&lt;/li&gt;\n      }\n}\n\nReactDOM.render(&lt;Name /&gt;,mountNode)\n*/\n</code></pre><p><a href=\"https://segmentfault.com/a/1190000006752076\" target=\"_blank\" rel=\"noopener\">JavaScript 深入了解基本类型和引用类型的值</a></p>\n<h3 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h3><pre><code>/*\n方法有：三元 if else 组件 方法 &amp;&amp;判断\n*/\n\nclass Name extends React.Component{\n      render(){\n          let isLogin = this.props.isLogin\n          let comp = null\n          if(isLogin){\n          comp = &lt;Logout /&gt;\n          }else{\n          comp = &lt;Login /&gt;\n          }\n          return(&lt;div&gt;\n              {comp}\n              // {isLogin ? &lt;Logout /&gt; : &lt;Login /&gt;}  // 主要用三元运算\n          &lt;/div&gt;)\n      }\n}\n\nclass Login extends React.Component{\n      render(){\n          return &lt;div&gt;login&lt;/div&gt;\n      }\n}\n\nclass Logout extends React.Component{\n      render(){\n          return &lt;div&gt;logout&lt;/div&gt;\n      }\n}\n\nReactDOM.render(&lt;Name isLogin={true}/&gt;,mountNode)\n\n/*\n可以封装成一个组件\nfunction SignIn(isLogin) {\n      if(isLogin){\n      return &lt;Logout/&gt;\n      }else{\n      return &lt;Login/&gt;\n      }\n}\n\n// 在 render 写\nrender(){\n  return(&lt;SignIn isLogin={isLogin}/&gt;)\n}\n*/\n\n/*\n也可以做成一个方法\ngetLogIn(isLogin) {\n  if(isLogin){\n    return &lt;Logout /&gt;\n  }else{\n    return &lt;login/&gt;\n  }\n}\n\nrender(){\n  return(&lt;div&gt;\n      {this.getLogin(isLogin)}\n  &lt;/div&gt;)\n}\n*/\n\n/*\n还有一种用 &amp;&amp; 判断\n{isLogin &amp;&amp; &lt;Logout/&gt;}\n{isLogin &amp;&amp; &lt;LoginIn/&gt;}\n*/\n</code></pre><h3 id=\"HOC\"><a href=\"#HOC\" class=\"headerlink\" title=\"HOC\"></a>HOC</h3><pre><code>/*\n传一个组件出一个组件\n其实可以理解为一个给基础组件加方法的处理器\n比如说有两个组件 Ad1 Ad2 他们有 abc 三个方法\n\nAd1Component{\n  a(){};b(){};c(){};\n}\nAd2Component{\n  a(){};b(){};c(){};\n}\n\n那我们可以把方法抽离出一个 Basic 组件\nBasicComponent{\n  a(){};b(){};c(){};\n}\n\n然后写到 HOC 转换\nfunction wrapper(WrapperComponent){\n  return BasicComponent{\n    a(){};b(){};c(){};\n    render(){\n      return &lt;WrapperComponent /&gt;\n    }\n  }\n}\n*/\n\n// 写个例子\n// 在 input 组件的名字改变的时候加上一些日志的方法但是不能 input 组件上写（为什么会有这个需求？因为有可能这个组件不是你自己写的）\n/*\n想到一个方法用 prototype 但是会影响原型链\n function logProps(InputComponent) {\n    InputComponent.prototype.componentWillReceiveProps = function(nextProps, nextState) {\n      console.log(&#39;============&#39;)\n      console.log(&#39;Current props: &#39;, this.props);\n      console.log(&#39;Next props: &#39;, nextProps);\n    };\n    return InputComponent;\n}\n*/\n\n// 正确的方法应该是利用 HOC 封装方法\n\nclass InputComponent extends React.Component{\n    componentWillReceiveProps() {\n\n    }\n    render() {\n        return &lt;div&gt;{this.props.name}&lt;/div&gt;\n    }\n}\n\nfunction logProps(WrappedComponent) {\n    return class extends React.Component {  // 匿名组件，要实现的共有方法都在这里做\n      componentWillReceiveProps(nextProps) {    \n        console.log(&#39;Current props: &#39;, this.props);\n        console.log(&#39;Next props: &#39;, nextProps);\n      }\n      render() {\n        return &lt;WrappedComponent {...this.props} /&gt;;\n      }\n    }\n}\n\nconst EnhancedComponent = logProps(InputComponent);\n\n let name = &#39;dalao&#39;;\n setInterval(() =&gt; {\n    name += &#39; hah&#39;;\n    ReactDOM.render(&lt;EnhancedComponent name={name} /&gt;, document.getElementById(&#39;root&#39;));\n }, 1000)\n</code></pre><h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p><a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">Redux 官方文档</a></p>\n<p><a href=\"https://github.com/slashhuang/redux-annotation\" target=\"_blank\" rel=\"noopener\">https://github.com/slashhuang/redux-annotation</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/11/04/59fd9c6002509.jpg\" alt=\"\"></p>\n<h3 id=\"第一个简单的例子\"><a href=\"#第一个简单的例子\" class=\"headerlink\" title=\"第一个简单的例子\"></a>第一个简单的例子</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">Object.assign()</a></p>\n<pre><code>import { createStore } from &#39;redux&#39;\nconst initState = {}\nconst reducer = (state, action) =&gt; {\n    return action\n}\nconst store = createStore(reducer, initState)\nstore.dispatch({\n    type: &#39;init&#39;,\n    payload: &#39;hello world&#39;\n})\nconsole.log(store.getState())\n\n// redux 的整体架构\n// action (动作) ===&gt; 发起 AJAX\n// reducer (Handler处理器) ===&gt; JSON 处理\n// state (最后的状态) ===&gt; JSON 保存起来\n\n// 通常从后端拉数据的流程是这样的\n// AJAX ===&gt; JSON ===&gt; UI\n\n// 所以上面这个代码拆分开来就是\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {  // state 是前一次保存的数据状态\n      return Object.assign({}, state, action);  // 生成下一个数据状态\n}\nconst store = createStore(reducer, initState)\nstore.dispatch(action)\nconsole.log(store.getState())\n</code></pre><h3 id=\"createStore-源码\"><a href=\"#createStore-源码\" class=\"headerlink\" title=\"createStore 源码\"></a>createStore 源码</h3><pre><code>// 需要注意的是第一个参数和第二个参数（reducer, 初始化的 state）\nexport default function createStore(reducer, preloadedState, enhancer)\n\n/*\n判断...\n*/\n\nvar currentReducer = reducer;  // 当前的处理器\nvar currentState = preloadedState;   // 当前的state ===&gt; 初始化的 state\nvar currentListeners = []; \nvar nextListeners = currentListeners;\nvar isDispatching = false;  // 不执行\n\n/*\n往下看\n*/\n\nfunction getState() {\n    return currentState;  // 直接 return currentState\n}\n\n/*\n往下看\n*/\n\n  function dispatch(action) {\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);  \n      // 用当前的 reducer 处理当前的 state 和 action\n      // 只要 dispatch(action) 就会处理一遍生成一个 state\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i &lt; listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;  // 返回一个 action\n  }\n\n/*\n往下看\n*/\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n  // 最后也是返回出来\n</code></pre><h3 id=\"回看例子分析-createStore-源码\"><a href=\"#回看例子分析-createStore-源码\" class=\"headerlink\" title=\"回看例子分析 createStore 源码\"></a>回看例子分析 createStore 源码</h3><pre><code>import { createStore } from &#39;redux&#39;\nconst initState = {}\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {   // currentState = currentReducer(currentState, action);  \n      return Object.assign({}, state, action);  // 当前的数据状态\n}\ndebugger\nconst store = createStore(reducer, initState)  // reducer = (state, action) =&gt; {...}, initState = {}\ndebugger\nstore.dispatch(action)  // 所以 store 有 dispatch 方法\nconsole.log(store.getState())  // return currentState\n// Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}\n\n// debugger 看过程\n// var currentReducer = reducer;  // currentReducer = function reducer(state, action), reducer = function reducer(state, action)\n// var currentState = preloadedState;  // currentState = Object {}, preloadedState = Object {}\n\n/*\n跳到 dispatch return 一个 API 集合\n*/\n\n/*\n下一个 debugger\ncurrentState = currentReducer(currentState, action); 进去看一下\nreturn Object.assign({}, state, action);  做一个覆盖\ncurrentState 变成了 Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}\n*/\n\n/*\n看一下 console.log(store.getState())\nfunction getState() {\n    return currentState; // 返回 currentState\n}\n*/\n\n--------------------------------------------------------------------\n\n// 修改一下代码\nimport { createStore } from &#39;redux&#39;\nconst initState = {}\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {\n      return Object.assign({}, state, action);\n}\nconst store = createStore(reducer, initState)\ndebugger\nstore.subscribe(() =&gt; {\n      console.log(&#39;我注册啦&#39;)\n})\nstore.dispatch(action)\nconsole.log(store.getState())\n\n// store.subscribe 进去看看\n/*\n  function subscribe(listener) {\n\n    //...\n\n    nextListeners.push(listener);    // nextListeners 是一个长度为零的数组，把 listener push 进去\n    return function unsubscribe() {\n        // ...\n    };\n  }\n*/\n\n// store.dispatch(action) 进去看看\n/*\n  function dispatch(action) {\n    //...\n    // 这里会读当前的观察者数组\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i &lt; listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  ---------------------\n\n  在 console 打 listeners 会打印出 [function]\n  listeners[0] 是\n  function () {\n      console.log(&#39;我注册啦&#39;);\n  }\n*/\n\n/*\n需要注意的一点是\n  // When a store is created, an &quot;INIT&quot; action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT })\n  也就是说，每调用一遍 createStore 就会执行一遍 dispatch({ type: ActionTypes.INIT })\n  所以初始化的 action 是 type: &quot;@@redux/INIT&quot;\n*/\n</code></pre><h3 id=\"怎么改变-dom\"><a href=\"#怎么改变-dom\" class=\"headerlink\" title=\"怎么改变 dom\"></a>怎么改变 dom</h3><pre><code>// HTML\n    &lt;div id=&#39;root&#39;&gt;\n        1\n    &lt;/div&gt;\n// JS\nimport { createStore } from &#39;redux&#39;\nconst ROOTDOM = document.getElementById(&#39;root&#39;)\nconst initState = {}\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {  \n      return Object.assign({}, state, action); \n}\nconst store = createStore(reducer, initState) \nstore.subscribe(() =&gt; {\n      ROOTDOM.innerHTML = JSON.stringify(store.getState())\n})\nlet counter = 0\nROOTDOM.addEventListener(&#39;click&#39;, () =&gt; {\n      counter++\n      const action = {\n          type: &#39;click&#39;,\n          payload: counter\n      }\n      store.dispatch(action)\n})\n</code></pre><h3 id=\"实现一个MVVM\"><a href=\"#实现一个MVVM\" class=\"headerlink\" title=\"实现一个MVVM\"></a>实现一个MVVM</h3><pre><code>// HTML\n&lt;input id=&quot;name&quot;/&gt;\n数据预览区\n&lt;div id=&quot;preview&quot;&gt;&lt;/div&gt;\n&lt;div id=&#39;root&#39;&gt;\n1\n&lt;/div&gt;\n// JS\nimport { createStore } from &#39;redux&#39;;\nconst initState = {};\nconst action = {\n    type: &#39;init&#39;,\n    payload: &#39;hello world&#39;,\n};\nconst reducer = (state, action) =&gt; {\n    return Object.assign({}, state, action);\n};\nconst store = createStore(reducer, initState);\nconst INPUTDOM = document.getElementById(&#39;name&#39;);\nconst PREVIEWDOM = document.getElementById(&#39;preview&#39;);\nconst digestUI = () =&gt; {\n    PREVIEWDOM.innerHTML = store.getState().payload;\n    if (PREVIEWDOM.innerHTML.length &gt; 20) {\n        alert(&#39;length is 20&#39;)\n    }\n};\nconst inputChange = () =&gt;{\n    let val = INPUTDOM.value;\n    const action = {\n        type: &#39;input_change&#39;,\n        payload: val,\n    };\n    store.dispatch(action);\n};\nlet counter = 0;\nINPUTDOM.addEventListener(&#39;input&#39;, inputChange)\nstore.subscribe(digestUI);\n\n// 可以看出好处就是行为都是分离的\n</code></pre><h3 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h3><pre><code>// redux中的applyMiddleware中间件\n// Middleware makes it easier for software developers\n// to implement 【communication and input/output】,\n// so they can focus on the 【specific purpose of their application】.\n// 更专注 service 服务 input/output service 输入和输出\n// ajax ==&gt; json(乱得一笔) =service转换(中间件)=&gt; UI(整理成好的)\n// express/Koa\n\n// 前端\n// ajax ==http==&gt;\n// httpRequest(head,cookie,body)\n// middlewares(解析cookie, 拿到post请求的数据)\n// 数据就是好的一笔的数据\n// 后端(node.js)\n\n// 看一个例子\n// 注意下面这些很多箭头的叫做高阶函数\n// 例如 const highFunction = a =&gt; b =&gt; c =&gt; console.log(a+b+c); highFunction(1)(2)(3) // 6 // 一个函数执行完之后返回值是一个函数\n// 多参函数 ===&gt; 单参函数\n\n// 如果在 createStore 用上 enhancer 逻辑就会被 applyMiddleware 控制\n// return enhancer(createStore)(reducer, preloadedState)\n\n// 前一个 next 指向下一个 action=&gt; { next(action) }; 最后一个 next 指向 dispatch \n\n// 没有中间件 action ==&gt; ==dispatch==&gt; reducer ==&gt; nextState;\n// 有中间件 action ==middlewares==&gt; ==dispatch==&gt; reducer ==&gt; nextState;\n\n// applyMiddleware 的思想是把一堆函数封装成一个函数\n\nimport { createStore, applyMiddleware } from &#39;redux&#39;;\nconst logger1 = store =&gt; next =&gt; action =&gt; {\n    console.log(&#39;current dipatch&#39; + JSON.stringify(action));\n    next(action);\n};\nconst logger2 = store =&gt; next =&gt; action=&gt; {\n    next(action);\n};\nconst logger3 = store =&gt; next =&gt; action=&gt; {\n    next(action);\n};\n\nconst enhancer = applyMiddleware(logger1, logger2, logger3);\nconst reducer = (state, action) =&gt; state;\nconst store = createStore(reducer, {}, enhancer);\nstore.dispatch({type:1});\nstore.dispatch({type:2});\nstore.dispatch({type:3});\n</code></pre><p>action 的另一种写法 <a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\" rel=\"noopener\">https://github.com/acdlite/flux-standard-action</a></p>\n<p><a href=\"https://stackoverflow.com/questions/32646920/whats-the-at-symbol-in-the-redux-connect-decorator\" target=\"_blank\" rel=\"noopener\">What’s the ‘@’ (at symbol) in the Redux @connect decorator?</a></p>\n<p><a href=\"http://taobaofed.org/blog/2016/08/18/react-redux-connect/\" target=\"_blank\" rel=\"noopener\">React 实践心得：react-redux 之 connect 方法详解</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><p><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ES6 教程</a></p>\n<p><a href=\"https://frankietang.github.io/2017/10/14/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 ES6 的门把手</a></p>\n<p>Stage 0 - Strawman（展示阶段）</p>\n<ul>\n<li>Stage 1 - Proposal（征求意见阶段）</li>\n<li>Stage 2 - Draft（草案阶段）</li>\n<li>Stage 3 - Candidate（候选人阶段）</li>\n<li>Stage 4 - Finished（定案阶段）</li>\n</ul>\n<p>配 babel 的时候有用 </p>\n<h3 id=\"Set-和-Map-的数据结构\"><a href=\"#Set-和-Map-的数据结构\" class=\"headerlink\" title=\"Set 和 Map 的数据结构\"></a>Set 和 Map 的数据结构</h3><p><a href=\"https://github.com/ruanyf/es6tutorial/blob/2ac6e76b38f117f2acf6c465ab70709275b4241a/docs/set-map.md\" target=\"_blank\" rel=\"noopener\">set-map</a></p>\n<pre><code>// 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。\nlet s = new Set()\ns.size // 0\ns.add(1) // {1}\ns.size // 1\ns.add(1) // {1}\ns.size // 1\ns.add(&#39;1&#39;) // {1,&#39;1&#39;}\ns.size // 2\n\n// 如何快速去除数组里的重复元素\n[...new Set([1,2,3,4,5,4,3,2,1])]  // (5) [1, 2, 3, 4, 5]\n</code></pre><h3 id=\"Decorators\"><a href=\"#Decorators\" class=\"headerlink\" title=\"Decorators\"></a>Decorators</h3><pre><code>// 对类做一个封装\n// 懂了，大概就是在 class 上面绑定方法可以直接调用\n\nfunction divide(target){\n  target.prototype.divide = function(a,b) {return a/b}\n  return target\n}\n\n@divide\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n\n// 再封装多一个判断\n\nfunction divide(needAdd){\n  return function(target){\n    if(needAdd){\n      target.prototype.divide = function(a,b) {return a/b}\n    }\n  }\n  return target\n}\n\n@divide(true)\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n</code></pre><h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack 官方文档</a></p>\n<h3 id=\"webpack-与-react\"><a href=\"#webpack-与-react\" class=\"headerlink\" title=\"webpack 与 react\"></a>webpack 与 react</h3><pre><code>// 主要是配 loaders\n{\n    test: /\\.js[x]?$/,        // 符合 js 或者 jsx\n    loader: &quot;babel-loader&quot;,   // 运行 babel-loader\n    exclude: /node_modules/\n},\n</code></pre><p>说实话 webpack 这东西翻翻文档就好，不用死记硬背的。要什么功能直接 Google ，<code>npm i -D &lt;package&gt;</code></p>\n<p><a href=\"https://juejin.im/post/59bb37fa6fb9a00a554f89d2\" target=\"_blank\" rel=\"noopener\">webpack：从入门到真实项目配置</a></p>\n<h2 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h2><p><a href=\"http://babeljs.io/\" target=\"_blank\" rel=\"noopener\">babel 官方文档</a></p>\n<h3 id=\"babel-1\"><a href=\"#babel-1\" class=\"headerlink\" title=\"babel\"></a>babel</h3><pre><code>// 因为 react 用的是 JSX 所以需要用到 babel\n// 不止 JSX 还有高阶组件(HOC) 要用到 es7 的 Decorator\n// 把这一堆代码转换成 JS\n// 以下是配法 \n{\n  &quot;presets&quot;: [\n     &quot;stage-0&quot;, // 草案 0\n     &quot;es2015&quot;,  // es6\n     &quot;react&quot;    // react\n  ],\n   &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]  // 翻译 Decorator\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：React-Redux-ES6-webpack-babel\"><a href=\"#补基础：React-Redux-ES6-webpack-babel\" class=\"headerlink\" title=\"补基础：React-Redux-ES6-webpack-babel\"></a>补基础：React-Redux-ES6-webpack-babel</h1><p><a href=\"https://www.docschina.org/\" target=\"_blank\" rel=\"noopener\">印记中文</a></p>\n<p>先看一遍中文文档，第二遍中英文对着看，第三遍才看英文文档</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p><a href=\"https://facebook.github.io/react/\" target=\"_blank\" rel=\"noopener\">React 官方文档</a></p>\n<pre><code>/**\n * JSX : xml in JavaScript\n * 1、tagName\n * 2、attributes(props)\n * 3、children\n */\n/**\n * 组件化: \n * 1、函数式组件props =&gt; JSX ; \n * 2、类组件:class A extends Component;\n */ \n/**\n * 数据源 : state  + props\n * 更新数据: setState\n * 方案: 当数据越来越复杂的时候，我们需要一个数据解决方案 ==&gt; redux\n * 发起数据变更(click etc.) ==&gt; action\n * 生成新的数据结构(state[store])  ==&gt; redux的reducer生成react的state\n * 渲染(render) ==&gt; react来做\n */\n</code></pre><h3 id=\"DOM-对比\"><a href=\"#DOM-对比\" class=\"headerlink\" title=\"DOM 对比\"></a>DOM 对比</h3><pre><code>// 传统方式\n&lt;div data-id=&#39;1&#39;&gt;\n    hello world\n&lt;/div&gt;\n\n// vue \n&lt;div data-id={{id}}&gt;\n    {{name}}\n&lt;/div&gt;\n{\n      data: ()=&gt; {\n          return {\n              name: &#39;hello world&#39;,\n              id: 1\n          }\n      }\n}\n// 注意 vue 是一个 MVVM 框架\n// 特点就是数据和模板分离\n\n// 实际上 react 也可以认为是一个 MVVM 框架\nvar JSX = &lt;div data-id=&#39;1&#39;&gt;\n    hello world\n&lt;/div&gt;;\nrender(JSX,document.getElementById(&#39;root&#39;));\n// 数据和模板绑定在一起\n\nVirtual dom\n\n&lt;div width=&#39;100px&#39;&gt;a&lt;/div&gt;\n==&gt;\ntagname: div\nattributes:{width: &#39;100px&#39;}\nchildren: a\n\n==&gt; IOS / Android\ntagname: UIButton\nattributes:{display: flex}\nchildren: ...\n</code></pre><h3 id=\"用-react-问候世界\"><a href=\"#用-react-问候世界\" class=\"headerlink\" title=\"用 react 问候世界\"></a>用 react 问候世界</h3><pre><code>import react, { Component } from &#39;react&#39; // 基础库\nimport { render } from &#39;react-dom&#39;  // 平台库 这是 web 库\n// 为什么要引两个库呢？\n// 为了跨平台\n// 比如在 ios/android 用上 react-native\n// import from &#39;react-natiev&#39;\nrender(\n    &lt;h1&gt;Hello, world&lt;/h1&gt;              // 要塞的代码\n    document.getElementById(&#39;root&#39;)    // 容器\n)\n\n// 接下来看看用 webpack 编译后的代码\n_react2.default.createElement(\n  &#39;h1&#39;,\n  null,\n  &#39;Hello, world!&#39;\n\n/*\n 也就是说 react 会把 JSX 分成三个部分\n * tagname\n * attributes\n * children\n*/\n</code></pre><h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><pre><code>// 这种模板语法就叫做 JSX\nimport React, { Component } from &#39;react&#39;\nimport { render } from &#39;react-dom&#39;\nconst RootDom = document.getElementById(&#39;root&#39;)\nlet JSX = &lt;div name=&quot;frankie&quot;&gt;\n    Hello world&lt;span&gt;你好&lt;/span&gt;\n&lt;/div&gt;\nrender(JSX, RootDom)\n\n// 以下是编译出来的结果\n/*\nvar JSX = _react2.default.createElement(\n  &#39;div&#39;,\n  { name: &#39;jirengu&#39; },\n  &#39;Hello world&#39;,\n  _react2.default.createElement(\n    &#39;span&#39;,\n    null,\n    &#39;\\u4F60\\u597D&#39;\n  )\n);\n*/\n\n// 结构就相当于这个\n/*\ntagname: &#39;div&#39;\nattributes: {\n      name: &#39;frankie&#39;\n}\nchildren: &#39;hello world&#39;,{\n      tagname: &#39;span&#39;\n      attributes: null\n      children: &#39;你好&#39;\n}\n*/\n</code></pre><pre><code>// 值得注意的地方\n// JSX 可以防止 XSS 漏洞\n// 比如写在 JSX 里会直接输出，写在 HTML 会把 &amp;gt; 转成 &gt;\n\nrender() {\n  let b = &#39;First &amp;gt; Second&#39;\n  return (&lt;div&gt; {b} &lt;/div&gt;)\n} \n\n// 如果要不转译该怎么办？\n/*\ndangerouslySetInnerHTML函数\ndangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。一般而言，使用JS代码设置HTML文档的内容是危险的，因为这样很容易把你的用户信息暴露给跨站脚本攻击.所以，你虽然可以直接在React中设置html的内容，但你要使用 dangerouslySetInnerHTML 并向该函数传递一个含有__html键的对象，用来提醒你自己这样做很危险。例如：\nfunction createMarkup() {\n  return {__html: &#39;First &amp;middot; Second&#39;};\n}\n\nfunction MyComponent() {\n  return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;\n}\n*/\n\n// 实际上，JSX 里面输入 false ，null ，undefined 都是不渲染的\n\nrender() {\n  return (&lt;div&gt; {false} {null} {undefined} {0} &lt;/div&gt;)\n} \n\n// 那如果有个空格在中间呢？\n\nrender() {\n  let b = &#39;First         Second&#39;  // 这里这个空格会打印么？ 不会的\n  return (&lt;div&gt; {b} &lt;/div&gt;)\n} \n\n// 还有一些属性啊，比如 onChange onClick 都要用驼峰命名\n</code></pre><p><a href=\"https://zhuanlan.zhihu.com/p/22500730?refer=study-fe\" target=\"_blank\" rel=\"noopener\">XSS是什么</a> <a href=\"https://zhuanlan.zhihu.com/p/22521378?refer=study-fe\" target=\"_blank\" rel=\"noopener\">CSRF是什么</a></p>\n<h3 id=\"JS-in-JSX（动态化）\"><a href=\"#JS-in-JSX（动态化）\" class=\"headerlink\" title=\"JS-in-JSX（动态化）\"></a>JS-in-JSX（动态化）</h3><pre><code>// 记住要用大括号来包裹变量\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\nlet a = 1;\nlet jsx1 = &lt;div&gt;{a}&lt;/div&gt;;\nlet b = { id : 2 };\nlet jsx2 = &lt;div&gt;{b.id}&lt;/div&gt;;\nlet jsx3 = [&#39;i&#39;,&#39;love&#39;,&#39;react&#39;].map((name) =&gt; {\n    return &lt;div&gt;{name}&lt;/div&gt;\n});\nrender(&lt;div&gt;\n    {jsx1}{jsx2}{jsx3}\n    &lt;/div&gt;, RootDom);\n// 事实上 render 还有第三个参数 callback\n</code></pre><h3 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"Component\"></a>Component</h3><pre><code>import React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom = document.getElementById(&#39;root&#39;);\n\n/*\n * pure functional components \n * it must never modify its own props\n */\n\nconst A = (props) =&gt; {\n    return &lt;div&gt;{ props.gender } + { props.name }&lt;/div&gt;\n};\nrender(&lt;A gender=&#39;male name=&#39;frankie&#39;/&gt;,RootDom);\n\n// tagname  A, ==&gt; 不是传统的html标签，而是个函数\n// attributes {   ==&gt; 函数的情况下 attributes === props\n//     gender: &#39;male&#39;,\n//     name: &quot;frankie&quot;\n// }\n// children: null\n\n/*\n * class components\n * - Adding Local State to a Class\n * - Adding Lifecycle Methods to a Class\n */\n class FisstComponent extends Component{\n        constructor() {\n            super()\n            this.state = {\n                b: 1\n            }\n        }\n        render() {\n            return(\n                 &lt;div&gt;\n                      I am a component\n                      {this.state.b}\n                 &lt;/div&gt;\n            )\n        }\n }\n render(&lt;FirstComponent /&gt;,RootDom);\n\n // class 组件必须有 render 方法\n // class 组件必须继承 Component\n\n // 组件为什么要大写？区分 HTML 和 组件\n</code></pre><h3 id=\"life-cycle\"><a href=\"#life-cycle\" class=\"headerlink\" title=\"life-cycle\"></a>life-cycle</h3><p><a href=\"https://facebook.github.io/react/docs/state-and-lifecycle.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react/docs/state-and-lifecycle.html</a></p>\n<pre><code>// 写代码的时候更具有控制力\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\nclass FirstComponent extends Component{\n    constructor(){\n        super();\n        this.state = {\n            b:1\n        }\n    }\n    // shouldComponentUpdate / componentWillReceiveProps / componentDidMount 用得比较多\n    shouldComponentUpdate(){   // 组件是不是应该被更新\n        console.log(&#39;shouldComponentUpdate&#39;);\n        return true;\n    }\n    componentWillUnmount(){   // 组件将会移除\n        console.log(&#39;componentWillUnmount&#39;)\n    }\n    componentDidUpdate(){   // 组件更新好了\n        console.log(&#39;componentDidUpdate&#39;)\n    }\n    componentWillUpdate(){   // 组件将会更新\n        console.log(&#39;componentWillUpdate&#39;)\n    }\n    componentWillReceiveProps(){   // 组件获得了新的 props\n        console.log(&#39;componentWillReceiveProps&#39;)\n    }\n    componentWillMount(){   // 组件将被加载\n        console.log(&#39;componentWillMount&#39;)\n    }\n    componentDidMount(){   // 组件加载完成\n        this.setState({b:1})\n        console.log(&#39;componentDidMount&#39;)\n    }\n    render(){   // 组件将被渲染\n        console.log(&#39;render&#39;)\n        let a = &#39;10/26&#39;\n        return &lt;div&gt;\n               I am a component\n                   {a }\n                {this.state.b}\n            &lt;/div&gt;\n    }\n };\n\nrender(&lt;FirstComponent /&gt;,RootDom);\n\n// componentWillMount\n// render\n// componentDidMount\n// shouldComponentUpdate\n// componentWillUpdate\n// render\n// componentDidUpdate\n</code></pre><h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><pre><code>// &lt;A a=&#39;1&#39;&gt; ==&gt; props = {a:&#39;1&#39;}\n\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\nclass Welcome extends Component {\n  render() {\n    return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt;\n  }\n}\n/** props.children\n * React uses this.props.children to access a component&#39;s children nodes.\n * ==== ! props should be pure === // 不应该做任何修改\n */\nclass ChildComponent extends Component{\n    render(){\n        return (\n        &lt;div&gt;\n            {this.props.children}   // 如果 render 写成传统的 html 标签，那“我是个孩子”就是 {this.props.children}\n            &lt;Welcome gender=&#39;male&#39; name=&#39;frankie&#39; /&gt;\n        &lt;/div&gt;\n        );\n    }\n };\nrender(&lt;ChildComponent&gt;我是个孩子&lt;/ChildComponent&gt;,RootDom);\n\n // 设置默认值 defaultProps\n // 方法 1\n Welcome.defaultProps = {\n      gender: &#39;male&#39;,\n      name: &#39;frankie&#39;\n }\n // 方法 2\n class Welcome extends Component {\n    static defaultProps = {\n       gender: &#39;male&#39;,\n         name: &#39;frankie&#39;\n    }\n }\n</code></pre><pre><code> // 类型检测\n import PropTypes from &#39;prop-types&#39;;\n\n class Welcome extends Component {\n    static defaultProps = {\n       gender: PropTypes.string,\n         name: PropTypes.string\n    }\n    render(){\n          return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt; \n    }\n }\n\n // 假设这里传了数字怎么办？\n ReactDOM.render(&lt;Welcome gender=&#39;0234&#39; name=&#39;0234&#39;/&gt;,RootDom)\n</code></pre><p><a href=\"https://reactjs.org/docs/typechecking-with-proptypes.html\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/typechecking-with-proptypes.html</a></p>\n<h3 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h3><pre><code>// setState 是一个异步的操作\n// 改变数据只有一种方法 setState\nimport React,{Component} from &#39;react&#39;;\nimport {render} from &#39;react-dom&#39;;\nconst RootDom= document.getElementById(&#39;root&#39;);\n/**\n * 数据源: state + props\n * props: parent ==&gt; child 【pure不能修改】\n * state: 自身维护的数据状态\n */\nclass PropState extends Component{\n    constructor(){\n        super();\n        this.state={a:&#39;I am state&#39;}\n    }\n    click(){\n        /**\n         * setState ==&gt; 本组件重新render\n         */\n        this.setState({\n            a:&#39;我更新啦 哈哈哈&#39;\n        })\n    }\n    render(){\n        return &lt;div onClick={()=&gt;this.click()}&gt;\n                {this.state.a}\n                &lt;A name= {this.state.a} /&gt;\n              &lt;/div&gt;\n    }\n };\nconst A = (props) =&gt; {\n    return &lt;div&gt;{props.name}&lt;/div&gt;\n}\nrender(&lt;PropState/&gt;,RootDom);\n</code></pre><pre><code>// 定时器\n// 记住在 numount 要取消定时器，要不然很容易会造成内存泄露\nclass Timer extends Component {\n    constructor() {\n          super()\n          this.state = {\n              count: 0,\n              time: (new Date()).toLocaleTimeString()\n          }\n    }\n    tick() {\n        this.setState({\n            count: 1,\n            time: (new Date()).toLocaleTimeString()\n        })\n        console.log(this.state.count)  // 0,因为 setState() 是异步函数        \n    }\n    componentWillMount() {\n        this.interval = setInterval(() =&gt; this.tick(),1000)\n    }\n    componentWillUnmount() {\n          clearInterval(this.interval)\n    }\n    shouldComponentUpate(nextProps, nextState) {\n          return true;\n    }\n    render() {\n          return (&lt;div&gt;the time is {this.state.time}&lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Timer /&gt;,RootDom)\n</code></pre><h3 id=\"值得注意的地方\"><a href=\"#值得注意的地方\" class=\"headerlink\" title=\"值得注意的地方\"></a>值得注意的地方</h3><pre><code>// 绑定 this 的方法\n// 箭头函数和 constructor 都可以\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              name: &#39;frankie&#39;\n          }\n          // 构造函数绑 this\n          // this.handleClick = this.handleClick.bind(this)\n    }\n    // 箭头函数绑 this\n    handleClick = () =&gt; {\n          alert(this.state.name)\n    }\n    render() {\n          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)\n    }\n}\n\n// 最后一种 ReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)\n// 这种是不建议的，会触发 componentWillReceiveProps 和 shouldComponentUpdate，假如在定时器里，子组件就会一直 render\n// 也不能在 render 里用箭头函数\nReactDOM.render(&lt;Name onClick={this.handleClick}/&gt;,RootDom)\n</code></pre><pre><code>// 阻止事件冒泡\n/*\n先考虑一个东西\n写在 React 的 div 和原生的 div 是不一样的\n那它们的 event 是一样的吗？\n// \n&lt;div onclick=&quot;&quot;&gt;&lt;/div&gt;\nfunction test(event){\n  return false\n}\n// react\nhandleClick = (event) =&gt; {\n\n}\n\n其实是不一样的\nreact 的 event 是被封装过的，叫做 SyntheticEvent 能实现百分之九十的 event 原生事件 \n通过 ev.nativeEvent === event 封装\nev.nativeEvent.stopImmediatePropagation()\n\nhandleClick = (event) =&gt; {\n  setTimeout(()=&gt; {\n    console.log(event.type)\n  })\n  console.log(event.type)\n}\n\nreact 的 event 是不能异步执行的\nreact 的 event 有一个事件值，触发完成之后就会销毁\n*/\n\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              name: &#39;frankie&#39;\n          }\n    }\n    handleClick() {\n          alert(this.state.name)\n          // 可以直接调用\n        // event.stopPropagation()\n        // event.preventDefault()\n    }    \n    render() {\n          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)\n</code></pre><h3 id=\"ref-和-DOM\"><a href=\"#ref-和-DOM\" class=\"headerlink\" title=\"ref 和 DOM\"></a>ref 和 DOM</h3><p><a href=\"https://reactjs.org/docs/refs-and-the-dom.html\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/refs-and-the-dom.html</a></p>\n<pre><code>// 利用 ref 操作 DOM\n// react 不建议直接操作 DOM 元素，性能不好\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              name: &#39;frankie&#39;\n          }\n    }\n    handleClick = (event) =&gt; {\n          // var el = document.getElementById(&#39;content&#39;)\n          // this.refs.style.color = &#39;red&#39;  这是旧的\n          this.contentRef.style.color = &#39;red&#39;\n    }    \n    render() {\n          return (\n          // &lt;div ref=&quot;content&quot;&gt;  这是旧的\n          &lt;div onClick={this.handleClick}&gt;\n            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;\n            my name is {this.state.name}\n            &lt;/div&gt;\n          &lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name /&gt;,RootDom)\n\n/*\n其实上面这种做法 React 是不推荐的\nclass Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n              color: &#39;&#39;,\n              name: &#39;frankie&#39;\n          }\n    }\n    handleClick(event){\n        this.setState({\n              color: &#39;red&#39;\n        })\n    }    \n    render() {\n          return (\n          /*\n          直接在标签上使用style属性时，\n          要写成style={{}}是两个大括号，\n          外层大括号是告知jsx这里是js语法，\n          和真实DOM不同的是，属性值不能是字符串而必须为对象，\n          需要注意的是属性名同样需要驼峰命名法。即margin-top要写成marginTop。\n          */\n          &lt;div style={{color: this.state.color}} onClick={this.handleClick.bind(this)}&gt;\n            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;\n            my name is {this.state.name}\n            &lt;/div&gt;\n          &lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name /&gt;,RootDom)\n\n*/\n</code></pre><h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><pre><code>class Name extends Component {\n    constructor() {\n          super()\n          this.state = {\n             let arr = [{\n              id: &#39;1&#39;,\n              name: &#39;dalao1&#39;\n            }, {\n              id: &#39;2&#39;,\n              name: &#39;dalao2&#39;\n            }, {\n              id: &#39;3&#39;,\n              name: &#39;dalao3&#39;\n            }]             \n          }\n    }\n    render() {\n          return (\n          &lt;div onClick={this.handleClick}&gt;\n            &lt;ul&gt;\n                {arr.map((item, i) =&gt; {\n                    // return &lt;li key={i}&gt;{item.name}&lt;/li&gt;\n                    // 这个 key 的作用是见下面\n                      return &lt;li&gt;{item.name}&lt;/li&gt;\n                })}\n            &lt;/ul&gt;\n          &lt;/div&gt;)\n    }\n}\n\nReactDOM.render(&lt;Name /&gt;,RootDom)\n\n/*\nkey 的作用 react 做 diff 算法的时候使用\n如果 key 能保持稳定，DOM 内容不变就可以避免重新渲染\nkey 不要用 index 不要用随机数\n\nclass Name extends React.Component {\n    constructor() {\n          super()\n          this.state = {\n             people : [{\n              id: &#39;1&#39;,\n              name: &#39;dalao1&#39;\n            }, {\n              id: &#39;2&#39;,\n              name: &#39;dalao2&#39;\n            }, {\n              id: &#39;3&#39;,\n              name: &#39;dalao3&#39;\n            }]             \n          }\n    }\n    handleClick(event) {\n        // 这里要用深拷贝\n        let people = this.state.people\n        let newPeople = people.map((person =&gt; {\n              let newPerson = {...person}  // 这里相当于浅拷贝\n              if (newPerson.id == &#39;2&#39;) {\n                  newPerson.name += &#39;haha&#39;\n              }\n              return newPeople  // 返回了新的地址相当于深拷贝\n        }))\n        this.setState({\n            people : newPeople\n        })\n    }    \n    render() {\n          return (\n          &lt;div onClick={this.handleClick.bind(this)}&gt;\n            &lt;ul&gt;\n                {this.state.people.map((item, i) =&gt; {\n                    // return &lt;Person key={Math.random() * 100} item={item}&gt;&lt;/Person&gt;\n                    // 如果像上面一样，因为 key 是不一样的，所以 react 以为这个组件没有使用过，要重新构造一份\n                    return &lt;Person key={i} item={item}&gt;&lt;/Person&gt;\n                })}\n            &lt;/ul&gt;\n          &lt;/div&gt;)\n    }\n}\n\nclass Person extends React.Component{\n    shouldComponentUpdate(nextProps, nextState) {\n          return nextProps.item.name !== this.props.item.name\n          // 如果不用深拷贝，nextProps.item.name === this.props.item.name 是 true，相等的原因是因为 item 是引用类型\n    }\n      render(){\n          console.log(&#39;render&#39; + this.props.item.id)\n          /* \n          这里打印的是\n          render1\n          render2\n          render3\n          避免 1 3 渲染的方法是\n          key 值要稳定\n          深拷贝\n          */\n          return &lt;li&gt;{this.props.item.name}&lt;/li&gt;\n      }\n}\n\nReactDOM.render(&lt;Name /&gt;,mountNode)\n*/\n</code></pre><p><a href=\"https://segmentfault.com/a/1190000006752076\" target=\"_blank\" rel=\"noopener\">JavaScript 深入了解基本类型和引用类型的值</a></p>\n<h3 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h3><pre><code>/*\n方法有：三元 if else 组件 方法 &amp;&amp;判断\n*/\n\nclass Name extends React.Component{\n      render(){\n          let isLogin = this.props.isLogin\n          let comp = null\n          if(isLogin){\n          comp = &lt;Logout /&gt;\n          }else{\n          comp = &lt;Login /&gt;\n          }\n          return(&lt;div&gt;\n              {comp}\n              // {isLogin ? &lt;Logout /&gt; : &lt;Login /&gt;}  // 主要用三元运算\n          &lt;/div&gt;)\n      }\n}\n\nclass Login extends React.Component{\n      render(){\n          return &lt;div&gt;login&lt;/div&gt;\n      }\n}\n\nclass Logout extends React.Component{\n      render(){\n          return &lt;div&gt;logout&lt;/div&gt;\n      }\n}\n\nReactDOM.render(&lt;Name isLogin={true}/&gt;,mountNode)\n\n/*\n可以封装成一个组件\nfunction SignIn(isLogin) {\n      if(isLogin){\n      return &lt;Logout/&gt;\n      }else{\n      return &lt;Login/&gt;\n      }\n}\n\n// 在 render 写\nrender(){\n  return(&lt;SignIn isLogin={isLogin}/&gt;)\n}\n*/\n\n/*\n也可以做成一个方法\ngetLogIn(isLogin) {\n  if(isLogin){\n    return &lt;Logout /&gt;\n  }else{\n    return &lt;login/&gt;\n  }\n}\n\nrender(){\n  return(&lt;div&gt;\n      {this.getLogin(isLogin)}\n  &lt;/div&gt;)\n}\n*/\n\n/*\n还有一种用 &amp;&amp; 判断\n{isLogin &amp;&amp; &lt;Logout/&gt;}\n{isLogin &amp;&amp; &lt;LoginIn/&gt;}\n*/\n</code></pre><h3 id=\"HOC\"><a href=\"#HOC\" class=\"headerlink\" title=\"HOC\"></a>HOC</h3><pre><code>/*\n传一个组件出一个组件\n其实可以理解为一个给基础组件加方法的处理器\n比如说有两个组件 Ad1 Ad2 他们有 abc 三个方法\n\nAd1Component{\n  a(){};b(){};c(){};\n}\nAd2Component{\n  a(){};b(){};c(){};\n}\n\n那我们可以把方法抽离出一个 Basic 组件\nBasicComponent{\n  a(){};b(){};c(){};\n}\n\n然后写到 HOC 转换\nfunction wrapper(WrapperComponent){\n  return BasicComponent{\n    a(){};b(){};c(){};\n    render(){\n      return &lt;WrapperComponent /&gt;\n    }\n  }\n}\n*/\n\n// 写个例子\n// 在 input 组件的名字改变的时候加上一些日志的方法但是不能 input 组件上写（为什么会有这个需求？因为有可能这个组件不是你自己写的）\n/*\n想到一个方法用 prototype 但是会影响原型链\n function logProps(InputComponent) {\n    InputComponent.prototype.componentWillReceiveProps = function(nextProps, nextState) {\n      console.log(&#39;============&#39;)\n      console.log(&#39;Current props: &#39;, this.props);\n      console.log(&#39;Next props: &#39;, nextProps);\n    };\n    return InputComponent;\n}\n*/\n\n// 正确的方法应该是利用 HOC 封装方法\n\nclass InputComponent extends React.Component{\n    componentWillReceiveProps() {\n\n    }\n    render() {\n        return &lt;div&gt;{this.props.name}&lt;/div&gt;\n    }\n}\n\nfunction logProps(WrappedComponent) {\n    return class extends React.Component {  // 匿名组件，要实现的共有方法都在这里做\n      componentWillReceiveProps(nextProps) {    \n        console.log(&#39;Current props: &#39;, this.props);\n        console.log(&#39;Next props: &#39;, nextProps);\n      }\n      render() {\n        return &lt;WrappedComponent {...this.props} /&gt;;\n      }\n    }\n}\n\nconst EnhancedComponent = logProps(InputComponent);\n\n let name = &#39;dalao&#39;;\n setInterval(() =&gt; {\n    name += &#39; hah&#39;;\n    ReactDOM.render(&lt;EnhancedComponent name={name} /&gt;, document.getElementById(&#39;root&#39;));\n }, 1000)\n</code></pre><h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p><a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">Redux 官方文档</a></p>\n<p><a href=\"https://github.com/slashhuang/redux-annotation\" target=\"_blank\" rel=\"noopener\">https://github.com/slashhuang/redux-annotation</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/11/04/59fd9c6002509.jpg\" alt=\"\"></p>\n<h3 id=\"第一个简单的例子\"><a href=\"#第一个简单的例子\" class=\"headerlink\" title=\"第一个简单的例子\"></a>第一个简单的例子</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">Object.assign()</a></p>\n<pre><code>import { createStore } from &#39;redux&#39;\nconst initState = {}\nconst reducer = (state, action) =&gt; {\n    return action\n}\nconst store = createStore(reducer, initState)\nstore.dispatch({\n    type: &#39;init&#39;,\n    payload: &#39;hello world&#39;\n})\nconsole.log(store.getState())\n\n// redux 的整体架构\n// action (动作) ===&gt; 发起 AJAX\n// reducer (Handler处理器) ===&gt; JSON 处理\n// state (最后的状态) ===&gt; JSON 保存起来\n\n// 通常从后端拉数据的流程是这样的\n// AJAX ===&gt; JSON ===&gt; UI\n\n// 所以上面这个代码拆分开来就是\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {  // state 是前一次保存的数据状态\n      return Object.assign({}, state, action);  // 生成下一个数据状态\n}\nconst store = createStore(reducer, initState)\nstore.dispatch(action)\nconsole.log(store.getState())\n</code></pre><h3 id=\"createStore-源码\"><a href=\"#createStore-源码\" class=\"headerlink\" title=\"createStore 源码\"></a>createStore 源码</h3><pre><code>// 需要注意的是第一个参数和第二个参数（reducer, 初始化的 state）\nexport default function createStore(reducer, preloadedState, enhancer)\n\n/*\n判断...\n*/\n\nvar currentReducer = reducer;  // 当前的处理器\nvar currentState = preloadedState;   // 当前的state ===&gt; 初始化的 state\nvar currentListeners = []; \nvar nextListeners = currentListeners;\nvar isDispatching = false;  // 不执行\n\n/*\n往下看\n*/\n\nfunction getState() {\n    return currentState;  // 直接 return currentState\n}\n\n/*\n往下看\n*/\n\n  function dispatch(action) {\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);  \n      // 用当前的 reducer 处理当前的 state 和 action\n      // 只要 dispatch(action) 就会处理一遍生成一个 state\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i &lt; listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;  // 返回一个 action\n  }\n\n/*\n往下看\n*/\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n  // 最后也是返回出来\n</code></pre><h3 id=\"回看例子分析-createStore-源码\"><a href=\"#回看例子分析-createStore-源码\" class=\"headerlink\" title=\"回看例子分析 createStore 源码\"></a>回看例子分析 createStore 源码</h3><pre><code>import { createStore } from &#39;redux&#39;\nconst initState = {}\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {   // currentState = currentReducer(currentState, action);  \n      return Object.assign({}, state, action);  // 当前的数据状态\n}\ndebugger\nconst store = createStore(reducer, initState)  // reducer = (state, action) =&gt; {...}, initState = {}\ndebugger\nstore.dispatch(action)  // 所以 store 有 dispatch 方法\nconsole.log(store.getState())  // return currentState\n// Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}\n\n// debugger 看过程\n// var currentReducer = reducer;  // currentReducer = function reducer(state, action), reducer = function reducer(state, action)\n// var currentState = preloadedState;  // currentState = Object {}, preloadedState = Object {}\n\n/*\n跳到 dispatch return 一个 API 集合\n*/\n\n/*\n下一个 debugger\ncurrentState = currentReducer(currentState, action); 进去看一下\nreturn Object.assign({}, state, action);  做一个覆盖\ncurrentState 变成了 Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}\n*/\n\n/*\n看一下 console.log(store.getState())\nfunction getState() {\n    return currentState; // 返回 currentState\n}\n*/\n\n--------------------------------------------------------------------\n\n// 修改一下代码\nimport { createStore } from &#39;redux&#39;\nconst initState = {}\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {\n      return Object.assign({}, state, action);\n}\nconst store = createStore(reducer, initState)\ndebugger\nstore.subscribe(() =&gt; {\n      console.log(&#39;我注册啦&#39;)\n})\nstore.dispatch(action)\nconsole.log(store.getState())\n\n// store.subscribe 进去看看\n/*\n  function subscribe(listener) {\n\n    //...\n\n    nextListeners.push(listener);    // nextListeners 是一个长度为零的数组，把 listener push 进去\n    return function unsubscribe() {\n        // ...\n    };\n  }\n*/\n\n// store.dispatch(action) 进去看看\n/*\n  function dispatch(action) {\n    //...\n    // 这里会读当前的观察者数组\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i &lt; listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  ---------------------\n\n  在 console 打 listeners 会打印出 [function]\n  listeners[0] 是\n  function () {\n      console.log(&#39;我注册啦&#39;);\n  }\n*/\n\n/*\n需要注意的一点是\n  // When a store is created, an &quot;INIT&quot; action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT })\n  也就是说，每调用一遍 createStore 就会执行一遍 dispatch({ type: ActionTypes.INIT })\n  所以初始化的 action 是 type: &quot;@@redux/INIT&quot;\n*/\n</code></pre><h3 id=\"怎么改变-dom\"><a href=\"#怎么改变-dom\" class=\"headerlink\" title=\"怎么改变 dom\"></a>怎么改变 dom</h3><pre><code>// HTML\n    &lt;div id=&#39;root&#39;&gt;\n        1\n    &lt;/div&gt;\n// JS\nimport { createStore } from &#39;redux&#39;\nconst ROOTDOM = document.getElementById(&#39;root&#39;)\nconst initState = {}\nconst action = {\n      type: &#39;init&#39;,\n      payload: &#39;hello world&#39;,\n}\nconst reducer = (state, action) =&gt; {  \n      return Object.assign({}, state, action); \n}\nconst store = createStore(reducer, initState) \nstore.subscribe(() =&gt; {\n      ROOTDOM.innerHTML = JSON.stringify(store.getState())\n})\nlet counter = 0\nROOTDOM.addEventListener(&#39;click&#39;, () =&gt; {\n      counter++\n      const action = {\n          type: &#39;click&#39;,\n          payload: counter\n      }\n      store.dispatch(action)\n})\n</code></pre><h3 id=\"实现一个MVVM\"><a href=\"#实现一个MVVM\" class=\"headerlink\" title=\"实现一个MVVM\"></a>实现一个MVVM</h3><pre><code>// HTML\n&lt;input id=&quot;name&quot;/&gt;\n数据预览区\n&lt;div id=&quot;preview&quot;&gt;&lt;/div&gt;\n&lt;div id=&#39;root&#39;&gt;\n1\n&lt;/div&gt;\n// JS\nimport { createStore } from &#39;redux&#39;;\nconst initState = {};\nconst action = {\n    type: &#39;init&#39;,\n    payload: &#39;hello world&#39;,\n};\nconst reducer = (state, action) =&gt; {\n    return Object.assign({}, state, action);\n};\nconst store = createStore(reducer, initState);\nconst INPUTDOM = document.getElementById(&#39;name&#39;);\nconst PREVIEWDOM = document.getElementById(&#39;preview&#39;);\nconst digestUI = () =&gt; {\n    PREVIEWDOM.innerHTML = store.getState().payload;\n    if (PREVIEWDOM.innerHTML.length &gt; 20) {\n        alert(&#39;length is 20&#39;)\n    }\n};\nconst inputChange = () =&gt;{\n    let val = INPUTDOM.value;\n    const action = {\n        type: &#39;input_change&#39;,\n        payload: val,\n    };\n    store.dispatch(action);\n};\nlet counter = 0;\nINPUTDOM.addEventListener(&#39;input&#39;, inputChange)\nstore.subscribe(digestUI);\n\n// 可以看出好处就是行为都是分离的\n</code></pre><h3 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h3><pre><code>// redux中的applyMiddleware中间件\n// Middleware makes it easier for software developers\n// to implement 【communication and input/output】,\n// so they can focus on the 【specific purpose of their application】.\n// 更专注 service 服务 input/output service 输入和输出\n// ajax ==&gt; json(乱得一笔) =service转换(中间件)=&gt; UI(整理成好的)\n// express/Koa\n\n// 前端\n// ajax ==http==&gt;\n// httpRequest(head,cookie,body)\n// middlewares(解析cookie, 拿到post请求的数据)\n// 数据就是好的一笔的数据\n// 后端(node.js)\n\n// 看一个例子\n// 注意下面这些很多箭头的叫做高阶函数\n// 例如 const highFunction = a =&gt; b =&gt; c =&gt; console.log(a+b+c); highFunction(1)(2)(3) // 6 // 一个函数执行完之后返回值是一个函数\n// 多参函数 ===&gt; 单参函数\n\n// 如果在 createStore 用上 enhancer 逻辑就会被 applyMiddleware 控制\n// return enhancer(createStore)(reducer, preloadedState)\n\n// 前一个 next 指向下一个 action=&gt; { next(action) }; 最后一个 next 指向 dispatch \n\n// 没有中间件 action ==&gt; ==dispatch==&gt; reducer ==&gt; nextState;\n// 有中间件 action ==middlewares==&gt; ==dispatch==&gt; reducer ==&gt; nextState;\n\n// applyMiddleware 的思想是把一堆函数封装成一个函数\n\nimport { createStore, applyMiddleware } from &#39;redux&#39;;\nconst logger1 = store =&gt; next =&gt; action =&gt; {\n    console.log(&#39;current dipatch&#39; + JSON.stringify(action));\n    next(action);\n};\nconst logger2 = store =&gt; next =&gt; action=&gt; {\n    next(action);\n};\nconst logger3 = store =&gt; next =&gt; action=&gt; {\n    next(action);\n};\n\nconst enhancer = applyMiddleware(logger1, logger2, logger3);\nconst reducer = (state, action) =&gt; state;\nconst store = createStore(reducer, {}, enhancer);\nstore.dispatch({type:1});\nstore.dispatch({type:2});\nstore.dispatch({type:3});\n</code></pre><p>action 的另一种写法 <a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\" rel=\"noopener\">https://github.com/acdlite/flux-standard-action</a></p>\n<p><a href=\"https://stackoverflow.com/questions/32646920/whats-the-at-symbol-in-the-redux-connect-decorator\" target=\"_blank\" rel=\"noopener\">What’s the ‘@’ (at symbol) in the Redux @connect decorator?</a></p>\n<p><a href=\"http://taobaofed.org/blog/2016/08/18/react-redux-connect/\" target=\"_blank\" rel=\"noopener\">React 实践心得：react-redux 之 connect 方法详解</a></p>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><p><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ES6 教程</a></p>\n<p><a href=\"https://frankietang.github.io/2017/10/14/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/\" target=\"_blank\" rel=\"noopener\">摸到 ES6 的门把手</a></p>\n<p>Stage 0 - Strawman（展示阶段）</p>\n<ul>\n<li>Stage 1 - Proposal（征求意见阶段）</li>\n<li>Stage 2 - Draft（草案阶段）</li>\n<li>Stage 3 - Candidate（候选人阶段）</li>\n<li>Stage 4 - Finished（定案阶段）</li>\n</ul>\n<p>配 babel 的时候有用 </p>\n<h3 id=\"Set-和-Map-的数据结构\"><a href=\"#Set-和-Map-的数据结构\" class=\"headerlink\" title=\"Set 和 Map 的数据结构\"></a>Set 和 Map 的数据结构</h3><p><a href=\"https://github.com/ruanyf/es6tutorial/blob/2ac6e76b38f117f2acf6c465ab70709275b4241a/docs/set-map.md\" target=\"_blank\" rel=\"noopener\">set-map</a></p>\n<pre><code>// 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。\nlet s = new Set()\ns.size // 0\ns.add(1) // {1}\ns.size // 1\ns.add(1) // {1}\ns.size // 1\ns.add(&#39;1&#39;) // {1,&#39;1&#39;}\ns.size // 2\n\n// 如何快速去除数组里的重复元素\n[...new Set([1,2,3,4,5,4,3,2,1])]  // (5) [1, 2, 3, 4, 5]\n</code></pre><h3 id=\"Decorators\"><a href=\"#Decorators\" class=\"headerlink\" title=\"Decorators\"></a>Decorators</h3><pre><code>// 对类做一个封装\n// 懂了，大概就是在 class 上面绑定方法可以直接调用\n\nfunction divide(target){\n  target.prototype.divide = function(a,b) {return a/b}\n  return target\n}\n\n@divide\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n\n// 再封装多一个判断\n\nfunction divide(needAdd){\n  return function(target){\n    if(needAdd){\n      target.prototype.divide = function(a,b) {return a/b}\n    }\n  }\n  return target\n}\n\n@divide(true)\nclass Math{\n  add(a,b){\n    return a+b\n  }\n}\n\nlet m = new Math()\nconsole.log(m.divide(6,3)) // 2\n</code></pre><h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">webpack 官方文档</a></p>\n<h3 id=\"webpack-与-react\"><a href=\"#webpack-与-react\" class=\"headerlink\" title=\"webpack 与 react\"></a>webpack 与 react</h3><pre><code>// 主要是配 loaders\n{\n    test: /\\.js[x]?$/,        // 符合 js 或者 jsx\n    loader: &quot;babel-loader&quot;,   // 运行 babel-loader\n    exclude: /node_modules/\n},\n</code></pre><p>说实话 webpack 这东西翻翻文档就好，不用死记硬背的。要什么功能直接 Google ，<code>npm i -D &lt;package&gt;</code></p>\n<p><a href=\"https://juejin.im/post/59bb37fa6fb9a00a554f89d2\" target=\"_blank\" rel=\"noopener\">webpack：从入门到真实项目配置</a></p>\n<h2 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h2><p><a href=\"http://babeljs.io/\" target=\"_blank\" rel=\"noopener\">babel 官方文档</a></p>\n<h3 id=\"babel-1\"><a href=\"#babel-1\" class=\"headerlink\" title=\"babel\"></a>babel</h3><pre><code>// 因为 react 用的是 JSX 所以需要用到 babel\n// 不止 JSX 还有高阶组件(HOC) 要用到 es7 的 Decorator\n// 把这一堆代码转换成 JS\n// 以下是配法 \n{\n  &quot;presets&quot;: [\n     &quot;stage-0&quot;, // 草案 0\n     &quot;es2015&quot;,  // es6\n     &quot;react&quot;    // react\n  ],\n   &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]  // 翻译 Decorator\n}\n</code></pre>"},{"title":"补基础： node 各种知识点","date":"2017-11-29T10:56:54.000Z","_content":"# 补基础：node 各种知识点\n\n简单带过所有开发环境\n\nNVM:nvm是一个node.js版本管理器，我们将会使用nvm安装node.js的不同版本\n[NVM安装指南](https://github.com/creationix/nvm#installation)\n\nNode.js和npm: [Node.js官方文档](https://nodejs.org/dist/latest-v8.x/docs/api/) | [Node.js 教程| 菜鸟教程](https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwieh52Cgd_XAhUKrI8KHT9NBAoQFggmMAA&url=http%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-tutorial.html&usg=AOvVaw2jflp9kjA1IHdV5QL7UYRB)\n\nGit: [Git 教程| 菜鸟教程](https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjD3buFgd_XAhUJvo8KHem-BIIQFggmMAA&url=http%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html&usg=AOvVaw2SlbSmAVE814KUmXI236qx)\n\nMongoDB：MongoDB是时下最流行的NoSQL数据库，[MongoDB官网](https://www.mongodb.com/) | [官方文档](https://docs.mongodb.com/manual/introduction/)\n\n[Ubuntu下安装MongoDB官方文档](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/)\n\nRedis:运用最广的K-V数据库之一。在Ubuntu下使用 `sudo apt-get install redis-server` [官网](https://redis.io/)\n\n## HTTP\n\n[HTTP - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)\n\n[HTTP](https://blog.zain.red/2017/11/23/http/)\n\n[关于HTTP协议，一篇就够了](http://www.jianshu.com/p/80e25cb1d81a)\n\n## Git 和 Linux\n\n看我的旧文章 [Linux 的基本命令行和 Git 的基本操作](http://www.jianshu.com/p/82142a85df5d)\n\n## Node\n\n写一个脚本文件 show.js，满足以下需求：运行 node /path/to/show.js，输出当前目录下的所有文件。\n\n```\ntouch show.js\nvi show.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar fs = require(\"fs\")\nconsole.log(\"查看当前目录\")\nfs.readdir(process.cwd(),function(error, files){\n  if(error){\n    return console.error(error)\n  }\n  files.forEach(function(file){\n    console.log(file)\n  })\n})\n\nnode show.js\n```\n\n写一个脚本文件 view.js，满足以下需求：运行 node /path/to/view.js xxx，如果 xxx 文件存在，就输出 xxx 内容；如果 xxx 文件不存在，就输出「xxx 不存在」\n\n```\ntouch view.js\nvi view.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar file = process.argv[2]  // 获取输入命令行第三个参数\nvar fs = require('fs')\nfs.stat(file, function(error, stat){\n  if(stat&&stat.isFile()) {\n    console.log('文件存在')\n    var data = fs.readFileSync(file, \"utf-8\")  // 读取文件内容\n    console.log(data)\n  } else {\n    console.log('文件不存在或不是标准文件')\n  }\n})\n\nnode view.js show.js\n```\n\n## npm\n\n把上面那两个代码上传\n\n```\nnpm adduser  // 一顿操作\nls\nnpm init  // 一顿起名\n/*\n在 package.json 设置东西\n\"bin\":{\n  \"view\":\"view.js\",\n  \"show\":\"show.js\"\n}\n*/\nnpm publish\n\nnpm i -g frankie-demo-2017-11-19\n/*\n新加了两行\n/usr/local/bin/show -> /usr/local/lib/node_modules/frankie-demo-2017-11-19/show.js\n/usr/local/bin/view -> /usr/local/lib/node_modules/frankie-demo-2017-11-19/view.js\n*/\n// 然后就可以全局使用 show 和 view 了\n\nnpm uninstall -g frankie-demo-2017-11-19  // 卸载掉 demo\n```\n\nhttps://www.npmjs.com/package/frankie-demo-2017-11-19","source":"_posts/补基础：node 各种知识点.md","raw":"---\ntitle: 补基础： node 各种知识点\ndate: 2017-11-29 18:56:54\ntags: [Node,HTTP]\n---\n# 补基础：node 各种知识点\n\n简单带过所有开发环境\n\nNVM:nvm是一个node.js版本管理器，我们将会使用nvm安装node.js的不同版本\n[NVM安装指南](https://github.com/creationix/nvm#installation)\n\nNode.js和npm: [Node.js官方文档](https://nodejs.org/dist/latest-v8.x/docs/api/) | [Node.js 教程| 菜鸟教程](https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwieh52Cgd_XAhUKrI8KHT9NBAoQFggmMAA&url=http%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-tutorial.html&usg=AOvVaw2jflp9kjA1IHdV5QL7UYRB)\n\nGit: [Git 教程| 菜鸟教程](https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjD3buFgd_XAhUJvo8KHem-BIIQFggmMAA&url=http%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html&usg=AOvVaw2SlbSmAVE814KUmXI236qx)\n\nMongoDB：MongoDB是时下最流行的NoSQL数据库，[MongoDB官网](https://www.mongodb.com/) | [官方文档](https://docs.mongodb.com/manual/introduction/)\n\n[Ubuntu下安装MongoDB官方文档](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/)\n\nRedis:运用最广的K-V数据库之一。在Ubuntu下使用 `sudo apt-get install redis-server` [官网](https://redis.io/)\n\n## HTTP\n\n[HTTP - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP)\n\n[HTTP](https://blog.zain.red/2017/11/23/http/)\n\n[关于HTTP协议，一篇就够了](http://www.jianshu.com/p/80e25cb1d81a)\n\n## Git 和 Linux\n\n看我的旧文章 [Linux 的基本命令行和 Git 的基本操作](http://www.jianshu.com/p/82142a85df5d)\n\n## Node\n\n写一个脚本文件 show.js，满足以下需求：运行 node /path/to/show.js，输出当前目录下的所有文件。\n\n```\ntouch show.js\nvi show.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar fs = require(\"fs\")\nconsole.log(\"查看当前目录\")\nfs.readdir(process.cwd(),function(error, files){\n  if(error){\n    return console.error(error)\n  }\n  files.forEach(function(file){\n    console.log(file)\n  })\n})\n\nnode show.js\n```\n\n写一个脚本文件 view.js，满足以下需求：运行 node /path/to/view.js xxx，如果 xxx 文件存在，就输出 xxx 内容；如果 xxx 文件不存在，就输出「xxx 不存在」\n\n```\ntouch view.js\nvi view.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar file = process.argv[2]  // 获取输入命令行第三个参数\nvar fs = require('fs')\nfs.stat(file, function(error, stat){\n  if(stat&&stat.isFile()) {\n    console.log('文件存在')\n    var data = fs.readFileSync(file, \"utf-8\")  // 读取文件内容\n    console.log(data)\n  } else {\n    console.log('文件不存在或不是标准文件')\n  }\n})\n\nnode view.js show.js\n```\n\n## npm\n\n把上面那两个代码上传\n\n```\nnpm adduser  // 一顿操作\nls\nnpm init  // 一顿起名\n/*\n在 package.json 设置东西\n\"bin\":{\n  \"view\":\"view.js\",\n  \"show\":\"show.js\"\n}\n*/\nnpm publish\n\nnpm i -g frankie-demo-2017-11-19\n/*\n新加了两行\n/usr/local/bin/show -> /usr/local/lib/node_modules/frankie-demo-2017-11-19/show.js\n/usr/local/bin/view -> /usr/local/lib/node_modules/frankie-demo-2017-11-19/view.js\n*/\n// 然后就可以全局使用 show 和 view 了\n\nnpm uninstall -g frankie-demo-2017-11-19  // 卸载掉 demo\n```\n\nhttps://www.npmjs.com/package/frankie-demo-2017-11-19","slug":"补基础：node 各种知识点","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d9b001ff1xhaz5bxs3o","content":"<h1 id=\"补基础：node-各种知识点\"><a href=\"#补基础：node-各种知识点\" class=\"headerlink\" title=\"补基础：node 各种知识点\"></a>补基础：node 各种知识点</h1><p>简单带过所有开发环境</p>\n<p>NVM:nvm是一个node.js版本管理器，我们将会使用nvm安装node.js的不同版本<br><a href=\"https://github.com/creationix/nvm#installation\" target=\"_blank\" rel=\"noopener\">NVM安装指南</a></p>\n<p>Node.js和npm: <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/\" target=\"_blank\" rel=\"noopener\">Node.js官方文档</a> | <a href=\"https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwieh52Cgd_XAhUKrI8KHT9NBAoQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-tutorial.html&amp;usg=AOvVaw2jflp9kjA1IHdV5QL7UYRB\" target=\"_blank\" rel=\"noopener\">Node.js 教程| 菜鸟教程</a></p>\n<p>Git: <a href=\"https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjD3buFgd_XAhUJvo8KHem-BIIQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html&amp;usg=AOvVaw2SlbSmAVE814KUmXI236qx\" target=\"_blank\" rel=\"noopener\">Git 教程| 菜鸟教程</a></p>\n<p>MongoDB：MongoDB是时下最流行的NoSQL数据库，<a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener\">MongoDB官网</a> | <a href=\"https://docs.mongodb.com/manual/introduction/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p><a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/\" target=\"_blank\" rel=\"noopener\">Ubuntu下安装MongoDB官方文档</a></p>\n<p>Redis:运用最广的K-V数据库之一。在Ubuntu下使用 <code>sudo apt-get install redis-server</code> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP\" target=\"_blank\" rel=\"noopener\">HTTP - MDN</a></p>\n<p><a href=\"https://blog.zain.red/2017/11/23/http/\" target=\"_blank\" rel=\"noopener\">HTTP</a></p>\n<p><a href=\"http://www.jianshu.com/p/80e25cb1d81a\" target=\"_blank\" rel=\"noopener\">关于HTTP协议，一篇就够了</a></p>\n<h2 id=\"Git-和-Linux\"><a href=\"#Git-和-Linux\" class=\"headerlink\" title=\"Git 和 Linux\"></a>Git 和 Linux</h2><p>看我的旧文章 <a href=\"http://www.jianshu.com/p/82142a85df5d\" target=\"_blank\" rel=\"noopener\">Linux 的基本命令行和 Git 的基本操作</a></p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><p>写一个脚本文件 show.js，满足以下需求：运行 node /path/to/show.js，输出当前目录下的所有文件。</p>\n<pre><code>touch show.js\nvi show.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar fs = require(&quot;fs&quot;)\nconsole.log(&quot;查看当前目录&quot;)\nfs.readdir(process.cwd(),function(error, files){\n  if(error){\n    return console.error(error)\n  }\n  files.forEach(function(file){\n    console.log(file)\n  })\n})\n\nnode show.js\n</code></pre><p>写一个脚本文件 view.js，满足以下需求：运行 node /path/to/view.js xxx，如果 xxx 文件存在，就输出 xxx 内容；如果 xxx 文件不存在，就输出「xxx 不存在」</p>\n<pre><code>touch view.js\nvi view.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar file = process.argv[2]  // 获取输入命令行第三个参数\nvar fs = require(&#39;fs&#39;)\nfs.stat(file, function(error, stat){\n  if(stat&amp;&amp;stat.isFile()) {\n    console.log(&#39;文件存在&#39;)\n    var data = fs.readFileSync(file, &quot;utf-8&quot;)  // 读取文件内容\n    console.log(data)\n  } else {\n    console.log(&#39;文件不存在或不是标准文件&#39;)\n  }\n})\n\nnode view.js show.js\n</code></pre><h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><p>把上面那两个代码上传</p>\n<pre><code>npm adduser  // 一顿操作\nls\nnpm init  // 一顿起名\n/*\n在 package.json 设置东西\n&quot;bin&quot;:{\n  &quot;view&quot;:&quot;view.js&quot;,\n  &quot;show&quot;:&quot;show.js&quot;\n}\n*/\nnpm publish\n\nnpm i -g frankie-demo-2017-11-19\n/*\n新加了两行\n/usr/local/bin/show -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/show.js\n/usr/local/bin/view -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/view.js\n*/\n// 然后就可以全局使用 show 和 view 了\n\nnpm uninstall -g frankie-demo-2017-11-19  // 卸载掉 demo\n</code></pre><p><a href=\"https://www.npmjs.com/package/frankie-demo-2017-11-19\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/frankie-demo-2017-11-19</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：node-各种知识点\"><a href=\"#补基础：node-各种知识点\" class=\"headerlink\" title=\"补基础：node 各种知识点\"></a>补基础：node 各种知识点</h1><p>简单带过所有开发环境</p>\n<p>NVM:nvm是一个node.js版本管理器，我们将会使用nvm安装node.js的不同版本<br><a href=\"https://github.com/creationix/nvm#installation\" target=\"_blank\" rel=\"noopener\">NVM安装指南</a></p>\n<p>Node.js和npm: <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/\" target=\"_blank\" rel=\"noopener\">Node.js官方文档</a> | <a href=\"https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwieh52Cgd_XAhUKrI8KHT9NBAoQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-tutorial.html&amp;usg=AOvVaw2jflp9kjA1IHdV5QL7UYRB\" target=\"_blank\" rel=\"noopener\">Node.js 教程| 菜鸟教程</a></p>\n<p>Git: <a href=\"https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjD3buFgd_XAhUJvo8KHem-BIIQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html&amp;usg=AOvVaw2SlbSmAVE814KUmXI236qx\" target=\"_blank\" rel=\"noopener\">Git 教程| 菜鸟教程</a></p>\n<p>MongoDB：MongoDB是时下最流行的NoSQL数据库，<a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener\">MongoDB官网</a> | <a href=\"https://docs.mongodb.com/manual/introduction/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p><a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/\" target=\"_blank\" rel=\"noopener\">Ubuntu下安装MongoDB官方文档</a></p>\n<p>Redis:运用最广的K-V数据库之一。在Ubuntu下使用 <code>sudo apt-get install redis-server</code> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP\" target=\"_blank\" rel=\"noopener\">HTTP - MDN</a></p>\n<p><a href=\"https://blog.zain.red/2017/11/23/http/\" target=\"_blank\" rel=\"noopener\">HTTP</a></p>\n<p><a href=\"http://www.jianshu.com/p/80e25cb1d81a\" target=\"_blank\" rel=\"noopener\">关于HTTP协议，一篇就够了</a></p>\n<h2 id=\"Git-和-Linux\"><a href=\"#Git-和-Linux\" class=\"headerlink\" title=\"Git 和 Linux\"></a>Git 和 Linux</h2><p>看我的旧文章 <a href=\"http://www.jianshu.com/p/82142a85df5d\" target=\"_blank\" rel=\"noopener\">Linux 的基本命令行和 Git 的基本操作</a></p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><p>写一个脚本文件 show.js，满足以下需求：运行 node /path/to/show.js，输出当前目录下的所有文件。</p>\n<pre><code>touch show.js\nvi show.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar fs = require(&quot;fs&quot;)\nconsole.log(&quot;查看当前目录&quot;)\nfs.readdir(process.cwd(),function(error, files){\n  if(error){\n    return console.error(error)\n  }\n  files.forEach(function(file){\n    console.log(file)\n  })\n})\n\nnode show.js\n</code></pre><p>写一个脚本文件 view.js，满足以下需求：运行 node /path/to/view.js xxx，如果 xxx 文件存在，就输出 xxx 内容；如果 xxx 文件不存在，就输出「xxx 不存在」</p>\n<pre><code>touch view.js\nvi view.js\n\n#!/usr/bin/env node  // 告诉 bash 用 node 运行\nvar file = process.argv[2]  // 获取输入命令行第三个参数\nvar fs = require(&#39;fs&#39;)\nfs.stat(file, function(error, stat){\n  if(stat&amp;&amp;stat.isFile()) {\n    console.log(&#39;文件存在&#39;)\n    var data = fs.readFileSync(file, &quot;utf-8&quot;)  // 读取文件内容\n    console.log(data)\n  } else {\n    console.log(&#39;文件不存在或不是标准文件&#39;)\n  }\n})\n\nnode view.js show.js\n</code></pre><h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><p>把上面那两个代码上传</p>\n<pre><code>npm adduser  // 一顿操作\nls\nnpm init  // 一顿起名\n/*\n在 package.json 设置东西\n&quot;bin&quot;:{\n  &quot;view&quot;:&quot;view.js&quot;,\n  &quot;show&quot;:&quot;show.js&quot;\n}\n*/\nnpm publish\n\nnpm i -g frankie-demo-2017-11-19\n/*\n新加了两行\n/usr/local/bin/show -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/show.js\n/usr/local/bin/view -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/view.js\n*/\n// 然后就可以全局使用 show 和 view 了\n\nnpm uninstall -g frankie-demo-2017-11-19  // 卸载掉 demo\n</code></pre><p><a href=\"https://www.npmjs.com/package/frankie-demo-2017-11-19\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/frankie-demo-2017-11-19</a></p>\n"},{"title":"补基础：this","date":"2017-10-19T13:23:13.000Z","_content":"# 补基础：this\n\n> [this 的值到底是什么？一次说清楚](https://zhuanlan.zhihu.com/p/23804247?refer=study-fe)\n>\n> [你怎么还没搞懂 this？](https://zhuanlan.zhihu.com/p/25991271)\n>\n> this的值是在函数调用的时候决定，而不是定义的时候决定\n\n##  this 的四种绑定规则\n\n```\n// 默认绑定\nwindow.a = 3;\nfunction f() {\n    let a = 4;\n    console.log(this.a);\n}\n\nf(); // 3\n// 通过上面的文章我们得出其实是 f().call(undefined) 默认为 global\n```\n\n```\n// 隐式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nlet obj1 = {\n    a: 4,\n    obj: {\n        a: 5,\n        f: function() {\n            console.log(this.a);\n        }\n    }\n};\n\nobj.f() // obj.f.call(obj) 所以是 4\nobj1.obj.f(); // obj1.obj.f.call(obj1.obj) 是 5\n\nlet f = obj1.obj.f;\nf(); // f.call(undefined) 是 3\n```\n\n```\n// 显式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nobj.f.call({a: 6}); // 6\nlet f = obj.f;\nf.call({a: 5}); // 5\n```\n\n```\n// new绑定\nfunction Person(age) {\n    this.age = age;\n}\n\nlet mike = Person(12); // Person.call(12) 如果在全局作用域写一个 12 那就会有 12 ,但是 mike.age 还是 undefined\nconsole.log(mike.age); // undefined\n\n// 所以应该这样写\n// let mike = new Person(12)\n// 关于 new 这个方法，我在原型链实现过，内部应该会有一个 call() 的用法来调用 this\n```\n\n## forEach 方法\n\n```\nArray.prototype._forEach = function(fn) {\n\t// 实现一个 forEach 方法\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn(it, i, this); // 看这里，调用的时候是这样的 fn.call(it,i,this) fn 没有绑定任何的上下文，所以是全局变量\n    }\n};\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n    \t// console.log(this) 这里其实会打印出 global 属性, 原因看上面\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    });\n}\n\nlet mike = new Person(12);\n// 3 year later I'm 15 year old\n// 5 year later I'm 17 year old\n// 10 year later I'm 22 year old\n```\n\n所以真正实现方法是：\n\n```\n// 实际上原生的 forEach 可以传两个参数，一个是 callback ，还有一个其实是 this，所以其实 forEach 他本来就考虑到这种情况，所以可以直接传一个 this 进去\nArray.prototype._forEach = function(fn, ctx) {\n\t// 实现一个 forEach 方法\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn.call(ctx || this, it, i, this); // 所以可以这样实现\n    }\n};\n\n/*\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    }, this);\n}\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    }.bind(this)); // bind(this) 会绑定成上下文的 this\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    let that = this\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I'm ${that.age + it} year old`);\n    });  // 使 this 变成一个普通的变量，其实和 bind(this) 是一样的套路\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach((it) => {\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    }); // \n}\n*/\n\nlet mike = new Person(12);\n// 3 year later I'm 15 year old\n// 5 year later I'm 17 year old\n// 10 year later I'm 22 year old\n```\n\n```\n// 这里说一下箭头函数的 this\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n\nfunction Person(age) {\n    [3,5,10]._forEach((it) => {\n        console.log(this);\n    });\n}\n\nPerson.call({a: 'a'}); // 绑定了 call 值 输出 => {a: 'a'}\nPerson(); // Person 的 this 输出 => global\nlet obj = {\n  b: 1,\n  f: Person\n}\n\nobj.f(); // 绑定了 obj 所以是 { b: 1, [Function: Person] }\n```\n\n这里说一个很可能会出现的 bug ，在 `this.age = age` 这里如果不加分号会出现 bug ，变成了 `this.age = age[3,4,5]._forEach()` `age[3,4,5]` 返回是一个 `undefined`\n\n## bind 方法\n\n```\n// 先看 _bind 的 this 值是什么\n/*\nFunction.prototype._bind = function(ctx) {\n\tconsole.log(this)\n};\n\nfunction Person(age) {\n    this.age = age;\n\t(function(){})._bind(this)\n\tconsole.log(this)\n}\n\nlet mike = new Person(12);\n// Function 因为上下文的关系\n// Person { age: 12 } \n*/\n\nFunction.prototype._bind = function(ctx) {\n\t// 实现一个 bind 方法\n\t// return fn\n\t// 注意不能用箭头函数，因为箭头函数没有 arguments\n\tlet that = this\n\tlet args = Array.prototype.slice.call(arguments, 1) // [1,3]\n\treturn function() {\n\t\tlet args2 = Array.prototype.slice.call(arguments) // [4,5]\n      \tlet all = args.concat(args2); \n        return that.apply(ctx, all);\n\t}\n};\n\n/*\nFunction.prototype._bind = function(ctx) {\n\t// 如果要用箭头函数，用 ... 取剩余的值\n\tlet args = Array.prototype.slice.call(arguments, 1)\n\treturn (...args2) {\n\t\tconsole.log(args2)\n      \tlet all = args.concat(args2); \n      \tcosole.log(all)\n        return that.apply(ctx, all);\n\t}\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10].forEach(function(it){\n        console.log(`${it} yeas later I'm ${this.age + it} yeas old`);\n    }._bind(this, 1, 2));\n    // let fn = function(it) {\n    // }._bind(this, 1, 3);\n    // fn(4,5)\n    // 所以用了 _bind() 方法后就是等于 fn(this, 1, 3, 4, 5)\n    // let fn = function(it) {\n    // }\n    // let fn2 = fn._bind(this, 1, 2)\n    // fn2(4, 5, 6, 7, 8)\n    // 相当于 fn(1, 2, 4, 5, 6, 7, 8)\n}\n\nlet mike = new Person(12);\n```\n\n如何摊平数组?\n\n```\n// 正常来说 数组 push 一个数组那就是数组内嵌数组\nlet arr = [1,2]\narr.push([3,4])\narr // [1, 2, [3, 4]]\narr.concat([3, 4]) // [1, 2, [3, 4], 3, 4]\narr.push.apply(arr, [5, 6]) // [1, 2, [3, 4], 3, 4, 5, 6]\n```\n\n","source":"_posts/补基础：this.md","raw":"---\ntitle: 补基础：this\ndate: 2017-10-19 21:23:13\ntags: [JavaScript]\n---\n# 补基础：this\n\n> [this 的值到底是什么？一次说清楚](https://zhuanlan.zhihu.com/p/23804247?refer=study-fe)\n>\n> [你怎么还没搞懂 this？](https://zhuanlan.zhihu.com/p/25991271)\n>\n> this的值是在函数调用的时候决定，而不是定义的时候决定\n\n##  this 的四种绑定规则\n\n```\n// 默认绑定\nwindow.a = 3;\nfunction f() {\n    let a = 4;\n    console.log(this.a);\n}\n\nf(); // 3\n// 通过上面的文章我们得出其实是 f().call(undefined) 默认为 global\n```\n\n```\n// 隐式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nlet obj1 = {\n    a: 4,\n    obj: {\n        a: 5,\n        f: function() {\n            console.log(this.a);\n        }\n    }\n};\n\nobj.f() // obj.f.call(obj) 所以是 4\nobj1.obj.f(); // obj1.obj.f.call(obj1.obj) 是 5\n\nlet f = obj1.obj.f;\nf(); // f.call(undefined) 是 3\n```\n\n```\n// 显式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nobj.f.call({a: 6}); // 6\nlet f = obj.f;\nf.call({a: 5}); // 5\n```\n\n```\n// new绑定\nfunction Person(age) {\n    this.age = age;\n}\n\nlet mike = Person(12); // Person.call(12) 如果在全局作用域写一个 12 那就会有 12 ,但是 mike.age 还是 undefined\nconsole.log(mike.age); // undefined\n\n// 所以应该这样写\n// let mike = new Person(12)\n// 关于 new 这个方法，我在原型链实现过，内部应该会有一个 call() 的用法来调用 this\n```\n\n## forEach 方法\n\n```\nArray.prototype._forEach = function(fn) {\n\t// 实现一个 forEach 方法\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn(it, i, this); // 看这里，调用的时候是这样的 fn.call(it,i,this) fn 没有绑定任何的上下文，所以是全局变量\n    }\n};\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n    \t// console.log(this) 这里其实会打印出 global 属性, 原因看上面\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    });\n}\n\nlet mike = new Person(12);\n// 3 year later I'm 15 year old\n// 5 year later I'm 17 year old\n// 10 year later I'm 22 year old\n```\n\n所以真正实现方法是：\n\n```\n// 实际上原生的 forEach 可以传两个参数，一个是 callback ，还有一个其实是 this，所以其实 forEach 他本来就考虑到这种情况，所以可以直接传一个 this 进去\nArray.prototype._forEach = function(fn, ctx) {\n\t// 实现一个 forEach 方法\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn.call(ctx || this, it, i, this); // 所以可以这样实现\n    }\n};\n\n/*\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    }, this);\n}\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    }.bind(this)); // bind(this) 会绑定成上下文的 this\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    let that = this\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I'm ${that.age + it} year old`);\n    });  // 使 this 变成一个普通的变量，其实和 bind(this) 是一样的套路\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach((it) => {\n        console.log(`${it} year later I'm ${this.age + it} year old`);\n    }); // \n}\n*/\n\nlet mike = new Person(12);\n// 3 year later I'm 15 year old\n// 5 year later I'm 17 year old\n// 10 year later I'm 22 year old\n```\n\n```\n// 这里说一下箭头函数的 this\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i < this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n\nfunction Person(age) {\n    [3,5,10]._forEach((it) => {\n        console.log(this);\n    });\n}\n\nPerson.call({a: 'a'}); // 绑定了 call 值 输出 => {a: 'a'}\nPerson(); // Person 的 this 输出 => global\nlet obj = {\n  b: 1,\n  f: Person\n}\n\nobj.f(); // 绑定了 obj 所以是 { b: 1, [Function: Person] }\n```\n\n这里说一个很可能会出现的 bug ，在 `this.age = age` 这里如果不加分号会出现 bug ，变成了 `this.age = age[3,4,5]._forEach()` `age[3,4,5]` 返回是一个 `undefined`\n\n## bind 方法\n\n```\n// 先看 _bind 的 this 值是什么\n/*\nFunction.prototype._bind = function(ctx) {\n\tconsole.log(this)\n};\n\nfunction Person(age) {\n    this.age = age;\n\t(function(){})._bind(this)\n\tconsole.log(this)\n}\n\nlet mike = new Person(12);\n// Function 因为上下文的关系\n// Person { age: 12 } \n*/\n\nFunction.prototype._bind = function(ctx) {\n\t// 实现一个 bind 方法\n\t// return fn\n\t// 注意不能用箭头函数，因为箭头函数没有 arguments\n\tlet that = this\n\tlet args = Array.prototype.slice.call(arguments, 1) // [1,3]\n\treturn function() {\n\t\tlet args2 = Array.prototype.slice.call(arguments) // [4,5]\n      \tlet all = args.concat(args2); \n        return that.apply(ctx, all);\n\t}\n};\n\n/*\nFunction.prototype._bind = function(ctx) {\n\t// 如果要用箭头函数，用 ... 取剩余的值\n\tlet args = Array.prototype.slice.call(arguments, 1)\n\treturn (...args2) {\n\t\tconsole.log(args2)\n      \tlet all = args.concat(args2); \n      \tcosole.log(all)\n        return that.apply(ctx, all);\n\t}\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10].forEach(function(it){\n        console.log(`${it} yeas later I'm ${this.age + it} yeas old`);\n    }._bind(this, 1, 2));\n    // let fn = function(it) {\n    // }._bind(this, 1, 3);\n    // fn(4,5)\n    // 所以用了 _bind() 方法后就是等于 fn(this, 1, 3, 4, 5)\n    // let fn = function(it) {\n    // }\n    // let fn2 = fn._bind(this, 1, 2)\n    // fn2(4, 5, 6, 7, 8)\n    // 相当于 fn(1, 2, 4, 5, 6, 7, 8)\n}\n\nlet mike = new Person(12);\n```\n\n如何摊平数组?\n\n```\n// 正常来说 数组 push 一个数组那就是数组内嵌数组\nlet arr = [1,2]\narr.push([3,4])\narr // [1, 2, [3, 4]]\narr.concat([3, 4]) // [1, 2, [3, 4], 3, 4]\narr.push.apply(arr, [5, 6]) // [1, 2, [3, 4], 3, 4, 5, 6]\n```\n\n","slug":"补基础：this","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d9c001hf1xhbyobvsru","content":"<h1 id=\"补基础：this\"><a href=\"#补基础：this\" class=\"headerlink\" title=\"补基础：this\"></a>补基础：this</h1><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/23804247?refer=study-fe\" target=\"_blank\" rel=\"noopener\">this 的值到底是什么？一次说清楚</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/25991271\" target=\"_blank\" rel=\"noopener\">你怎么还没搞懂 this？</a></p>\n<p>this的值是在函数调用的时候决定，而不是定义的时候决定</p>\n</blockquote>\n<h2 id=\"this-的四种绑定规则\"><a href=\"#this-的四种绑定规则\" class=\"headerlink\" title=\"this 的四种绑定规则\"></a>this 的四种绑定规则</h2><pre><code>// 默认绑定\nwindow.a = 3;\nfunction f() {\n    let a = 4;\n    console.log(this.a);\n}\n\nf(); // 3\n// 通过上面的文章我们得出其实是 f().call(undefined) 默认为 global\n</code></pre><pre><code>// 隐式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nlet obj1 = {\n    a: 4,\n    obj: {\n        a: 5,\n        f: function() {\n            console.log(this.a);\n        }\n    }\n};\n\nobj.f() // obj.f.call(obj) 所以是 4\nobj1.obj.f(); // obj1.obj.f.call(obj1.obj) 是 5\n\nlet f = obj1.obj.f;\nf(); // f.call(undefined) 是 3\n</code></pre><pre><code>// 显式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nobj.f.call({a: 6}); // 6\nlet f = obj.f;\nf.call({a: 5}); // 5\n</code></pre><pre><code>// new绑定\nfunction Person(age) {\n    this.age = age;\n}\n\nlet mike = Person(12); // Person.call(12) 如果在全局作用域写一个 12 那就会有 12 ,但是 mike.age 还是 undefined\nconsole.log(mike.age); // undefined\n\n// 所以应该这样写\n// let mike = new Person(12)\n// 关于 new 这个方法，我在原型链实现过，内部应该会有一个 call() 的用法来调用 this\n</code></pre><h2 id=\"forEach-方法\"><a href=\"#forEach-方法\" class=\"headerlink\" title=\"forEach 方法\"></a>forEach 方法</h2><pre><code>Array.prototype._forEach = function(fn) {\n    // 实现一个 forEach 方法\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn(it, i, this); // 看这里，调用的时候是这样的 fn.call(it,i,this) fn 没有绑定任何的上下文，所以是全局变量\n    }\n};\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        // console.log(this) 这里其实会打印出 global 属性, 原因看上面\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    });\n}\n\nlet mike = new Person(12);\n// 3 year later I&#39;m 15 year old\n// 5 year later I&#39;m 17 year old\n// 10 year later I&#39;m 22 year old\n</code></pre><p>所以真正实现方法是：</p>\n<pre><code>// 实际上原生的 forEach 可以传两个参数，一个是 callback ，还有一个其实是 this，所以其实 forEach 他本来就考虑到这种情况，所以可以直接传一个 this 进去\nArray.prototype._forEach = function(fn, ctx) {\n    // 实现一个 forEach 方法\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn.call(ctx || this, it, i, this); // 所以可以这样实现\n    }\n};\n\n/*\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    }, this);\n}\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    }.bind(this)); // bind(this) 会绑定成上下文的 this\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    let that = this\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I&#39;m ${that.age + it} year old`);\n    });  // 使 this 变成一个普通的变量，其实和 bind(this) 是一样的套路\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach((it) =&gt; {\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    }); // \n}\n*/\n\nlet mike = new Person(12);\n// 3 year later I&#39;m 15 year old\n// 5 year later I&#39;m 17 year old\n// 10 year later I&#39;m 22 year old\n</code></pre><pre><code>// 这里说一下箭头函数的 this\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n\nfunction Person(age) {\n    [3,5,10]._forEach((it) =&gt; {\n        console.log(this);\n    });\n}\n\nPerson.call({a: &#39;a&#39;}); // 绑定了 call 值 输出 =&gt; {a: &#39;a&#39;}\nPerson(); // Person 的 this 输出 =&gt; global\nlet obj = {\n  b: 1,\n  f: Person\n}\n\nobj.f(); // 绑定了 obj 所以是 { b: 1, [Function: Person] }\n</code></pre><p>这里说一个很可能会出现的 bug ，在 <code>this.age = age</code> 这里如果不加分号会出现 bug ，变成了 <code>this.age = age[3,4,5]._forEach()</code> <code>age[3,4,5]</code> 返回是一个 <code>undefined</code></p>\n<h2 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h2><pre><code>// 先看 _bind 的 this 值是什么\n/*\nFunction.prototype._bind = function(ctx) {\n    console.log(this)\n};\n\nfunction Person(age) {\n    this.age = age;\n    (function(){})._bind(this)\n    console.log(this)\n}\n\nlet mike = new Person(12);\n// Function 因为上下文的关系\n// Person { age: 12 } \n*/\n\nFunction.prototype._bind = function(ctx) {\n    // 实现一个 bind 方法\n    // return fn\n    // 注意不能用箭头函数，因为箭头函数没有 arguments\n    let that = this\n    let args = Array.prototype.slice.call(arguments, 1) // [1,3]\n    return function() {\n        let args2 = Array.prototype.slice.call(arguments) // [4,5]\n          let all = args.concat(args2); \n        return that.apply(ctx, all);\n    }\n};\n\n/*\nFunction.prototype._bind = function(ctx) {\n    // 如果要用箭头函数，用 ... 取剩余的值\n    let args = Array.prototype.slice.call(arguments, 1)\n    return (...args2) {\n        console.log(args2)\n          let all = args.concat(args2); \n          cosole.log(all)\n        return that.apply(ctx, all);\n    }\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10].forEach(function(it){\n        console.log(`${it} yeas later I&#39;m ${this.age + it} yeas old`);\n    }._bind(this, 1, 2));\n    // let fn = function(it) {\n    // }._bind(this, 1, 3);\n    // fn(4,5)\n    // 所以用了 _bind() 方法后就是等于 fn(this, 1, 3, 4, 5)\n    // let fn = function(it) {\n    // }\n    // let fn2 = fn._bind(this, 1, 2)\n    // fn2(4, 5, 6, 7, 8)\n    // 相当于 fn(1, 2, 4, 5, 6, 7, 8)\n}\n\nlet mike = new Person(12);\n</code></pre><p>如何摊平数组?</p>\n<pre><code>// 正常来说 数组 push 一个数组那就是数组内嵌数组\nlet arr = [1,2]\narr.push([3,4])\narr // [1, 2, [3, 4]]\narr.concat([3, 4]) // [1, 2, [3, 4], 3, 4]\narr.push.apply(arr, [5, 6]) // [1, 2, [3, 4], 3, 4, 5, 6]\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：this\"><a href=\"#补基础：this\" class=\"headerlink\" title=\"补基础：this\"></a>补基础：this</h1><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/23804247?refer=study-fe\" target=\"_blank\" rel=\"noopener\">this 的值到底是什么？一次说清楚</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/25991271\" target=\"_blank\" rel=\"noopener\">你怎么还没搞懂 this？</a></p>\n<p>this的值是在函数调用的时候决定，而不是定义的时候决定</p>\n</blockquote>\n<h2 id=\"this-的四种绑定规则\"><a href=\"#this-的四种绑定规则\" class=\"headerlink\" title=\"this 的四种绑定规则\"></a>this 的四种绑定规则</h2><pre><code>// 默认绑定\nwindow.a = 3;\nfunction f() {\n    let a = 4;\n    console.log(this.a);\n}\n\nf(); // 3\n// 通过上面的文章我们得出其实是 f().call(undefined) 默认为 global\n</code></pre><pre><code>// 隐式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nlet obj1 = {\n    a: 4,\n    obj: {\n        a: 5,\n        f: function() {\n            console.log(this.a);\n        }\n    }\n};\n\nobj.f() // obj.f.call(obj) 所以是 4\nobj1.obj.f(); // obj1.obj.f.call(obj1.obj) 是 5\n\nlet f = obj1.obj.f;\nf(); // f.call(undefined) 是 3\n</code></pre><pre><code>// 显式绑定\nwindow.a = 3;\nlet obj = {\n    a: 4,\n    f: function() {\n        console.log(this.a);\n    }\n};\n\nobj.f.call({a: 6}); // 6\nlet f = obj.f;\nf.call({a: 5}); // 5\n</code></pre><pre><code>// new绑定\nfunction Person(age) {\n    this.age = age;\n}\n\nlet mike = Person(12); // Person.call(12) 如果在全局作用域写一个 12 那就会有 12 ,但是 mike.age 还是 undefined\nconsole.log(mike.age); // undefined\n\n// 所以应该这样写\n// let mike = new Person(12)\n// 关于 new 这个方法，我在原型链实现过，内部应该会有一个 call() 的用法来调用 this\n</code></pre><h2 id=\"forEach-方法\"><a href=\"#forEach-方法\" class=\"headerlink\" title=\"forEach 方法\"></a>forEach 方法</h2><pre><code>Array.prototype._forEach = function(fn) {\n    // 实现一个 forEach 方法\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn(it, i, this); // 看这里，调用的时候是这样的 fn.call(it,i,this) fn 没有绑定任何的上下文，所以是全局变量\n    }\n};\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        // console.log(this) 这里其实会打印出 global 属性, 原因看上面\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    });\n}\n\nlet mike = new Person(12);\n// 3 year later I&#39;m 15 year old\n// 5 year later I&#39;m 17 year old\n// 10 year later I&#39;m 22 year old\n</code></pre><p>所以真正实现方法是：</p>\n<pre><code>// 实际上原生的 forEach 可以传两个参数，一个是 callback ，还有一个其实是 this，所以其实 forEach 他本来就考虑到这种情况，所以可以直接传一个 this 进去\nArray.prototype._forEach = function(fn, ctx) {\n    // 实现一个 forEach 方法\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn.call(ctx || this, it, i, this); // 所以可以这样实现\n    }\n};\n\n/*\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    }, this);\n}\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    }.bind(this)); // bind(this) 会绑定成上下文的 this\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    let that = this\n    [3,5,10]._forEach(function(it){\n        console.log(`${it} year later I&#39;m ${that.age + it} year old`);\n    });  // 使 this 变成一个普通的变量，其实和 bind(this) 是一样的套路\n}\n*/\n\n/*\nfunction Person(age) {\n    this.age = age;\n    [3,5,10]._forEach((it) =&gt; {\n        console.log(`${it} year later I&#39;m ${this.age + it} year old`);\n    }); // \n}\n*/\n\nlet mike = new Person(12);\n// 3 year later I&#39;m 15 year old\n// 5 year later I&#39;m 17 year old\n// 10 year later I&#39;m 22 year old\n</code></pre><pre><code>// 这里说一下箭头函数的 this\nArray.prototype._forEach = function(fn) {\n    for(let i = 0; i &lt; this.length; i++) {\n        let it = this[i];\n        fn(it, i, this);\n    }\n};\n\nfunction Person(age) {\n    [3,5,10]._forEach((it) =&gt; {\n        console.log(this);\n    });\n}\n\nPerson.call({a: &#39;a&#39;}); // 绑定了 call 值 输出 =&gt; {a: &#39;a&#39;}\nPerson(); // Person 的 this 输出 =&gt; global\nlet obj = {\n  b: 1,\n  f: Person\n}\n\nobj.f(); // 绑定了 obj 所以是 { b: 1, [Function: Person] }\n</code></pre><p>这里说一个很可能会出现的 bug ，在 <code>this.age = age</code> 这里如果不加分号会出现 bug ，变成了 <code>this.age = age[3,4,5]._forEach()</code> <code>age[3,4,5]</code> 返回是一个 <code>undefined</code></p>\n<h2 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h2><pre><code>// 先看 _bind 的 this 值是什么\n/*\nFunction.prototype._bind = function(ctx) {\n    console.log(this)\n};\n\nfunction Person(age) {\n    this.age = age;\n    (function(){})._bind(this)\n    console.log(this)\n}\n\nlet mike = new Person(12);\n// Function 因为上下文的关系\n// Person { age: 12 } \n*/\n\nFunction.prototype._bind = function(ctx) {\n    // 实现一个 bind 方法\n    // return fn\n    // 注意不能用箭头函数，因为箭头函数没有 arguments\n    let that = this\n    let args = Array.prototype.slice.call(arguments, 1) // [1,3]\n    return function() {\n        let args2 = Array.prototype.slice.call(arguments) // [4,5]\n          let all = args.concat(args2); \n        return that.apply(ctx, all);\n    }\n};\n\n/*\nFunction.prototype._bind = function(ctx) {\n    // 如果要用箭头函数，用 ... 取剩余的值\n    let args = Array.prototype.slice.call(arguments, 1)\n    return (...args2) {\n        console.log(args2)\n          let all = args.concat(args2); \n          cosole.log(all)\n        return that.apply(ctx, all);\n    }\n};\n*/\n\nfunction Person(age) {\n    this.age = age;\n    [3,5,10].forEach(function(it){\n        console.log(`${it} yeas later I&#39;m ${this.age + it} yeas old`);\n    }._bind(this, 1, 2));\n    // let fn = function(it) {\n    // }._bind(this, 1, 3);\n    // fn(4,5)\n    // 所以用了 _bind() 方法后就是等于 fn(this, 1, 3, 4, 5)\n    // let fn = function(it) {\n    // }\n    // let fn2 = fn._bind(this, 1, 2)\n    // fn2(4, 5, 6, 7, 8)\n    // 相当于 fn(1, 2, 4, 5, 6, 7, 8)\n}\n\nlet mike = new Person(12);\n</code></pre><p>如何摊平数组?</p>\n<pre><code>// 正常来说 数组 push 一个数组那就是数组内嵌数组\nlet arr = [1,2]\narr.push([3,4])\narr // [1, 2, [3, 4]]\narr.concat([3, 4]) // [1, 2, [3, 4], 3, 4]\narr.push.apply(arr, [5, 6]) // [1, 2, [3, 4], 3, 4, 5, 6]\n</code></pre>"},{"title":"补基础：事件","date":"2017-11-19T05:43:09.000Z","_content":"# 补基础：事件\n\n什么情况下会用到事件？\n\n- DOM 操作\n- 服务器的事件操作\n\n## [node events](https://nodejs.org/api/events.html)\n\n[emitter.on(eventName, listener)](https://nodejs.org/api/events.html#events_emitter_on_eventname_listener) [emitter.emit(eventName[, ...args])](https://nodejs.org/api/events.html#events_emitter_emit_eventname_args)\n\n```\n// example.js\nconst EventEmitter = require('events');  // 这是 node 的一个内置模块，给 node 提供一个事件功能\nconst emitter = new EventEmitter();\n\nemitter.on('iEvent', (...args) => {  // 这里这个 on 相当于 addEventListener\n  console.log(`an event occurred! with response ${arg}`)\n})\n\nemitter.emit('iEvent', 'a', 'b')  // 用 emit 触发事件\n\n// node example.js\n// an event occurred! with response a,b\n```\n\n[emitter.eventNames()](https://nodejs.org/api/events.html#events_emitter_eventnames) [emitter.listenerCount(eventName)](https://nodejs.org/api/events.html#events_emitter_listenercount_eventname)\n\n```\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nemitter.on('iEvent', (...args) => {  // 1\n  console.log(`an event occurred! with response ${arg}`)\n});\n\nemitter.on('iEvent', () => {  // 2\n  console.log(`another event occurred!`);\n})\n\nemitter.on('newEvent', () => {\n  console.log(`another event occurred!`);\n})\n\nemitter.emit('iEvent', 'a', 'b');  //  同时触发 1 和 2\n\nlet eNames = emitter.eventNames();\nconsole.log(eName);  // ['iEvent', 'newEvent']  // 返回所有注册实例的名称\n\nlet iEventListenerCount = emitter.listenerCount('iEvent');\nconsole.log(iEventListenerCount);  // 2  // 绑定了多少个 handler \n```\n\n[emitter.removeListener(eventName, listener)](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener)\n\n```\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nemitter.on('iEvent', (...args) => {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nlet handler = function() {\n  console.log(`handler`);\n}\nemitter.on('iEvent', handler);  // an event occurred! with response a,b   handler // 加一个 handler\n\nemitter.removeListener('iEvent', handler);  // an event occurred! with response a,b\n\n/* 这样做不会 remove handler \nemitter.removeListener('iEvent', function() {\n  console.log(`handler`)  // an event occurred! with response a,b   handler\n})\n*/\n\nemitter.emit('iEvent', 'a', 'b');\n```\n\n[emitter.once(eventName, listener)](https://nodejs.org/api/events.html#events_emitter_once_eventname_listener)\n\n```\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\n/* 这样会打印两次\nemitter.on('iEvent', (...args) => {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nemitter.emit('iEvent', 'a', 'b');  // an event occurred! with response a,b\nemitter.emit('iEvent', 'a', 'b');  // an event occurred! with response a,b\n*/\n\nemitter.once('onceEvent', (...args) => {\n  console.log(`an event occurred! with response ${args}`);\n})\n\nemitter.emit('iEvent', 'a', 'b');\nemitter.emit('iEvent', 'a', 'b');\n// 只会触发一次\n// an event occurred! with response a,b\n```\n\n## 实现一个 Event\n\n### on 和 emit\n\n```\n// on 可以想象成是一个订阅事件\n// emit 可以想象成一个发布事件\n// sub/pub(subscribe/publish)\n\nfunction Event() {\n    // todo...\n    this.eventToHandlers = {}  // 设置一个空对象\n}\n// todo...\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);  // 如果已经有 callback 了就继续添加\n    } else {\n        this.eventToHandlers[eventName] = [callback];  // 没有的话就让 eventToHandlers[name] 变为 callback\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];  // 解决变量名字是 undefined 的问题\n    for (let fn of handlers) {  // 遍历 eventName 下面的数组\n        fn(...args)\n    }\n}\n\n\nlet emitter = new Event();\n\nlet handler1 = (...args) => {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on('iEvent', handler1)\nemitter.emit('iEvent', 'a', 'b')\n\nlet handler2 = () => { console.log(`another handler2`); };\nlet handler3 = () => { console.log(`another handler3`); };\nemitter.on('iEvent2', handler2)\nemitter.on('iEvent2', handler3)\nemitter.emit('iEvent2', 'c', 'd')\n  \n// an event occurred! with response a,b\n// another handler2\n// another handler3\n\n// 保存的数据结构的格式最好是\n/*\n{\n  \"iEvent\": [handler1]\n  \"iEvent2\": [handler2, handler3]\n}\n*/\n```\n\n### eventNames 和 listenerCount\n\n```\nfunction Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现 eventNames 和 listenerCount\nEvent.prototype.eventNames = function () {\n    // return array\n    return Object.keys(this.eventToHandlers);\n}\n\nEvent.prototype.listenerCount = function (eventNames) {\n    // return number\n    // return (this.eventToHandlers[eventNames] || []).length  // 如果 this.eventToHandlers[eventNames] 没有就会取一个空数组\n    return this.eventToHandlers[eventNames] ? this.eventToHandlers[eventNames].length : 0;\n}\n\nlet emitter = new Event();\n\nlet handler1 = (...args) => {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on('iEvent', handler1)\nemitter.emit('iEvent', 'a', 'b')\n\nlet handler2 = () => { console.log(`another handler2`); };\nlet handler3 = () => { console.log(`another handler3`); };\nemitter.on('iEvent2', handler2)\nemitter.on('iEvent2', handler3)\nemitter.emit('iEvent2', 'c', 'd')\n\nconsole.log(emitter.eventNames());  // ['iEvent', 'iEvent2']\nconsole.log(emitter.listenerCount('iEvent2'));  // 2\nconsole.log(emitter.listenerCount('abc'));  // 做一个处理 0\n```\n\n### removeListener\n\n```\nfunction Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现一个 removeListener\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index > -1) {\n        handlers.splice(index, 1)\n    }\n}\n\nlet emitter = new Event();\n\nlet handler2 = () => { console.log(`another handler2`); };\nlet handler3 = () => { console.log(`another handler3`); };\nemitter.on('iEvent2', handler2)\nemitter.on('iEvent2', handler3)\nemitter.removeListener('iEvent2', handler3)\nemitter.emit('iEvent2', 'c', 'd')\n\n// another handler2\n```\n\n### once\n\n```\nfunction Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index > -1) {\n        handlers.splice(index, 1)\n    }\n}\n\n// 实现一个 once\nEvent.prototype.once = function (eventName, callback) {\n    // 触发之后删除掉\n    let handler = (...args) => {\n        callback(...args)\n        this.removeListener(eventName, handler)\n    }\n    this.on(eventName, handler)\n}\n\nlet emitter = new Event();\n\n\nlet handler4 = () => { console.log(`another handler4`); }\nemitter.once('iEvent4', handler4)\nemitter.emit('iEvent4')  // another handler4\nemitter.emit('iEvent4')  // 不打印 \n```\n\n","source":"_posts/补基础：事件.md","raw":"---\ntitle: 补基础：事件\ndate: 2017-11-19 13:43:09\ntags: [JavaScript]\n---\n# 补基础：事件\n\n什么情况下会用到事件？\n\n- DOM 操作\n- 服务器的事件操作\n\n## [node events](https://nodejs.org/api/events.html)\n\n[emitter.on(eventName, listener)](https://nodejs.org/api/events.html#events_emitter_on_eventname_listener) [emitter.emit(eventName[, ...args])](https://nodejs.org/api/events.html#events_emitter_emit_eventname_args)\n\n```\n// example.js\nconst EventEmitter = require('events');  // 这是 node 的一个内置模块，给 node 提供一个事件功能\nconst emitter = new EventEmitter();\n\nemitter.on('iEvent', (...args) => {  // 这里这个 on 相当于 addEventListener\n  console.log(`an event occurred! with response ${arg}`)\n})\n\nemitter.emit('iEvent', 'a', 'b')  // 用 emit 触发事件\n\n// node example.js\n// an event occurred! with response a,b\n```\n\n[emitter.eventNames()](https://nodejs.org/api/events.html#events_emitter_eventnames) [emitter.listenerCount(eventName)](https://nodejs.org/api/events.html#events_emitter_listenercount_eventname)\n\n```\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nemitter.on('iEvent', (...args) => {  // 1\n  console.log(`an event occurred! with response ${arg}`)\n});\n\nemitter.on('iEvent', () => {  // 2\n  console.log(`another event occurred!`);\n})\n\nemitter.on('newEvent', () => {\n  console.log(`another event occurred!`);\n})\n\nemitter.emit('iEvent', 'a', 'b');  //  同时触发 1 和 2\n\nlet eNames = emitter.eventNames();\nconsole.log(eName);  // ['iEvent', 'newEvent']  // 返回所有注册实例的名称\n\nlet iEventListenerCount = emitter.listenerCount('iEvent');\nconsole.log(iEventListenerCount);  // 2  // 绑定了多少个 handler \n```\n\n[emitter.removeListener(eventName, listener)](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener)\n\n```\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nemitter.on('iEvent', (...args) => {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nlet handler = function() {\n  console.log(`handler`);\n}\nemitter.on('iEvent', handler);  // an event occurred! with response a,b   handler // 加一个 handler\n\nemitter.removeListener('iEvent', handler);  // an event occurred! with response a,b\n\n/* 这样做不会 remove handler \nemitter.removeListener('iEvent', function() {\n  console.log(`handler`)  // an event occurred! with response a,b   handler\n})\n*/\n\nemitter.emit('iEvent', 'a', 'b');\n```\n\n[emitter.once(eventName, listener)](https://nodejs.org/api/events.html#events_emitter_once_eventname_listener)\n\n```\nconst EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\n/* 这样会打印两次\nemitter.on('iEvent', (...args) => {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nemitter.emit('iEvent', 'a', 'b');  // an event occurred! with response a,b\nemitter.emit('iEvent', 'a', 'b');  // an event occurred! with response a,b\n*/\n\nemitter.once('onceEvent', (...args) => {\n  console.log(`an event occurred! with response ${args}`);\n})\n\nemitter.emit('iEvent', 'a', 'b');\nemitter.emit('iEvent', 'a', 'b');\n// 只会触发一次\n// an event occurred! with response a,b\n```\n\n## 实现一个 Event\n\n### on 和 emit\n\n```\n// on 可以想象成是一个订阅事件\n// emit 可以想象成一个发布事件\n// sub/pub(subscribe/publish)\n\nfunction Event() {\n    // todo...\n    this.eventToHandlers = {}  // 设置一个空对象\n}\n// todo...\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);  // 如果已经有 callback 了就继续添加\n    } else {\n        this.eventToHandlers[eventName] = [callback];  // 没有的话就让 eventToHandlers[name] 变为 callback\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];  // 解决变量名字是 undefined 的问题\n    for (let fn of handlers) {  // 遍历 eventName 下面的数组\n        fn(...args)\n    }\n}\n\n\nlet emitter = new Event();\n\nlet handler1 = (...args) => {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on('iEvent', handler1)\nemitter.emit('iEvent', 'a', 'b')\n\nlet handler2 = () => { console.log(`another handler2`); };\nlet handler3 = () => { console.log(`another handler3`); };\nemitter.on('iEvent2', handler2)\nemitter.on('iEvent2', handler3)\nemitter.emit('iEvent2', 'c', 'd')\n  \n// an event occurred! with response a,b\n// another handler2\n// another handler3\n\n// 保存的数据结构的格式最好是\n/*\n{\n  \"iEvent\": [handler1]\n  \"iEvent2\": [handler2, handler3]\n}\n*/\n```\n\n### eventNames 和 listenerCount\n\n```\nfunction Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现 eventNames 和 listenerCount\nEvent.prototype.eventNames = function () {\n    // return array\n    return Object.keys(this.eventToHandlers);\n}\n\nEvent.prototype.listenerCount = function (eventNames) {\n    // return number\n    // return (this.eventToHandlers[eventNames] || []).length  // 如果 this.eventToHandlers[eventNames] 没有就会取一个空数组\n    return this.eventToHandlers[eventNames] ? this.eventToHandlers[eventNames].length : 0;\n}\n\nlet emitter = new Event();\n\nlet handler1 = (...args) => {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on('iEvent', handler1)\nemitter.emit('iEvent', 'a', 'b')\n\nlet handler2 = () => { console.log(`another handler2`); };\nlet handler3 = () => { console.log(`another handler3`); };\nemitter.on('iEvent2', handler2)\nemitter.on('iEvent2', handler3)\nemitter.emit('iEvent2', 'c', 'd')\n\nconsole.log(emitter.eventNames());  // ['iEvent', 'iEvent2']\nconsole.log(emitter.listenerCount('iEvent2'));  // 2\nconsole.log(emitter.listenerCount('abc'));  // 做一个处理 0\n```\n\n### removeListener\n\n```\nfunction Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现一个 removeListener\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index > -1) {\n        handlers.splice(index, 1)\n    }\n}\n\nlet emitter = new Event();\n\nlet handler2 = () => { console.log(`another handler2`); };\nlet handler3 = () => { console.log(`another handler3`); };\nemitter.on('iEvent2', handler2)\nemitter.on('iEvent2', handler3)\nemitter.removeListener('iEvent2', handler3)\nemitter.emit('iEvent2', 'c', 'd')\n\n// another handler2\n```\n\n### once\n\n```\nfunction Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index > -1) {\n        handlers.splice(index, 1)\n    }\n}\n\n// 实现一个 once\nEvent.prototype.once = function (eventName, callback) {\n    // 触发之后删除掉\n    let handler = (...args) => {\n        callback(...args)\n        this.removeListener(eventName, handler)\n    }\n    this.on(eventName, handler)\n}\n\nlet emitter = new Event();\n\n\nlet handler4 = () => { console.log(`another handler4`); }\nemitter.once('iEvent4', handler4)\nemitter.emit('iEvent4')  // another handler4\nemitter.emit('iEvent4')  // 不打印 \n```\n\n","slug":"补基础：事件","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d9d001kf1xhp00pb137","content":"<h1 id=\"补基础：事件\"><a href=\"#补基础：事件\" class=\"headerlink\" title=\"补基础：事件\"></a>补基础：事件</h1><p>什么情况下会用到事件？</p>\n<ul>\n<li>DOM 操作</li>\n<li>服务器的事件操作</li>\n</ul>\n<h2 id=\"node-events\"><a href=\"#node-events\" class=\"headerlink\" title=\"node events\"></a><a href=\"https://nodejs.org/api/events.html\" target=\"_blank\" rel=\"noopener\">node events</a></h2><p><a href=\"https://nodejs.org/api/events.html#events_emitter_on_eventname_listener\" target=\"_blank\" rel=\"noopener\">emitter.on(eventName, listener)</a> <a href=\"https://nodejs.org/api/events.html#events_emitter_emit_eventname_args\" target=\"_blank\" rel=\"noopener\">emitter.emit(eventName[, …args])</a></p>\n<pre><code>// example.js\nconst EventEmitter = require(&#39;events&#39;);  // 这是 node 的一个内置模块，给 node 提供一个事件功能\nconst emitter = new EventEmitter();\n\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 这里这个 on 相当于 addEventListener\n  console.log(`an event occurred! with response ${arg}`)\n})\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)  // 用 emit 触发事件\n\n// node example.js\n// an event occurred! with response a,b\n</code></pre><p><a href=\"https://nodejs.org/api/events.html#events_emitter_eventnames\" target=\"_blank\" rel=\"noopener\">emitter.eventNames()</a> <a href=\"https://nodejs.org/api/events.html#events_emitter_listenercount_eventname\" target=\"_blank\" rel=\"noopener\">emitter.listenerCount(eventName)</a></p>\n<pre><code>const EventEmitter = require(&#39;events&#39;);\nconst emitter = new EventEmitter();\n\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 1\n  console.log(`an event occurred! with response ${arg}`)\n});\n\nemitter.on(&#39;iEvent&#39;, () =&gt; {  // 2\n  console.log(`another event occurred!`);\n})\n\nemitter.on(&#39;newEvent&#39;, () =&gt; {\n  console.log(`another event occurred!`);\n})\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  //  同时触发 1 和 2\n\nlet eNames = emitter.eventNames();\nconsole.log(eName);  // [&#39;iEvent&#39;, &#39;newEvent&#39;]  // 返回所有注册实例的名称\n\nlet iEventListenerCount = emitter.listenerCount(&#39;iEvent&#39;);\nconsole.log(iEventListenerCount);  // 2  // 绑定了多少个 handler\n</code></pre><p><a href=\"https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener\" target=\"_blank\" rel=\"noopener\">emitter.removeListener(eventName, listener)</a></p>\n<pre><code>const EventEmitter = require(&#39;events&#39;);\nconst emitter = new EventEmitter();\n\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nlet handler = function() {\n  console.log(`handler`);\n}\nemitter.on(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b   handler // 加一个 handler\n\nemitter.removeListener(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b\n\n/* 这样做不会 remove handler \nemitter.removeListener(&#39;iEvent&#39;, function() {\n  console.log(`handler`)  // an event occurred! with response a,b   handler\n})\n*/\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);\n</code></pre><p><a href=\"https://nodejs.org/api/events.html#events_emitter_once_eventname_listener\" target=\"_blank\" rel=\"noopener\">emitter.once(eventName, listener)</a></p>\n<pre><code>const EventEmitter = require(&#39;events&#39;);\nconst emitter = new EventEmitter();\n\n/* 这样会打印两次\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,b\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,b\n*/\n\nemitter.once(&#39;onceEvent&#39;, (...args) =&gt; {\n  console.log(`an event occurred! with response ${args}`);\n})\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);\n// 只会触发一次\n// an event occurred! with response a,b\n</code></pre><h2 id=\"实现一个-Event\"><a href=\"#实现一个-Event\" class=\"headerlink\" title=\"实现一个 Event\"></a>实现一个 Event</h2><h3 id=\"on-和-emit\"><a href=\"#on-和-emit\" class=\"headerlink\" title=\"on 和 emit\"></a>on 和 emit</h3><pre><code>// on 可以想象成是一个订阅事件\n// emit 可以想象成一个发布事件\n// sub/pub(subscribe/publish)\n\nfunction Event() {\n    // todo...\n    this.eventToHandlers = {}  // 设置一个空对象\n}\n// todo...\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);  // 如果已经有 callback 了就继续添加\n    } else {\n        this.eventToHandlers[eventName] = [callback];  // 没有的话就让 eventToHandlers[name] 变为 callback\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];  // 解决变量名字是 undefined 的问题\n    for (let fn of handlers) {  // 遍历 eventName 下面的数组\n        fn(...args)\n    }\n}\n\n\nlet emitter = new Event();\n\nlet handler1 = (...args) =&gt; {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on(&#39;iEvent&#39;, handler1)\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)\n\nlet handler2 = () =&gt; { console.log(`another handler2`); };\nlet handler3 = () =&gt; { console.log(`another handler3`); };\nemitter.on(&#39;iEvent2&#39;, handler2)\nemitter.on(&#39;iEvent2&#39;, handler3)\nemitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)\n\n// an event occurred! with response a,b\n// another handler2\n// another handler3\n\n// 保存的数据结构的格式最好是\n/*\n{\n  &quot;iEvent&quot;: [handler1]\n  &quot;iEvent2&quot;: [handler2, handler3]\n}\n*/\n</code></pre><h3 id=\"eventNames-和-listenerCount\"><a href=\"#eventNames-和-listenerCount\" class=\"headerlink\" title=\"eventNames 和 listenerCount\"></a>eventNames 和 listenerCount</h3><pre><code>function Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现 eventNames 和 listenerCount\nEvent.prototype.eventNames = function () {\n    // return array\n    return Object.keys(this.eventToHandlers);\n}\n\nEvent.prototype.listenerCount = function (eventNames) {\n    // return number\n    // return (this.eventToHandlers[eventNames] || []).length  // 如果 this.eventToHandlers[eventNames] 没有就会取一个空数组\n    return this.eventToHandlers[eventNames] ? this.eventToHandlers[eventNames].length : 0;\n}\n\nlet emitter = new Event();\n\nlet handler1 = (...args) =&gt; {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on(&#39;iEvent&#39;, handler1)\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)\n\nlet handler2 = () =&gt; { console.log(`another handler2`); };\nlet handler3 = () =&gt; { console.log(`another handler3`); };\nemitter.on(&#39;iEvent2&#39;, handler2)\nemitter.on(&#39;iEvent2&#39;, handler3)\nemitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)\n\nconsole.log(emitter.eventNames());  // [&#39;iEvent&#39;, &#39;iEvent2&#39;]\nconsole.log(emitter.listenerCount(&#39;iEvent2&#39;));  // 2\nconsole.log(emitter.listenerCount(&#39;abc&#39;));  // 做一个处理 0\n</code></pre><h3 id=\"removeListener\"><a href=\"#removeListener\" class=\"headerlink\" title=\"removeListener\"></a>removeListener</h3><pre><code>function Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现一个 removeListener\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index &gt; -1) {\n        handlers.splice(index, 1)\n    }\n}\n\nlet emitter = new Event();\n\nlet handler2 = () =&gt; { console.log(`another handler2`); };\nlet handler3 = () =&gt; { console.log(`another handler3`); };\nemitter.on(&#39;iEvent2&#39;, handler2)\nemitter.on(&#39;iEvent2&#39;, handler3)\nemitter.removeListener(&#39;iEvent2&#39;, handler3)\nemitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)\n\n// another handler2\n</code></pre><h3 id=\"once\"><a href=\"#once\" class=\"headerlink\" title=\"once\"></a>once</h3><pre><code>function Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index &gt; -1) {\n        handlers.splice(index, 1)\n    }\n}\n\n// 实现一个 once\nEvent.prototype.once = function (eventName, callback) {\n    // 触发之后删除掉\n    let handler = (...args) =&gt; {\n        callback(...args)\n        this.removeListener(eventName, handler)\n    }\n    this.on(eventName, handler)\n}\n\nlet emitter = new Event();\n\n\nlet handler4 = () =&gt; { console.log(`another handler4`); }\nemitter.once(&#39;iEvent4&#39;, handler4)\nemitter.emit(&#39;iEvent4&#39;)  // another handler4\nemitter.emit(&#39;iEvent4&#39;)  // 不打印\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：事件\"><a href=\"#补基础：事件\" class=\"headerlink\" title=\"补基础：事件\"></a>补基础：事件</h1><p>什么情况下会用到事件？</p>\n<ul>\n<li>DOM 操作</li>\n<li>服务器的事件操作</li>\n</ul>\n<h2 id=\"node-events\"><a href=\"#node-events\" class=\"headerlink\" title=\"node events\"></a><a href=\"https://nodejs.org/api/events.html\" target=\"_blank\" rel=\"noopener\">node events</a></h2><p><a href=\"https://nodejs.org/api/events.html#events_emitter_on_eventname_listener\" target=\"_blank\" rel=\"noopener\">emitter.on(eventName, listener)</a> <a href=\"https://nodejs.org/api/events.html#events_emitter_emit_eventname_args\" target=\"_blank\" rel=\"noopener\">emitter.emit(eventName[, …args])</a></p>\n<pre><code>// example.js\nconst EventEmitter = require(&#39;events&#39;);  // 这是 node 的一个内置模块，给 node 提供一个事件功能\nconst emitter = new EventEmitter();\n\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 这里这个 on 相当于 addEventListener\n  console.log(`an event occurred! with response ${arg}`)\n})\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)  // 用 emit 触发事件\n\n// node example.js\n// an event occurred! with response a,b\n</code></pre><p><a href=\"https://nodejs.org/api/events.html#events_emitter_eventnames\" target=\"_blank\" rel=\"noopener\">emitter.eventNames()</a> <a href=\"https://nodejs.org/api/events.html#events_emitter_listenercount_eventname\" target=\"_blank\" rel=\"noopener\">emitter.listenerCount(eventName)</a></p>\n<pre><code>const EventEmitter = require(&#39;events&#39;);\nconst emitter = new EventEmitter();\n\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 1\n  console.log(`an event occurred! with response ${arg}`)\n});\n\nemitter.on(&#39;iEvent&#39;, () =&gt; {  // 2\n  console.log(`another event occurred!`);\n})\n\nemitter.on(&#39;newEvent&#39;, () =&gt; {\n  console.log(`another event occurred!`);\n})\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  //  同时触发 1 和 2\n\nlet eNames = emitter.eventNames();\nconsole.log(eName);  // [&#39;iEvent&#39;, &#39;newEvent&#39;]  // 返回所有注册实例的名称\n\nlet iEventListenerCount = emitter.listenerCount(&#39;iEvent&#39;);\nconsole.log(iEventListenerCount);  // 2  // 绑定了多少个 handler\n</code></pre><p><a href=\"https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener\" target=\"_blank\" rel=\"noopener\">emitter.removeListener(eventName, listener)</a></p>\n<pre><code>const EventEmitter = require(&#39;events&#39;);\nconst emitter = new EventEmitter();\n\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nlet handler = function() {\n  console.log(`handler`);\n}\nemitter.on(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b   handler // 加一个 handler\n\nemitter.removeListener(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b\n\n/* 这样做不会 remove handler \nemitter.removeListener(&#39;iEvent&#39;, function() {\n  console.log(`handler`)  // an event occurred! with response a,b   handler\n})\n*/\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);\n</code></pre><p><a href=\"https://nodejs.org/api/events.html#events_emitter_once_eventname_listener\" target=\"_blank\" rel=\"noopener\">emitter.once(eventName, listener)</a></p>\n<pre><code>const EventEmitter = require(&#39;events&#39;);\nconst emitter = new EventEmitter();\n\n/* 这样会打印两次\nemitter.on(&#39;iEvent&#39;, (...args) =&gt; {\n  console.log(`an event occurred! with response ${args}`);\n});\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,b\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,b\n*/\n\nemitter.once(&#39;onceEvent&#39;, (...args) =&gt; {\n  console.log(`an event occurred! with response ${args}`);\n})\n\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);\n// 只会触发一次\n// an event occurred! with response a,b\n</code></pre><h2 id=\"实现一个-Event\"><a href=\"#实现一个-Event\" class=\"headerlink\" title=\"实现一个 Event\"></a>实现一个 Event</h2><h3 id=\"on-和-emit\"><a href=\"#on-和-emit\" class=\"headerlink\" title=\"on 和 emit\"></a>on 和 emit</h3><pre><code>// on 可以想象成是一个订阅事件\n// emit 可以想象成一个发布事件\n// sub/pub(subscribe/publish)\n\nfunction Event() {\n    // todo...\n    this.eventToHandlers = {}  // 设置一个空对象\n}\n// todo...\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);  // 如果已经有 callback 了就继续添加\n    } else {\n        this.eventToHandlers[eventName] = [callback];  // 没有的话就让 eventToHandlers[name] 变为 callback\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];  // 解决变量名字是 undefined 的问题\n    for (let fn of handlers) {  // 遍历 eventName 下面的数组\n        fn(...args)\n    }\n}\n\n\nlet emitter = new Event();\n\nlet handler1 = (...args) =&gt; {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on(&#39;iEvent&#39;, handler1)\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)\n\nlet handler2 = () =&gt; { console.log(`another handler2`); };\nlet handler3 = () =&gt; { console.log(`another handler3`); };\nemitter.on(&#39;iEvent2&#39;, handler2)\nemitter.on(&#39;iEvent2&#39;, handler3)\nemitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)\n\n// an event occurred! with response a,b\n// another handler2\n// another handler3\n\n// 保存的数据结构的格式最好是\n/*\n{\n  &quot;iEvent&quot;: [handler1]\n  &quot;iEvent2&quot;: [handler2, handler3]\n}\n*/\n</code></pre><h3 id=\"eventNames-和-listenerCount\"><a href=\"#eventNames-和-listenerCount\" class=\"headerlink\" title=\"eventNames 和 listenerCount\"></a>eventNames 和 listenerCount</h3><pre><code>function Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现 eventNames 和 listenerCount\nEvent.prototype.eventNames = function () {\n    // return array\n    return Object.keys(this.eventToHandlers);\n}\n\nEvent.prototype.listenerCount = function (eventNames) {\n    // return number\n    // return (this.eventToHandlers[eventNames] || []).length  // 如果 this.eventToHandlers[eventNames] 没有就会取一个空数组\n    return this.eventToHandlers[eventNames] ? this.eventToHandlers[eventNames].length : 0;\n}\n\nlet emitter = new Event();\n\nlet handler1 = (...args) =&gt; {\n    console.log(`an event occurred! with response ${args}`);\n};\nemitter.on(&#39;iEvent&#39;, handler1)\nemitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)\n\nlet handler2 = () =&gt; { console.log(`another handler2`); };\nlet handler3 = () =&gt; { console.log(`another handler3`); };\nemitter.on(&#39;iEvent2&#39;, handler2)\nemitter.on(&#39;iEvent2&#39;, handler3)\nemitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)\n\nconsole.log(emitter.eventNames());  // [&#39;iEvent&#39;, &#39;iEvent2&#39;]\nconsole.log(emitter.listenerCount(&#39;iEvent2&#39;));  // 2\nconsole.log(emitter.listenerCount(&#39;abc&#39;));  // 做一个处理 0\n</code></pre><h3 id=\"removeListener\"><a href=\"#removeListener\" class=\"headerlink\" title=\"removeListener\"></a>removeListener</h3><pre><code>function Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\n// 实现一个 removeListener\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index &gt; -1) {\n        handlers.splice(index, 1)\n    }\n}\n\nlet emitter = new Event();\n\nlet handler2 = () =&gt; { console.log(`another handler2`); };\nlet handler3 = () =&gt; { console.log(`another handler3`); };\nemitter.on(&#39;iEvent2&#39;, handler2)\nemitter.on(&#39;iEvent2&#39;, handler3)\nemitter.removeListener(&#39;iEvent2&#39;, handler3)\nemitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)\n\n// another handler2\n</code></pre><h3 id=\"once\"><a href=\"#once\" class=\"headerlink\" title=\"once\"></a>once</h3><pre><code>function Event() {\n    this.eventToHandlers = {}\n}\n\nEvent.prototype.on = function (eventName, callback) {\n    if (this.eventToHandlers[eventName]) {\n        this.eventToHandlers[eventName].push(callback);\n    } else {\n        this.eventToHandlers[eventName] = [callback];\n    }\n}\n\nEvent.prototype.emit = function (eventName, ...args) {\n    let handlers = this.eventToHandlers[eventName] || [];\n    for (let fn of handlers) {\n        fn(...args)\n    }\n}\n\nEvent.prototype.removeListener = function (eventName, fn) {\n    let handlers = this.eventToHandlers[eventName];\n    let index = handlers.indexOf(fn);\n    if (index &gt; -1) {\n        handlers.splice(index, 1)\n    }\n}\n\n// 实现一个 once\nEvent.prototype.once = function (eventName, callback) {\n    // 触发之后删除掉\n    let handler = (...args) =&gt; {\n        callback(...args)\n        this.removeListener(eventName, handler)\n    }\n    this.on(eventName, handler)\n}\n\nlet emitter = new Event();\n\n\nlet handler4 = () =&gt; { console.log(`another handler4`); }\nemitter.once(&#39;iEvent4&#39;, handler4)\nemitter.emit(&#39;iEvent4&#39;)  // another handler4\nemitter.emit(&#39;iEvent4&#39;)  // 不打印\n</code></pre>"},{"title":"补基础：函数","date":"2017-10-23T17:19:56.000Z","_content":"# 补基础：函数\n\n>- [函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)\n>- [实参](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments)\n>- [length](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length)\n>- [call](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n>- [apply](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n>- [bind](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n>- [Generator Function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*)\n>- [Generator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator)\n>- [迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)\n>- [for of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\n\n## 什么是函数\n\n```1\nfunction fn() {\n  \tconsole.log(1)\n}\n\nfn() // 1\n\n// 传东西\nfunction fn(num, fn) {\n  \tconsole.log(fn(num))\n}\n\nfn(1, function(a){\n  \treturn a + 1\n}) // 2\n```\n\n```\n// whether fn is function\nfunction fn() {}\n\nconsole.log(typeof fn === 'function')\nconsole.log(fn instanceof Function)\nconsole.log(Object.prototype.toString.call(fn) === '[object Function]')\n```\n\n```\n// 函数调用和没调用的区别\nfunction fn2() {\n  \treturn 2\n}\n\nfn2()\n\nlet obj = {\n  \tfn: fn2\n}\n\nconsole.log(obj.fn)     // 返回是一个函数\nconsole.log(obj.fn())   // 返回函数的结果\n```\n\n```\n// 函数的借用\nlet user = {\n  \tname: 'xiaohong',\n  \tsayHi: function() {\n      \tconsole.log('hello my name is ' + this.name)\n  \t}\n}\n\nuesr.sayHi()  // hello my name is xiaohong\n\n// 怎么借用方法\nlet user2 = {name: 'xiaohei'}\n// to-do\nuser.sayHi.call(user2)\n// hello my name is xiaohong\n\n\nsetTimeout(function() {\n  \tconsole.log('hello')\n}, 1000)\n\n// 怎么写成一行呢？\nsetTimeout(console.log.bind(null, 'hello'), 1000)\n\n// 举个实用场景\n// var collection = document.getElementsByClassName('a')\n// 但是 collection 没有 forEach 方法\n// Array.prototype.forEach.call(collection)\n```\n\n## 形参(parameters) vs 实参(arguments)\n\n实参是实际传进来的参数\n\n形参是定义时候的参数\n\n```javascrip\n// arguments\nfunction fn(a, b) {\n\tconsole.log(a, b)\n  \tconsole.log(arguments)\n  \tconsole.log(arguments.length)\n}\n\nfunction fn(a, b, ...args) {\n\tconsole.log(a, b)\n  \tconsole.log(args)   // [3,4]\n  \tlet args1 = Array.prototype.slice.call(arguments, 2)\n  \tconsole.log(args1)  // [3,4]\n}\n\nfn(1,2,3,4)\n// 1 2\n// { '0': 1, '1': 2, '2': 3, '3': 4 }\n// 4\n\nlet arr = [1,2,3]\narr.push(1,2,3,4,5)\nconsole.log(arr)\n\nArray.prototype.push = function() {\n\t// arguments\n  \tlet args = Array.prototype.slice.call(arguments)\n}\n```\n\n```\n// parameters\nfunction fn(a, b) {\n  \tconsole.log(arguments.length)\n}\n\nfn(1,2,3,4)\nconsole.log(fn.length) // 2 形参个数 = 函数名.length\n\n// 实现一个功能\nfunction sum(a, b, c) {\n  \treturn a + b + c\n}\n\nconsole.log(sum(1,2,3))\n\n// fn 是一个函数\nfunction curry(fn) {\n\tvar len = fn.length\n  \treturn function f1() {\n      \tlet args = Array.prototype.slice.call(arguments)\n      \tif(args.length < len) {\n          \treturn function() {\n              \tlet args2 = Array.prototype.slice.call(arguments)\n              \treturn f1.apply(this, args.concat(args2))\n          \t}\n      \t} else {\n          \treturn fn.apply(null,args)\n      \t}\n  \t}\n}\n\nlet sumWithCurry = curry(sum) \nsumWithCurry(1,2,3)   // 6 len = 3, args.length = 3 sum.apply(null,[1,2,3])\nsumWithCurry(1)(2,3)  // 6\n\n// 先运行 sumWithCurry(1) 然后吃掉后面的函数 利用 concat \n\nsumWithCurry(1,2)(3)  // 6\n```\n\n[柯里化](https://github.com/n0ruSh/the-art-of-reading/issues/5)\n\n## 生成器(Generator)\n\n```\n// 在 function 加一个 * 号就可以变成一个 Generator 函数\nfunction* fn() {\n  \tyield 3;\n  \tyield 4;\n  \t// console.log('hello')\n}\n\nconsole.log(typeof fn)     // function\nconsole.log(fn())          // {}\nlet iterator = fn()\nconsole.log(iterator.next())  // {value: 3, done: false}\nconsole.log(iterator.next())  // {value: 4, done: false}\nconsole.log(iterator.next())  // {value: undefined, done: true}\n// 3 -> 4 -> done\n\nfor(let i of fn()) {  // for of 遍历方法，可以遍历数组\n  \tconsole.log(i)\n}\n// 3\n// 4\n\n// 看看是怎么做到的\nlet arr = [2,3,4]\nlet iterator = arr[Symbol.iterator]()\nconsole.log(iterator.next()) // {value: 2, done: false}\nconsole.log(iterator.next()) // {value: 3, done: false}\nconsole.log(iterator.next()) // {value: 4, done: false}\nconsole.log(iterator.next()) // {value: undefined, done: true}\n// 只要符合迭代器 就可以用 for of 方法\nfor(let j of iterator) {\n  \tconsole.log(j)\n}\n\n// 也可以遍历对象\nObject.defineProperty(Object.prototype, Symbol.iterator, {\n  \tenumerable: false,\n  \twritable: false,\n  \tconfigurable: false,\n  \tvalue: function() {\n      \tlet self = this;\n      \tlet keys = Object.keys(self); // ['a', 'd']\n      \tlet index = 0;\n      \treturn {\n          \tnext: function() {\n              \treturn {\n                  \tvalue: self[keys[index++]],  // 加点注释啥的 + 'suffix'\n                  \tdone: index > keys.length\n              \t}\n          \t}\n      \t}\n  \t}\n})\n\nlet obj = {a: 'b', c: 'd'}\n\nlet iterator2 = obj[Symbol.iterator]()\nconsole.log(iterator2.next()) // {value: 'b', done: false}\nconsole.log(iterator2.next()) // {value: 'd', done: false}\nconsole.log(iterator2.next()) // {value: undefined, done: true}\n\nfor(let val of obj) {\n  \tconsole.log(val)\n}\n\nlet obj2 = {name: 'xiaohong', age: 20, sex: 'male'}\nfor(let j of obj2) {  // 只要支持迭代器协议就可以了\n  \tconsole.log(j)\n}\n```\n\n```\n// 彩蛋 和 Promise 的比较\n\n// Promise\nnew Promise()\n.then()\n.then()\n.then()\n\n// yield + generator\nlet a = yield promise1\nlet b = yield promise2\nlet c = yield promise3\n// 看起来像是同步，实际上是异步\n```\n\n```\n// 彩蛋2 为什么不支持 for of 遍历对象\n// 原因有可能是这样的\n// 数组不关心索引，对象关心\n\nlet arr = ['a','b','c'] = {\n  \t'0' : 'a',\n  \t'1' : 'b',\n  \t'2' : 'c',\n}\n\nlet obj = {\n  \t'a': 'b',\n  \t'c': 'd'\n}\n```\n\n其实有两个新方法，[Object.values()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values) 和 [Object.entries()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) 可以遍历，Object.values() 只返回 value ，Object.entries() 返回全部\n\n```\n// 彩蛋3 Symbol 是用来干嘛的？\n// 避免相等的值重复\nlet a = 'a'\nlet b = 'a'\n\nlet obj = {}\nobj[a]\nobj[b]\n```\n\n[深入浅出ES6（八）：Symbols](http://www.infoq.com/cn/articles/es6-in-depth-symbols)","source":"_posts/补基础：函数.md","raw":"---\ntitle: 补基础：函数\ndate: 2017-10-24 01:19:56\ntags: [JavaScript]\n---\n# 补基础：函数\n\n>- [函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)\n>- [实参](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments)\n>- [length](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length)\n>- [call](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n>- [apply](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n>- [bind](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n>- [Generator Function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*)\n>- [Generator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator)\n>- [迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)\n>- [for of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\n\n## 什么是函数\n\n```1\nfunction fn() {\n  \tconsole.log(1)\n}\n\nfn() // 1\n\n// 传东西\nfunction fn(num, fn) {\n  \tconsole.log(fn(num))\n}\n\nfn(1, function(a){\n  \treturn a + 1\n}) // 2\n```\n\n```\n// whether fn is function\nfunction fn() {}\n\nconsole.log(typeof fn === 'function')\nconsole.log(fn instanceof Function)\nconsole.log(Object.prototype.toString.call(fn) === '[object Function]')\n```\n\n```\n// 函数调用和没调用的区别\nfunction fn2() {\n  \treturn 2\n}\n\nfn2()\n\nlet obj = {\n  \tfn: fn2\n}\n\nconsole.log(obj.fn)     // 返回是一个函数\nconsole.log(obj.fn())   // 返回函数的结果\n```\n\n```\n// 函数的借用\nlet user = {\n  \tname: 'xiaohong',\n  \tsayHi: function() {\n      \tconsole.log('hello my name is ' + this.name)\n  \t}\n}\n\nuesr.sayHi()  // hello my name is xiaohong\n\n// 怎么借用方法\nlet user2 = {name: 'xiaohei'}\n// to-do\nuser.sayHi.call(user2)\n// hello my name is xiaohong\n\n\nsetTimeout(function() {\n  \tconsole.log('hello')\n}, 1000)\n\n// 怎么写成一行呢？\nsetTimeout(console.log.bind(null, 'hello'), 1000)\n\n// 举个实用场景\n// var collection = document.getElementsByClassName('a')\n// 但是 collection 没有 forEach 方法\n// Array.prototype.forEach.call(collection)\n```\n\n## 形参(parameters) vs 实参(arguments)\n\n实参是实际传进来的参数\n\n形参是定义时候的参数\n\n```javascrip\n// arguments\nfunction fn(a, b) {\n\tconsole.log(a, b)\n  \tconsole.log(arguments)\n  \tconsole.log(arguments.length)\n}\n\nfunction fn(a, b, ...args) {\n\tconsole.log(a, b)\n  \tconsole.log(args)   // [3,4]\n  \tlet args1 = Array.prototype.slice.call(arguments, 2)\n  \tconsole.log(args1)  // [3,4]\n}\n\nfn(1,2,3,4)\n// 1 2\n// { '0': 1, '1': 2, '2': 3, '3': 4 }\n// 4\n\nlet arr = [1,2,3]\narr.push(1,2,3,4,5)\nconsole.log(arr)\n\nArray.prototype.push = function() {\n\t// arguments\n  \tlet args = Array.prototype.slice.call(arguments)\n}\n```\n\n```\n// parameters\nfunction fn(a, b) {\n  \tconsole.log(arguments.length)\n}\n\nfn(1,2,3,4)\nconsole.log(fn.length) // 2 形参个数 = 函数名.length\n\n// 实现一个功能\nfunction sum(a, b, c) {\n  \treturn a + b + c\n}\n\nconsole.log(sum(1,2,3))\n\n// fn 是一个函数\nfunction curry(fn) {\n\tvar len = fn.length\n  \treturn function f1() {\n      \tlet args = Array.prototype.slice.call(arguments)\n      \tif(args.length < len) {\n          \treturn function() {\n              \tlet args2 = Array.prototype.slice.call(arguments)\n              \treturn f1.apply(this, args.concat(args2))\n          \t}\n      \t} else {\n          \treturn fn.apply(null,args)\n      \t}\n  \t}\n}\n\nlet sumWithCurry = curry(sum) \nsumWithCurry(1,2,3)   // 6 len = 3, args.length = 3 sum.apply(null,[1,2,3])\nsumWithCurry(1)(2,3)  // 6\n\n// 先运行 sumWithCurry(1) 然后吃掉后面的函数 利用 concat \n\nsumWithCurry(1,2)(3)  // 6\n```\n\n[柯里化](https://github.com/n0ruSh/the-art-of-reading/issues/5)\n\n## 生成器(Generator)\n\n```\n// 在 function 加一个 * 号就可以变成一个 Generator 函数\nfunction* fn() {\n  \tyield 3;\n  \tyield 4;\n  \t// console.log('hello')\n}\n\nconsole.log(typeof fn)     // function\nconsole.log(fn())          // {}\nlet iterator = fn()\nconsole.log(iterator.next())  // {value: 3, done: false}\nconsole.log(iterator.next())  // {value: 4, done: false}\nconsole.log(iterator.next())  // {value: undefined, done: true}\n// 3 -> 4 -> done\n\nfor(let i of fn()) {  // for of 遍历方法，可以遍历数组\n  \tconsole.log(i)\n}\n// 3\n// 4\n\n// 看看是怎么做到的\nlet arr = [2,3,4]\nlet iterator = arr[Symbol.iterator]()\nconsole.log(iterator.next()) // {value: 2, done: false}\nconsole.log(iterator.next()) // {value: 3, done: false}\nconsole.log(iterator.next()) // {value: 4, done: false}\nconsole.log(iterator.next()) // {value: undefined, done: true}\n// 只要符合迭代器 就可以用 for of 方法\nfor(let j of iterator) {\n  \tconsole.log(j)\n}\n\n// 也可以遍历对象\nObject.defineProperty(Object.prototype, Symbol.iterator, {\n  \tenumerable: false,\n  \twritable: false,\n  \tconfigurable: false,\n  \tvalue: function() {\n      \tlet self = this;\n      \tlet keys = Object.keys(self); // ['a', 'd']\n      \tlet index = 0;\n      \treturn {\n          \tnext: function() {\n              \treturn {\n                  \tvalue: self[keys[index++]],  // 加点注释啥的 + 'suffix'\n                  \tdone: index > keys.length\n              \t}\n          \t}\n      \t}\n  \t}\n})\n\nlet obj = {a: 'b', c: 'd'}\n\nlet iterator2 = obj[Symbol.iterator]()\nconsole.log(iterator2.next()) // {value: 'b', done: false}\nconsole.log(iterator2.next()) // {value: 'd', done: false}\nconsole.log(iterator2.next()) // {value: undefined, done: true}\n\nfor(let val of obj) {\n  \tconsole.log(val)\n}\n\nlet obj2 = {name: 'xiaohong', age: 20, sex: 'male'}\nfor(let j of obj2) {  // 只要支持迭代器协议就可以了\n  \tconsole.log(j)\n}\n```\n\n```\n// 彩蛋 和 Promise 的比较\n\n// Promise\nnew Promise()\n.then()\n.then()\n.then()\n\n// yield + generator\nlet a = yield promise1\nlet b = yield promise2\nlet c = yield promise3\n// 看起来像是同步，实际上是异步\n```\n\n```\n// 彩蛋2 为什么不支持 for of 遍历对象\n// 原因有可能是这样的\n// 数组不关心索引，对象关心\n\nlet arr = ['a','b','c'] = {\n  \t'0' : 'a',\n  \t'1' : 'b',\n  \t'2' : 'c',\n}\n\nlet obj = {\n  \t'a': 'b',\n  \t'c': 'd'\n}\n```\n\n其实有两个新方法，[Object.values()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values) 和 [Object.entries()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) 可以遍历，Object.values() 只返回 value ，Object.entries() 返回全部\n\n```\n// 彩蛋3 Symbol 是用来干嘛的？\n// 避免相等的值重复\nlet a = 'a'\nlet b = 'a'\n\nlet obj = {}\nobj[a]\nobj[b]\n```\n\n[深入浅出ES6（八）：Symbols](http://www.infoq.com/cn/articles/es6-in-depth-symbols)","slug":"补基础：函数","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d9f001mf1xhgwkmovpo","content":"<h1 id=\"补基础：函数\"><a href=\"#补基础：函数\" class=\"headerlink\" title=\"补基础：函数\"></a>补基础：函数</h1><blockquote>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function\" target=\"_blank\" rel=\"noopener\">函数</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\" target=\"_blank\" rel=\"noopener\">实参</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length\" target=\"_blank\" rel=\"noopener\">length</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">call</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">apply</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">bind</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*\" target=\"_blank\" rel=\"noopener\">Generator Function</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator\" target=\"_blank\" rel=\"noopener\">Generator</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator\" target=\"_blank\" rel=\"noopener\">迭代器协议</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\" target=\"_blank\" rel=\"noopener\">for of</a></li>\n</ul>\n</blockquote>\n<h2 id=\"什么是函数\"><a href=\"#什么是函数\" class=\"headerlink\" title=\"什么是函数\"></a>什么是函数</h2><pre><code class=\"1\">function fn() {\n      console.log(1)\n}\n\nfn() // 1\n\n// 传东西\nfunction fn(num, fn) {\n      console.log(fn(num))\n}\n\nfn(1, function(a){\n      return a + 1\n}) // 2\n</code></pre>\n<pre><code>// whether fn is function\nfunction fn() {}\n\nconsole.log(typeof fn === &#39;function&#39;)\nconsole.log(fn instanceof Function)\nconsole.log(Object.prototype.toString.call(fn) === &#39;[object Function]&#39;)\n</code></pre><pre><code>// 函数调用和没调用的区别\nfunction fn2() {\n      return 2\n}\n\nfn2()\n\nlet obj = {\n      fn: fn2\n}\n\nconsole.log(obj.fn)     // 返回是一个函数\nconsole.log(obj.fn())   // 返回函数的结果\n</code></pre><pre><code>// 函数的借用\nlet user = {\n      name: &#39;xiaohong&#39;,\n      sayHi: function() {\n          console.log(&#39;hello my name is &#39; + this.name)\n      }\n}\n\nuesr.sayHi()  // hello my name is xiaohong\n\n// 怎么借用方法\nlet user2 = {name: &#39;xiaohei&#39;}\n// to-do\nuser.sayHi.call(user2)\n// hello my name is xiaohong\n\n\nsetTimeout(function() {\n      console.log(&#39;hello&#39;)\n}, 1000)\n\n// 怎么写成一行呢？\nsetTimeout(console.log.bind(null, &#39;hello&#39;), 1000)\n\n// 举个实用场景\n// var collection = document.getElementsByClassName(&#39;a&#39;)\n// 但是 collection 没有 forEach 方法\n// Array.prototype.forEach.call(collection)\n</code></pre><h2 id=\"形参-parameters-vs-实参-arguments\"><a href=\"#形参-parameters-vs-实参-arguments\" class=\"headerlink\" title=\"形参(parameters) vs 实参(arguments)\"></a>形参(parameters) vs 实参(arguments)</h2><p>实参是实际传进来的参数</p>\n<p>形参是定义时候的参数</p>\n<pre><code class=\"javascrip\">// arguments\nfunction fn(a, b) {\n    console.log(a, b)\n      console.log(arguments)\n      console.log(arguments.length)\n}\n\nfunction fn(a, b, ...args) {\n    console.log(a, b)\n      console.log(args)   // [3,4]\n      let args1 = Array.prototype.slice.call(arguments, 2)\n      console.log(args1)  // [3,4]\n}\n\nfn(1,2,3,4)\n// 1 2\n// { &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3, &#39;3&#39;: 4 }\n// 4\n\nlet arr = [1,2,3]\narr.push(1,2,3,4,5)\nconsole.log(arr)\n\nArray.prototype.push = function() {\n    // arguments\n      let args = Array.prototype.slice.call(arguments)\n}\n</code></pre>\n<pre><code>// parameters\nfunction fn(a, b) {\n      console.log(arguments.length)\n}\n\nfn(1,2,3,4)\nconsole.log(fn.length) // 2 形参个数 = 函数名.length\n\n// 实现一个功能\nfunction sum(a, b, c) {\n      return a + b + c\n}\n\nconsole.log(sum(1,2,3))\n\n// fn 是一个函数\nfunction curry(fn) {\n    var len = fn.length\n      return function f1() {\n          let args = Array.prototype.slice.call(arguments)\n          if(args.length &lt; len) {\n              return function() {\n                  let args2 = Array.prototype.slice.call(arguments)\n                  return f1.apply(this, args.concat(args2))\n              }\n          } else {\n              return fn.apply(null,args)\n          }\n      }\n}\n\nlet sumWithCurry = curry(sum) \nsumWithCurry(1,2,3)   // 6 len = 3, args.length = 3 sum.apply(null,[1,2,3])\nsumWithCurry(1)(2,3)  // 6\n\n// 先运行 sumWithCurry(1) 然后吃掉后面的函数 利用 concat \n\nsumWithCurry(1,2)(3)  // 6\n</code></pre><p><a href=\"https://github.com/n0ruSh/the-art-of-reading/issues/5\" target=\"_blank\" rel=\"noopener\">柯里化</a></p>\n<h2 id=\"生成器-Generator\"><a href=\"#生成器-Generator\" class=\"headerlink\" title=\"生成器(Generator)\"></a>生成器(Generator)</h2><pre><code>// 在 function 加一个 * 号就可以变成一个 Generator 函数\nfunction* fn() {\n      yield 3;\n      yield 4;\n      // console.log(&#39;hello&#39;)\n}\n\nconsole.log(typeof fn)     // function\nconsole.log(fn())          // {}\nlet iterator = fn()\nconsole.log(iterator.next())  // {value: 3, done: false}\nconsole.log(iterator.next())  // {value: 4, done: false}\nconsole.log(iterator.next())  // {value: undefined, done: true}\n// 3 -&gt; 4 -&gt; done\n\nfor(let i of fn()) {  // for of 遍历方法，可以遍历数组\n      console.log(i)\n}\n// 3\n// 4\n\n// 看看是怎么做到的\nlet arr = [2,3,4]\nlet iterator = arr[Symbol.iterator]()\nconsole.log(iterator.next()) // {value: 2, done: false}\nconsole.log(iterator.next()) // {value: 3, done: false}\nconsole.log(iterator.next()) // {value: 4, done: false}\nconsole.log(iterator.next()) // {value: undefined, done: true}\n// 只要符合迭代器 就可以用 for of 方法\nfor(let j of iterator) {\n      console.log(j)\n}\n\n// 也可以遍历对象\nObject.defineProperty(Object.prototype, Symbol.iterator, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: function() {\n          let self = this;\n          let keys = Object.keys(self); // [&#39;a&#39;, &#39;d&#39;]\n          let index = 0;\n          return {\n              next: function() {\n                  return {\n                      value: self[keys[index++]],  // 加点注释啥的 + &#39;suffix&#39;\n                      done: index &gt; keys.length\n                  }\n              }\n          }\n      }\n})\n\nlet obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\nlet iterator2 = obj[Symbol.iterator]()\nconsole.log(iterator2.next()) // {value: &#39;b&#39;, done: false}\nconsole.log(iterator2.next()) // {value: &#39;d&#39;, done: false}\nconsole.log(iterator2.next()) // {value: undefined, done: true}\n\nfor(let val of obj) {\n      console.log(val)\n}\n\nlet obj2 = {name: &#39;xiaohong&#39;, age: 20, sex: &#39;male&#39;}\nfor(let j of obj2) {  // 只要支持迭代器协议就可以了\n      console.log(j)\n}\n</code></pre><pre><code>// 彩蛋 和 Promise 的比较\n\n// Promise\nnew Promise()\n.then()\n.then()\n.then()\n\n// yield + generator\nlet a = yield promise1\nlet b = yield promise2\nlet c = yield promise3\n// 看起来像是同步，实际上是异步\n</code></pre><pre><code>// 彩蛋2 为什么不支持 for of 遍历对象\n// 原因有可能是这样的\n// 数组不关心索引，对象关心\n\nlet arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] = {\n      &#39;0&#39; : &#39;a&#39;,\n      &#39;1&#39; : &#39;b&#39;,\n      &#39;2&#39; : &#39;c&#39;,\n}\n\nlet obj = {\n      &#39;a&#39;: &#39;b&#39;,\n      &#39;c&#39;: &#39;d&#39;\n}\n</code></pre><p>其实有两个新方法，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values\" target=\"_blank\" rel=\"noopener\">Object.values()</a> 和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" target=\"_blank\" rel=\"noopener\">Object.entries()</a> 可以遍历，Object.values() 只返回 value ，Object.entries() 返回全部</p>\n<pre><code>// 彩蛋3 Symbol 是用来干嘛的？\n// 避免相等的值重复\nlet a = &#39;a&#39;\nlet b = &#39;a&#39;\n\nlet obj = {}\nobj[a]\nobj[b]\n</code></pre><p><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-symbols\" target=\"_blank\" rel=\"noopener\">深入浅出ES6（八）：Symbols</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：函数\"><a href=\"#补基础：函数\" class=\"headerlink\" title=\"补基础：函数\"></a>补基础：函数</h1><blockquote>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function\" target=\"_blank\" rel=\"noopener\">函数</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\" target=\"_blank\" rel=\"noopener\">实参</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length\" target=\"_blank\" rel=\"noopener\">length</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">call</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">apply</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">bind</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*\" target=\"_blank\" rel=\"noopener\">Generator Function</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator\" target=\"_blank\" rel=\"noopener\">Generator</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator\" target=\"_blank\" rel=\"noopener\">迭代器协议</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\" target=\"_blank\" rel=\"noopener\">for of</a></li>\n</ul>\n</blockquote>\n<h2 id=\"什么是函数\"><a href=\"#什么是函数\" class=\"headerlink\" title=\"什么是函数\"></a>什么是函数</h2><pre><code class=\"1\">function fn() {\n      console.log(1)\n}\n\nfn() // 1\n\n// 传东西\nfunction fn(num, fn) {\n      console.log(fn(num))\n}\n\nfn(1, function(a){\n      return a + 1\n}) // 2\n</code></pre>\n<pre><code>// whether fn is function\nfunction fn() {}\n\nconsole.log(typeof fn === &#39;function&#39;)\nconsole.log(fn instanceof Function)\nconsole.log(Object.prototype.toString.call(fn) === &#39;[object Function]&#39;)\n</code></pre><pre><code>// 函数调用和没调用的区别\nfunction fn2() {\n      return 2\n}\n\nfn2()\n\nlet obj = {\n      fn: fn2\n}\n\nconsole.log(obj.fn)     // 返回是一个函数\nconsole.log(obj.fn())   // 返回函数的结果\n</code></pre><pre><code>// 函数的借用\nlet user = {\n      name: &#39;xiaohong&#39;,\n      sayHi: function() {\n          console.log(&#39;hello my name is &#39; + this.name)\n      }\n}\n\nuesr.sayHi()  // hello my name is xiaohong\n\n// 怎么借用方法\nlet user2 = {name: &#39;xiaohei&#39;}\n// to-do\nuser.sayHi.call(user2)\n// hello my name is xiaohong\n\n\nsetTimeout(function() {\n      console.log(&#39;hello&#39;)\n}, 1000)\n\n// 怎么写成一行呢？\nsetTimeout(console.log.bind(null, &#39;hello&#39;), 1000)\n\n// 举个实用场景\n// var collection = document.getElementsByClassName(&#39;a&#39;)\n// 但是 collection 没有 forEach 方法\n// Array.prototype.forEach.call(collection)\n</code></pre><h2 id=\"形参-parameters-vs-实参-arguments\"><a href=\"#形参-parameters-vs-实参-arguments\" class=\"headerlink\" title=\"形参(parameters) vs 实参(arguments)\"></a>形参(parameters) vs 实参(arguments)</h2><p>实参是实际传进来的参数</p>\n<p>形参是定义时候的参数</p>\n<pre><code class=\"javascrip\">// arguments\nfunction fn(a, b) {\n    console.log(a, b)\n      console.log(arguments)\n      console.log(arguments.length)\n}\n\nfunction fn(a, b, ...args) {\n    console.log(a, b)\n      console.log(args)   // [3,4]\n      let args1 = Array.prototype.slice.call(arguments, 2)\n      console.log(args1)  // [3,4]\n}\n\nfn(1,2,3,4)\n// 1 2\n// { &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3, &#39;3&#39;: 4 }\n// 4\n\nlet arr = [1,2,3]\narr.push(1,2,3,4,5)\nconsole.log(arr)\n\nArray.prototype.push = function() {\n    // arguments\n      let args = Array.prototype.slice.call(arguments)\n}\n</code></pre>\n<pre><code>// parameters\nfunction fn(a, b) {\n      console.log(arguments.length)\n}\n\nfn(1,2,3,4)\nconsole.log(fn.length) // 2 形参个数 = 函数名.length\n\n// 实现一个功能\nfunction sum(a, b, c) {\n      return a + b + c\n}\n\nconsole.log(sum(1,2,3))\n\n// fn 是一个函数\nfunction curry(fn) {\n    var len = fn.length\n      return function f1() {\n          let args = Array.prototype.slice.call(arguments)\n          if(args.length &lt; len) {\n              return function() {\n                  let args2 = Array.prototype.slice.call(arguments)\n                  return f1.apply(this, args.concat(args2))\n              }\n          } else {\n              return fn.apply(null,args)\n          }\n      }\n}\n\nlet sumWithCurry = curry(sum) \nsumWithCurry(1,2,3)   // 6 len = 3, args.length = 3 sum.apply(null,[1,2,3])\nsumWithCurry(1)(2,3)  // 6\n\n// 先运行 sumWithCurry(1) 然后吃掉后面的函数 利用 concat \n\nsumWithCurry(1,2)(3)  // 6\n</code></pre><p><a href=\"https://github.com/n0ruSh/the-art-of-reading/issues/5\" target=\"_blank\" rel=\"noopener\">柯里化</a></p>\n<h2 id=\"生成器-Generator\"><a href=\"#生成器-Generator\" class=\"headerlink\" title=\"生成器(Generator)\"></a>生成器(Generator)</h2><pre><code>// 在 function 加一个 * 号就可以变成一个 Generator 函数\nfunction* fn() {\n      yield 3;\n      yield 4;\n      // console.log(&#39;hello&#39;)\n}\n\nconsole.log(typeof fn)     // function\nconsole.log(fn())          // {}\nlet iterator = fn()\nconsole.log(iterator.next())  // {value: 3, done: false}\nconsole.log(iterator.next())  // {value: 4, done: false}\nconsole.log(iterator.next())  // {value: undefined, done: true}\n// 3 -&gt; 4 -&gt; done\n\nfor(let i of fn()) {  // for of 遍历方法，可以遍历数组\n      console.log(i)\n}\n// 3\n// 4\n\n// 看看是怎么做到的\nlet arr = [2,3,4]\nlet iterator = arr[Symbol.iterator]()\nconsole.log(iterator.next()) // {value: 2, done: false}\nconsole.log(iterator.next()) // {value: 3, done: false}\nconsole.log(iterator.next()) // {value: 4, done: false}\nconsole.log(iterator.next()) // {value: undefined, done: true}\n// 只要符合迭代器 就可以用 for of 方法\nfor(let j of iterator) {\n      console.log(j)\n}\n\n// 也可以遍历对象\nObject.defineProperty(Object.prototype, Symbol.iterator, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: function() {\n          let self = this;\n          let keys = Object.keys(self); // [&#39;a&#39;, &#39;d&#39;]\n          let index = 0;\n          return {\n              next: function() {\n                  return {\n                      value: self[keys[index++]],  // 加点注释啥的 + &#39;suffix&#39;\n                      done: index &gt; keys.length\n                  }\n              }\n          }\n      }\n})\n\nlet obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\nlet iterator2 = obj[Symbol.iterator]()\nconsole.log(iterator2.next()) // {value: &#39;b&#39;, done: false}\nconsole.log(iterator2.next()) // {value: &#39;d&#39;, done: false}\nconsole.log(iterator2.next()) // {value: undefined, done: true}\n\nfor(let val of obj) {\n      console.log(val)\n}\n\nlet obj2 = {name: &#39;xiaohong&#39;, age: 20, sex: &#39;male&#39;}\nfor(let j of obj2) {  // 只要支持迭代器协议就可以了\n      console.log(j)\n}\n</code></pre><pre><code>// 彩蛋 和 Promise 的比较\n\n// Promise\nnew Promise()\n.then()\n.then()\n.then()\n\n// yield + generator\nlet a = yield promise1\nlet b = yield promise2\nlet c = yield promise3\n// 看起来像是同步，实际上是异步\n</code></pre><pre><code>// 彩蛋2 为什么不支持 for of 遍历对象\n// 原因有可能是这样的\n// 数组不关心索引，对象关心\n\nlet arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] = {\n      &#39;0&#39; : &#39;a&#39;,\n      &#39;1&#39; : &#39;b&#39;,\n      &#39;2&#39; : &#39;c&#39;,\n}\n\nlet obj = {\n      &#39;a&#39;: &#39;b&#39;,\n      &#39;c&#39;: &#39;d&#39;\n}\n</code></pre><p>其实有两个新方法，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values\" target=\"_blank\" rel=\"noopener\">Object.values()</a> 和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" target=\"_blank\" rel=\"noopener\">Object.entries()</a> 可以遍历，Object.values() 只返回 value ，Object.entries() 返回全部</p>\n<pre><code>// 彩蛋3 Symbol 是用来干嘛的？\n// 避免相等的值重复\nlet a = &#39;a&#39;\nlet b = &#39;a&#39;\n\nlet obj = {}\nobj[a]\nobj[b]\n</code></pre><p><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-symbols\" target=\"_blank\" rel=\"noopener\">深入浅出ES6（八）：Symbols</a></p>\n"},{"title":"补基础：原型链和 prototype","date":"2017-10-16T17:58:32.000Z","_content":"# 补基础：原型链和 prototype\n\n先搞清楚两个东西\n\n- `__proto__`\n- `prototype`\n\n>实例化对象的原型(`__proto__`)指向了构造函数的prototype属性\n\n例如\n\n```\nlet arr = [1,2]\nlet arr2 = new Array(3,4)\n\narr.__proto__ === Array.prototype\n```\n\n再举个例子\n\n```\n// Array 实际是一个构造函数\nArray.__proto__ === Function.prototype\n\n// 我们经常用到的 Array.forEach Array.push 实际上是 Function 的方法\nArray.prototype.forEach\nArray.prototype.push\n\n// 举个例子\nlet arr = [1,2]\narr.push(3)\nconsole.log(arr) // [1,2,3]\n// 利用 hasOwnProperty 的方法看看\nconsole.log(arr.hasOwnProperty('push')) // false\nconsole.log(Array.prototype.hasOwnProperty('push'))\n```\n\n所以说，本身 `arr` 是没有 `push` 这个方法的 ，于是就会从他的原型上找。先会找它的原型 (`arr.__proto__` 等价与在 `Array.prototype` 里面找) 。\n\n 那 `arr.hasOwnProperty` 又是怎么来的呢？\n\n```\nconsole.log(Object.prototype.hasOwnProperty.call(arr, 'hasOwnProperty')) //false\nconsole.log(Object.prototype.hasOwnProperty.call(arr.__proto__, 'hasOwnProperty')) //false\nconsole.log(Object.prototype.hasOwnProperty.call(Array.prototype, 'hasOwnProperty')) //false\n// 既然找不到，那我们可以往上一级找\n// arr.__proto__.__proto___ === Array.prototype.__proto__ === Object.prototype\n/*\n为什么 Array 是一个对象呢？\n因为是对象格式\nArray.prototype = {\n  push: function() {\n    \n  }\n}\n*/\n\nconsole.log(Object.prototype.hasOwnProperty.call(Object.prototype, 'hasOwnProperty')) // true\n\n\n/*\n实际上是有尽头的\n一直往原型上找的话\n最后是一个 null\n*/\n```\n\n## 例子\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nconsole.log(mike.hasOwnProperty('sayHi')) // false\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n    this.sayHi = function() {\n        console.log(`hello I'm ${this.name}`);\n    };\n}\n\nlet mike = new Person('mike');\nconsole.log(mike.hasOwnProperty('sayHi')) // true\n```\n\n所以说，`prototype` 会给每个实例对象赋予一个新的 `sayHi()` \n\n```\nfunction Person(name) {\n    this.name = name;\n\tthis.sayHi = function() {\n    \tconsole.log(`hello I'm ${this.name}`);\n\t};\n}\n\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // false\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // true\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nPerson.prototype.sayHi = function() {\n    console.log(`hi I'm ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I'm mike\n// hello I'm mike2\n// hi I'm mike\n// hi I'm mike2\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nmike.sayHi = function() {\n    console.log(`hi I'm ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I'm mike\n// hello I'm mike2\n// hi I'm mike\n// hello I'm mike2\n```\n\n所以，如果要找 a 里面有没有 b 这个玩意，就一直 `a.__proto__.__proto__` ... 这个子子孙孙无穷尽也 \n\n## instanceof\n\n> 判断自定义对象的类型\n\n```\nlet arr = [1,2]\nconsole.log(arr instanceof Array)\n// 实际上就是 arr.__proto__ === Array.prototype\n```\n\n```\nlet arr = [1,2]\n\n// 实现一个 instanceof, in 是实例 fn 是构造函数\nfunction io(ins, fn) {\n    if(ins.__proto__){\n        if(ins.__proto__ === fn.prototype){\n            return true;\n        } else {\n            return io(ins.__proto__, fn);\n        }\n    }else {\n        return false;\n    }\n}\n\n/*\nfunction io(ins, fn) {\n\twhile(ins.__proto__ !== null){\n      if(ins.__proto__ === fn.prototype){\n        return true\n      }\n      ins = ins.__proto__\n\t}\n\treturn false\n}\n*/\n\n/*\nfunction io(ins, fn) {\n\tif(ins.__proto__ === fn.prototype) return true\n\telse if(ins.__proto__ === null){\n      \treturn false\n\t}\n\telse return io(ins.__proto__, fn)\n}\n*/\n\nconsole.log(io(arr, Array)); //true\nconsole.log(io(arr, Object)); //true\nconsole.log(io(arr, Number)); //false\n```\n\n## new\n\n>创建一个实例化对象，继承构造函数的一些实例和方法\n>\n>- 新生成一个对象\n>- 将构造函数的 this 指向这个新生成的对象\n>- 设置新生成对象的原型\n>- 执行构造函数\n>- 返回这个对象\n\n```\nfunction Person(name,age) {\n    this.name = name;\n\tthis.age = age;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nmike.sayHi()\n\n// 实现一个 new 方法\nfunction myNewObject(f, ...arg) {\n    var obj, ret, proto;\n    proto = f.prototype;\n    obj = Object.create(proto);\n    ret = f.apply(obj, arg);\n    return obj;\n}\n\n// function myNewObject(fn, ...arg) {\n// \tlet obj = {}\n// \tobj.__proto__ = fn.prototype\n// \tfn.call(obj,arg)\n// \treturn obj\n// }\n\nlet mike2 = myNewObject(Person, 'mike2', 12);\nconsole.log(mike2.name) // mike2\nmike2.sayHi(); // hello I'm mike2\nconsole.log(mike2 instanceof Person); // true\n```\n\n```\nfunction Person(name) {\n\t// 看这里，因为 this 不是那个实例化对象了\n\tif(!(this instanceof Person)) {\n        return new Person(name);\n    }\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike3 = Person('mike3');\nconsole.log(mike3) //undefined\n\n// 怎么让 mike3 也成为一个正常的实例化对象呢？\n// 看上面\n\nconsole.log(mike3.name); //mike3\nmike3.sayHi(); //hello I'm mike3\nconsole.log(mike3 instanceof Person); //true\n```\n\n## inheritance\n\n继承方法\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nfunction Student(name, grade) {\n\t// to-do\n\tPerson.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype); //to-do\n// Student.prototype.__proto__ = Person.prototype\n// Student.prototype.constructor = Student;\n\n// 注意如果用以下这种方法\n// Student.prototype = new Person()\n// xiaohong.__proto__ === Student.prototype\n// xiaohong.__proto__.name === undefined // 多余的东西 \n// 需要的条件是\n// xiaohong.__proto__ // Student.prototype\n// xiaohong.__proto__.__proto__ // Person.protoype\n\nStudent.prototype.study = function(){\n    console.log(\"I'm studying\");\n};\n\nlet xiaohong = new Student('xiaohong', 6);\nxiaohong.sayHi(); //hello I'm xiaohong\nxiaohong.study(); //I'm studying\nconsole.log(xiaohong.grade); //6\nconsole.log(xiaohong.name); //xiaohong\nconsole.log(xiaohong instanceof Person); //true\nconsole.log(xiaohong instanceof Student); //true\nconsole.log(xiaohong.constructor === Person); //true\n```\n\n```\n// 彩蛋 做一个 Object.create()\nif(typeof Object.create !== 'function'){\n  \tObject.create = function(obj){\n      function F(){}\n      F.prototype = obj\n      return new F()\n  \t}\n}\n```\n\n注意 `__proto__` 不是规范里面的，是浏览器的规范 `Object.getPrototype(Array) === Array.__proto__`","source":"_posts/补基础：原型链和 prototype.md","raw":"---\ntitle: 补基础：原型链和 prototype\ndate: 2017-10-17 01:58:32\ntags: [JavaScript]\n---\n# 补基础：原型链和 prototype\n\n先搞清楚两个东西\n\n- `__proto__`\n- `prototype`\n\n>实例化对象的原型(`__proto__`)指向了构造函数的prototype属性\n\n例如\n\n```\nlet arr = [1,2]\nlet arr2 = new Array(3,4)\n\narr.__proto__ === Array.prototype\n```\n\n再举个例子\n\n```\n// Array 实际是一个构造函数\nArray.__proto__ === Function.prototype\n\n// 我们经常用到的 Array.forEach Array.push 实际上是 Function 的方法\nArray.prototype.forEach\nArray.prototype.push\n\n// 举个例子\nlet arr = [1,2]\narr.push(3)\nconsole.log(arr) // [1,2,3]\n// 利用 hasOwnProperty 的方法看看\nconsole.log(arr.hasOwnProperty('push')) // false\nconsole.log(Array.prototype.hasOwnProperty('push'))\n```\n\n所以说，本身 `arr` 是没有 `push` 这个方法的 ，于是就会从他的原型上找。先会找它的原型 (`arr.__proto__` 等价与在 `Array.prototype` 里面找) 。\n\n 那 `arr.hasOwnProperty` 又是怎么来的呢？\n\n```\nconsole.log(Object.prototype.hasOwnProperty.call(arr, 'hasOwnProperty')) //false\nconsole.log(Object.prototype.hasOwnProperty.call(arr.__proto__, 'hasOwnProperty')) //false\nconsole.log(Object.prototype.hasOwnProperty.call(Array.prototype, 'hasOwnProperty')) //false\n// 既然找不到，那我们可以往上一级找\n// arr.__proto__.__proto___ === Array.prototype.__proto__ === Object.prototype\n/*\n为什么 Array 是一个对象呢？\n因为是对象格式\nArray.prototype = {\n  push: function() {\n    \n  }\n}\n*/\n\nconsole.log(Object.prototype.hasOwnProperty.call(Object.prototype, 'hasOwnProperty')) // true\n\n\n/*\n实际上是有尽头的\n一直往原型上找的话\n最后是一个 null\n*/\n```\n\n## 例子\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nconsole.log(mike.hasOwnProperty('sayHi')) // false\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n    this.sayHi = function() {\n        console.log(`hello I'm ${this.name}`);\n    };\n}\n\nlet mike = new Person('mike');\nconsole.log(mike.hasOwnProperty('sayHi')) // true\n```\n\n所以说，`prototype` 会给每个实例对象赋予一个新的 `sayHi()` \n\n```\nfunction Person(name) {\n    this.name = name;\n\tthis.sayHi = function() {\n    \tconsole.log(`hello I'm ${this.name}`);\n\t};\n}\n\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // false\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // true\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nPerson.prototype.sayHi = function() {\n    console.log(`hi I'm ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I'm mike\n// hello I'm mike2\n// hi I'm mike\n// hi I'm mike2\n```\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nlet mike2 = new Person('mike2');\nmike.sayHi();\nmike2.sayHi();\n\nmike.sayHi = function() {\n    console.log(`hi I'm ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I'm mike\n// hello I'm mike2\n// hi I'm mike\n// hello I'm mike2\n```\n\n所以，如果要找 a 里面有没有 b 这个玩意，就一直 `a.__proto__.__proto__` ... 这个子子孙孙无穷尽也 \n\n## instanceof\n\n> 判断自定义对象的类型\n\n```\nlet arr = [1,2]\nconsole.log(arr instanceof Array)\n// 实际上就是 arr.__proto__ === Array.prototype\n```\n\n```\nlet arr = [1,2]\n\n// 实现一个 instanceof, in 是实例 fn 是构造函数\nfunction io(ins, fn) {\n    if(ins.__proto__){\n        if(ins.__proto__ === fn.prototype){\n            return true;\n        } else {\n            return io(ins.__proto__, fn);\n        }\n    }else {\n        return false;\n    }\n}\n\n/*\nfunction io(ins, fn) {\n\twhile(ins.__proto__ !== null){\n      if(ins.__proto__ === fn.prototype){\n        return true\n      }\n      ins = ins.__proto__\n\t}\n\treturn false\n}\n*/\n\n/*\nfunction io(ins, fn) {\n\tif(ins.__proto__ === fn.prototype) return true\n\telse if(ins.__proto__ === null){\n      \treturn false\n\t}\n\telse return io(ins.__proto__, fn)\n}\n*/\n\nconsole.log(io(arr, Array)); //true\nconsole.log(io(arr, Object)); //true\nconsole.log(io(arr, Number)); //false\n```\n\n## new\n\n>创建一个实例化对象，继承构造函数的一些实例和方法\n>\n>- 新生成一个对象\n>- 将构造函数的 this 指向这个新生成的对象\n>- 设置新生成对象的原型\n>- 执行构造函数\n>- 返回这个对象\n\n```\nfunction Person(name,age) {\n    this.name = name;\n\tthis.age = age;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike = new Person('mike');\nmike.sayHi()\n\n// 实现一个 new 方法\nfunction myNewObject(f, ...arg) {\n    var obj, ret, proto;\n    proto = f.prototype;\n    obj = Object.create(proto);\n    ret = f.apply(obj, arg);\n    return obj;\n}\n\n// function myNewObject(fn, ...arg) {\n// \tlet obj = {}\n// \tobj.__proto__ = fn.prototype\n// \tfn.call(obj,arg)\n// \treturn obj\n// }\n\nlet mike2 = myNewObject(Person, 'mike2', 12);\nconsole.log(mike2.name) // mike2\nmike2.sayHi(); // hello I'm mike2\nconsole.log(mike2 instanceof Person); // true\n```\n\n```\nfunction Person(name) {\n\t// 看这里，因为 this 不是那个实例化对象了\n\tif(!(this instanceof Person)) {\n        return new Person(name);\n    }\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nlet mike3 = Person('mike3');\nconsole.log(mike3) //undefined\n\n// 怎么让 mike3 也成为一个正常的实例化对象呢？\n// 看上面\n\nconsole.log(mike3.name); //mike3\nmike3.sayHi(); //hello I'm mike3\nconsole.log(mike3 instanceof Person); //true\n```\n\n## inheritance\n\n继承方法\n\n```\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I'm ${this.name}`);\n};\n\nfunction Student(name, grade) {\n\t// to-do\n\tPerson.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype); //to-do\n// Student.prototype.__proto__ = Person.prototype\n// Student.prototype.constructor = Student;\n\n// 注意如果用以下这种方法\n// Student.prototype = new Person()\n// xiaohong.__proto__ === Student.prototype\n// xiaohong.__proto__.name === undefined // 多余的东西 \n// 需要的条件是\n// xiaohong.__proto__ // Student.prototype\n// xiaohong.__proto__.__proto__ // Person.protoype\n\nStudent.prototype.study = function(){\n    console.log(\"I'm studying\");\n};\n\nlet xiaohong = new Student('xiaohong', 6);\nxiaohong.sayHi(); //hello I'm xiaohong\nxiaohong.study(); //I'm studying\nconsole.log(xiaohong.grade); //6\nconsole.log(xiaohong.name); //xiaohong\nconsole.log(xiaohong instanceof Person); //true\nconsole.log(xiaohong instanceof Student); //true\nconsole.log(xiaohong.constructor === Person); //true\n```\n\n```\n// 彩蛋 做一个 Object.create()\nif(typeof Object.create !== 'function'){\n  \tObject.create = function(obj){\n      function F(){}\n      F.prototype = obj\n      return new F()\n  \t}\n}\n```\n\n注意 `__proto__` 不是规范里面的，是浏览器的规范 `Object.getPrototype(Array) === Array.__proto__`","slug":"补基础：原型链和 prototype","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d9g001pf1xhvdpfgxiz","content":"<h1 id=\"补基础：原型链和-prototype\"><a href=\"#补基础：原型链和-prototype\" class=\"headerlink\" title=\"补基础：原型链和 prototype\"></a>补基础：原型链和 prototype</h1><p>先搞清楚两个东西</p>\n<ul>\n<li><code>__proto__</code></li>\n<li><code>prototype</code></li>\n</ul>\n<blockquote>\n<p>实例化对象的原型(<code>__proto__</code>)指向了构造函数的prototype属性</p>\n</blockquote>\n<p>例如</p>\n<pre><code>let arr = [1,2]\nlet arr2 = new Array(3,4)\n\narr.__proto__ === Array.prototype\n</code></pre><p>再举个例子</p>\n<pre><code>// Array 实际是一个构造函数\nArray.__proto__ === Function.prototype\n\n// 我们经常用到的 Array.forEach Array.push 实际上是 Function 的方法\nArray.prototype.forEach\nArray.prototype.push\n\n// 举个例子\nlet arr = [1,2]\narr.push(3)\nconsole.log(arr) // [1,2,3]\n// 利用 hasOwnProperty 的方法看看\nconsole.log(arr.hasOwnProperty(&#39;push&#39;)) // false\nconsole.log(Array.prototype.hasOwnProperty(&#39;push&#39;))\n</code></pre><p>所以说，本身 <code>arr</code> 是没有 <code>push</code> 这个方法的 ，于是就会从他的原型上找。先会找它的原型 (<code>arr.__proto__</code> 等价与在 <code>Array.prototype</code> 里面找) 。</p>\n<p> 那 <code>arr.hasOwnProperty</code> 又是怎么来的呢？</p>\n<pre><code>console.log(Object.prototype.hasOwnProperty.call(arr, &#39;hasOwnProperty&#39;)) //false\nconsole.log(Object.prototype.hasOwnProperty.call(arr.__proto__, &#39;hasOwnProperty&#39;)) //false\nconsole.log(Object.prototype.hasOwnProperty.call(Array.prototype, &#39;hasOwnProperty&#39;)) //false\n// 既然找不到，那我们可以往上一级找\n// arr.__proto__.__proto___ === Array.prototype.__proto__ === Object.prototype\n/*\n为什么 Array 是一个对象呢？\n因为是对象格式\nArray.prototype = {\n  push: function() {\n\n  }\n}\n*/\n\nconsole.log(Object.prototype.hasOwnProperty.call(Object.prototype, &#39;hasOwnProperty&#39;)) // true\n\n\n/*\n实际上是有尽头的\n一直往原型上找的话\n最后是一个 null\n*/\n</code></pre><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nconsole.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // false\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n    this.sayHi = function() {\n        console.log(`hello I&#39;m ${this.name}`);\n    };\n}\n\nlet mike = new Person(&#39;mike&#39;);\nconsole.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // true\n</code></pre><p>所以说，<code>prototype</code> 会给每个实例对象赋予一个新的 <code>sayHi()</code> </p>\n<pre><code>function Person(name) {\n    this.name = name;\n    this.sayHi = function() {\n        console.log(`hello I&#39;m ${this.name}`);\n    };\n}\n\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // false\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // true\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nPerson.prototype.sayHi = function() {\n    console.log(`hi I&#39;m ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I&#39;m mike\n// hello I&#39;m mike2\n// hi I&#39;m mike\n// hi I&#39;m mike2\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nmike.sayHi = function() {\n    console.log(`hi I&#39;m ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I&#39;m mike\n// hello I&#39;m mike2\n// hi I&#39;m mike\n// hello I&#39;m mike2\n</code></pre><p>所以，如果要找 a 里面有没有 b 这个玩意，就一直 <code>a.__proto__.__proto__</code> … 这个子子孙孙无穷尽也 </p>\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><blockquote>\n<p>判断自定义对象的类型</p>\n</blockquote>\n<pre><code>let arr = [1,2]\nconsole.log(arr instanceof Array)\n// 实际上就是 arr.__proto__ === Array.prototype\n</code></pre><pre><code>let arr = [1,2]\n\n// 实现一个 instanceof, in 是实例 fn 是构造函数\nfunction io(ins, fn) {\n    if(ins.__proto__){\n        if(ins.__proto__ === fn.prototype){\n            return true;\n        } else {\n            return io(ins.__proto__, fn);\n        }\n    }else {\n        return false;\n    }\n}\n\n/*\nfunction io(ins, fn) {\n    while(ins.__proto__ !== null){\n      if(ins.__proto__ === fn.prototype){\n        return true\n      }\n      ins = ins.__proto__\n    }\n    return false\n}\n*/\n\n/*\nfunction io(ins, fn) {\n    if(ins.__proto__ === fn.prototype) return true\n    else if(ins.__proto__ === null){\n          return false\n    }\n    else return io(ins.__proto__, fn)\n}\n*/\n\nconsole.log(io(arr, Array)); //true\nconsole.log(io(arr, Object)); //true\nconsole.log(io(arr, Number)); //false\n</code></pre><h2 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h2><blockquote>\n<p>创建一个实例化对象，继承构造函数的一些实例和方法</p>\n<ul>\n<li>新生成一个对象</li>\n<li>将构造函数的 this 指向这个新生成的对象</li>\n<li>设置新生成对象的原型</li>\n<li>执行构造函数</li>\n<li>返回这个对象</li>\n</ul>\n</blockquote>\n<pre><code>function Person(name,age) {\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nmike.sayHi()\n\n// 实现一个 new 方法\nfunction myNewObject(f, ...arg) {\n    var obj, ret, proto;\n    proto = f.prototype;\n    obj = Object.create(proto);\n    ret = f.apply(obj, arg);\n    return obj;\n}\n\n// function myNewObject(fn, ...arg) {\n//     let obj = {}\n//     obj.__proto__ = fn.prototype\n//     fn.call(obj,arg)\n//     return obj\n// }\n\nlet mike2 = myNewObject(Person, &#39;mike2&#39;, 12);\nconsole.log(mike2.name) // mike2\nmike2.sayHi(); // hello I&#39;m mike2\nconsole.log(mike2 instanceof Person); // true\n</code></pre><pre><code>function Person(name) {\n    // 看这里，因为 this 不是那个实例化对象了\n    if(!(this instanceof Person)) {\n        return new Person(name);\n    }\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike3 = Person(&#39;mike3&#39;);\nconsole.log(mike3) //undefined\n\n// 怎么让 mike3 也成为一个正常的实例化对象呢？\n// 看上面\n\nconsole.log(mike3.name); //mike3\nmike3.sayHi(); //hello I&#39;m mike3\nconsole.log(mike3 instanceof Person); //true\n</code></pre><h2 id=\"inheritance\"><a href=\"#inheritance\" class=\"headerlink\" title=\"inheritance\"></a>inheritance</h2><p>继承方法</p>\n<pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nfunction Student(name, grade) {\n    // to-do\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype); //to-do\n// Student.prototype.__proto__ = Person.prototype\n// Student.prototype.constructor = Student;\n\n// 注意如果用以下这种方法\n// Student.prototype = new Person()\n// xiaohong.__proto__ === Student.prototype\n// xiaohong.__proto__.name === undefined // 多余的东西 \n// 需要的条件是\n// xiaohong.__proto__ // Student.prototype\n// xiaohong.__proto__.__proto__ // Person.protoype\n\nStudent.prototype.study = function(){\n    console.log(&quot;I&#39;m studying&quot;);\n};\n\nlet xiaohong = new Student(&#39;xiaohong&#39;, 6);\nxiaohong.sayHi(); //hello I&#39;m xiaohong\nxiaohong.study(); //I&#39;m studying\nconsole.log(xiaohong.grade); //6\nconsole.log(xiaohong.name); //xiaohong\nconsole.log(xiaohong instanceof Person); //true\nconsole.log(xiaohong instanceof Student); //true\nconsole.log(xiaohong.constructor === Person); //true\n</code></pre><pre><code>// 彩蛋 做一个 Object.create()\nif(typeof Object.create !== &#39;function&#39;){\n      Object.create = function(obj){\n      function F(){}\n      F.prototype = obj\n      return new F()\n      }\n}\n</code></pre><p>注意 <code>__proto__</code> 不是规范里面的，是浏览器的规范 <code>Object.getPrototype(Array) === Array.__proto__</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：原型链和-prototype\"><a href=\"#补基础：原型链和-prototype\" class=\"headerlink\" title=\"补基础：原型链和 prototype\"></a>补基础：原型链和 prototype</h1><p>先搞清楚两个东西</p>\n<ul>\n<li><code>__proto__</code></li>\n<li><code>prototype</code></li>\n</ul>\n<blockquote>\n<p>实例化对象的原型(<code>__proto__</code>)指向了构造函数的prototype属性</p>\n</blockquote>\n<p>例如</p>\n<pre><code>let arr = [1,2]\nlet arr2 = new Array(3,4)\n\narr.__proto__ === Array.prototype\n</code></pre><p>再举个例子</p>\n<pre><code>// Array 实际是一个构造函数\nArray.__proto__ === Function.prototype\n\n// 我们经常用到的 Array.forEach Array.push 实际上是 Function 的方法\nArray.prototype.forEach\nArray.prototype.push\n\n// 举个例子\nlet arr = [1,2]\narr.push(3)\nconsole.log(arr) // [1,2,3]\n// 利用 hasOwnProperty 的方法看看\nconsole.log(arr.hasOwnProperty(&#39;push&#39;)) // false\nconsole.log(Array.prototype.hasOwnProperty(&#39;push&#39;))\n</code></pre><p>所以说，本身 <code>arr</code> 是没有 <code>push</code> 这个方法的 ，于是就会从他的原型上找。先会找它的原型 (<code>arr.__proto__</code> 等价与在 <code>Array.prototype</code> 里面找) 。</p>\n<p> 那 <code>arr.hasOwnProperty</code> 又是怎么来的呢？</p>\n<pre><code>console.log(Object.prototype.hasOwnProperty.call(arr, &#39;hasOwnProperty&#39;)) //false\nconsole.log(Object.prototype.hasOwnProperty.call(arr.__proto__, &#39;hasOwnProperty&#39;)) //false\nconsole.log(Object.prototype.hasOwnProperty.call(Array.prototype, &#39;hasOwnProperty&#39;)) //false\n// 既然找不到，那我们可以往上一级找\n// arr.__proto__.__proto___ === Array.prototype.__proto__ === Object.prototype\n/*\n为什么 Array 是一个对象呢？\n因为是对象格式\nArray.prototype = {\n  push: function() {\n\n  }\n}\n*/\n\nconsole.log(Object.prototype.hasOwnProperty.call(Object.prototype, &#39;hasOwnProperty&#39;)) // true\n\n\n/*\n实际上是有尽头的\n一直往原型上找的话\n最后是一个 null\n*/\n</code></pre><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nconsole.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // false\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n    this.sayHi = function() {\n        console.log(`hello I&#39;m ${this.name}`);\n    };\n}\n\nlet mike = new Person(&#39;mike&#39;);\nconsole.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // true\n</code></pre><p>所以说，<code>prototype</code> 会给每个实例对象赋予一个新的 <code>sayHi()</code> </p>\n<pre><code>function Person(name) {\n    this.name = name;\n    this.sayHi = function() {\n        console.log(`hello I&#39;m ${this.name}`);\n    };\n}\n\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // false\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nconsole.log(mike.sayHi === mike2.sayHi) // true\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nPerson.prototype.sayHi = function() {\n    console.log(`hi I&#39;m ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I&#39;m mike\n// hello I&#39;m mike2\n// hi I&#39;m mike\n// hi I&#39;m mike2\n</code></pre><pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nlet mike2 = new Person(&#39;mike2&#39;);\nmike.sayHi();\nmike2.sayHi();\n\nmike.sayHi = function() {\n    console.log(`hi I&#39;m ${this.name}`);\n};\n\nmike.sayHi();\nmike2.sayHi();\n\n// hello I&#39;m mike\n// hello I&#39;m mike2\n// hi I&#39;m mike\n// hello I&#39;m mike2\n</code></pre><p>所以，如果要找 a 里面有没有 b 这个玩意，就一直 <code>a.__proto__.__proto__</code> … 这个子子孙孙无穷尽也 </p>\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><blockquote>\n<p>判断自定义对象的类型</p>\n</blockquote>\n<pre><code>let arr = [1,2]\nconsole.log(arr instanceof Array)\n// 实际上就是 arr.__proto__ === Array.prototype\n</code></pre><pre><code>let arr = [1,2]\n\n// 实现一个 instanceof, in 是实例 fn 是构造函数\nfunction io(ins, fn) {\n    if(ins.__proto__){\n        if(ins.__proto__ === fn.prototype){\n            return true;\n        } else {\n            return io(ins.__proto__, fn);\n        }\n    }else {\n        return false;\n    }\n}\n\n/*\nfunction io(ins, fn) {\n    while(ins.__proto__ !== null){\n      if(ins.__proto__ === fn.prototype){\n        return true\n      }\n      ins = ins.__proto__\n    }\n    return false\n}\n*/\n\n/*\nfunction io(ins, fn) {\n    if(ins.__proto__ === fn.prototype) return true\n    else if(ins.__proto__ === null){\n          return false\n    }\n    else return io(ins.__proto__, fn)\n}\n*/\n\nconsole.log(io(arr, Array)); //true\nconsole.log(io(arr, Object)); //true\nconsole.log(io(arr, Number)); //false\n</code></pre><h2 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h2><blockquote>\n<p>创建一个实例化对象，继承构造函数的一些实例和方法</p>\n<ul>\n<li>新生成一个对象</li>\n<li>将构造函数的 this 指向这个新生成的对象</li>\n<li>设置新生成对象的原型</li>\n<li>执行构造函数</li>\n<li>返回这个对象</li>\n</ul>\n</blockquote>\n<pre><code>function Person(name,age) {\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike = new Person(&#39;mike&#39;);\nmike.sayHi()\n\n// 实现一个 new 方法\nfunction myNewObject(f, ...arg) {\n    var obj, ret, proto;\n    proto = f.prototype;\n    obj = Object.create(proto);\n    ret = f.apply(obj, arg);\n    return obj;\n}\n\n// function myNewObject(fn, ...arg) {\n//     let obj = {}\n//     obj.__proto__ = fn.prototype\n//     fn.call(obj,arg)\n//     return obj\n// }\n\nlet mike2 = myNewObject(Person, &#39;mike2&#39;, 12);\nconsole.log(mike2.name) // mike2\nmike2.sayHi(); // hello I&#39;m mike2\nconsole.log(mike2 instanceof Person); // true\n</code></pre><pre><code>function Person(name) {\n    // 看这里，因为 this 不是那个实例化对象了\n    if(!(this instanceof Person)) {\n        return new Person(name);\n    }\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nlet mike3 = Person(&#39;mike3&#39;);\nconsole.log(mike3) //undefined\n\n// 怎么让 mike3 也成为一个正常的实例化对象呢？\n// 看上面\n\nconsole.log(mike3.name); //mike3\nmike3.sayHi(); //hello I&#39;m mike3\nconsole.log(mike3 instanceof Person); //true\n</code></pre><h2 id=\"inheritance\"><a href=\"#inheritance\" class=\"headerlink\" title=\"inheritance\"></a>inheritance</h2><p>继承方法</p>\n<pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHi = function() {\n    console.log(`hello I&#39;m ${this.name}`);\n};\n\nfunction Student(name, grade) {\n    // to-do\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype); //to-do\n// Student.prototype.__proto__ = Person.prototype\n// Student.prototype.constructor = Student;\n\n// 注意如果用以下这种方法\n// Student.prototype = new Person()\n// xiaohong.__proto__ === Student.prototype\n// xiaohong.__proto__.name === undefined // 多余的东西 \n// 需要的条件是\n// xiaohong.__proto__ // Student.prototype\n// xiaohong.__proto__.__proto__ // Person.protoype\n\nStudent.prototype.study = function(){\n    console.log(&quot;I&#39;m studying&quot;);\n};\n\nlet xiaohong = new Student(&#39;xiaohong&#39;, 6);\nxiaohong.sayHi(); //hello I&#39;m xiaohong\nxiaohong.study(); //I&#39;m studying\nconsole.log(xiaohong.grade); //6\nconsole.log(xiaohong.name); //xiaohong\nconsole.log(xiaohong instanceof Person); //true\nconsole.log(xiaohong instanceof Student); //true\nconsole.log(xiaohong.constructor === Person); //true\n</code></pre><pre><code>// 彩蛋 做一个 Object.create()\nif(typeof Object.create !== &#39;function&#39;){\n      Object.create = function(obj){\n      function F(){}\n      F.prototype = obj\n      return new F()\n      }\n}\n</code></pre><p>注意 <code>__proto__</code> 不是规范里面的，是浏览器的规范 <code>Object.getPrototype(Array) === Array.__proto__</code></p>\n"},{"title":"补基础：对象与数组的遍历方式","date":"2017-10-22T13:40:50.000Z","_content":"# 补基础：对象与数组的遍历方式\n\n>- [Object.getOwnPropertyNames](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)\n>\n>\n>- [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n>\n>\n>- [Object.getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)\n>\n>\n>- [getOwnPropertyDescriptors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)\n\n## 数组的遍历\n\n```\nlet arr = [1, 2, 3]\n\nfor(let i = 0, len = arr.length; i < len; i++){\n  \tconsole.log(arr[i])\n}\n\narr.forEach((it, index, self) => {\n  \tconsole.log(it, index, self)\n})\n// 1 0 [1,2,3]\n// 2 1 [1,2,3]\n// 3 2 [1,2,3]\n// 等于\narr.forEach(console.log)\n```\n\n## 对象的遍历\n\n```\nlet obj = {a: 'b', c: 'd'}\n\n// 打印出\n// key a -> b\n// key c -> d\n\nfor(let key in obj) {\n  \tconsole.log(`key ${key} -> ${obj[key]}`)\n}\n\n// 要注意的是，for in 会遍历原型链上的属性\n// 但是并没有打印到 console.log(obj.toString) 这个值\n// 没有打印 key toString -> [Function: toString]\n\nObject.prototype.test = 'mytest'\n\n// key a -> b\n// key c -> d\n// key test -> mytest\n// 说明确实会遍历找到原型链上的属性\n// 那为什么 toString 没有打印出来？\n\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, 'toString'))\n// {writable: true, enumerable: false, configurable: true, value: ƒ}\n// 通过 getOwnPropertyDescriptor 看到 enumerable 的确是 false ，说明了不可枚举。 \n// 所以说 Object.prototype 里面内置的方法大多数都是不可枚举的\n```\n\n```\n// 那怎么可以只 for in 自身属性呢而不会遍历其他赋予到原型链上的属性呢？ （有的第三方库会在原型链上赋值）\n\nlet obj = {a: 'b', c: 'd'}\n\nObject.prototype.test = 'mytest'\n\nfor(let key in obj) {\n\t// 只遍历自身属性 可以加一层判断\n\tif(obj.hasOwnProperty(key)) {\n      \tconsole.log(`key ${key} -> ${obj[key]}`)\n\t}\n}\n```\n\n```\n// 看一个使用场景\nfunction validUser(obj) {\n    // 同时具有name, age属性的为合法用户\n\treturn obj.hasOwnProperty('name') && obj.hasOwnProperty('age')\n}\n\nconsole.log(validUser({name: 'mike'})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: 'xiaohong', age: 18})); // true\n```\n\n要注意不能用 `(!!obj.name && !!obj.age)` 这种方法，要考虑到 `{age: 0}` 的可能性或者其他 如：`!!0 -> false` `!!{} -> true` `!![] -> true` `!!'' -> false`\n\n```\n// 多个属性\nfunction validUser(obj) {\n    // 同时具有 name, age, sex 属性的为合法用户\n    // 若是上面那种做法，会导致多属性很麻烦\n\t// return obj.hasOwnProperty('name') && \n\t//\t      obj.hasOwnProperty('age') &&\n\t//\t      obj.hasOwnProperty('sex')\n\t// 以下为解决方法\n\treturn requiredFields.every((it) => {\n      \treturn obj.hasOwnProperty(it)\n\t})\n}\n\n// 可以先配置成一个数组, 改变量就好\nlet requiredFields = ['name', 'age', 'sex']\n\nconsole.log(validUser({name: 'mike'})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: 'xiaohong', age: 18})); // true\nconsole.log(validUser({name: 'xiaohong', age: 18, sex: 'ddd'})); // true\n```\n\n## Object.keys(obj)\n\n```\n// 另外一种遍历方法 Object.keys(obj)\nlet obj = {a: 'b', c: 'd'}\n\nObject.prototype.test = 'myTest'\n\nObject.keys(obj).forEach((key) => {\n  \tconsole.log(`key ${key} -> ${obj[key]}`)\n})\n\n// 这个方法只能遍历到自身可枚举属性，那有没有办法可以遍历到不可枚举属性呢？\n\n// 打印所有自身属性，包含不可枚举\n\nconsole.log(Object.getOwnPropertyNames(obj)) // [\"a\", \"c\", \"nonEnumerable\"]\n\nObject.getOwnPropertyNames(obj).forEach((key) => {\n  \tconsole.log(`key ${key} -> ${obj[key]}`)\n})\n\n// key a -> b\n// key c -> d\n// key nonEnumerable -> static\n\n// 设置不可枚举的方法\nObject.defineProperty(obj, 'nonEnumerable', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: 'static'\n});\n\nconsole.log(obj.nonEnumerable) // 'static'\nconsole.log(obj.hasOwnProperty('nonEnumerable')) // ture\n// 说明 obj 自身有 nonEnumerable ，设置为 static\n```\n\n## get - set\n\n数据双向绑定\n\n```\nlet obj = {a: 'b'}\n\n// 可以这样\nObject.defineProperty(obj, 'c', {\n    get() {\n    \t// business logic 业务逻辑\n    \t// if(...) {\n        //  \tthrow Error()\n    \t// } \n    \t// return 3 \n      \treturn 2\n    },\n    set() {\n   \t\t// 绑定逻辑 vue 的原理\n      \tconsole.log('setting value')\n    }\n});\n\nconsole.log(obj.c) // 在什么情况下会打印出 2 ？\nobj.c = 10         // 相当于运行了 set() 这个函数 打印出 setting value\nconsole.log(obj.c) // 仍然是 2\n\n// 也就是说可以变成一个私有变量\n```\n\n```\n// 如果要设置深层次的赋值\nobj = {\n    a: {\n        b: {\n            c: {\n                d: 3\n            }\n        }\n    }\n}\nconsole.log(obj.a.b.c.d); // 3\n\n// 用 defineProperty\nObject.defineProperty(obj, '_deep', {\n    get: function(){\n        return obj.a.b.c.d;\n    }\n});\n\nconsole.log(obj._deep); //3\n```\n\n## 怎么大小通吃\n\n```\n// 对象和数组一起遍历\nfunction _each(objOrArray, callback) {\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object array]'){\n        objOrArray.forEach(callback); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object object]'){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback(key,objOrArray[key]);\n            }\n        }\n    }  \t\n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index);  \n}); \n// 1\n// 3\n// 5\n\n_each({a: 'b', c: 'd'}, function(key, value) {\n    console.log(key + value);\n});\n// ab\n// cd\n```\n\n```\n// 设置一个上下文\nfunction _each(objOrArray, callback, ctx){\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object array]'){\n        objOrArray.forEach(callback, ctx || this); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object object]'){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback.call(ctx || this, key,objOrArray[key]);\n            }\n        }\n    }\n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index + this.a);  \n}, {a: 3}); \n// 4\n// 6\n// 8\n\n_each({a: 'b', c: 'd'}, function(key, value) {\n    console.log(key + value + this.a);\n}, {a: 'e'});\n// abe\n// cde\n```\n\n三板斧 `typeof` `Array.isArray([1,2])` `(Object.prototype.toString.call([1,2])`","source":"_posts/补基础：对象与数组的遍历方式.md","raw":"---\ntitle: 补基础：对象与数组的遍历方式\ndate: 2017-10-22 21:40:50\ntags: [JavaScript]\n---\n# 补基础：对象与数组的遍历方式\n\n>- [Object.getOwnPropertyNames](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)\n>\n>\n>- [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n>\n>\n>- [Object.getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)\n>\n>\n>- [getOwnPropertyDescriptors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)\n\n## 数组的遍历\n\n```\nlet arr = [1, 2, 3]\n\nfor(let i = 0, len = arr.length; i < len; i++){\n  \tconsole.log(arr[i])\n}\n\narr.forEach((it, index, self) => {\n  \tconsole.log(it, index, self)\n})\n// 1 0 [1,2,3]\n// 2 1 [1,2,3]\n// 3 2 [1,2,3]\n// 等于\narr.forEach(console.log)\n```\n\n## 对象的遍历\n\n```\nlet obj = {a: 'b', c: 'd'}\n\n// 打印出\n// key a -> b\n// key c -> d\n\nfor(let key in obj) {\n  \tconsole.log(`key ${key} -> ${obj[key]}`)\n}\n\n// 要注意的是，for in 会遍历原型链上的属性\n// 但是并没有打印到 console.log(obj.toString) 这个值\n// 没有打印 key toString -> [Function: toString]\n\nObject.prototype.test = 'mytest'\n\n// key a -> b\n// key c -> d\n// key test -> mytest\n// 说明确实会遍历找到原型链上的属性\n// 那为什么 toString 没有打印出来？\n\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, 'toString'))\n// {writable: true, enumerable: false, configurable: true, value: ƒ}\n// 通过 getOwnPropertyDescriptor 看到 enumerable 的确是 false ，说明了不可枚举。 \n// 所以说 Object.prototype 里面内置的方法大多数都是不可枚举的\n```\n\n```\n// 那怎么可以只 for in 自身属性呢而不会遍历其他赋予到原型链上的属性呢？ （有的第三方库会在原型链上赋值）\n\nlet obj = {a: 'b', c: 'd'}\n\nObject.prototype.test = 'mytest'\n\nfor(let key in obj) {\n\t// 只遍历自身属性 可以加一层判断\n\tif(obj.hasOwnProperty(key)) {\n      \tconsole.log(`key ${key} -> ${obj[key]}`)\n\t}\n}\n```\n\n```\n// 看一个使用场景\nfunction validUser(obj) {\n    // 同时具有name, age属性的为合法用户\n\treturn obj.hasOwnProperty('name') && obj.hasOwnProperty('age')\n}\n\nconsole.log(validUser({name: 'mike'})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: 'xiaohong', age: 18})); // true\n```\n\n要注意不能用 `(!!obj.name && !!obj.age)` 这种方法，要考虑到 `{age: 0}` 的可能性或者其他 如：`!!0 -> false` `!!{} -> true` `!![] -> true` `!!'' -> false`\n\n```\n// 多个属性\nfunction validUser(obj) {\n    // 同时具有 name, age, sex 属性的为合法用户\n    // 若是上面那种做法，会导致多属性很麻烦\n\t// return obj.hasOwnProperty('name') && \n\t//\t      obj.hasOwnProperty('age') &&\n\t//\t      obj.hasOwnProperty('sex')\n\t// 以下为解决方法\n\treturn requiredFields.every((it) => {\n      \treturn obj.hasOwnProperty(it)\n\t})\n}\n\n// 可以先配置成一个数组, 改变量就好\nlet requiredFields = ['name', 'age', 'sex']\n\nconsole.log(validUser({name: 'mike'})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: 'xiaohong', age: 18})); // true\nconsole.log(validUser({name: 'xiaohong', age: 18, sex: 'ddd'})); // true\n```\n\n## Object.keys(obj)\n\n```\n// 另外一种遍历方法 Object.keys(obj)\nlet obj = {a: 'b', c: 'd'}\n\nObject.prototype.test = 'myTest'\n\nObject.keys(obj).forEach((key) => {\n  \tconsole.log(`key ${key} -> ${obj[key]}`)\n})\n\n// 这个方法只能遍历到自身可枚举属性，那有没有办法可以遍历到不可枚举属性呢？\n\n// 打印所有自身属性，包含不可枚举\n\nconsole.log(Object.getOwnPropertyNames(obj)) // [\"a\", \"c\", \"nonEnumerable\"]\n\nObject.getOwnPropertyNames(obj).forEach((key) => {\n  \tconsole.log(`key ${key} -> ${obj[key]}`)\n})\n\n// key a -> b\n// key c -> d\n// key nonEnumerable -> static\n\n// 设置不可枚举的方法\nObject.defineProperty(obj, 'nonEnumerable', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: 'static'\n});\n\nconsole.log(obj.nonEnumerable) // 'static'\nconsole.log(obj.hasOwnProperty('nonEnumerable')) // ture\n// 说明 obj 自身有 nonEnumerable ，设置为 static\n```\n\n## get - set\n\n数据双向绑定\n\n```\nlet obj = {a: 'b'}\n\n// 可以这样\nObject.defineProperty(obj, 'c', {\n    get() {\n    \t// business logic 业务逻辑\n    \t// if(...) {\n        //  \tthrow Error()\n    \t// } \n    \t// return 3 \n      \treturn 2\n    },\n    set() {\n   \t\t// 绑定逻辑 vue 的原理\n      \tconsole.log('setting value')\n    }\n});\n\nconsole.log(obj.c) // 在什么情况下会打印出 2 ？\nobj.c = 10         // 相当于运行了 set() 这个函数 打印出 setting value\nconsole.log(obj.c) // 仍然是 2\n\n// 也就是说可以变成一个私有变量\n```\n\n```\n// 如果要设置深层次的赋值\nobj = {\n    a: {\n        b: {\n            c: {\n                d: 3\n            }\n        }\n    }\n}\nconsole.log(obj.a.b.c.d); // 3\n\n// 用 defineProperty\nObject.defineProperty(obj, '_deep', {\n    get: function(){\n        return obj.a.b.c.d;\n    }\n});\n\nconsole.log(obj._deep); //3\n```\n\n## 怎么大小通吃\n\n```\n// 对象和数组一起遍历\nfunction _each(objOrArray, callback) {\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object array]'){\n        objOrArray.forEach(callback); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object object]'){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback(key,objOrArray[key]);\n            }\n        }\n    }  \t\n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index);  \n}); \n// 1\n// 3\n// 5\n\n_each({a: 'b', c: 'd'}, function(key, value) {\n    console.log(key + value);\n});\n// ab\n// cd\n```\n\n```\n// 设置一个上下文\nfunction _each(objOrArray, callback, ctx){\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object array]'){\n        objOrArray.forEach(callback, ctx || this); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === '[object object]'){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback.call(ctx || this, key,objOrArray[key]);\n            }\n        }\n    }\n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index + this.a);  \n}, {a: 3}); \n// 4\n// 6\n// 8\n\n_each({a: 'b', c: 'd'}, function(key, value) {\n    console.log(key + value + this.a);\n}, {a: 'e'});\n// abe\n// cde\n```\n\n三板斧 `typeof` `Array.isArray([1,2])` `(Object.prototype.toString.call([1,2])`","slug":"补基础：对象与数组的遍历方式","published":1,"updated":"2017-12-12T17:58:37.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4q0d9j001rf1xhg4u4rg6n","content":"<h1 id=\"补基础：对象与数组的遍历方式\"><a href=\"#补基础：对象与数组的遍历方式\" class=\"headerlink\" title=\"补基础：对象与数组的遍历方式\"></a>补基础：对象与数组的遍历方式</h1><blockquote>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\" target=\"_blank\" rel=\"noopener\">Object.getOwnPropertyNames</a></li>\n</ul>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener\">Object.defineProperty</a></li>\n</ul>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\" target=\"_blank\" rel=\"noopener\">Object.getOwnPropertyDescriptor</a></li>\n</ul>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\" target=\"_blank\" rel=\"noopener\">getOwnPropertyDescriptors</a></li>\n</ul>\n</blockquote>\n<h2 id=\"数组的遍历\"><a href=\"#数组的遍历\" class=\"headerlink\" title=\"数组的遍历\"></a>数组的遍历</h2><pre><code>let arr = [1, 2, 3]\n\nfor(let i = 0, len = arr.length; i &lt; len; i++){\n      console.log(arr[i])\n}\n\narr.forEach((it, index, self) =&gt; {\n      console.log(it, index, self)\n})\n// 1 0 [1,2,3]\n// 2 1 [1,2,3]\n// 3 2 [1,2,3]\n// 等于\narr.forEach(console.log)\n</code></pre><h2 id=\"对象的遍历\"><a href=\"#对象的遍历\" class=\"headerlink\" title=\"对象的遍历\"></a>对象的遍历</h2><pre><code>let obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\n// 打印出\n// key a -&gt; b\n// key c -&gt; d\n\nfor(let key in obj) {\n      console.log(`key ${key} -&gt; ${obj[key]}`)\n}\n\n// 要注意的是，for in 会遍历原型链上的属性\n// 但是并没有打印到 console.log(obj.toString) 这个值\n// 没有打印 key toString -&gt; [Function: toString]\n\nObject.prototype.test = &#39;mytest&#39;\n\n// key a -&gt; b\n// key c -&gt; d\n// key test -&gt; mytest\n// 说明确实会遍历找到原型链上的属性\n// 那为什么 toString 没有打印出来？\n\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;))\n// {writable: true, enumerable: false, configurable: true, value: ƒ}\n// 通过 getOwnPropertyDescriptor 看到 enumerable 的确是 false ，说明了不可枚举。 \n// 所以说 Object.prototype 里面内置的方法大多数都是不可枚举的\n</code></pre><pre><code>// 那怎么可以只 for in 自身属性呢而不会遍历其他赋予到原型链上的属性呢？ （有的第三方库会在原型链上赋值）\n\nlet obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\nObject.prototype.test = &#39;mytest&#39;\n\nfor(let key in obj) {\n    // 只遍历自身属性 可以加一层判断\n    if(obj.hasOwnProperty(key)) {\n          console.log(`key ${key} -&gt; ${obj[key]}`)\n    }\n}\n</code></pre><pre><code>// 看一个使用场景\nfunction validUser(obj) {\n    // 同时具有name, age属性的为合法用户\n    return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp; obj.hasOwnProperty(&#39;age&#39;)\n}\n\nconsole.log(validUser({name: &#39;mike&#39;})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // true\n</code></pre><p>要注意不能用 <code>(!!obj.name &amp;&amp; !!obj.age)</code> 这种方法，要考虑到 <code>{age: 0}</code> 的可能性或者其他 如：<code>!!0 -&gt; false</code> <code>!!{} -&gt; true</code> <code>!![] -&gt; true</code> <code>!!&#39;&#39; -&gt; false</code></p>\n<pre><code>// 多个属性\nfunction validUser(obj) {\n    // 同时具有 name, age, sex 属性的为合法用户\n    // 若是上面那种做法，会导致多属性很麻烦\n    // return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp; \n    //          obj.hasOwnProperty(&#39;age&#39;) &amp;&amp;\n    //          obj.hasOwnProperty(&#39;sex&#39;)\n    // 以下为解决方法\n    return requiredFields.every((it) =&gt; {\n          return obj.hasOwnProperty(it)\n    })\n}\n\n// 可以先配置成一个数组, 改变量就好\nlet requiredFields = [&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;]\n\nconsole.log(validUser({name: &#39;mike&#39;})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // true\nconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18, sex: &#39;ddd&#39;})); // true\n</code></pre><h2 id=\"Object-keys-obj\"><a href=\"#Object-keys-obj\" class=\"headerlink\" title=\"Object.keys(obj)\"></a>Object.keys(obj)</h2><pre><code>// 另外一种遍历方法 Object.keys(obj)\nlet obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\nObject.prototype.test = &#39;myTest&#39;\n\nObject.keys(obj).forEach((key) =&gt; {\n      console.log(`key ${key} -&gt; ${obj[key]}`)\n})\n\n// 这个方法只能遍历到自身可枚举属性，那有没有办法可以遍历到不可枚举属性呢？\n\n// 打印所有自身属性，包含不可枚举\n\nconsole.log(Object.getOwnPropertyNames(obj)) // [&quot;a&quot;, &quot;c&quot;, &quot;nonEnumerable&quot;]\n\nObject.getOwnPropertyNames(obj).forEach((key) =&gt; {\n      console.log(`key ${key} -&gt; ${obj[key]}`)\n})\n\n// key a -&gt; b\n// key c -&gt; d\n// key nonEnumerable -&gt; static\n\n// 设置不可枚举的方法\nObject.defineProperty(obj, &#39;nonEnumerable&#39;, {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: &#39;static&#39;\n});\n\nconsole.log(obj.nonEnumerable) // &#39;static&#39;\nconsole.log(obj.hasOwnProperty(&#39;nonEnumerable&#39;)) // ture\n// 说明 obj 自身有 nonEnumerable ，设置为 static\n</code></pre><h2 id=\"get-set\"><a href=\"#get-set\" class=\"headerlink\" title=\"get - set\"></a>get - set</h2><p>数据双向绑定</p>\n<pre><code>let obj = {a: &#39;b&#39;}\n\n// 可以这样\nObject.defineProperty(obj, &#39;c&#39;, {\n    get() {\n        // business logic 业务逻辑\n        // if(...) {\n        //      throw Error()\n        // } \n        // return 3 \n          return 2\n    },\n    set() {\n           // 绑定逻辑 vue 的原理\n          console.log(&#39;setting value&#39;)\n    }\n});\n\nconsole.log(obj.c) // 在什么情况下会打印出 2 ？\nobj.c = 10         // 相当于运行了 set() 这个函数 打印出 setting value\nconsole.log(obj.c) // 仍然是 2\n\n// 也就是说可以变成一个私有变量\n</code></pre><pre><code>// 如果要设置深层次的赋值\nobj = {\n    a: {\n        b: {\n            c: {\n                d: 3\n            }\n        }\n    }\n}\nconsole.log(obj.a.b.c.d); // 3\n\n// 用 defineProperty\nObject.defineProperty(obj, &#39;_deep&#39;, {\n    get: function(){\n        return obj.a.b.c.d;\n    }\n});\n\nconsole.log(obj._deep); //3\n</code></pre><h2 id=\"怎么大小通吃\"><a href=\"#怎么大小通吃\" class=\"headerlink\" title=\"怎么大小通吃\"></a>怎么大小通吃</h2><pre><code>// 对象和数组一起遍历\nfunction _each(objOrArray, callback) {\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){\n        objOrArray.forEach(callback); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback(key,objOrArray[key]);\n            }\n        }\n    }      \n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index);  \n}); \n// 1\n// 3\n// 5\n\n_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {\n    console.log(key + value);\n});\n// ab\n// cd\n</code></pre><pre><code>// 设置一个上下文\nfunction _each(objOrArray, callback, ctx){\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){\n        objOrArray.forEach(callback, ctx || this); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback.call(ctx || this, key,objOrArray[key]);\n            }\n        }\n    }\n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index + this.a);  \n}, {a: 3}); \n// 4\n// 6\n// 8\n\n_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {\n    console.log(key + value + this.a);\n}, {a: &#39;e&#39;});\n// abe\n// cde\n</code></pre><p>三板斧 <code>typeof</code> <code>Array.isArray([1,2])</code> <code>(Object.prototype.toString.call([1,2])</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"补基础：对象与数组的遍历方式\"><a href=\"#补基础：对象与数组的遍历方式\" class=\"headerlink\" title=\"补基础：对象与数组的遍历方式\"></a>补基础：对象与数组的遍历方式</h1><blockquote>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\" target=\"_blank\" rel=\"noopener\">Object.getOwnPropertyNames</a></li>\n</ul>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener\">Object.defineProperty</a></li>\n</ul>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\" target=\"_blank\" rel=\"noopener\">Object.getOwnPropertyDescriptor</a></li>\n</ul>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\" target=\"_blank\" rel=\"noopener\">getOwnPropertyDescriptors</a></li>\n</ul>\n</blockquote>\n<h2 id=\"数组的遍历\"><a href=\"#数组的遍历\" class=\"headerlink\" title=\"数组的遍历\"></a>数组的遍历</h2><pre><code>let arr = [1, 2, 3]\n\nfor(let i = 0, len = arr.length; i &lt; len; i++){\n      console.log(arr[i])\n}\n\narr.forEach((it, index, self) =&gt; {\n      console.log(it, index, self)\n})\n// 1 0 [1,2,3]\n// 2 1 [1,2,3]\n// 3 2 [1,2,3]\n// 等于\narr.forEach(console.log)\n</code></pre><h2 id=\"对象的遍历\"><a href=\"#对象的遍历\" class=\"headerlink\" title=\"对象的遍历\"></a>对象的遍历</h2><pre><code>let obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\n// 打印出\n// key a -&gt; b\n// key c -&gt; d\n\nfor(let key in obj) {\n      console.log(`key ${key} -&gt; ${obj[key]}`)\n}\n\n// 要注意的是，for in 会遍历原型链上的属性\n// 但是并没有打印到 console.log(obj.toString) 这个值\n// 没有打印 key toString -&gt; [Function: toString]\n\nObject.prototype.test = &#39;mytest&#39;\n\n// key a -&gt; b\n// key c -&gt; d\n// key test -&gt; mytest\n// 说明确实会遍历找到原型链上的属性\n// 那为什么 toString 没有打印出来？\n\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;))\n// {writable: true, enumerable: false, configurable: true, value: ƒ}\n// 通过 getOwnPropertyDescriptor 看到 enumerable 的确是 false ，说明了不可枚举。 \n// 所以说 Object.prototype 里面内置的方法大多数都是不可枚举的\n</code></pre><pre><code>// 那怎么可以只 for in 自身属性呢而不会遍历其他赋予到原型链上的属性呢？ （有的第三方库会在原型链上赋值）\n\nlet obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\nObject.prototype.test = &#39;mytest&#39;\n\nfor(let key in obj) {\n    // 只遍历自身属性 可以加一层判断\n    if(obj.hasOwnProperty(key)) {\n          console.log(`key ${key} -&gt; ${obj[key]}`)\n    }\n}\n</code></pre><pre><code>// 看一个使用场景\nfunction validUser(obj) {\n    // 同时具有name, age属性的为合法用户\n    return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp; obj.hasOwnProperty(&#39;age&#39;)\n}\n\nconsole.log(validUser({name: &#39;mike&#39;})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // true\n</code></pre><p>要注意不能用 <code>(!!obj.name &amp;&amp; !!obj.age)</code> 这种方法，要考虑到 <code>{age: 0}</code> 的可能性或者其他 如：<code>!!0 -&gt; false</code> <code>!!{} -&gt; true</code> <code>!![] -&gt; true</code> <code>!!&#39;&#39; -&gt; false</code></p>\n<pre><code>// 多个属性\nfunction validUser(obj) {\n    // 同时具有 name, age, sex 属性的为合法用户\n    // 若是上面那种做法，会导致多属性很麻烦\n    // return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp; \n    //          obj.hasOwnProperty(&#39;age&#39;) &amp;&amp;\n    //          obj.hasOwnProperty(&#39;sex&#39;)\n    // 以下为解决方法\n    return requiredFields.every((it) =&gt; {\n          return obj.hasOwnProperty(it)\n    })\n}\n\n// 可以先配置成一个数组, 改变量就好\nlet requiredFields = [&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;]\n\nconsole.log(validUser({name: &#39;mike&#39;})); // false;\nconsole.log(validUser({age: 15})); // false\nconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // true\nconsole.log(validUser({name: &#39;xiaohong&#39;, age: 18, sex: &#39;ddd&#39;})); // true\n</code></pre><h2 id=\"Object-keys-obj\"><a href=\"#Object-keys-obj\" class=\"headerlink\" title=\"Object.keys(obj)\"></a>Object.keys(obj)</h2><pre><code>// 另外一种遍历方法 Object.keys(obj)\nlet obj = {a: &#39;b&#39;, c: &#39;d&#39;}\n\nObject.prototype.test = &#39;myTest&#39;\n\nObject.keys(obj).forEach((key) =&gt; {\n      console.log(`key ${key} -&gt; ${obj[key]}`)\n})\n\n// 这个方法只能遍历到自身可枚举属性，那有没有办法可以遍历到不可枚举属性呢？\n\n// 打印所有自身属性，包含不可枚举\n\nconsole.log(Object.getOwnPropertyNames(obj)) // [&quot;a&quot;, &quot;c&quot;, &quot;nonEnumerable&quot;]\n\nObject.getOwnPropertyNames(obj).forEach((key) =&gt; {\n      console.log(`key ${key} -&gt; ${obj[key]}`)\n})\n\n// key a -&gt; b\n// key c -&gt; d\n// key nonEnumerable -&gt; static\n\n// 设置不可枚举的方法\nObject.defineProperty(obj, &#39;nonEnumerable&#39;, {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: &#39;static&#39;\n});\n\nconsole.log(obj.nonEnumerable) // &#39;static&#39;\nconsole.log(obj.hasOwnProperty(&#39;nonEnumerable&#39;)) // ture\n// 说明 obj 自身有 nonEnumerable ，设置为 static\n</code></pre><h2 id=\"get-set\"><a href=\"#get-set\" class=\"headerlink\" title=\"get - set\"></a>get - set</h2><p>数据双向绑定</p>\n<pre><code>let obj = {a: &#39;b&#39;}\n\n// 可以这样\nObject.defineProperty(obj, &#39;c&#39;, {\n    get() {\n        // business logic 业务逻辑\n        // if(...) {\n        //      throw Error()\n        // } \n        // return 3 \n          return 2\n    },\n    set() {\n           // 绑定逻辑 vue 的原理\n          console.log(&#39;setting value&#39;)\n    }\n});\n\nconsole.log(obj.c) // 在什么情况下会打印出 2 ？\nobj.c = 10         // 相当于运行了 set() 这个函数 打印出 setting value\nconsole.log(obj.c) // 仍然是 2\n\n// 也就是说可以变成一个私有变量\n</code></pre><pre><code>// 如果要设置深层次的赋值\nobj = {\n    a: {\n        b: {\n            c: {\n                d: 3\n            }\n        }\n    }\n}\nconsole.log(obj.a.b.c.d); // 3\n\n// 用 defineProperty\nObject.defineProperty(obj, &#39;_deep&#39;, {\n    get: function(){\n        return obj.a.b.c.d;\n    }\n});\n\nconsole.log(obj._deep); //3\n</code></pre><h2 id=\"怎么大小通吃\"><a href=\"#怎么大小通吃\" class=\"headerlink\" title=\"怎么大小通吃\"></a>怎么大小通吃</h2><pre><code>// 对象和数组一起遍历\nfunction _each(objOrArray, callback) {\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){\n        objOrArray.forEach(callback); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback(key,objOrArray[key]);\n            }\n        }\n    }      \n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index);  \n}); \n// 1\n// 3\n// 5\n\n_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {\n    console.log(key + value);\n});\n// ab\n// cd\n</code></pre><pre><code>// 设置一个上下文\nfunction _each(objOrArray, callback, ctx){\n    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){\n        objOrArray.forEach(callback, ctx || this); \n    }\n    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){\n        for(let key in objOrArray){\n            if(objOrArray.hasOwnProperty(key)){\n                callback.call(ctx || this, key,objOrArray[key]);\n            }\n        }\n    }\n}\n\n_each([1,2,3], function(it, index) {\n    console.log(it + index + this.a);  \n}, {a: 3}); \n// 4\n// 6\n// 8\n\n_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {\n    console.log(key + value + this.a);\n}, {a: &#39;e&#39;});\n// abe\n// cde\n</code></pre><p>三板斧 <code>typeof</code> <code>Array.isArray([1,2])</code> <code>(Object.prototype.toString.call([1,2])</code></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjb4q0d770001f1xhc1sveuyy","tag_id":"cjb4q0d7m0004f1xh9z39axy1","_id":"cjb4q0d87000af1xhtcq29y53"},{"post_id":"cjb4q0d7h0003f1xh6ansculi","tag_id":"cjb4q0d860009f1xhehb7bf58","_id":"cjb4q0d8g000if1xh25f2wgsr"},{"post_id":"cjb4q0d7h0003f1xh6ansculi","tag_id":"cjb4q0d8c000df1xhil0b9x4d","_id":"cjb4q0d8i000kf1xhp7wca5a9"},{"post_id":"cjb4q0d7q0006f1xh1u6c15pj","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d8j000nf1xhompwdyfi"},{"post_id":"cjb4q0d810007f1xh6vx6phzl","tag_id":"cjb4q0d8i000lf1xhfwzh13u3","_id":"cjb4q0d8q000rf1xh273hax5t"},{"post_id":"cjb4q0d840008f1xhjzmc6k3w","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d8u000vf1xh3b2lv03c"},{"post_id":"cjb4q0d87000bf1xhha3nlsgs","tag_id":"cjb4q0d8u000uf1xhbm3ygyv2","_id":"cjb4q0d950016f1xh5bylh1it"},{"post_id":"cjb4q0d87000bf1xhha3nlsgs","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d970018f1xhsgfz800d"},{"post_id":"cjb4q0d87000bf1xhha3nlsgs","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d99001bf1xh73hxn98b"},{"post_id":"cjb4q0d940015f1xhrfi2pgce","tag_id":"cjb4q0d7m0004f1xh9z39axy1","_id":"cjb4q0d9a001df1xh3otaooet"},{"post_id":"cjb4q0d950017f1xh5qaz5y67","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9c001gf1xhi9ddtuat"},{"post_id":"cjb4q0d98001af1xh7z1iya5l","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9d001if1xhbm99lbtm"},{"post_id":"cjb4q0d8a000cf1xh0k2v72mh","tag_id":"cjb4q0d8u000uf1xhbm3ygyv2","_id":"cjb4q0d9e001lf1xhe7h2nkh5"},{"post_id":"cjb4q0d8a000cf1xh0k2v72mh","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9g001nf1xhszfu5939"},{"post_id":"cjb4q0d8a000cf1xh0k2v72mh","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9j001qf1xhwcsa7qw9"},{"post_id":"cjb4q0d9c001hf1xhbyobvsru","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9k001sf1xhrpiwwr1h"},{"post_id":"cjb4q0d9d001kf1xhp00pb137","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9l001uf1xhtm3slvc9"},{"post_id":"cjb4q0d9f001mf1xhgwkmovpo","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9l001vf1xhe55m8nf0"},{"post_id":"cjb4q0d9g001pf1xhvdpfgxiz","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9m001xf1xhl5fhn7gn"},{"post_id":"cjb4q0d8c000ef1xh0pzdmugu","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0d9m001yf1xh7hh90cqz"},{"post_id":"cjb4q0d8c000ef1xh0pzdmugu","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9o0020f1xhfxt1mbzm"},{"post_id":"cjb4q0d9j001rf1xhg4u4rg6n","tag_id":"cjb4q0d8f000gf1xh1ikpeww9","_id":"cjb4q0d9o0021f1xh9xb41p33"},{"post_id":"cjb4q0d8e000ff1xhkdzwsw43","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0d9p0023f1xhhcviwmg3"},{"post_id":"cjb4q0d8e000ff1xhkdzwsw43","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9p0024f1xhyyqoyyr3"},{"post_id":"cjb4q0d8f000hf1xhu5zj9bn9","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0d9q0026f1xhcx6sunz1"},{"post_id":"cjb4q0d8f000hf1xhu5zj9bn9","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9q0027f1xhvj73j6cq"},{"post_id":"cjb4q0d8h000jf1xhzzemlbl5","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0d9r002af1xhxuquua5c"},{"post_id":"cjb4q0d8h000jf1xhzzemlbl5","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9r002bf1xhq1asn5wh"},{"post_id":"cjb4q0d8i000mf1xh62uvwmuk","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0d9s002ef1xh9w5wlzs4"},{"post_id":"cjb4q0d8i000mf1xh62uvwmuk","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9t002ff1xhorg770gf"},{"post_id":"cjb4q0d8k000of1xhtir0fwe1","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0d9u002if1xhhefansji"},{"post_id":"cjb4q0d8k000of1xhtir0fwe1","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9u002jf1xhi9ect3sq"},{"post_id":"cjb4q0d8l000pf1xh19adjq4m","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0d9v002mf1xhswo9budn"},{"post_id":"cjb4q0d8l000pf1xh19adjq4m","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9v002nf1xhjc7f5xo4"},{"post_id":"cjb4q0d8q000sf1xhzkeubous","tag_id":"cjb4q0d9u002lf1xhjil2ae08","_id":"cjb4q0d9w002qf1xhyk5y451h"},{"post_id":"cjb4q0d8q000sf1xhzkeubous","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9w002rf1xhugy17zrp"},{"post_id":"cjb4q0d8s000tf1xh8tfrp4e9","tag_id":"cjb4q0d9v002pf1xhqd3i9xmw","_id":"cjb4q0d9x002uf1xhj1gq8ilm"},{"post_id":"cjb4q0d8s000tf1xh8tfrp4e9","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9x002vf1xhwbf5t7n0"},{"post_id":"cjb4q0d8u000wf1xh1nfg3c9b","tag_id":"cjb4q0d9v002pf1xhqd3i9xmw","_id":"cjb4q0d9y002yf1xhoj8vct9v"},{"post_id":"cjb4q0d8u000wf1xh1nfg3c9b","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9y002zf1xhhgt07s27"},{"post_id":"cjb4q0d8w000xf1xhs3pyl1t8","tag_id":"cjb4q0d9v002pf1xhqd3i9xmw","_id":"cjb4q0d9z0032f1xhza5dqinp"},{"post_id":"cjb4q0d8w000xf1xhs3pyl1t8","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0d9z0033f1xh8jk75u8q"},{"post_id":"cjb4q0d8x000zf1xhhys0yugk","tag_id":"cjb4q0d9y0031f1xh9mgdb6js","_id":"cjb4q0da00036f1xhbd187fey"},{"post_id":"cjb4q0d8x000zf1xhhys0yugk","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0da00037f1xh85pjbezt"},{"post_id":"cjb4q0d8y0010f1xhudtmgse1","tag_id":"cjb4q0d9y0031f1xh9mgdb6js","_id":"cjb4q0da1003af1xhx2idrdo3"},{"post_id":"cjb4q0d8y0010f1xhudtmgse1","tag_id":"cjb4q0d8z0011f1xh1xsc065c","_id":"cjb4q0da1003bf1xh43b83dyq"},{"post_id":"cjb4q0d900012f1xhaeg4kdak","tag_id":"cjb4q0d7m0004f1xh9z39axy1","_id":"cjb4q0da1003df1xht6sddne6"},{"post_id":"cjb4q0d900012f1xhaeg4kdak","tag_id":"cjb4q0da10039f1xhgrq03pq2","_id":"cjb4q0da1003ef1xhmxjmu4n7"},{"post_id":"cjb4q0d910013f1xh5r2ufqiy","tag_id":"cjb4q0da1003cf1xhibjz8dbg","_id":"cjb4q0da2003gf1xhi5hfgzbj"},{"post_id":"cjb4q0d99001cf1xhbhrezk17","tag_id":"cjb4q0d9d001jf1xhm4yus1yy","_id":"cjb4q0da4003if1xhk7efhsva"},{"post_id":"cjb4q0d9b001ff1xhaz5bxs3o","tag_id":"cjb4q0d7m0004f1xh9z39axy1","_id":"cjb4q0da4003jf1xhmzj83dnu"},{"post_id":"cjb4q0d9b001ff1xhaz5bxs3o","tag_id":"cjb4q0da10039f1xhgrq03pq2","_id":"cjb4q0da4003kf1xhdwc7vwpw"}],"Tag":[{"name":"Node","_id":"cjb4q0d7m0004f1xh9z39axy1"},{"name":"Linux","_id":"cjb4q0d860009f1xhehb7bf58"},{"name":"Git","_id":"cjb4q0d8c000df1xhil0b9x4d"},{"name":"JavaScript","_id":"cjb4q0d8f000gf1xh1ikpeww9"},{"name":"fq","_id":"cjb4q0d8i000lf1xhfwzh13u3"},{"name":"ES6","_id":"cjb4q0d8u000uf1xhbm3ygyv2"},{"name":"Black History","_id":"cjb4q0d8z0011f1xh1xsc065c"},{"name":"React","_id":"cjb4q0d9d001jf1xhm4yus1yy"},{"name":"TypeScript","_id":"cjb4q0d9u002lf1xhjil2ae08"},{"name":"Vue","_id":"cjb4q0d9v002pf1xhqd3i9xmw"},{"name":"webpack","_id":"cjb4q0d9y0031f1xh9mgdb6js"},{"name":"HTTP","_id":"cjb4q0da10039f1xhgrq03pq2"},{"name":"Interview","_id":"cjb4q0da1003cf1xhibjz8dbg"}]}}