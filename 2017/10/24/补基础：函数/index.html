<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 补基础：函数 · 付林恒的博客</title><meta name="description" content="补基础：函数 - Frankie Tang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="付林恒的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/frankietang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">补基础：函数</h1><div class="post-info">Oct 24, 2017</div><div class="post-content"><h1 id="补基础：函数"><a href="#补基础：函数" class="headerlink" title="补基础：函数"></a>补基础：函数</h1><blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="external">函数</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments" target="_blank" rel="external">实参</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" target="_blank" rel="external">length</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">call</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external">apply</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">bind</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">Generator Function</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Generator</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" target="_blank" rel="external">迭代器协议</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" rel="external">for of</a></li>
</ul>
</blockquote>
<h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><pre><code class="1">function fn() {
      console.log(1)
}

fn() // 1

// 传东西
function fn(num, fn) {
      console.log(fn(num))
}

fn(1, function(a){
      return a + 1
}) // 2
</code></pre>
<pre><code>// whether fn is function
function fn() {}

console.log(typeof fn === &#39;function&#39;)
console.log(fn instanceof Function)
console.log(Object.prototype.toString.call(fn) === &#39;[object Function]&#39;)
</code></pre><pre><code>// 函数调用和没调用的区别
function fn2() {
      return 2
}

fn2()

let obj = {
      fn: fn2
}

console.log(obj.fn)     // 返回是一个函数
console.log(obj.fn())   // 返回函数的结果
</code></pre><pre><code>// 函数的借用
let user = {
      name: &#39;xiaohong&#39;,
      sayHi: function() {
          console.log(&#39;hello my name is &#39; + this.name)
      }
}

uesr.sayHi()  // hello my name is xiaohong

// 怎么借用方法
let user2 = {name: &#39;xiaohei&#39;}
// to-do
user.sayHi.call(user2)
// hello my name is xiaohong


setTimeout(function() {
      console.log(&#39;hello&#39;)
}, 1000)

// 怎么写成一行呢？
setTimeout(console.log.bind(null, &#39;hello&#39;), 1000)

// 举个实用场景
// var collection = document.getElementsByClassName(&#39;a&#39;)
// 但是 collection 没有 forEach 方法
// Array.prototype.forEach.call(collection)
</code></pre><h2 id="形参-parameters-vs-实参-arguments"><a href="#形参-parameters-vs-实参-arguments" class="headerlink" title="形参(parameters) vs 实参(arguments)"></a>形参(parameters) vs 实参(arguments)</h2><p>实参是实际传进来的参数</p>
<p>形参是定义时候的参数</p>
<pre><code class="javascrip">// arguments
function fn(a, b) {
    console.log(a, b)
      console.log(arguments)
      console.log(arguments.length)
}

function fn(a, b, ...args) {
    console.log(a, b)
      console.log(args)   // [3,4]
      let args1 = Array.prototype.slice.call(arguments, 2)
      console.log(args1)  // [3,4]
}

fn(1,2,3,4)
// 1 2
// { &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3, &#39;3&#39;: 4 }
// 4

let arr = [1,2,3]
arr.push(1,2,3,4,5)
console.log(arr)

Array.prototype.push = function() {
    // arguments
      let args = Array.prototype.slice.call(arguments)
}
</code></pre>
<pre><code>// parameters
function fn(a, b) {
      console.log(arguments.length)
}

fn(1,2,3,4)
console.log(fn.length) // 2 形参个数 = 函数名.length

// 实现一个功能
function sum(a, b, c) {
      return a + b + c
}

console.log(sum(1,2,3))

// fn 是一个函数
function curry(fn) {
    var len = fn.length
      return function f1() {
          let args = Array.prototype.slice.call(arguments)
          if(args.length &lt; len) {
              return function() {
                  let args2 = Array.prototype.slice.call(arguments)
                  return f1.apply(this, args.concat(args2))
              }
          } else {
              return fn.apply(null,args)
          }
      }
}

let sumWithCurry = curry(sum) 
sumWithCurry(1,2,3)   // 6 len = 3, args.length = 3 sum.apply(null,[1,2,3])
sumWithCurry(1)(2,3)  // 6

// 先运行 sumWithCurry(1) 然后吃掉后面的函数 利用 concat 

sumWithCurry(1,2)(3)  // 6
</code></pre><p><a href="https://github.com/n0ruSh/the-art-of-reading/issues/5" target="_blank" rel="external">柯里化</a></p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h2><pre><code>// 在 function 加一个 * 号就可以变成一个 Generator 函数
function* fn() {
      yield 3;
      yield 4;
      // console.log(&#39;hello&#39;)
}

console.log(typeof fn)     // function
console.log(fn())          // {}
let iterator = fn()
console.log(iterator.next())  // {value: 3, done: false}
console.log(iterator.next())  // {value: 4, done: false}
console.log(iterator.next())  // {value: undefined, done: true}
// 3 -&gt; 4 -&gt; done

for(let i of fn()) {  // for of 遍历方法，可以遍历数组
      console.log(i)
}
// 3
// 4

// 看看是怎么做到的
let arr = [2,3,4]
let iterator = arr[Symbol.iterator]()
console.log(iterator.next()) // {value: 2, done: false}
console.log(iterator.next()) // {value: 3, done: false}
console.log(iterator.next()) // {value: 4, done: false}
console.log(iterator.next()) // {value: undefined, done: true}
// 只要符合迭代器 就可以用 for of 方法
for(let j of iterator) {
      console.log(j)
}

// 也可以遍历对象
Object.defineProperty(Object.prototype, Symbol.iterator, {
      enumerable: false,
      writable: false,
      configurable: false,
      value: function() {
          let self = this;
          let keys = Object.keys(self); // [&#39;a&#39;, &#39;d&#39;]
          let index = 0;
          return {
              next: function() {
                  return {
                      value: self[keys[index++]],  // 加点注释啥的 + &#39;suffix&#39;
                      done: index &gt; keys.length
                  }
              }
          }
      }
})

let obj = {a: &#39;b&#39;, c: &#39;d&#39;}

let iterator2 = obj[Symbol.iterator]()
console.log(iterator2.next()) // {value: &#39;b&#39;, done: false}
console.log(iterator2.next()) // {value: &#39;d&#39;, done: false}
console.log(iterator2.next()) // {value: undefined, done: true}

for(let val of obj) {
      console.log(val)
}

let obj2 = {name: &#39;xiaohong&#39;, age: 20, sex: &#39;male&#39;}
for(let j of obj2) {  // 只要支持迭代器协议就可以了
      console.log(j)
}
</code></pre><pre><code>// 彩蛋 和 Promise 的比较

// Promise
new Promise()
.then()
.then()
.then()

// yield + generator
let a = yield promise1
let b = yield promise2
let c = yield promise3
// 看起来像是同步，实际上是异步
</code></pre><pre><code>// 彩蛋2 为什么不支持 for of 遍历对象
// 原因有可能是这样的
// 数组不关心索引，对象关心

let arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] = {
      &#39;0&#39; : &#39;a&#39;,
      &#39;1&#39; : &#39;b&#39;,
      &#39;2&#39; : &#39;c&#39;,
}

let obj = {
      &#39;a&#39;: &#39;b&#39;,
      &#39;c&#39;: &#39;d&#39;
}
</code></pre><p>其实有两个新方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="external">Object.values()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="external">Object.entries()</a> 可以遍历，Object.values() 只返回 value ，Object.entries() 返回全部</p>
<pre><code>// 彩蛋3 Symbol 是用来干嘛的？
// 避免相等的值重复
let a = &#39;a&#39;
let b = &#39;a&#39;

let obj = {}
obj[a]
obj[b]
</code></pre><p><a href="http://www.infoq.com/cn/articles/es6-in-depth-symbols" target="_blank" rel="external">深入浅出ES6（八）：Symbols</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/25/deepin shadowsocks-qt5 全局翻了个墙/" class="prev">PREV</a><a href="/2017/10/22/补基础：对象与数组的遍历方式/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2017/10/24/补基础：函数/';
var disqus_title = '补基础：函数';
var disqus_url = 'http://yoursite.com/2017/10/24/补基础：函数/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="http://yoursite.com">Frankie Tang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>