<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 摸到 ES6 的门把手 · 付林恒的博客</title><meta name="description" content="摸到 ES6 的门把手 - Frankie Tang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="付林恒的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/frankietang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">摸到 ES6 的门把手</h1><div class="post-info">Oct 14, 2017</div><div class="post-content"><h1 id="ES-6标准入门（个人笔记）"><a href="#ES-6标准入门（个人笔记）" class="headerlink" title="ES 6标准入门（个人笔记）"></a>ES 6标准入门（个人笔记）</h1><h2 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1.let 和 const"></a>1.<code>let</code> 和 <code>const</code></h2><p>主要是解决作用域问题。</p>
<h3 id="1-1let"><a href="#1-1let" class="headerlink" title="1.1let"></a>1.1<code>let</code></h3><h4 id="1-1-1for-循环"><a href="#1-1-1for-循环" class="headerlink" title="1.1.1for 循环"></a>1.1.1for 循环</h4><pre><code>//在 var 里
var a = 0
for (var i = 0;i &lt; 10;i++) {
  console.log(i)//10
}
console.log(i)//10
</code></pre><pre><code>//而在 let 则不一样
let a = 0
for (let i = 0;i &lt; 10;i++) {
  console.log(i)//10
}
console.log(i)//undefined
//等于
var a = 0
for (var _i = 0;_i &lt; 10;_i++) {
  console.log(_i)
}
console.log(i)
</code></pre><h4 id="1-1-2块级作用域"><a href="#1-1-2块级作用域" class="headerlink" title="1.1.2块级作用域"></a>1.1.2块级作用域</h4><pre><code>function f1() {
  var n = 5
  if (true) {
    var n = 10
  }
  console.log(n)//10
}
f1()
</code></pre><pre><code>//而在 let 里面，会偷梁换柱
function f1() {
  let n = 5
  if (true) {
    let n = 10
  }
  console.log(n)//5
}
//相当于
function f1() {
  var n = 5
  if (true) {
    var _n = 10
  }
  console.log(n)//5
}
//换掉了变量名
</code></pre><h3 id="1-2const"><a href="#1-2const" class="headerlink" title="1.2const"></a>1.2<code>const</code></h3><pre><code>//这样写会报错
const b = 0
b = 1
//这样写反而不会报错
const c = {
  a:1
}
c.a = 2
//为什么呢？
//因为 b 指向了另外一个地方
//用 const 赋值的时候，b 是 only 的。
//而 c.a 并没有改变 c 的指向
//如果是
/*
c = {a:2}
*/
//这样就会报错，指向另外一个地方了
</code></pre><p>const 能在块级作用域里吗？</p>
<pre><code>    const C = &#39;c&#39;;
    const s = () =&gt; {
        const C = &#39;s&#39;;
        return {
            a: &#39;hello world&#39;
        }
    }
    //相当于
    var C = &#39;c&#39;;
    var s = function s() {
        var C = &#39;s&#39;;
        return {
            a: &#39;hello world&#39;
        };
    };
</code></pre><p>是可以的。</p>
<h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h2><h3 id="2-1基本用法"><a href="#2-1基本用法" class="headerlink" title="2.1基本用法"></a>2.1基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>
<p>解构赋值是讲究叶子节点的。</p>
<pre><code>//一个简单的例子
let [a,b,c] = [1,2,3]
//相当于
var a = 1,
    b = 2,
    c = 3
</code></pre><pre><code>//我们再来看一个例子
let { d,e }={ d:1, e:2 }
//相当于
var _d$e = { d:1,e:2 },
    d = _d$e.d
    e = _d$e.e
</code></pre><h3 id="2-2深度解构"><a href="#2-2深度解构" class="headerlink" title="2.2深度解构"></a>2.2深度解构</h3><pre><code>//例子
let obj = {
  p: [
    &#39;Hello&#39;,
    {y:&#39;World&#39;}
  ]
}

let { p:[x,{ y }] } = obj
//相当于
var obj = {
  p: [&#39;Hello&#39;,{ y:&#39;World&#39; }]
}

var _obj$p = _slicedToArray(obj.p,2),
    x = _obj$p[0],
    y = _obj$p[1].y

//_slicedToArray 只是一个方法，了解就好
//先把 obj 给克隆下来，层级展开，其实就是递归
</code></pre><pre><code>//_slicedToArray
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[&quot;return&quot;]) _i[&quot;return&quot;](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance&quot;); } }; }()
</code></pre><h3 id="2-3应用"><a href="#2-3应用" class="headerlink" title="2.3应用"></a>2.3应用</h3><h4 id="2-3-1function-add-a-b-return-a-b"><a href="#2-3-1function-add-a-b-return-a-b" class="headerlink" title="2.3.1function add(a,b){return a+b}"></a>2.3.1<code>function add(a,b){return a+b}</code></h4><pre><code>//传入数组相加
function add([x,y]){
  return x+y
}
add([1,2])//3
//相当于
function add(_ref){
  var _ref2 = _slicedToArray(_ref,2),
        x = _ref2[0],
        y = _ref2[1]

  return x + y
}

add([1,2])//3
</code></pre><h4 id="2-3-2字符串解构"><a href="#2-3-2字符串解构" class="headerlink" title="2.3.2字符串解构"></a>2.3.2字符串解构</h4><pre><code>const [a1,b1,c1,d1,e1] = &#39;hello&#39;
//相当于
var _hello = &#39;hello&#39;,
    _hello2 = _slicedToArray(_hello,5),
    a1 = _hello2[0],
    b1 = _hello2[1],
    c1 = _hello2[2],
    d1 = _hello2[3],
    e1 = _hello2[4]
</code></pre><h4 id="2-3-3-rest-解构"><a href="#2-3-3-rest-解构" class="headerlink" title="2.3.3 rest 解构"></a>2.3.3 rest 解构</h4><pre><code>const { p,...rest } = {p:1,a:2,c:2}
console.log(rest) // {a:2,c:2}
//相当于
var _p$a$c = {p:1,a:2,c:2},
    p = _p$a$c.p,
    rest = _objectWithoutProperties(_p$a$c,[&#39;p&#39;])
console.log(rest)//{a:2, c:2}
//_objectWithoutProperties 也是一个方法，知道就好
</code></pre><pre><code>//_objectWithoutProperties
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) &gt;= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
</code></pre><pre><code>//最后一个例子
function add({
  name,
  list:[x,y]
}){
  return name+y
}
add({name:&#39;tangkalun&#39;,list:[&#39;21&#39;,&#39;male&#39;]})
</code></pre><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="3-1函数参数默认值"><a href="#3-1函数参数默认值" class="headerlink" title="3.1函数参数默认值"></a>3.1函数参数默认值</h3><pre><code>function log(x, y = &#39;World&#39;) {
  console.log(x, y);
}
log(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World
//相当于
function log(x) {
    var y = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &#39;World&#39;;
    console.log(x, y);
}
log(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World
</code></pre><h3 id="3-2-rest-参数"><a href="#3-2-rest-参数" class="headerlink" title="3.2 rest 参数"></a>3.2 rest 参数</h3><pre><code>function add(a, b, ...values) {
  console.log(values)
}
add(2, 5, 3) // 3
//相当于
function add(a, b) {
    for (var _len = arguments.length, values = Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {
        values[_key - 2] = arguments[_key];
    }

    console.log(values);
}
add(2, 5, 3); // 3
</code></pre><h3 id="3-3扩展运算符"><a href="#3-3扩展运算符" class="headerlink" title="3.3扩展运算符"></a>3.3扩展运算符</h3><pre><code>console.log(5,...[1, 2, 3])
//相当于
(_console = console).log.apply(_console, [5].concat([1, 2, 3]));
//注意如果 console.log(...5,[1,2,3]) 会出错
//...要放在最后一项
</code></pre><h3 id="3-4箭头函数"><a href="#3-4箭头函数" class="headerlink" title="3.4箭头函数"></a>3.4箭头函数</h3><pre><code>var f = v =&gt; v;
var f1 = v =&gt; {
  return v
}
//相当于
var f = function f(v) {
    return v;
};
var f1 = function f1(v) {
    return v;
};
</code></pre><pre><code>const pa = () =&gt; [1,2,3]
pa()
//[1,2,3]
</code></pre><pre><code>    const pa = (...args) =&gt; {
        console.log(args);
        return args.reduce((pre,cur) =&gt; {
            return pre+cur;
        }, 0);
    };
    pa.apply(this, [1,2,45]);
    //[1,2,45]
    //48
</code></pre><h4 id="3-4-1箭头函数的-this"><a href="#3-4-1箭头函数的-this" class="headerlink" title="3.4.1箭头函数的 this"></a>3.4.1箭头函数的 this</h4><pre><code>var f1 = v=&gt;{
    console.log(this)
}
var f3 = function(v){
    //this
    return v=&gt;{
        console.log(this);
    }
}
//相当于
var f1 = function f1(v) {
    console.log(undefined);
};
var f3 = function f3(v) {
    var _this = this;
    //this
    return function (v) {
        console.log(_this);
    };
};
//由于函数作用域的关系，this 的指向会指向上级作用域
//作用域没有就 undefined
//这样搞都是假 this
</code></pre><pre><code>const s = () =&gt; {
  console.log(this)
}
s()
//window
//注意 babel 环境下输出的 this 是 undefined
</code></pre><blockquote>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<h2 id="4-Promise"><a href="#4-Promise" class="headerlink" title="4. Promise"></a>4. Promise</h2></blockquote>
<pre><code>let p = new Promise((resolve,reject)=&gt;{
    setTimeout(resolve,3000,1)
})
let q = new Promise((resolve, reject) =&gt; {
    reject(&#39;not good time&#39;)
})
let pending = new Promise((resolve,reject)=&gt;{

})

// p ==&gt; fulfilled 1
// Promise的状态 fulfilled pending rejected
// Promise的值  

// 3s 后
let p1 = p.then(val=&gt;{
    val += 2;
    //return 2
    return new Promise((res, rej) =&gt; {
        res(2)
    })
}).then((val) =&gt; {
    console.log(val);
});

//只要 return 的话这个 return 的值就是 p1 的当前的状态
</code></pre><p><a href="https://www.zhihu.com/question/36972010" target="_blank" rel="external">为什么要加 setTimeout</a> 神坑，这里我也不是很懂。</p>
<p>其实我们只用知道这只是一个异步过程</p>
<pre><code>let p = new Promise((resolve,reject)=&gt;{
    setTimeout(resolve,3000,1)
})
p
//Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}
//3s 后
//Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1}
</code></pre><h2 id="5-Iterator"><a href="#5-Iterator" class="headerlink" title="5. Iterator"></a>5. Iterator</h2><pre><code>let t = [1,2,3];

for(let val of t){
    console.log(val)
};
//1 2 3
</code></pre><pre><code>const s= function(){
    for(let val of arguments){
        console.log(val)
    };
}
s(1,2,34);
//for...of 可以同时处理数组和类数组对象
//就是说，可以循环一个数据结构
</code></pre><h2 id="6-Class"><a href="#6-Class" class="headerlink" title="6. Class"></a>6. Class</h2><pre><code>//例子
class Test{
  constructor(){
    this.a = &#39;a&#39;
    this.b = &#39;b&#39;    
  }
}
//等于
let Test = function(argument){
  this.a = &#39;a&#39;
  this.b = &#39;b&#39;
}

let inst = new Test()
console.log(inst.a)
//这个例子是用 class 来实现语法转换的一个例子
</code></pre><pre><code>//实现面向对象
let Test = function(argument){
  this.a = &#39;a&#39;
  this.b = &#39;b&#39;
}
Test.prototype.c =()=&gt; {console.log(&#39;c&#39;)}

let inst = new Test()
console.log(inst.c)
//用 class 来实现
class Test{
  constructor(){
    this.a = &#39;a&#39;
    this.b = &#39;b&#39;    
  }
  c(){console.log(&#39;c&#39;)}
}
let inst = new Test()
console.log(inst.c())
//这里会有个 undefined ，因为 console.log(&#39;c&#39;) 并没有返回值
</code></pre><pre><code>//以前我们写构造函数会这样写
let Test = function(argument){
  this.a = a
  this.b = b
}
Test.prototype.c = function(){
  return &#39;ddddd&#39;
}
//用 class
class Test{
  constructor(){
    this.a = &#39;a&#39;
    this.b = &#39;b&#39;
  }
  c(){
    return &#39;ddddd&#39;
  }
}
</code></pre><p>关于 <code>super()</code> 的问题</p>
<pre><code>class TestSuper {
  constructor() {
    this.a = &#39;a&#39;
  }
}
class Test extends TestSuper {
  constructor() {
    super()
    this.b = &#39;b&#39;
  }
}
let inst = new Test()
console.log(inst.a)   //a
console.log(inst)     //Test{a:&#39;a&#39;,b:&#39;b&#39;}
</code></pre><h2 id="7-Module"><a href="#7-Module" class="headerlink" title="7. Module"></a>7. Module</h2><pre><code>//a.js
function f1(){
  let a = 1
}
export {f1}
</code></pre><pre><code>//module.js
import {f1} from &#39;./let_const.js&#39;
//相当于
var _let_const = require(&#39;./a.js&#39;)
//只有 nodejs 有 require 函数
//先把 import...form 转换成 require 的形式
//用 webpack 来处理 require 函数
</code></pre><pre><code>a.js ==&gt;  require(&#39;./b.js&#39;).kkkkk
b.js ==&gt;  require(&#39;./c.js&#39;).kkkkk
c.js ==&gt;  require(&#39;./a.js&#39;).kkkkk

AMD  define + require

webpack ==&gt; node.js的fs io体系来把所有的require依赖放在一个文件里面
bundle.js

(function(moduleArr) {
    // XXX
}[
    a.js ,
    c.js,
    d.js
])()
</code></pre><p>webpack3 会自己封装一层 require</p>
<h2 id="8-Generator"><a href="#8-Generator" class="headerlink" title="8. Generator"></a>8. Generator</h2><p>是一种异步编程解决方案</p>
<p><code>yield</code> 产出</p>
<pre><code>function* helloWorldGenerator() {
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
};
//最好仅在 nodejs 上使用 generator
//yield 执行完之后是停止的
//需要手动执行 .next()
var hw = helloWorldGenerator();
let a = hw.next();
let b = hw.next();
let c = hw.next();
console.log(a,b,c)
/*
{ value: &#39;hello&#39;, done: false } { value: &#39;world&#39;, done: false } { value: &#39;ending&#39;, done: true }
*/
</code></pre><h2 id="ES6-语法测试"><a href="#ES6-语法测试" class="headerlink" title="ES6 语法测试"></a>ES6 语法测试</h2><ul>
<li>安装babel命令行</li>
</ul>
<pre><code class="bash">$ cnpm install babel-cli
</code></pre>
<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">参考文档</a></p>
<p>第一次接触 <code>&#39;use strict&#39;</code> </p>
<p>看来踩的坑还有点少。</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="external">Javascript 严格模式详解 - 阮一峰</a></p>
<p>这只是笔记，多看看阮一峰的 ES6 文档吧。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/14/摸到 Promise 的门把手/" class="prev">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2017/10/14/摸到 ES6 的门把手/';
var disqus_title = '摸到 ES6 的门把手';
var disqus_url = 'http://yoursite.com/2017/10/14/摸到 ES6 的门把手/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="http://yoursite.com">Frankie Tang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>