<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 摸到 TypeScript 的门把手 · 付林恒的博客</title><meta name="description" content="摸到 TypeScript 的门把手 - Frankie Tang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="付林恒的博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/frankietang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">摸到 TypeScript 的门把手</h1><div class="post-info">Oct 14, 2017</div><div class="post-content"><h1 id="摸到-TypeScript-的门把手"><a href="#摸到-TypeScript-的门把手" class="headerlink" title="摸到 TypeScript 的门把手"></a>摸到 TypeScript 的门把手</h1><p><a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">TypeScript</a></p>
<h2 id="Basic-Types（原始数据类型）"><a href="#Basic-Types（原始数据类型）" class="headerlink" title="Basic Types（原始数据类型）"></a>Basic Types（原始数据类型）</h2><pre><code>let a: boolean = false;
a = &#39;hello&#39;
//这样是错的
//因为类型不兼容 要 a = true
let b: number = 1;
let c: string = &#39;1&#39;;
let e: number[] = [1,2,3];
//number[] 等于 Array&lt;number&gt;

//这里有一个新类型 Tuple
//有限长度的有限列表
let f: [string, number] = [&#39;1&#39;,2];

//Enum 一个数字的集合
enum g {
  hello = 0,
  world = 1,
}
enum g1 {
  hello,
  world,
}
//是默认012345这样赋值
//转成 JS
(function (g) {
    g[g[&quot;hello&quot;] = 0] = &quot;hello&quot;;
    g[g[&quot;world&quot;] = 1] = &quot;world&quot;;
})(g || (g = {}));
var g1;
(function (g1) {
    g1[g1[&quot;hello&quot;] = 0] = &quot;hello&quot;;
    g1[g1[&quot;world&quot;] = 1] = &quot;world&quot;;
})(g1 || (g1 = {}));
//TS2.4后可以赋值 string
enum g {
  hello = &#39;0&#39;,
  world = &#39;1&#39;,
}

//Any
//let the values pass through compile-time checks
let notSure:any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false;

//Void
function a(): void {
  alert(&#39;hello world&#39;)
}

//Never
function never1(): never {
  throw Error(&#39;Something failed&#39;)
}

//assert 断言
//Type assertion
let someValue1: any = &quot;this is a string&quot;;
let strLength1: number = (&lt;string&gt;someValue).length;
//让 String 具有 Number 的办法
</code></pre><h2 id="Variable-Declarations"><a href="#Variable-Declarations" class="headerlink" title="Variable Declarations"></a>Variable Declarations</h2><pre><code>var s = 1;
let s1 = 2;
const s2 = 3;
function s3 () {
  return 4;
} 
const s4 = () =&gt; {
  return 5；
}
</code></pre><h2 id="Interfaces（接口）"><a href="#Interfaces（接口）" class="headerlink" title="Interfaces（接口）"></a>Interfaces（接口）</h2><pre><code>interface IMap {
  a: string;
}
//type contract
let obj1: IMap = {
  a: &#39;1&#39;,
  b: 2,   //error 一定要 string
}
function sss (a: IMap): IMap{
  return a;
}

//Optional Properties
interface IOptional1 {
  a: number;
  b?: string;
}
// arg.b 有可能 undefined
function sss1(arg: IOptional1): string{
  return arg.b + &#39;&#39;
}

//Readonly properties
interface Point {
    readonly x: number;
    readonly y: number;
}
let point: IPoint = {
  x: 1, 
  y: 2,
}
//point.x = 23;
//只读属性没法定义

//Function Types
interface ISearchFunc {
    (source: string, subString: string): boolean;
}
//function(source, subString) 没有必要再定义
let mySearch: ISearchFunc = function(source: string, subString: string) {
    let result = source.search(subString);
    return result &gt; -1;
}
//Indexable Types
interface IndexType {
  [key:string]:number
}
let inst1: IndexType {
  a: &#39;1&#39;,     //error
}

//type
type aType = IndexType;
//比如说是let啊，就是类型声明对吧 type 就类似

type aaaaa = string;
let ssss: aaaaa = &#39;1&#39;

interface IPeople {
  eyes: number;
}
enum LapTopEnum {
  haiwei,
  lenovo,
  apple,
  IBM,
}
interface ImonkeyProgramer extends IPeople {
  laptop: LapTopEnum
}
let tangkalun: ImonkeyProgramer = {
  laptop: LapTopEnum.apple,
  eyes: 2,
}
</code></pre><blockquote>
<p>In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</p>
</blockquote>
<h2 id="Classes（类）"><a href="#Classes（类）" class="headerlink" title="Classes（类）"></a>Classes（类）</h2><pre><code>class A {
    a:string
    constructor() {
        this.a = &#39;1&#39;
    }
    hello(): string {
        return &#39;1&#39;;
    }
}
let instA = new A();
instA.a
//转换成 JS
var A = (function () {
    function A() {
        this.a = &#39;1&#39;;
    }
    A.prototype.hello = function () {
        return &#39;1&#39;;
    };
    return A;
}());
var instA = new A();
instA.a;
//注意 private public protect

//Inheritance
class People {
    name: string
    constructor(name: string) {
        this.name = name;
    }
}
class A extends People {
    a: string;
    constructor() {
        super(&#39;tangkalun&#39;);
        this.a = &#39;1&#39;;
    }
    hello(): string {
        return this.a;
    }
}
// class 不仅可以描述数据结构,同时他还有方法、属性等等的封装
let instA = new A();
instA.a;
instA.name;
//关于super()这个问题，是调用父类的构造函数
</code></pre><h2 id="Generics（泛型）"><a href="#Generics（泛型）" class="headerlink" title="Generics（泛型）"></a>Generics（泛型）</h2><pre><code>interface SillyBoy&lt;T&gt; {
  skills: T
}
const tangkalun: SillyBoy&lt;[&#39;string&#39;,&#39;string&#39;,&#39;string&#39;]&gt; = {
  skills: [&#39;eat&#39;,&#39;fuck&#39;,&#39;sleep&#39;]
}
const frankie: SillyBoy&lt;[string]&gt; = {
  skills: [&#39;fuck&#39;],
}
const tang: SillyBoy&lt;[undefined]&gt; = {
  skills: undefined,
}
const kalun: SillyBoy&lt;string&gt; = {
    skills: &#39;sleep&#39;,
}
</code></pre><p>先到这里吧，我太菜了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/14/摸到 React 的门把手/" class="prev">PREV</a><a href="/2017/10/14/摸到 webpack 的门把手 (2)/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2017/10/14/摸到 TypeScript 的门把手/';
var disqus_title = '摸到 TypeScript 的门把手';
var disqus_url = 'http://yoursite.com/2017/10/14/摸到 TypeScript 的门把手/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 <a href="http://yoursite.com">Frankie Tang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>