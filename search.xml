<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[补基础： node 各种知识点]]></title>
      <url>/2017/11/29/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%20node%20%E5%90%84%E7%A7%8D%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h1 id="补基础：-node-各种知识点"><a href="#补基础：-node-各种知识点" class="headerlink" title="补基础： node 各种知识点"></a>补基础： node 各种知识点</h1><p>简单带过所有开发环境</p>
<p>NVM:nvm是一个node.js版本管理器，我们将会使用nvm安装node.js的不同版本<br><a href="https://github.com/creationix/nvm#installation" target="_blank" rel="external">NVM安装指南</a></p>
<p>Node.js和npm: <a href="https://nodejs.org/dist/latest-v8.x/docs/api/" target="_blank" rel="external">Node.js官方文档</a> | <a href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwieh52Cgd_XAhUKrI8KHT9NBAoQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fnodejs%2Fnodejs-tutorial.html&amp;usg=AOvVaw2jflp9kjA1IHdV5QL7UYRB" target="_blank" rel="external">Node.js 教程| 菜鸟教程</a></p>
<p>Git: <a href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjD3buFgd_XAhUJvo8KHem-BIIQFggmMAA&amp;url=http%3A%2F%2Fwww.runoob.com%2Fgit%2Fgit-tutorial.html&amp;usg=AOvVaw2SlbSmAVE814KUmXI236qx" target="_blank" rel="external">Git 教程| 菜鸟教程</a></p>
<p>MongoDB：MongoDB是时下最流行的NoSQL数据库，<a href="https://www.mongodb.com/" target="_blank" rel="external">MongoDB官网</a> | <a href="https://docs.mongodb.com/manual/introduction/" target="_blank" rel="external">官方文档</a></p>
<p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="external">Ubuntu下安装MongoDB官方文档</a></p>
<p>Redis:运用最广的K-V数据库之一。在Ubuntu下使用 <code>sudo apt-get install redis-server</code> <a href="https://redis.io/" target="_blank" rel="external">官网</a></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="external">HTTP - MDN</a></p>
<p><a href="https://blog.zain.red/2017/11/23/http/" target="_blank" rel="external">HTTP</a></p>
<p><a href="http://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="external">关于HTTP协议，一篇就够了</a></p>
<h2 id="Git-和-Linux"><a href="#Git-和-Linux" class="headerlink" title="Git 和 Linux"></a>Git 和 Linux</h2><p>看我的旧文章 <a href="http://www.jianshu.com/p/82142a85df5d" target="_blank" rel="external">Linux 的基本命令行和 Git 的基本操作</a></p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>写一个脚本文件 show.js，满足以下需求：运行 node /path/to/show.js，输出当前目录下的所有文件。</p>
<pre><code>touch show.js
vi show.js

#!/usr/bin/env node  // 告诉 bash 用 node 运行
var fs = require(&quot;fs&quot;)
console.log(&quot;查看当前目录&quot;)
fs.readdir(process.cwd(),function(error, files){
  if(error){
    return console.error(error)
  }
  files.forEach(function(file){
    console.log(file)
  })
})

node show.js
</code></pre><p>写一个脚本文件 view.js，满足以下需求：运行 node /path/to/view.js xxx，如果 xxx 文件存在，就输出 xxx 内容；如果 xxx 文件不存在，就输出「xxx 不存在」</p>
<pre><code>touch view.js
vi view.js

#!/usr/bin/env node  // 告诉 bash 用 node 运行
var file = process.argv[2]  // 获取输入命令行第三个参数
var fs = require(&#39;fs&#39;)
fs.stat(file, function(error, stat){
  if(stat&amp;&amp;stat.isFile()) {
    console.log(&#39;文件存在&#39;)
    var data = fs.readFileSync(file, &quot;utf-8&quot;)  // 读取文件内容
    console.log(data)
  } else {
    console.log(&#39;文件不存在或不是标准文件&#39;)
  }
})

node view.js show.js
</code></pre><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>把上面那两个代码上传</p>
<pre><code>npm adduser  // 一顿操作
ls
npm init  // 一顿起名
/*
在 package.json 设置东西
&quot;bin&quot;:{
  &quot;view&quot;:&quot;view.js&quot;,
  &quot;show&quot;:&quot;show.js&quot;
}
*/
npm publish

npm i -g frankie-demo-2017-11-19
/*
新加了两行
/usr/local/bin/show -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/show.js
/usr/local/bin/view -&gt; /usr/local/lib/node_modules/frankie-demo-2017-11-19/view.js
*/
// 然后就可以全局使用 show 和 view 了

npm uninstall -g frankie-demo-2017-11-19  // 卸载掉 demo
</code></pre><p><a href="https://www.npmjs.com/package/frankie-demo-2017-11-19" target="_blank" rel="external">https://www.npmjs.com/package/frankie-demo-2017-11-19</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Node </tag>
            
            <tag> HTTP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 的基本命令行和 Git 的基本操作]]></title>
      <url>/2017/11/27/Linux%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8C%20Git%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="Linux-的基本命令行和-Git-的基本操作"><a href="#Linux-的基本命令行和-Git-的基本操作" class="headerlink" title="Linux 的基本命令行和 Git 的基本操作"></a>Linux 的基本命令行和 Git 的基本操作</h1><h2 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h2><pre><code>//进入目录
cd
//显示当前目录
pwd
//创建目录
mkdir 目录名
//创建目录
mkdir -p 目录路径
//查看路径
ls 路径
//查看路径
ls -a 路径
//查看路径
ls -l 路径
//查看路径 
ls -al 路径
//创建文件
echo &#39;1&#39; &gt; 文件路径
//创建文件
echo &#39;1&#39; &gt;! 文件路径
//创建文件
echo &#39;1&#39; &gt;&gt; 文件路径
//创建文件
touch 文件名
//改变文件更新时间
touch 文件名
//复制文件
cp 源路径 目标路径
//复制目录
cp -r 源路径 目标路径
//移动节点
mv 源路径 目标路径
//删除文件
rm 文件路径
//强制删除文件
rm -f 文件路径
//删除目录
rm -r 目录路径
//强制删除目录
rm -rf 目录路径
//查看目录结构
tree
//建立软链接
ln -s 真实文件 链接
</code></pre><h2 id="怎么把项目上传到-GitHub"><a href="#怎么把项目上传到-GitHub" class="headerlink" title="怎么把项目上传到 GitHub"></a>怎么把项目上传到 GitHub</h2><pre><code>//把项目先克隆到本地
git clone git@github.com:FRANKIETANG/Remote-Mouse.git
//把文件夹里的东西全部清除，然后运行以下命令
git add *
git commit -m ‘del’
git push origin master
//把新项目放在文件夹，再运行以下命令
git add *
git commit -m ‘intinal’
git pull origin master
git push origin master
//这样，项目就可以在 GitHub 上看到啦哈哈哈
</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="external">vim 的基本操作</a></p>
<p>自制命令行</p>
<pre><code>// ~/.bashrc

vi ~/.bashrc
alias xx = &quot;要干的事情&quot;
source ~/.bashrc
xx 

// ~/.zshrc

vi ~/.zshrc
alias xx = &quot;要干的事情&quot;
source ~/.zshrc
xx
</code></pre><p>命令行小工具</p>
<ul>
<li>z: 方便实现快速目录跳转，<a href="https://github.com/rupa/z" target="_blank" rel="external">下载在此</a></li>
<li>fzf: 方便快速搜索文件或目录，<a href="https://github.com/junegunn/fzf#installation" target="_blank" rel="external">官网在此</a></li>
</ul>
<pre><code>curl -L https://raw.githubusercontent.com/rupa/z/master/z.sh &gt; z.sh
vi ~/.zshrc
source ~/z.sh
source ~/.zshrc
z // 看到你以前去过的所有目录
z Desk // 去桌面
</code></pre><pre><code>git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
~/.fzf/install

source ~/.zshrc
fzf
// 然后就可以在命令行搜索文件了
</code></pre><pre><code>把 z 和 fzf 合在一起
vi ~/.zshrc

unalias z // 不要 z 命令
// 以下为合并命令，理解就好。把 z 换成 j 和 jj 。jj 是上一次搜索的记录
j() {
     if [[ -z &quot;$*&quot; ]]; then
         cd &quot;$(_z -l 2&gt;&amp;1 | fzf +s | sed &#39;s/^[0-9,.]* *//&#39;)&quot;
     else
         _last_z_args=&quot;$@&quot;
         _z &quot;$@&quot;
     fi
 }

 jj() {
     cd &quot;$(_z -l 2&gt;&amp;1 | sed &#39;s/^[0-9,.]* *//&#39; | fzf -q $_last_z_args)&quot;
 }

 source ~/.zshrc
</code></pre><pre><code>// 安装 yarn
sudo apt-get update &amp;&amp; sudo apt-get install yarn
</code></pre><pre><code>// 怎么看精简文档
npm i -g tldr
// tldr = too long; didn&#39;t read
// 比如看 linux 下的 less 怎么使用
man less
// 太多了
tldr less
// 就会精简
tldr npm
</code></pre><pre><code>// git 操作脱离民工三连的方法

git --version  // git 版本号


git config --global user.name xxx  // 全局设置 user.name
git config --global user.email yyy  // 全局设置 user.email
git config --global push.default simple
// 这个 simple 可以换成 matching，通常默认为是 simple 
// 意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。
// matching 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。
git config --global core.quotepath false // 防止文件名变成数字，因为有可能你的文件是中文上传的是后变成中文
git config --global push.editor &quot;vim&quot;  // 使用 vim 编辑提交信息
// 以上这些都是在编辑 ~/.gitconfig


mkdir git-demo
cd git-demo
git init  // 创建 .git 目录（本地仓库）
touch 1.txt  // 打开写点东西
git starus -sb  // ?? 1.txt  // 看文件处于什么状态
// 这个 -sb 不是傻逼的意思，s 是 summary，b 是 branch
git add .  // 将多行文字（注意是 行 文字）纳入 git 控制 
git starus -sb  // A 1.txt A 就是 ADD 的意思    M 就是改变的意思 
git commit -v  // 进入 vim 编gaibain辑，在第一行写字相当于 git commit -m &quot;&quot; 引号里的文字
git log  // 显示历史
git show  // 后面加 commit 的 ID 可以看到哪行文字改变
git remote add origin https://github.com/xxx/xxx.git  
// 与仓库建立链接，名字叫 origin，地址叫后面那个像网址一样的东西（错的）
git remote set-url origin git@github.com/xxx/xxx.git  // 更换地址
git push -u origin master  // -u 是本地的分支和远程的分支建立链接，master 是远程的分支
git clone  // 复制仓库并克隆，后面接仓库地址
git pull  // 更新本地仓库（.git）和本地文件
/*
1. git push 之前必须 git pull
2. git pull 之前必须 git commit
3. git commit 之前必须 git add
*/


// 以下命令 Google 点击第一个
git stash  // 不想提交进行了一半的工作
git branch  // 分支的新建
git checkout  // 切换分支
git merge  // 分支的合并
git reset  // 和 git checkout 差不多，细节 google
git reflog  // 用来数据恢复的
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单走一遍 node]]></title>
      <url>/2017/11/26/%E7%AE%80%E5%8D%95%E8%B5%B0%E4%B8%80%E9%81%8D%20node/</url>
      <content type="html"><![CDATA[<h1 id="简单走一遍-node"><a href="#简单走一遍-node" class="headerlink" title="简单走一遍 node"></a>简单走一遍 node</h1><p>一个 Express 便利贴项目 | 预览 <a href="http://tangkalun.top" target="_blank" rel="external">http://tangkalun.top</a> 源码 <a href="https://github.com/FRANKIETANG/Express-node" target="_blank" rel="external">https://github.com/FRANKIETANG/Express-node</a></p>
<p>详情代码看我 <a href="https://github.com/FRANKIETANG/Express-node/commits/master" target="_blank" rel="external">commit</a> </p>
<p><a href="http://expressjs.com" target="_blank" rel="external">http://expressjs.com</a></p>
<h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul>
<li>增删改查</li>
<li>便利贴可拖动</li>
<li>GitHub 登录</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h3><pre><code>npm init -y
npm install express --save
</code></pre><p>老套路，先用 express 问候一下世界</p>
<pre><code>// app.js
const express = require(&#39;express&#39;)
const app = express()

app.get(&#39;/&#39;, (req, res) =&gt; res.send(&#39;Hello World!&#39;))

app.listen(3000, () =&gt; console.log(&#39;Example app listening on port 3000!&#39;))
</code></pre><p>用 <code>node app.js</code> 成功的问候了世界</p>
<p>接下来安装 express-generator</p>
<pre><code>npm install express-generator --save-dev
</code></pre><p><code>./node_modules/express-generator/bin/express-cli.js . -f -e</code> 自动生成</p>
<pre><code>// 看看目录
tangkalun@tangkalun-PC:~/Desktop/Express-node$ ls
app.js  bin  node_modules  package.json  public  routes  views
</code></pre><pre><code>// 根据提示
npm i
npm start
</code></pre><p>换端口的方法是 <code>PORT=4000 node bin/www</code></p>
<h3 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h3><p>看以前写过的博客</p>
<h3 id="onchange"><a href="#onchange" class="headerlink" title="onchange"></a>onchange</h3><p><a href="https://www.npmjs.com/package/onchange" target="_blank" rel="external">https://www.npmjs.com/package/onchange</a> 查看当前文件状况</p>
<pre><code>&quot;build&quot;: &quot;webpack --config=src/webpack.config.js&quot;,
&quot;watch&quot;: &quot;onchange &#39;src/**/*.js&#39; &#39;src/**/*.less&#39; -- npm run build&quot;
</code></pre><h2 id="需要了解的内容有"><a href="#需要了解的内容有" class="headerlink" title="需要了解的内容有"></a><strong>需要了解的内容有</strong></h2><ul>
<li><a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="external">middleware</a></li>
<li><a href="http://expressjs.com/en/guide/using-template-engines.html" target="_blank" rel="external">template engines with Express</a></li>
<li><a href="http://expressjs.com/en/guide/routing.html" target="_blank" rel="external">Routing</a></li>
</ul>
<p>比如说一个简单的 middleware 可以这样子写</p>
<pre><code>app.use(&#39;/student&#39;, function (req, res, next) {
  res.send(&#39;hello frankie&#39;)
})
</code></pre><p>我理解的话，大概是一个类似路由的东西</p>
<p>模板引擎：<a href="https://www.npmjs.com/package/ejs" target="_blank" rel="external">https://www.npmjs.com/package/ejs</a></p>
<p>有一句话是设置路径的，很重要。是用来设置是路由还是其他公共路径下的文件不会被当成路由加载</p>
<pre><code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));
</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>没什么好说的都是以前做的轮子变形</p>
<p>不过发布订阅的确写得简单了点…</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>crud</code> <code>restful</code></p>
<ul>
<li>获取所有的 note <code>GET /api/notes  req:{}  res:{stauts: 0, data: [{},{}]} {status:1,errorMsg: &#39;失败的原因&#39;}</code></li>
<li>创建一个 note <code>POST /api/note/create  req:{note: &#39;hello world&#39;}  res:{stauts: 0}  {status:1,errorMsg: &#39;失败的原因&#39;}</code></li>
<li>修改一个 note <code>POST /api/note/edit  req:{note: &#39;new note&#39;, id:100}</code></li>
<li>删除一个 note <code>POST /api/note/delete req:{id:100}</code></li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="https://www.npmjs.com/package/sequelize" target="_blank" rel="external">https://www.npmjs.com/package/sequelize</a></p>
<p><a href="https://github.com/demopark/sequelize-docs-Zh-CN" target="_blank" rel="external">https://github.com/demopark/sequelize-docs-Zh-CN</a></p>
<pre><code>// 用 n 模块降级到 6.10.3
$ npm install --save sequelize
$ npm install --save sqlite3
</code></pre><h2 id="登录登出功能"><a href="#登录登出功能" class="headerlink" title="登录登出功能"></a>登录登出功能</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">理解OAuth 2.0</a></p>
<p><a href="https://www.npmjs.com/package/passport" target="_blank" rel="external">https://www.npmjs.com/package/passport</a> 注意文档中的 Sessions 和 Middleware</p>
<p><a href="https://www.npmjs.com/package/passport-github" target="_blank" rel="external">https://www.npmjs.com/package/passport-github</a> 注意文档中的 Configure Strategy 和 Authenticate Requests</p>
<p><a href="http://www.cnblogs.com/gabrielchen/p/5800225.html" target="_blank" rel="external">http://www.cnblogs.com/gabrielchen/p/5800225.html</a></p>
<p><a href="https://github.com/settings/applications/new" target="_blank" rel="external">https://github.com/settings/applications/new</a></p>
<p><a href="https://diamondfsd.com/article/7fc2b070-e238-4fbb-acaf-47f0e3fdaabc" target="_blank" rel="external">使用 GitHub OAuth 第三方验证登录</a></p>
<p><a href="http://www.open-open.com/lib/view/open1416812717570.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1416812717570.html</a></p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p><a href="https://github.com/FRANKIETANG/Express-node/commit/23e800fd0f76661225f5bae731cad4f22d302a6d" target="_blank" rel="external">permission - commit</a></p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>node 如何调试</p>
<pre><code>npm i -g node-inspector
node-inspector
// 然后打开他指定的端口
// 然后打开项目
node --debug bin/www
</code></pre><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>为了能让自己回想起自己的代码是啥意思，多看看自己的 commit</p>
<p>过一段时间想个更有难度的项目吧… 不应该老是做这种像 demo 一样的东西</p>
]]></content>
      
        
        <tags>
            
            <tag> Node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[补基础：事件]]></title>
      <url>/2017/11/19/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="补基础：事件"><a href="#补基础：事件" class="headerlink" title="补基础：事件"></a>补基础：事件</h1><p>什么情况下会用到事件？</p>
<ul>
<li>DOM 操作</li>
<li>服务器的事件操作</li>
</ul>
<h2 id="node-events"><a href="#node-events" class="headerlink" title="node events"></a><a href="https://nodejs.org/api/events.html" target="_blank" rel="external">node events</a></h2><p><a href="https://nodejs.org/api/events.html#events_emitter_on_eventname_listener" target="_blank" rel="external">emitter.on(eventName, listener)</a> <a href="https://nodejs.org/api/events.html#events_emitter_emit_eventname_args" target="_blank" rel="external">emitter.emit(eventName[, …args])</a></p>
<pre><code>// example.js
const EventEmitter = require(&#39;events&#39;);  // 这是 node 的一个内置模块，给 node 提供一个事件功能
const emitter = new EventEmitter();

emitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 这里这个 on 相当于 addEventListener
  console.log(`an event occurred! with response ${arg}`)
})

emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)  // 用 emit 触发事件

// node example.js
// an event occurred! with response a,b
</code></pre><p><a href="https://nodejs.org/api/events.html#events_emitter_eventnames" target="_blank" rel="external">emitter.eventNames()</a> <a href="https://nodejs.org/api/events.html#events_emitter_listenercount_eventname" target="_blank" rel="external">emitter.listenerCount(eventName)</a></p>
<pre><code>const EventEmitter = require(&#39;events&#39;);
const emitter = new EventEmitter();

emitter.on(&#39;iEvent&#39;, (...args) =&gt; {  // 1
  console.log(`an event occurred! with response ${arg}`)
});

emitter.on(&#39;iEvent&#39;, () =&gt; {  // 2
  console.log(`another event occurred!`);
})

emitter.on(&#39;newEvent&#39;, () =&gt; {
  console.log(`another event occurred!`);
})

emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  //  同时触发 1 和 2

let eNames = emitter.eventNames();
console.log(eName);  // [&#39;iEvent&#39;, &#39;newEvent&#39;]  // 返回所有注册实例的名称

let iEventListenerCount = emitter.listenerCount(&#39;iEvent&#39;);
console.log(iEventListenerCount);  // 2  // 绑定了多少个 handler
</code></pre><p><a href="https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener" target="_blank" rel="external">emitter.removeListener(eventName, listener)</a></p>
<pre><code>const EventEmitter = require(&#39;events&#39;);
const emitter = new EventEmitter();

emitter.on(&#39;iEvent&#39;, (...args) =&gt; {
  console.log(`an event occurred! with response ${args}`);
});

let handler = function() {
  console.log(`handler`);
}
emitter.on(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b   handler // 加一个 handler

emitter.removeListener(&#39;iEvent&#39;, handler);  // an event occurred! with response a,b

/* 这样做不会 remove handler 
emitter.removeListener(&#39;iEvent&#39;, function() {
  console.log(`handler`)  // an event occurred! with response a,b   handler
})
*/

emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);
</code></pre><p><a href="https://nodejs.org/api/events.html#events_emitter_once_eventname_listener" target="_blank" rel="external">emitter.once(eventName, listener)</a></p>
<pre><code>const EventEmitter = require(&#39;events&#39;);
const emitter = new EventEmitter();

/* 这样会打印两次
emitter.on(&#39;iEvent&#39;, (...args) =&gt; {
  console.log(`an event occurred! with response ${args}`);
});

emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,b
emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);  // an event occurred! with response a,b
*/

emitter.once(&#39;onceEvent&#39;, (...args) =&gt; {
  console.log(`an event occurred! with response ${args}`);
})

emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);
emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;);
// 只会触发一次
// an event occurred! with response a,b
</code></pre><h2 id="实现一个-Event"><a href="#实现一个-Event" class="headerlink" title="实现一个 Event"></a>实现一个 Event</h2><h3 id="on-和-emit"><a href="#on-和-emit" class="headerlink" title="on 和 emit"></a>on 和 emit</h3><pre><code>// on 可以想象成是一个订阅事件
// emit 可以想象成一个发布事件
// sub/pub(subscribe/publish)

function Event() {
    // todo...
    this.eventToHandlers = {}  // 设置一个空对象
}
// todo...

Event.prototype.on = function (eventName, callback) {
    if (this.eventToHandlers[eventName]) {
        this.eventToHandlers[eventName].push(callback);  // 如果已经有 callback 了就继续添加
    } else {
        this.eventToHandlers[eventName] = [callback];  // 没有的话就让 eventToHandlers[name] 变为 callback
    }
}

Event.prototype.emit = function (eventName, ...args) {
    let handlers = this.eventToHandlers[eventName] || [];  // 解决变量名字是 undefined 的问题
    for (let fn of handlers) {  // 遍历 eventName 下面的数组
        fn(...args)
    }
}


let emitter = new Event();

let handler1 = (...args) =&gt; {
    console.log(`an event occurred! with response ${args}`);
};
emitter.on(&#39;iEvent&#39;, handler1)
emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)

let handler2 = () =&gt; { console.log(`another handler2`); };
let handler3 = () =&gt; { console.log(`another handler3`); };
emitter.on(&#39;iEvent2&#39;, handler2)
emitter.on(&#39;iEvent2&#39;, handler3)
emitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)

// an event occurred! with response a,b
// another handler2
// another handler3

// 保存的数据结构的格式最好是
/*
{
  &quot;iEvent&quot;: [handler1]
  &quot;iEvent2&quot;: [handler2, handler3]
}
*/
</code></pre><h3 id="eventNames-和-listenerCount"><a href="#eventNames-和-listenerCount" class="headerlink" title="eventNames 和 listenerCount"></a>eventNames 和 listenerCount</h3><pre><code>function Event() {
    this.eventToHandlers = {}
}

Event.prototype.on = function (eventName, callback) {
    if (this.eventToHandlers[eventName]) {
        this.eventToHandlers[eventName].push(callback);
    } else {
        this.eventToHandlers[eventName] = [callback];
    }
}

Event.prototype.emit = function (eventName, ...args) {
    let handlers = this.eventToHandlers[eventName] || [];
    for (let fn of handlers) {
        fn(...args)
    }
}

// 实现 eventNames 和 listenerCount
Event.prototype.eventNames = function () {
    // return array
    return Object.keys(this.eventToHandlers);
}

Event.prototype.listenerCount = function (eventNames) {
    // return number
    // return (this.eventToHandlers[eventNames] || []).length  // 如果 this.eventToHandlers[eventNames] 没有就会取一个空数组
    return this.eventToHandlers[eventNames] ? this.eventToHandlers[eventNames].length : 0;
}

let emitter = new Event();

let handler1 = (...args) =&gt; {
    console.log(`an event occurred! with response ${args}`);
};
emitter.on(&#39;iEvent&#39;, handler1)
emitter.emit(&#39;iEvent&#39;, &#39;a&#39;, &#39;b&#39;)

let handler2 = () =&gt; { console.log(`another handler2`); };
let handler3 = () =&gt; { console.log(`another handler3`); };
emitter.on(&#39;iEvent2&#39;, handler2)
emitter.on(&#39;iEvent2&#39;, handler3)
emitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)

console.log(emitter.eventNames());  // [&#39;iEvent&#39;, &#39;iEvent2&#39;]
console.log(emitter.listenerCount(&#39;iEvent2&#39;));  // 2
console.log(emitter.listenerCount(&#39;abc&#39;));  // 做一个处理 0
</code></pre><h3 id="removeListener"><a href="#removeListener" class="headerlink" title="removeListener"></a>removeListener</h3><pre><code>function Event() {
    this.eventToHandlers = {}
}

Event.prototype.on = function (eventName, callback) {
    if (this.eventToHandlers[eventName]) {
        this.eventToHandlers[eventName].push(callback);
    } else {
        this.eventToHandlers[eventName] = [callback];
    }
}

Event.prototype.emit = function (eventName, ...args) {
    let handlers = this.eventToHandlers[eventName] || [];
    for (let fn of handlers) {
        fn(...args)
    }
}

// 实现一个 removeListener
Event.prototype.removeListener = function (eventName, fn) {
    let handlers = this.eventToHandlers[eventName];
    let index = handlers.indexOf(fn);
    if (index &gt; -1) {
        handlers.splice(index, 1)
    }
}

let emitter = new Event();

let handler2 = () =&gt; { console.log(`another handler2`); };
let handler3 = () =&gt; { console.log(`another handler3`); };
emitter.on(&#39;iEvent2&#39;, handler2)
emitter.on(&#39;iEvent2&#39;, handler3)
emitter.removeListener(&#39;iEvent2&#39;, handler3)
emitter.emit(&#39;iEvent2&#39;, &#39;c&#39;, &#39;d&#39;)

// another handler2
</code></pre><h3 id="once"><a href="#once" class="headerlink" title="once"></a>once</h3><pre><code>function Event() {
    this.eventToHandlers = {}
}

Event.prototype.on = function (eventName, callback) {
    if (this.eventToHandlers[eventName]) {
        this.eventToHandlers[eventName].push(callback);
    } else {
        this.eventToHandlers[eventName] = [callback];
    }
}

Event.prototype.emit = function (eventName, ...args) {
    let handlers = this.eventToHandlers[eventName] || [];
    for (let fn of handlers) {
        fn(...args)
    }
}

Event.prototype.removeListener = function (eventName, fn) {
    let handlers = this.eventToHandlers[eventName];
    let index = handlers.indexOf(fn);
    if (index &gt; -1) {
        handlers.splice(index, 1)
    }
}

// 实现一个 once
Event.prototype.once = function (eventName, callback) {
    // 触发之后删除掉
    let handler = (...args) =&gt; {
        callback(...args)
        this.removeListener(eventName, handler)
    }
    this.on(eventName, handler)
}

let emitter = new Event();


let handler4 = () =&gt; { console.log(`another handler4`); }
emitter.once(&#39;iEvent4&#39;, handler4)
emitter.emit(&#39;iEvent4&#39;)  // another handler4
emitter.emit(&#39;iEvent4&#39;)  // 不打印
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[看点面试题]]></title>
      <url>/2017/11/15/%E7%9C%8B%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="看点面试题"><a href="#看点面试题" class="headerlink" title="看点面试题"></a>看点面试题</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a> — 解决状态码和请求方式</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li>2xx成功</li>
<li>3xx重定向</li>
<li>4xx客户端错误</li>
<li>5xx服务器错误（流量大啥的）</li>
</ul>
<p>3xx 重定向：比如访问网站 A，结果重新打到网站 B 上。怎么从 A 导到 B。</p>
<p>比如输入一个 <a href="http://www.baidu.com，它会自动转到" target="_blank" rel="external">http://www.baidu.com，它会自动转到</a> <a href="https://www.baidu.com，状态码是" target="_blank" rel="external">https://www.baidu.com，状态码是</a> 307，因为在 Response Headers 有一个 Location</p>
<p>还有一些缓存相关的</p>
<blockquote>
<p>304：当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候,就会发送一个条件请求.在Fiddler中,你可以在<strong>Headers Inspector</strong>查找相关请求头,这样就可以辨别出一个请求是否是条件请求.</p>
<p>在进行条件请求时,客户端会提供给服务器一个<strong>If-Modified-Since</strong>请求头,其值为服务器上次返回的<strong>Last-Modified</strong>响应头中的日期值,还会提供一个<strong>If-None-Match</strong>请求头,值为服务器上次返回的<strong>ETag</strong>响应头的值:</p>
<p><img src="http://pic002.cnblogs.com/images/2012/116671/2012111610163856.jpg" alt="Fiddler Request Headers Inspector screenshot"></p>
<p>服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回<strong>HTTP/304 Not Modified</strong>响应,但没有响应体.客户端收到304响应后,就会从缓存中读取对应的资源.</p>
<p>另一种情况是,如果服务器认为客户端缓存的资源已经过期了,那么服务器就会返回<strong>HTTP/200 OK</strong>响应,响应体就是该资源当前最新的内容.客户端收到200响应后,就会用新的响应体覆盖掉旧的缓存资源.</p>
<p>只有在客户端缓存了对应资源且该资源的响应头中包含了<strong>Last-Modified</strong>或<strong>ETag</strong>的情况下,才可能发送条件请求.如果这两个头都不存在,则必须无条件(<strong>unconditionally</strong>)请求该资源,服务器也就必须返回完整的资源数据.</p>
</blockquote>
<p>4xx客户端错误：</p>
<ul>
<li>404 就是页面不存在</li>
<li>403 Forbidden 服务器上文件或目录的权限设置导致，就是登录了但是没有权限修改就会返回403</li>
<li>401 Unanthorized 完全没有登录，比如说进入了一个系统看系统里的东西但是没登录就会返回401</li>
</ul>
<p>Cache-Control Expires 其实是一个同样的功能</p>
<blockquote>
<p><strong>Expires</strong></p>
<p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT</p>
<p>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。</p>
<p><strong>关于 Cache-Control: max-age=秒 和 Expires</strong></p>
<p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。</p>
<p>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p>
<p><strong>Expires = max-age +   “每次下载时的当前的request时间”</strong></p>
<p>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 </p>
</blockquote>
<p>不受系统时间的影响</p>
<h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>比如一些常见的 get post delete put 这些</p>
<p>get 和 post 的区别是？<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="external">HTTP协议中GET和POST方法的区别</a></p>
<p>put 和 patch 的区别？<a href="https://ihower.tw/blog/archives/6483" target="_blank" rel="external">HTTP Verbs: 談 POST, PUT 和 PATCH 的應用</a></p>
<h3 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files" target="_blank" rel="external">XMLHttpRequest</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form" target="_blank" rel="external">form</a></li>
</ul>
<pre><code>// 假设发送的字符串里有 &amp; 和 = 怎么转译

name: &#39;&amp;=xiaohong&#39;

encodeURIComponent(&#39;&amp;=xiaohong&#39;)  // %26%3Dxiaohong
decodeURIComponent(&#39;%26%3Dxiaohong&#39;)  // &amp;=xiaohong
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="external">FormData</a></p>
<p>application/json <code>JSON.parse(JSON.stringify(obj))</code></p>
<p>发数据的时候记得设置 content-type</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p><a href="https://segmentfault.com/a/1190000006689767" target="_blank" rel="external">HTTP 请求头与请求体</a></p>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p><a href="https://segmentfault.com/a/1190000006689786" target="_blank" rel="external">HTTP 响应头与状态码</a></p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="实参-Array-prototype-push"><a href="#实参-Array-prototype-push" class="headerlink" title="实参 - Array.prototype.push"></a>实参 - Array.prototype.push</h3><pre><code>// 实现一个 _push() 方法
// 一顿操作
Array.prototype._push = function() {
  // todo..
  for(let i = 0; i &lt; arguments.length; i++) {
    this.splice(this.length, 0, arguments[i]);
  }
}

var arr = [1,2,3]
arr._push(4,5)
console.log(arr)  // [1,2,3,4,5]
arr._push([1,2], 6)
console.log(arr)  // [1,2,3,4,5,[1,2],6]
</code></pre><h3 id="call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组"><a href="#call-amp-apply-amp-bind-把一个数组的元素添加到另一个数组" class="headerlink" title="call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组"></a>call&amp;apply&amp;bind - 把一个数组的元素添加到另一个数组</h3><pre><code>Array.prototype._concat = function () {
    // todo...
    let arr = this.slice(0);
    arguments.length &amp;&amp; [].forEach.call(arguments, (value) =&gt; {
        if (Array.isArray(value)) {
            value.forEach(val =&gt; {
                arr.push(val);
            })
        } else {
            arr.push(value);
        }
    })
    return arr;
}

let arr = [1, 2, 3]
arr._concat([4, 5])
console.log(arr) // [1,2,3,4,5]
</code></pre><p>利用 <code>[].forEach.call</code> 调用数组的 <code>forEach</code> 方法（arguments 是类数组没有 forEach 方法）</p>
<h3 id="原型-extend-parentConstructor-childConstructor"><a href="#原型-extend-parentConstructor-childConstructor" class="headerlink" title="原型 - extend(parentConstructor, childConstructor)"></a>原型 - extend(parentConstructor, childConstructor)</h3><p>实现 extend 方法让子构造函数继承父构造函数的方法。</p>
<pre><code>function extend(parentConstructor, childConstructor) {
  var prototype = Object.create(parentConstructor.prototype);
  prototype.constructor = childConstructor;
  childConstructor.prototype = prototype;
}

function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function() {
  console.log(`hi I&#39;m ${this.name}`);
}

var frankie = new Person(&#39;frankie&#39;);
frankie.sayHi();

function Student(name) {
  Person.call(this, name);
}

// 实现 extend 方法让 xiaoming 有问候大家的技能
extend(Person,Student);  //  extend 要挂在这里，如果挂在下面会有可能冲掉 student 的 prototype 属性
Student.prototype.study = function() {
  console.log(`hi I&#39;m ${this.name}. I&#39;m studying`);
}

var xiaoming = new Student(&#39;xiaoming&#39;);
xiaoming.study()  // hi I&#39;m xiaoming. I&#39;m studying
xiaoming.sayHi()  // hi I&#39;m xiaoming
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[补基础：JS 单元测试]]></title>
      <url>/2017/11/13/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9AJS%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h1 id="补基础：JS-单元测试"><a href="#补基础：JS-单元测试" class="headerlink" title="补基础：JS 单元测试"></a>补基础：JS 单元测试</h1><h2 id="单元测试有啥用？"><a href="#单元测试有啥用？" class="headerlink" title="单元测试有啥用？"></a>单元测试有啥用？</h2><p>修改函数的实现方式难以保证输出的东西是自己想要的。</p>
<p>比如 GitHub 上较大的开源项目在别人贡献代码的时候要保证输出的东西和原来的一样。</p>
<p>单元测试就是保证这个。</p>
<p>而且单元测试也是一个文档，告诉别人怎么使用这个文档。</p>
<p><a href="https://github.com/n0ruSh/blogs/issues/2" target="_blank" rel="external">教练我要写单元测试</a></p>
<p><a href="http://mochajs.org/" target="_blank" rel="external">Mocha</a></p>
<p><a href="http://shouldjs.github.io/" target="_blank" rel="external">Should</a></p>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>现在做一个方法 <code>takeWhile</code> ，传一个数组和函数通过所有的 Mocha 测试</p>
<pre><code>/**
 * @param {Array} arr - base array
 * @param {Function} pred - predicate
 * @returns {Array}
 */

function takeWhile(arr, pred) {
    // todo...
    /*
    第一个测试
    return []
    */
}

module.exports = takeWhile;
</code></pre><p>上面的 <code>@param</code> 看这个了解就好。<a href="http://www.css88.com/doc/jsdoc/tags-param.html" target="_blank" rel="external">@param</a></p>
<p>Mocha 的测试写法</p>
<pre><code>let takeWhile = require(&#39;../../src/array/takeWhile&#39;),
    should = require(&#39;should&#39;);  // 比较库或者叫断言库，用来看输出后的东西是不是一样的。

describe(&#39;array takeWhile&#39;, () =&gt; {  // describe 里面可以写一些小方法
    it(&#39;should be okay with empty array&#39;, () =&gt; {  // it 接一些小的用例，后面最好就给一些描述啥的
        let res = takeWhile([], (it) =&gt; {
            return it &lt;= 8;
        });
        res.should.be.eql([]);  // 用 should 来比较是不是一个空数组
    });

    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {
        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {
            return it &lt;= 8;
        });
        res.should.be.eql([1,2,3,8]);
    });

});
</code></pre><p>运行 <code>mocha takeWhile.js</code> 实现第一个测试 <code>return []</code> </p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-c3d18a2b8f498851.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>第一个通过了，第二个没有通过并且提示给了我们要输出 <code>[1,2,3,8]</code></p>
<p>事实上测试用例越多，则说明这个方法越全面。</p>
<pre><code>// 继续增加单元测试的用例

let takeWhile = require(&#39;../../src/array/takeWhile&#39;),
    should = require(&#39;should&#39;);

describe(&#39;array takeWhile&#39;, () =&gt; {
    it(&#39;should be okay with empty array&#39;, () =&gt; {
        let res = takeWhile([], (it) =&gt; {
            return it &lt;= 8;
        });
        res.should.be.eql([]);
    });

    it(&#39;should be okay for normal array less than or equal 8&#39;, () =&gt; {
        let res = takeWhile([1,2,3,8,10,6], (it) =&gt; {
            return it &lt;= 8;
        });
        res.should.be.eql([1,2,3,8]);
    });

    it(&#39;should be okay for normal array greater than 3&#39;, () =&gt; {
        let res = takeWhile([1,2,6], (it) =&gt; {
            return it &gt; 3;
        });
        res.should.be.eql([]);  // 第一个 1 就比 3 小直接返回空数组
    });

    it(&#39;should be okay for normal array greater than 3 with normal array&#39;, () =&gt; {
        let res = takeWhile([4,2,6], (it) =&gt; {
            return it &gt; 3;
        });
        res.should.be.eql([4]);  // 第一个 4 就比 3 大直接返回 [4]
    });

    it(&#39;should be okay for normal array with objects&#39;, () =&gt; {
        let res = takeWhile([{a: 3}, {a: 4}, {a: 5}], (it) =&gt; {
            return it.a &gt;= 3;
        });
        let obj = res[0];
        obj.should.be.eql({a: 3});  // 看看第一个对象是不是 {a: 3}
    });

    it(&#39;should be okay for normal array with objects that has property a&#39;, () =&gt; {
        let res = takeWhile([{a: 3}, {a: 4}, {c: 5}], (it) =&gt; {
            return it.hasOwnProperty(&#39;a&#39;);
        });
        res.length.should.be.eql(2);  // 有 a 的数组是否长度是 2
    });
});
</code></pre><p>那现在就实现方法 <code>takeWhile</code> 通过所有的单元实例</p>
<pre><code>/**
 * @param {Array} arr - base array
 * @param {Function} pred - predicate
 * @returns {Array}
 */

function takeWhile(arr, pred) {
    // todo...
    let temp = [];
    arr.some((it) =&gt; {
        if(pred(it)) {
            temp.push(it);
        } else {
            return true;
        }
    });
    return temp;
    /**
     * let temp = [];
     * for(let it of arr) {
     *     if(pred(it)){
     *         temp.push(it);
     *     } else {
     *         return temp;
     *     }
     * }
     * return temp;
     */    
}

module.exports = takeWhile;
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="external">Array.prototype.some()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" rel="external">for…of</a></p>
<pre><code>// 彩蛋 --- some() 的用法
let arr = [1,2,3]
arr.some(function(it) {return it &lt; 4})  // true
arr.some(function(it) {return it === 3})  // true
arr.some(function(it) {return it &gt; 5})  // false

arr.some(function(it) {console.log(it); return it &lt; 4})  // 1 true
// 只要有一个返回 true 就马上截止返回 true
</code></pre><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>判断对象是不是空的对象（并不是指完全空的，原型上的东西还是要有的）</p>
<pre><code>let isEmptyObject = require(&#39;../../src/object/isEmptyObject&#39;),
    should = require(&#39;should&#39;);

describe(&#39;isEmptyObject&#39;, () =&gt; {
    it(&#39;empty object&#39;, () =&gt; {
        isEmptyObject({}).should.eql(true);
    });

    it(&#39;non-empty object&#39;, () =&gt; {
        isEmptyObject({a: &#39;a&#39;}).should.eql(false);
    });

    it(&#39;should be okay for array&#39;, () =&gt; {
        isEmptyObject([]).should.eql(false);
    });

    it(&#39;should be okay for number&#39;, () =&gt; {
        isEmptyObject(1).should.eql(false);
    });

    it(&#39;should be okay for string&#39;, () =&gt; {
        isEmptyObject(&quot;abc&quot;).should.eql(false);
    });

});
</code></pre><pre><code>/**
 * @param {Any} obj
 * @returns {Boolean}
 */

function isEmptyObject(obj) {
    // todo...
    // Object.prototype.toString.call(obj).toLowerCase() === &#39;[object object]&#39;
    return obj.constructor === Object &amp;&amp; Object.keys(obj).length === 0;
}

module.exports = isEmptyObject;
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="external">Object.prototype.constructor</a></p>
<h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>实现一个 trim 方法去掉前后空格（单词中间的空格不能省略）</p>
<pre><code>let trim = require(&#39;../../src/string/trim&#39;),
    should = require(&#39;should&#39;);

describe(&#39;string trim&#39;, () =&gt; {
    it(&#39;trim string with no spaces at beginning and end&#39;, () =&gt; {
        trim(&#39;hello world&#39;).should.eql(&#39;hello world&#39;);
    });

    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {
        trim(&#39;  hello world&#39;).should.eql(&#39;hello world&#39;);
    });

    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {
        trim(&#39;\thello world&#39;).should.eql(&#39;hello world&#39;);
    });

    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {
        trim(&#39;\nhello world&#39;).should.eql(&#39;hello world&#39;);
    });

    it(&#39;trim string with space(s) at beginning&#39;, () =&gt; {
        trim(&#39;hello world  &#39;).should.eql(&#39;hello world&#39;);
    });

    it(&#39;trim string with tab(s) at beginning&#39;, () =&gt; {
        trim(&#39;hello world\t&#39;).should.eql(&#39;hello world&#39;);
    });

    it(&#39;trim string with new line(s) at beginning&#39;, () =&gt; {
        trim(&#39;hello world\n&#39;).should.eql(&#39;hello world&#39;);
    });

    it(&#39;trim string with spaces/tabs/new lines at beginning and end&#39;, () =&gt; {
        trim(&#39; \t\nhello world \t\n&#39;).should.eql(&#39;hello world&#39;);
    });
});
</code></pre><pre><code>/**
 * @param {String} str
 * @returns {String}
 */

function trim(str) {
    return str.replace(/^\s+|\s+$/g, &quot;&quot;);
}

module.exports = trim;
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" target="_blank" rel="external">String.prototype.trim()</a> 的 Polyfill 是 </p>
<pre><code>if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, &#39;&#39;);
  };
}
</code></pre><h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><p>变成小驼峰</p>
<pre><code>let toCamel = require(&#39;../../src/string/toCamel&#39;),
    should = require(&#39;should&#39;);

describe(&#39;string to camel case&#39;, () =&gt; {
    it(&#39;empty string&#39;, () =&gt; {
        toCamel(&#39;&#39;).should.eql(&#39;&#39;);
    });

    it(&#39;underscore string&#39;, () =&gt; {
        toCamel(&#39;hello_world&#39;).should.eql(&#39;helloWorld&#39;);
    });

    it(&#39;underscore string&#39;, () =&gt; {
        toCamel(&#39;hello_World&#39;).should.eql(&#39;helloWorld&#39;);
    });

    it(&#39;underscore string&#39;, () =&gt; {
        toCamel(&#39;hello-world&#39;).should.eql(&#39;hello-world&#39;);
    });

    it(&#39;normal string&#39;, () =&gt; {
        toCamel(&#39;helloWorld&#39;).should.eql(&#39;helloWorld&#39;);
    });
});
</code></pre><pre><code>/**
 * @param {String} str
 * @returns {String}
 */

function toCamel(str) {
    return str.replace(/_(.)/,(whole, matched) =&gt; {  // whole 就是 _(.) matched 就是 (.) // 括号在正则表达式里就是一个捕获的关系
        return matched.toUpperCase();
    });
}

module.exports = toCamel;

console.log(whole, matched)  // _w w _W W
</code></pre><h2 id="怎么做集成"><a href="#怎么做集成" class="headerlink" title="怎么做集成"></a>怎么做集成</h2><p>相当于有中央服务器做集成，我提交代码，服务器自动帮我跑</p>
<p><a href="https://www.travis-ci.org/" target="_blank" rel="external">Travis CI</a></p>
<p><a href="http://blog.csdn.net/buptgshengod/article/details/39578353" target="_blank" rel="external">Travis setup guide</a></p>
<p>可以在 github 上做一个仓库，我一提交代码就会自动帮忙跑。（这个了解就好，其实都差不多的，就是人工跑代码和机器跑代码的区别）</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[补基础：React-Redux-ES6-webpack-babel]]></title>
      <url>/2017/11/05/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9AReact-Redux-ES6-webpack-babel/</url>
      <content type="html"><![CDATA[<h1 id="补基础：React-Redux-ES6-webpack-babel"><a href="#补基础：React-Redux-ES6-webpack-babel" class="headerlink" title="补基础：React-Redux-ES6-webpack-babel"></a>补基础：React-Redux-ES6-webpack-babel</h1><p><a href="https://www.docschina.org/" target="_blank" rel="external">印记中文</a></p>
<p>先看一遍中文文档，第二遍中英文对着看，第三遍才看英文文档</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p><a href="https://facebook.github.io/react/" target="_blank" rel="external">React 官方文档</a></p>
<pre><code>/**
 * JSX : xml in JavaScript
 * 1、tagName
 * 2、attributes(props)
 * 3、children
 */
/**
 * 组件化: 
 * 1、函数式组件props =&gt; JSX ; 
 * 2、类组件:class A extends Component;
 */ 
/**
 * 数据源 : state  + props
 * 更新数据: setState
 * 方案: 当数据越来越复杂的时候，我们需要一个数据解决方案 ==&gt; redux
 * 发起数据变更(click etc.) ==&gt; action
 * 生成新的数据结构(state[store])  ==&gt; redux的reducer生成react的state
 * 渲染(render) ==&gt; react来做
 */
</code></pre><h3 id="DOM-对比"><a href="#DOM-对比" class="headerlink" title="DOM 对比"></a>DOM 对比</h3><pre><code>// 传统方式
&lt;div data-id=&#39;1&#39;&gt;
    hello world
&lt;/div&gt;

// vue 
&lt;div data-id={{id}}&gt;
    {{name}}
&lt;/div&gt;
{
      data: ()=&gt; {
          return {
              name: &#39;hello world&#39;,
              id: 1
          }
      }
}
// 注意 vue 是一个 MVVM 框架
// 特点就是数据和模板分离

// 实际上 react 也可以认为是一个 MVVM 框架
var JSX = &lt;div data-id=&#39;1&#39;&gt;
    hello world
&lt;/div&gt;;
render(JSX,document.getElementById(&#39;root&#39;));
// 数据和模板绑定在一起

Virtual dom

&lt;div width=&#39;100px&#39;&gt;a&lt;/div&gt;
==&gt;
tagname: div
attributes:{width: &#39;100px&#39;}
children: a

==&gt; IOS / Android
tagname: UIButton
attributes:{display: flex}
children: ...
</code></pre><h3 id="用-react-问候世界"><a href="#用-react-问候世界" class="headerlink" title="用 react 问候世界"></a>用 react 问候世界</h3><pre><code>import react, { Component } from &#39;react&#39; // 基础库
import { render } from &#39;react-dom&#39;  // 平台库 这是 web 库
// 为什么要引两个库呢？
// 为了跨平台
// 比如在 ios/android 用上 react-native
// import from &#39;react-natiev&#39;
render(
    &lt;h1&gt;Hello, world&lt;/h1&gt;              // 要塞的代码
    document.getElementById(&#39;root&#39;)    // 容器
)

// 接下来看看用 webpack 编译后的代码
_react2.default.createElement(
  &#39;h1&#39;,
  null,
  &#39;Hello, world!&#39;

/*
 也就是说 react 会把 JSX 分成三个部分
 * tagname
 * attributes
 * children
*/
</code></pre><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><pre><code>// 这种模板语法就叫做 JSX
import React, { Component } from &#39;react&#39;
import { render } from &#39;react-dom&#39;
const RootDom = document.getElementById(&#39;root&#39;)
let JSX = &lt;div name=&quot;frankie&quot;&gt;
    Hello world&lt;span&gt;你好&lt;/span&gt;
&lt;/div&gt;
render(JSX, RootDom)

// 以下是编译出来的结果
/*
var JSX = _react2.default.createElement(
  &#39;div&#39;,
  { name: &#39;jirengu&#39; },
  &#39;Hello world&#39;,
  _react2.default.createElement(
    &#39;span&#39;,
    null,
    &#39;\u4F60\u597D&#39;
  )
);
*/

// 结构就相当于这个
/*
tagname: &#39;div&#39;
attributes: {
      name: &#39;frankie&#39;
}
children: &#39;hello world&#39;,{
      tagname: &#39;span&#39;
      attributes: null
      children: &#39;你好&#39;
}
*/
</code></pre><pre><code>// 值得注意的地方
// JSX 可以防止 XSS 漏洞
// 比如写在 JSX 里会直接输出，写在 HTML 会把 &amp;gt; 转成 &gt;

render() {
  let b = &#39;First &amp;gt; Second&#39;
  return (&lt;div&gt; {b} &lt;/div&gt;)
} 

// 如果要不转译该怎么办？
/*
dangerouslySetInnerHTML函数
dangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。一般而言，使用JS代码设置HTML文档的内容是危险的，因为这样很容易把你的用户信息暴露给跨站脚本攻击.所以，你虽然可以直接在React中设置html的内容，但你要使用 dangerouslySetInnerHTML 并向该函数传递一个含有__html键的对象，用来提醒你自己这样做很危险。例如：
function createMarkup() {
  return {__html: &#39;First &amp;middot; Second&#39;};
}

function MyComponent() {
  return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;
}
*/

// 实际上，JSX 里面输入 false ，null ，undefined 都是不渲染的

render() {
  return (&lt;div&gt; {false} {null} {undefined} {0} &lt;/div&gt;)
} 

// 那如果有个空格在中间呢？

render() {
  let b = &#39;First         Second&#39;  // 这里这个空格会打印么？ 不会的
  return (&lt;div&gt; {b} &lt;/div&gt;)
} 

// 还有一些属性啊，比如 onChange onClick 都要用驼峰命名
</code></pre><p><a href="https://zhuanlan.zhihu.com/p/22500730?refer=study-fe" target="_blank" rel="external">XSS是什么</a> <a href="https://zhuanlan.zhihu.com/p/22521378?refer=study-fe" target="_blank" rel="external">CSRF是什么</a></p>
<h3 id="JS-in-JSX（动态化）"><a href="#JS-in-JSX（动态化）" class="headerlink" title="JS-in-JSX（动态化）"></a>JS-in-JSX（动态化）</h3><pre><code>// 记住要用大括号来包裹变量
import React,{Component} from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
const RootDom= document.getElementById(&#39;root&#39;);
let a = 1;
let jsx1 = &lt;div&gt;{a}&lt;/div&gt;;
let b = { id : 2 };
let jsx2 = &lt;div&gt;{b.id}&lt;/div&gt;;
let jsx3 = [&#39;i&#39;,&#39;love&#39;,&#39;react&#39;].map((name) =&gt; {
    return &lt;div&gt;{name}&lt;/div&gt;
});
render(&lt;div&gt;
    {jsx1}{jsx2}{jsx3}
    &lt;/div&gt;, RootDom);
// 事实上 render 还有第三个参数 callback
</code></pre><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><pre><code>import React,{Component} from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
const RootDom = document.getElementById(&#39;root&#39;);

/*
 * pure functional components 
 * it must never modify its own props
 */

const A = (props) =&gt; {
    return &lt;div&gt;{ props.gender } + { props.name }&lt;/div&gt;
};
render(&lt;A gender=&#39;male name=&#39;frankie&#39;/&gt;,RootDom);

// tagname  A, ==&gt; 不是传统的html标签，而是个函数
// attributes {   ==&gt; 函数的情况下 attributes === props
//     gender: &#39;male&#39;,
//     name: &quot;frankie&quot;
// }
// children: null

/*
 * class components
 * - Adding Local State to a Class
 * - Adding Lifecycle Methods to a Class
 */
 class FisstComponent extends Component{
        constructor() {
            super()
            this.state = {
                b: 1
            }
        }
        render() {
            return(
                 &lt;div&gt;
                      I am a component
                      {this.state.b}
                 &lt;/div&gt;
            )
        }
 }
 render(&lt;FirstComponent /&gt;,RootDom);

 // class 组件必须有 render 方法
 // class 组件必须继承 Component

 // 组件为什么要大写？区分 HTML 和 组件
</code></pre><h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life-cycle"></a>life-cycle</h3><p><a href="https://facebook.github.io/react/docs/state-and-lifecycle.html" target="_blank" rel="external">https://facebook.github.io/react/docs/state-and-lifecycle.html</a></p>
<pre><code>// 写代码的时候更具有控制力
import React,{Component} from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
const RootDom= document.getElementById(&#39;root&#39;);
class FirstComponent extends Component{
    constructor(){
        super();
        this.state = {
            b:1
        }
    }
    // shouldComponentUpdate / componentWillReceiveProps / componentDidMount 用得比较多
    shouldComponentUpdate(){   // 组件是不是应该被更新
        console.log(&#39;shouldComponentUpdate&#39;);
        return true;
    }
    componentWillUnmount(){   // 组件将会移除
        console.log(&#39;componentWillUnmount&#39;)
    }
    componentDidUpdate(){   // 组件更新好了
        console.log(&#39;componentDidUpdate&#39;)
    }
    componentWillUpdate(){   // 组件将会更新
        console.log(&#39;componentWillUpdate&#39;)
    }
    componentWillReceiveProps(){   // 组件获得了新的 props
        console.log(&#39;componentWillReceiveProps&#39;)
    }
    componentWillMount(){   // 组件将被加载
        console.log(&#39;componentWillMount&#39;)
    }
    componentDidMount(){   // 组件加载完成
        this.setState({b:1})
        console.log(&#39;componentDidMount&#39;)
    }
    render(){   // 组件将被渲染
        console.log(&#39;render&#39;)
        let a = &#39;10/26&#39;
        return &lt;div&gt;
               I am a component
                   {a }
                {this.state.b}
            &lt;/div&gt;
    }
 };

render(&lt;FirstComponent /&gt;,RootDom);

// componentWillMount
// render
// componentDidMount
// shouldComponentUpdate
// componentWillUpdate
// render
// componentDidUpdate
</code></pre><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><pre><code>// &lt;A a=&#39;1&#39;&gt; ==&gt; props = {a:&#39;1&#39;}

import React,{Component} from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
const RootDom= document.getElementById(&#39;root&#39;);
class Welcome extends Component {
  render() {
    return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt;
  }
}
/** props.children
 * React uses this.props.children to access a component&#39;s children nodes.
 * ==== ! props should be pure === // 不应该做任何修改
 */
class ChildComponent extends Component{
    render(){
        return (
        &lt;div&gt;
            {this.props.children}   // 如果 render 写成传统的 html 标签，那“我是个孩子”就是 {this.props.children}
            &lt;Welcome gender=&#39;male&#39; name=&#39;frankie&#39; /&gt;
        &lt;/div&gt;
        );
    }
 };
render(&lt;ChildComponent&gt;我是个孩子&lt;/ChildComponent&gt;,RootDom);

 // 设置默认值 defaultProps
 // 方法 1
 Welcome.defaultProps = {
      gender: &#39;male&#39;,
      name: &#39;frankie&#39;
 }
 // 方法 2
 class Welcome extends Component {
    static defaultProps = {
       gender: &#39;male&#39;,
         name: &#39;frankie&#39;
    }
 }
</code></pre><pre><code> // 类型检测
 import PropTypes from &#39;prop-types&#39;;

 class Welcome extends Component {
    static defaultProps = {
       gender: PropTypes.string,
         name: PropTypes.string
    }
    render(){
          return &lt;div&gt;{this.props.gender} + {this.props.name}&lt;/div&gt; 
    }
 }

 // 假设这里传了数字怎么办？
 ReactDOM.render(&lt;Welcome gender=&#39;0234&#39; name=&#39;0234&#39;/&gt;,RootDom)
</code></pre><p><a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="external">https://reactjs.org/docs/typechecking-with-proptypes.html</a></p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><pre><code>// setState 是一个异步的操作
// 改变数据只有一种方法 setState
import React,{Component} from &#39;react&#39;;
import {render} from &#39;react-dom&#39;;
const RootDom= document.getElementById(&#39;root&#39;);
/**
 * 数据源: state + props
 * props: parent ==&gt; child 【pure不能修改】
 * state: 自身维护的数据状态
 */
class PropState extends Component{
    constructor(){
        super();
        this.state={a:&#39;I am state&#39;}
    }
    click(){
        /**
         * setState ==&gt; 本组件重新render
         */
        this.setState({
            a:&#39;我更新啦 哈哈哈&#39;
        })
    }
    render(){
        return &lt;div onClick={()=&gt;this.click()}&gt;
                {this.state.a}
                &lt;A name= {this.state.a} /&gt;
              &lt;/div&gt;
    }
 };
const A = (props) =&gt; {
    return &lt;div&gt;{props.name}&lt;/div&gt;
}
render(&lt;PropState/&gt;,RootDom);
</code></pre><pre><code>// 定时器
// 记住在 numount 要取消定时器，要不然很容易会造成内存泄露
class Timer extends Component {
    constructor() {
          super()
          this.state = {
              count: 0,
              time: (new Date()).toLocaleTimeString()
          }
    }
    tick() {
        this.setState({
            count: 1,
            time: (new Date()).toLocaleTimeString()
        })
        console.log(this.state.count)  // 0,因为 setState() 是异步函数        
    }
    componentWillMount() {
        this.interval = setInterval(() =&gt; this.tick(),1000)
    }
    componentWillUnmount() {
          clearInterval(this.interval)
    }
    shouldComponentUpate(nextProps, nextState) {
          return true;
    }
    render() {
          return (&lt;div&gt;the time is {this.state.time}&lt;/div&gt;)
    }
}

ReactDOM.render(&lt;Timer /&gt;,RootDom)
</code></pre><h3 id="值得注意的地方"><a href="#值得注意的地方" class="headerlink" title="值得注意的地方"></a>值得注意的地方</h3><pre><code>// 绑定 this 的方法
// 箭头函数和 constructor 都可以
class Name extends Component {
    constructor() {
          super()
          this.state = {
              name: &#39;frankie&#39;
          }
          // 构造函数绑 this
          // this.handleClick = this.handleClick.bind(this)
    }
    // 箭头函数绑 this
    handleClick = () =&gt; {
          alert(this.state.name)
    }
    render() {
          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)
    }
}

// 最后一种 ReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)
// 这种是不建议的，会触发 componentWillReceiveProps 和 shouldComponentUpdate，假如在定时器里，子组件就会一直 render
// 也不能在 render 里用箭头函数
ReactDOM.render(&lt;Name onClick={this.handleClick}/&gt;,RootDom)
</code></pre><pre><code>// 阻止事件冒泡
/*
先考虑一个东西
写在 React 的 div 和原生的 div 是不一样的
那它们的 event 是一样的吗？
// 
&lt;div onclick=&quot;&quot;&gt;&lt;/div&gt;
function test(event){
  return false
}
// react
handleClick = (event) =&gt; {

}

其实是不一样的
react 的 event 是被封装过的，叫做 SyntheticEvent 能实现百分之九十的 event 原生事件 
通过 ev.nativeEvent === event 封装
ev.nativeEvent.stopImmediatePropagation()

handleClick = (event) =&gt; {
  setTimeout(()=&gt; {
    console.log(event.type)
  })
  console.log(event.type)
}

react 的 event 是不能异步执行的
react 的 event 有一个事件值，触发完成之后就会销毁
*/

class Name extends Component {
    constructor() {
          super()
          this.state = {
              name: &#39;frankie&#39;
          }
    }
    handleClick() {
          alert(this.state.name)
          // 可以直接调用
        // event.stopPropagation()
        // event.preventDefault()
    }    
    render() {
          return (&lt;div&gt;my name is {this.state.name}&lt;/div&gt;)
    }
}

ReactDOM.render(&lt;Name onClick={this.handleClick.bind(this)}/&gt;,RootDom)
</code></pre><h3 id="ref-和-DOM"><a href="#ref-和-DOM" class="headerlink" title="ref 和 DOM"></a>ref 和 DOM</h3><p><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="external">https://reactjs.org/docs/refs-and-the-dom.html</a></p>
<pre><code>// 利用 ref 操作 DOM
// react 不建议直接操作 DOM 元素，性能不好
class Name extends Component {
    constructor() {
          super()
          this.state = {
              name: &#39;frankie&#39;
          }
    }
    handleClick = (event) =&gt; {
          // var el = document.getElementById(&#39;content&#39;)
          // this.refs.style.color = &#39;red&#39;  这是旧的
          this.contentRef.style.color = &#39;red&#39;
    }    
    render() {
          return (
          // &lt;div ref=&quot;content&quot;&gt;  这是旧的
          &lt;div onClick={this.handleClick}&gt;
            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;
            my name is {this.state.name}
            &lt;/div&gt;
          &lt;/div&gt;)
    }
}

ReactDOM.render(&lt;Name /&gt;,RootDom)

/*
其实上面这种做法 React 是不推荐的
class Name extends Component {
    constructor() {
          super()
          this.state = {
              color: &#39;&#39;,
              name: &#39;frankie&#39;
          }
    }
    handleClick(event){
        this.setState({
              color: &#39;red&#39;
        })
    }    
    render() {
          return (
          /*
          直接在标签上使用style属性时，
          要写成style={{}}是两个大括号，
          外层大括号是告知jsx这里是js语法，
          和真实DOM不同的是，属性值不能是字符串而必须为对象，
          需要注意的是属性名同样需要驼峰命名法。即margin-top要写成marginTop。
          */
          &lt;div style={{color: this.state.color}} onClick={this.handleClick.bind(this)}&gt;
            &lt;div ref={(content) =&gt; {this.contentRef = content}}&gt;
            my name is {this.state.name}
            &lt;/div&gt;
          &lt;/div&gt;)
    }
}

ReactDOM.render(&lt;Name /&gt;,RootDom)

*/
</code></pre><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><pre><code>class Name extends Component {
    constructor() {
          super()
          this.state = {
             let arr = [{
              id: &#39;1&#39;,
              name: &#39;dalao1&#39;
            }, {
              id: &#39;2&#39;,
              name: &#39;dalao2&#39;
            }, {
              id: &#39;3&#39;,
              name: &#39;dalao3&#39;
            }]             
          }
    }
    render() {
          return (
          &lt;div onClick={this.handleClick}&gt;
            &lt;ul&gt;
                {arr.map((item, i) =&gt; {
                    // return &lt;li key={i}&gt;{item.name}&lt;/li&gt;
                    // 这个 key 的作用是见下面
                      return &lt;li&gt;{item.name}&lt;/li&gt;
                })}
            &lt;/ul&gt;
          &lt;/div&gt;)
    }
}

ReactDOM.render(&lt;Name /&gt;,RootDom)

/*
key 的作用 react 做 diff 算法的时候使用
如果 key 能保持稳定，DOM 内容不变就可以避免重新渲染
key 不要用 index 不要用随机数

class Name extends React.Component {
    constructor() {
          super()
          this.state = {
             people : [{
              id: &#39;1&#39;,
              name: &#39;dalao1&#39;
            }, {
              id: &#39;2&#39;,
              name: &#39;dalao2&#39;
            }, {
              id: &#39;3&#39;,
              name: &#39;dalao3&#39;
            }]             
          }
    }
    handleClick(event) {
        // 这里要用深拷贝
        let people = this.state.people
        let newPeople = people.map((person =&gt; {
              let newPerson = {...person}  // 这里相当于浅拷贝
              if (newPerson.id == &#39;2&#39;) {
                  newPerson.name += &#39;haha&#39;
              }
              return newPeople  // 返回了新的地址相当于深拷贝
        }))
        this.setState({
            people : newPeople
        })
    }    
    render() {
          return (
          &lt;div onClick={this.handleClick.bind(this)}&gt;
            &lt;ul&gt;
                {this.state.people.map((item, i) =&gt; {
                    // return &lt;Person key={Math.random() * 100} item={item}&gt;&lt;/Person&gt;
                    // 如果像上面一样，因为 key 是不一样的，所以 react 以为这个组件没有使用过，要重新构造一份
                    return &lt;Person key={i} item={item}&gt;&lt;/Person&gt;
                })}
            &lt;/ul&gt;
          &lt;/div&gt;)
    }
}

class Person extends React.Component{
    shouldComponentUpdate(nextProps, nextState) {
          return nextProps.item.name !== this.props.item.name
          // 如果不用深拷贝，nextProps.item.name === this.props.item.name 是 true，相等的原因是因为 item 是引用类型
    }
      render(){
          console.log(&#39;render&#39; + this.props.item.id)
          /* 
          这里打印的是
          render1
          render2
          render3
          避免 1 3 渲染的方法是
          key 值要稳定
          深拷贝
          */
          return &lt;li&gt;{this.props.item.name}&lt;/li&gt;
      }
}

ReactDOM.render(&lt;Name /&gt;,mountNode)
*/
</code></pre><p><a href="https://segmentfault.com/a/1190000006752076" target="_blank" rel="external">JavaScript 深入了解基本类型和引用类型的值</a></p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><pre><code>/*
方法有：三元 if else 组件 方法 &amp;&amp;判断
*/

class Name extends React.Component{
      render(){
          let isLogin = this.props.isLogin
          let comp = null
          if(isLogin){
          comp = &lt;Logout /&gt;
          }else{
          comp = &lt;Login /&gt;
          }
          return(&lt;div&gt;
              {comp}
              // {isLogin ? &lt;Logout /&gt; : &lt;Login /&gt;}  // 主要用三元运算
          &lt;/div&gt;)
      }
}

class Login extends React.Component{
      render(){
          return &lt;div&gt;login&lt;/div&gt;
      }
}

class Logout extends React.Component{
      render(){
          return &lt;div&gt;logout&lt;/div&gt;
      }
}

ReactDOM.render(&lt;Name isLogin={true}/&gt;,mountNode)

/*
可以封装成一个组件
function SignIn(isLogin) {
      if(isLogin){
      return &lt;Logout/&gt;
      }else{
      return &lt;Login/&gt;
      }
}

// 在 render 写
render(){
  return(&lt;SignIn isLogin={isLogin}/&gt;)
}
*/

/*
也可以做成一个方法
getLogIn(isLogin) {
  if(isLogin){
    return &lt;Logout /&gt;
  }else{
    return &lt;login/&gt;
  }
}

render(){
  return(&lt;div&gt;
      {this.getLogin(isLogin)}
  &lt;/div&gt;)
}
*/

/*
还有一种用 &amp;&amp; 判断
{isLogin &amp;&amp; &lt;Logout/&gt;}
{isLogin &amp;&amp; &lt;LoginIn/&gt;}
*/
</code></pre><h3 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h3><pre><code>/*
传一个组件出一个组件
其实可以理解为一个给基础组件加方法的处理器
比如说有两个组件 Ad1 Ad2 他们有 abc 三个方法

Ad1Component{
  a(){};b(){};c(){};
}
Ad2Component{
  a(){};b(){};c(){};
}

那我们可以把方法抽离出一个 Basic 组件
BasicComponent{
  a(){};b(){};c(){};
}

然后写到 HOC 转换
function wrapper(WrapperComponent){
  return BasicComponent{
    a(){};b(){};c(){};
    render(){
      return &lt;WrapperComponent /&gt;
    }
  }
}
*/

// 写个例子
// 在 input 组件的名字改变的时候加上一些日志的方法但是不能 input 组件上写（为什么会有这个需求？因为有可能这个组件不是你自己写的）
/*
想到一个方法用 prototype 但是会影响原型链
 function logProps(InputComponent) {
    InputComponent.prototype.componentWillReceiveProps = function(nextProps, nextState) {
      console.log(&#39;============&#39;)
      console.log(&#39;Current props: &#39;, this.props);
      console.log(&#39;Next props: &#39;, nextProps);
    };
    return InputComponent;
}
*/

// 正确的方法应该是利用 HOC 封装方法

class InputComponent extends React.Component{
    componentWillReceiveProps() {

    }
    render() {
        return &lt;div&gt;{this.props.name}&lt;/div&gt;
    }
}

function logProps(WrappedComponent) {
    return class extends React.Component {  // 匿名组件，要实现的共有方法都在这里做
      componentWillReceiveProps(nextProps) {    
        console.log(&#39;Current props: &#39;, this.props);
        console.log(&#39;Next props: &#39;, nextProps);
      }
      render() {
        return &lt;WrappedComponent {...this.props} /&gt;;
      }
    }
}

const EnhancedComponent = logProps(InputComponent);

 let name = &#39;dalao&#39;;
 setInterval(() =&gt; {
    name += &#39; hah&#39;;
    ReactDOM.render(&lt;EnhancedComponent name={name} /&gt;, document.getElementById(&#39;root&#39;));
 }, 1000)
</code></pre><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p><a href="http://www.redux.org.cn/" target="_blank" rel="external">Redux 官方文档</a></p>
<p><a href="https://github.com/slashhuang/redux-annotation" target="_blank" rel="external">https://github.com/slashhuang/redux-annotation</a></p>
<p><img src="https://ooo.0o0.ooo/2017/11/04/59fd9c6002509.jpg" alt=""></p>
<h3 id="第一个简单的例子"><a href="#第一个简单的例子" class="headerlink" title="第一个简单的例子"></a>第一个简单的例子</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">Object.assign()</a></p>
<pre><code>import { createStore } from &#39;redux&#39;
const initState = {}
const reducer = (state, action) =&gt; {
    return action
}
const store = createStore(reducer, initState)
store.dispatch({
    type: &#39;init&#39;,
    payload: &#39;hello world&#39;
})
console.log(store.getState())

// redux 的整体架构
// action (动作) ===&gt; 发起 AJAX
// reducer (Handler处理器) ===&gt; JSON 处理
// state (最后的状态) ===&gt; JSON 保存起来

// 通常从后端拉数据的流程是这样的
// AJAX ===&gt; JSON ===&gt; UI

// 所以上面这个代码拆分开来就是
const action = {
      type: &#39;init&#39;,
      payload: &#39;hello world&#39;,
}
const reducer = (state, action) =&gt; {  // state 是前一次保存的数据状态
      return Object.assign({}, state, action);  // 生成下一个数据状态
}
const store = createStore(reducer, initState)
store.dispatch(action)
console.log(store.getState())
</code></pre><h3 id="createStore-源码"><a href="#createStore-源码" class="headerlink" title="createStore 源码"></a>createStore 源码</h3><pre><code>// 需要注意的是第一个参数和第二个参数（reducer, 初始化的 state）
export default function createStore(reducer, preloadedState, enhancer)

/*
判断...
*/

var currentReducer = reducer;  // 当前的处理器
var currentState = preloadedState;   // 当前的state ===&gt; 初始化的 state
var currentListeners = []; 
var nextListeners = currentListeners;
var isDispatching = false;  // 不执行

/*
往下看
*/

function getState() {
    return currentState;  // 直接 return currentState
}

/*
往下看
*/

  function dispatch(action) {

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);  
      // 用当前的 reducer 处理当前的 state 和 action
      // 只要 dispatch(action) 就会处理一遍生成一个 state
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i &lt; listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;  // 返回一个 action
  }

/*
往下看
*/

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
  // 最后也是返回出来
</code></pre><h3 id="回看例子分析-createStore-源码"><a href="#回看例子分析-createStore-源码" class="headerlink" title="回看例子分析 createStore 源码"></a>回看例子分析 createStore 源码</h3><pre><code>import { createStore } from &#39;redux&#39;
const initState = {}
const action = {
      type: &#39;init&#39;,
      payload: &#39;hello world&#39;,
}
const reducer = (state, action) =&gt; {   // currentState = currentReducer(currentState, action);  
      return Object.assign({}, state, action);  // 当前的数据状态
}
debugger
const store = createStore(reducer, initState)  // reducer = (state, action) =&gt; {...}, initState = {}
debugger
store.dispatch(action)  // 所以 store 有 dispatch 方法
console.log(store.getState())  // return currentState
// Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}

// debugger 看过程
// var currentReducer = reducer;  // currentReducer = function reducer(state, action), reducer = function reducer(state, action)
// var currentState = preloadedState;  // currentState = Object {}, preloadedState = Object {}

/*
跳到 dispatch return 一个 API 集合
*/

/*
下一个 debugger
currentState = currentReducer(currentState, action); 进去看一下
return Object.assign({}, state, action);  做一个覆盖
currentState 变成了 Object {type: &quot;init&quot;, payload: &quot;hello world&quot;}
*/

/*
看一下 console.log(store.getState())
function getState() {
    return currentState; // 返回 currentState
}
*/

--------------------------------------------------------------------

// 修改一下代码
import { createStore } from &#39;redux&#39;
const initState = {}
const action = {
      type: &#39;init&#39;,
      payload: &#39;hello world&#39;,
}
const reducer = (state, action) =&gt; {
      return Object.assign({}, state, action);
}
const store = createStore(reducer, initState)
debugger
store.subscribe(() =&gt; {
      console.log(&#39;我注册啦&#39;)
})
store.dispatch(action)
console.log(store.getState())

// store.subscribe 进去看看
/*
  function subscribe(listener) {

    //...

    nextListeners.push(listener);    // nextListeners 是一个长度为零的数组，把 listener push 进去
    return function unsubscribe() {
        // ...
    };
  }
*/

// store.dispatch(action) 进去看看
/*
  function dispatch(action) {
    //...
    // 这里会读当前的观察者数组
    var listeners = currentListeners = nextListeners;
    for (var i = 0; i &lt; listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  ---------------------

  在 console 打 listeners 会打印出 [function]
  listeners[0] 是
  function () {
      console.log(&#39;我注册啦&#39;);
  }
*/

/*
需要注意的一点是
  // When a store is created, an &quot;INIT&quot; action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT })
  也就是说，每调用一遍 createStore 就会执行一遍 dispatch({ type: ActionTypes.INIT })
  所以初始化的 action 是 type: &quot;@@redux/INIT&quot;
*/
</code></pre><h3 id="怎么改变-dom"><a href="#怎么改变-dom" class="headerlink" title="怎么改变 dom"></a>怎么改变 dom</h3><pre><code>// HTML
    &lt;div id=&#39;root&#39;&gt;
        1
    &lt;/div&gt;
// JS
import { createStore } from &#39;redux&#39;
const ROOTDOM = document.getElementById(&#39;root&#39;)
const initState = {}
const action = {
      type: &#39;init&#39;,
      payload: &#39;hello world&#39;,
}
const reducer = (state, action) =&gt; {  
      return Object.assign({}, state, action); 
}
const store = createStore(reducer, initState) 
store.subscribe(() =&gt; {
      ROOTDOM.innerHTML = JSON.stringify(store.getState())
})
let counter = 0
ROOTDOM.addEventListener(&#39;click&#39;, () =&gt; {
      counter++
      const action = {
          type: &#39;click&#39;,
          payload: counter
      }
      store.dispatch(action)
})
</code></pre><h3 id="实现一个MVVM"><a href="#实现一个MVVM" class="headerlink" title="实现一个MVVM"></a>实现一个MVVM</h3><pre><code>// HTML
&lt;input id=&quot;name&quot;/&gt;
数据预览区
&lt;div id=&quot;preview&quot;&gt;&lt;/div&gt;
&lt;div id=&#39;root&#39;&gt;
1
&lt;/div&gt;
// JS
import { createStore } from &#39;redux&#39;;
const initState = {};
const action = {
    type: &#39;init&#39;,
    payload: &#39;hello world&#39;,
};
const reducer = (state, action) =&gt; {
    return Object.assign({}, state, action);
};
const store = createStore(reducer, initState);
const INPUTDOM = document.getElementById(&#39;name&#39;);
const PREVIEWDOM = document.getElementById(&#39;preview&#39;);
const digestUI = () =&gt; {
    PREVIEWDOM.innerHTML = store.getState().payload;
    if (PREVIEWDOM.innerHTML.length &gt; 20) {
        alert(&#39;length is 20&#39;)
    }
};
const inputChange = () =&gt;{
    let val = INPUTDOM.value;
    const action = {
        type: &#39;input_change&#39;,
        payload: val,
    };
    store.dispatch(action);
};
let counter = 0;
INPUTDOM.addEventListener(&#39;input&#39;, inputChange)
store.subscribe(digestUI);

// 可以看出好处就是行为都是分离的
</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><pre><code>// redux中的applyMiddleware中间件
// Middleware makes it easier for software developers
// to implement 【communication and input/output】,
// so they can focus on the 【specific purpose of their application】.
// 更专注 service 服务 input/output service 输入和输出
// ajax ==&gt; json(乱得一笔) =service转换(中间件)=&gt; UI(整理成好的)
// express/Koa

// 前端
// ajax ==http==&gt;
// httpRequest(head,cookie,body)
// middlewares(解析cookie, 拿到post请求的数据)
// 数据就是好的一笔的数据
// 后端(node.js)

// 看一个例子
// 注意下面这些很多箭头的叫做高阶函数
// 例如 const highFunction = a =&gt; b =&gt; c =&gt; console.log(a+b+c); highFunction(1)(2)(3) // 6 // 一个函数执行完之后返回值是一个函数
// 多参函数 ===&gt; 单参函数

// 如果在 createStore 用上 enhancer 逻辑就会被 applyMiddleware 控制
// return enhancer(createStore)(reducer, preloadedState)

// 前一个 next 指向下一个 action=&gt; { next(action) }; 最后一个 next 指向 dispatch 

// 没有中间件 action ==&gt; ==dispatch==&gt; reducer ==&gt; nextState;
// 有中间件 action ==middlewares==&gt; ==dispatch==&gt; reducer ==&gt; nextState;

// applyMiddleware 的思想是把一堆函数封装成一个函数

import { createStore, applyMiddleware } from &#39;redux&#39;;
const logger1 = store =&gt; next =&gt; action =&gt; {
    console.log(&#39;current dipatch&#39; + JSON.stringify(action));
    next(action);
};
const logger2 = store =&gt; next =&gt; action=&gt; {
    next(action);
};
const logger3 = store =&gt; next =&gt; action=&gt; {
    next(action);
};

const enhancer = applyMiddleware(logger1, logger2, logger3);
const reducer = (state, action) =&gt; state;
const store = createStore(reducer, {}, enhancer);
store.dispatch({type:1});
store.dispatch({type:2});
store.dispatch({type:3});
</code></pre><p>action 的另一种写法 <a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="external">https://github.com/acdlite/flux-standard-action</a></p>
<p><a href="https://stackoverflow.com/questions/32646920/whats-the-at-symbol-in-the-redux-connect-decorator" target="_blank" rel="external">What’s the ‘@’ (at symbol) in the Redux @connect decorator?</a></p>
<p><a href="http://taobaofed.org/blog/2016/08/18/react-redux-connect/" target="_blank" rel="external">React 实践心得：react-redux 之 connect 方法详解</a></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6 教程</a></p>
<p><a href="https://frankietang.github.io/2017/10/14/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 ES6 的门把手</a></p>
<p>Stage 0 - Strawman（展示阶段）</p>
<ul>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<p>配 babel 的时候有用 </p>
<h3 id="Set-和-Map-的数据结构"><a href="#Set-和-Map-的数据结构" class="headerlink" title="Set 和 Map 的数据结构"></a>Set 和 Map 的数据结构</h3><p><a href="https://github.com/ruanyf/es6tutorial/blob/2ac6e76b38f117f2acf6c465ab70709275b4241a/docs/set-map.md" target="_blank" rel="external">set-map</a></p>
<pre><code>// 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。
let s = new Set()
s.size // 0
s.add(1) // {1}
s.size // 1
s.add(1) // {1}
s.size // 1
s.add(&#39;1&#39;) // {1,&#39;1&#39;}
s.size // 2

// 如何快速去除数组里的重复元素
[...new Set([1,2,3,4,5,4,3,2,1])]  // (5) [1, 2, 3, 4, 5]
</code></pre><h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h3><pre><code>// 对类做一个封装
// 懂了，大概就是在 class 上面绑定方法可以直接调用

function divide(target){
  target.prototype.divide = function(a,b) {return a/b}
  return target
}

@divide
class Math{
  add(a,b){
    return a+b
  }
}

let m = new Math()
console.log(m.divide(6,3)) // 2

// 再封装多一个判断

function divide(needAdd){
  return function(target){
    if(needAdd){
      target.prototype.divide = function(a,b) {return a/b}
    }
  }
  return target
}

@divide(true)
class Math{
  add(a,b){
    return a+b
  }
}

let m = new Math()
console.log(m.divide(6,3)) // 2
</code></pre><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><a href="https://webpack.js.org/" target="_blank" rel="external">webpack 官方文档</a></p>
<h3 id="webpack-与-react"><a href="#webpack-与-react" class="headerlink" title="webpack 与 react"></a>webpack 与 react</h3><pre><code>// 主要是配 loaders
{
    test: /\.js[x]?$/,        // 符合 js 或者 jsx
    loader: &quot;babel-loader&quot;,   // 运行 babel-loader
    exclude: /node_modules/
},
</code></pre><p>说实话 webpack 这东西翻翻文档就好，不用死记硬背的。要什么功能直接 Google ，<code>npm i -D &lt;package&gt;</code></p>
<p><a href="https://juejin.im/post/59bb37fa6fb9a00a554f89d2" target="_blank" rel="external">webpack：从入门到真实项目配置</a></p>
<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p><a href="http://babeljs.io/" target="_blank" rel="external">babel 官方文档</a></p>
<h3 id="babel-1"><a href="#babel-1" class="headerlink" title="babel"></a>babel</h3><pre><code>// 因为 react 用的是 JSX 所以需要用到 babel
// 不止 JSX 还有高阶组件(HOC) 要用到 es7 的 Decorator
// 把这一堆代码转换成 JS
// 以下是配法 
{
  &quot;presets&quot;: [
     &quot;stage-0&quot;, // 草案 0
     &quot;es2015&quot;,  // es6
     &quot;react&quot;    // react
  ],
   &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]  // 翻译 Decorator
}
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[deepin shadowsocks-qt5 全局翻了个墙]]></title>
      <url>/2017/10/25/deepin%20shadowsocks-qt5%20%E5%85%A8%E5%B1%80%E7%BF%BB%E4%BA%86%E4%B8%AA%E5%A2%99/</url>
      <content type="html"><![CDATA[<h1 id="deepin-shadowsocks-qt5-全局翻了个墙"><a href="#deepin-shadowsocks-qt5-全局翻了个墙" class="headerlink" title="deepin shadowsocks-qt5 全局翻了个墙"></a>deepin shadowsocks-qt5 全局翻了个墙</h1><p>最近真的是非常时期 <code>git push</code> <code>git pull</code> <code>git clone</code> 全部显示了</p>
<p>Connection closed by 192.30.255.113 port 22</p>
<p>以下是解决办法</p>
<pre><code>sudo apt-get install shadowsocks-qt5
sudo apt-get install proxychains
// 配置 /etc/proxychains.conf
// 不要 socks4 127.0.0.1 9095 加上
socks5 127.0.0.1 1080
// 然后在每一条命令都加上
proxychains
</code></pre><p>关于怎么配 shadowsocks-qt5 网上一搜一大把，祝各位看到这篇文章能早日肉身翻墙吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> fq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[补基础：函数]]></title>
      <url>/2017/10/24/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="补基础：函数"><a href="#补基础：函数" class="headerlink" title="补基础：函数"></a>补基础：函数</h1><blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="external">函数</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments" target="_blank" rel="external">实参</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" target="_blank" rel="external">length</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">call</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external">apply</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">bind</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">Generator Function</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Generator</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" target="_blank" rel="external">迭代器协议</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" rel="external">for of</a></li>
</ul>
</blockquote>
<h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><pre><code class="1">function fn() {
      console.log(1)
}

fn() // 1

// 传东西
function fn(num, fn) {
      console.log(fn(num))
}

fn(1, function(a){
      return a + 1
}) // 2
</code></pre>
<pre><code>// whether fn is function
function fn() {}

console.log(typeof fn === &#39;function&#39;)
console.log(fn instanceof Function)
console.log(Object.prototype.toString.call(fn) === &#39;[object Function]&#39;)
</code></pre><pre><code>// 函数调用和没调用的区别
function fn2() {
      return 2
}

fn2()

let obj = {
      fn: fn2
}

console.log(obj.fn)     // 返回是一个函数
console.log(obj.fn())   // 返回函数的结果
</code></pre><pre><code>// 函数的借用
let user = {
      name: &#39;xiaohong&#39;,
      sayHi: function() {
          console.log(&#39;hello my name is &#39; + this.name)
      }
}

uesr.sayHi()  // hello my name is xiaohong

// 怎么借用方法
let user2 = {name: &#39;xiaohei&#39;}
// to-do
user.sayHi.call(user2)
// hello my name is xiaohong


setTimeout(function() {
      console.log(&#39;hello&#39;)
}, 1000)

// 怎么写成一行呢？
setTimeout(console.log.bind(null, &#39;hello&#39;), 1000)

// 举个实用场景
// var collection = document.getElementsByClassName(&#39;a&#39;)
// 但是 collection 没有 forEach 方法
// Array.prototype.forEach.call(collection)
</code></pre><h2 id="形参-parameters-vs-实参-arguments"><a href="#形参-parameters-vs-实参-arguments" class="headerlink" title="形参(parameters) vs 实参(arguments)"></a>形参(parameters) vs 实参(arguments)</h2><p>实参是实际传进来的参数</p>
<p>形参是定义时候的参数</p>
<pre><code class="javascrip">// arguments
function fn(a, b) {
    console.log(a, b)
      console.log(arguments)
      console.log(arguments.length)
}

function fn(a, b, ...args) {
    console.log(a, b)
      console.log(args)   // [3,4]
      let args1 = Array.prototype.slice.call(arguments, 2)
      console.log(args1)  // [3,4]
}

fn(1,2,3,4)
// 1 2
// { &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3, &#39;3&#39;: 4 }
// 4

let arr = [1,2,3]
arr.push(1,2,3,4,5)
console.log(arr)

Array.prototype.push = function() {
    // arguments
      let args = Array.prototype.slice.call(arguments)
}
</code></pre>
<pre><code>// parameters
function fn(a, b) {
      console.log(arguments.length)
}

fn(1,2,3,4)
console.log(fn.length) // 2 形参个数 = 函数名.length

// 实现一个功能
function sum(a, b, c) {
      return a + b + c
}

console.log(sum(1,2,3))

// fn 是一个函数
function curry(fn) {
    var len = fn.length
      return function f1() {
          let args = Array.prototype.slice.call(arguments)
          if(args.length &lt; len) {
              return function() {
                  let args2 = Array.prototype.slice.call(arguments)
                  return f1.apply(this, args.concat(args2))
              }
          } else {
              return fn.apply(null,args)
          }
      }
}

let sumWithCurry = curry(sum) 
sumWithCurry(1,2,3)   // 6 len = 3, args.length = 3 sum.apply(null,[1,2,3])
sumWithCurry(1)(2,3)  // 6

// 先运行 sumWithCurry(1) 然后吃掉后面的函数 利用 concat 

sumWithCurry(1,2)(3)  // 6
</code></pre><p><a href="https://github.com/n0ruSh/the-art-of-reading/issues/5" target="_blank" rel="external">柯里化</a></p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h2><pre><code>// 在 function 加一个 * 号就可以变成一个 Generator 函数
function* fn() {
      yield 3;
      yield 4;
      // console.log(&#39;hello&#39;)
}

console.log(typeof fn)     // function
console.log(fn())          // {}
let iterator = fn()
console.log(iterator.next())  // {value: 3, done: false}
console.log(iterator.next())  // {value: 4, done: false}
console.log(iterator.next())  // {value: undefined, done: true}
// 3 -&gt; 4 -&gt; done

for(let i of fn()) {  // for of 遍历方法，可以遍历数组
      console.log(i)
}
// 3
// 4

// 看看是怎么做到的
let arr = [2,3,4]
let iterator = arr[Symbol.iterator]()
console.log(iterator.next()) // {value: 2, done: false}
console.log(iterator.next()) // {value: 3, done: false}
console.log(iterator.next()) // {value: 4, done: false}
console.log(iterator.next()) // {value: undefined, done: true}
// 只要符合迭代器 就可以用 for of 方法
for(let j of iterator) {
      console.log(j)
}

// 也可以遍历对象
Object.defineProperty(Object.prototype, Symbol.iterator, {
      enumerable: false,
      writable: false,
      configurable: false,
      value: function() {
          let self = this;
          let keys = Object.keys(self); // [&#39;a&#39;, &#39;d&#39;]
          let index = 0;
          return {
              next: function() {
                  return {
                      value: self[keys[index++]],  // 加点注释啥的 + &#39;suffix&#39;
                      done: index &gt; keys.length
                  }
              }
          }
      }
})

let obj = {a: &#39;b&#39;, c: &#39;d&#39;}

let iterator2 = obj[Symbol.iterator]()
console.log(iterator2.next()) // {value: &#39;b&#39;, done: false}
console.log(iterator2.next()) // {value: &#39;d&#39;, done: false}
console.log(iterator2.next()) // {value: undefined, done: true}

for(let val of obj) {
      console.log(val)
}

let obj2 = {name: &#39;xiaohong&#39;, age: 20, sex: &#39;male&#39;}
for(let j of obj2) {  // 只要支持迭代器协议就可以了
      console.log(j)
}
</code></pre><pre><code>// 彩蛋 和 Promise 的比较

// Promise
new Promise()
.then()
.then()
.then()

// yield + generator
let a = yield promise1
let b = yield promise2
let c = yield promise3
// 看起来像是同步，实际上是异步
</code></pre><pre><code>// 彩蛋2 为什么不支持 for of 遍历对象
// 原因有可能是这样的
// 数组不关心索引，对象关心

let arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] = {
      &#39;0&#39; : &#39;a&#39;,
      &#39;1&#39; : &#39;b&#39;,
      &#39;2&#39; : &#39;c&#39;,
}

let obj = {
      &#39;a&#39;: &#39;b&#39;,
      &#39;c&#39;: &#39;d&#39;
}
</code></pre><p>其实有两个新方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank" rel="external">Object.values()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="external">Object.entries()</a> 可以遍历，Object.values() 只返回 value ，Object.entries() 返回全部</p>
<pre><code>// 彩蛋3 Symbol 是用来干嘛的？
// 避免相等的值重复
let a = &#39;a&#39;
let b = &#39;a&#39;

let obj = {}
obj[a]
obj[b]
</code></pre><p><a href="http://www.infoq.com/cn/articles/es6-in-depth-symbols" target="_blank" rel="external">深入浅出ES6（八）：Symbols</a></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[补基础：对象与数组的遍历方式]]></title>
      <url>/2017/10/22/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="补基础：对象与数组的遍历方式"><a href="#补基础：对象与数组的遍历方式" class="headerlink" title="补基础：对象与数组的遍历方式"></a>补基础：对象与数组的遍历方式</h1><blockquote>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="external">Object.getOwnPropertyNames</a></li>
</ul>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty</a></li>
</ul>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="external">Object.getOwnPropertyDescriptor</a></li>
</ul>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" target="_blank" rel="external">getOwnPropertyDescriptors</a></li>
</ul>
</blockquote>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><pre><code>let arr = [1, 2, 3]

for(let i = 0, len = arr.length; i &lt; len; i++){
      console.log(arr[i])
}

arr.forEach((it, index, self) =&gt; {
      console.log(it, index, self)
})
// 1 0 [1,2,3]
// 2 1 [1,2,3]
// 3 2 [1,2,3]
// 等于
arr.forEach(console.log)
</code></pre><h2 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h2><pre><code>let obj = {a: &#39;b&#39;, c: &#39;d&#39;}

// 打印出
// key a -&gt; b
// key c -&gt; d

for(let key in obj) {
      console.log(`key ${key} -&gt; ${obj[key]}`)
}

// 要注意的是，for in 会遍历原型链上的属性
// 但是并没有打印到 console.log(obj.toString) 这个值
// 没有打印 key toString -&gt; [Function: toString]

Object.prototype.test = &#39;mytest&#39;

// key a -&gt; b
// key c -&gt; d
// key test -&gt; mytest
// 说明确实会遍历找到原型链上的属性
// 那为什么 toString 没有打印出来？

console.log(Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;))
// {writable: true, enumerable: false, configurable: true, value: ƒ}
// 通过 getOwnPropertyDescriptor 看到 enumerable 的确是 false ，说明了不可枚举。 
// 所以说 Object.prototype 里面内置的方法大多数都是不可枚举的
</code></pre><pre><code>// 那怎么可以只 for in 自身属性呢而不会遍历其他赋予到原型链上的属性呢？ （有的第三方库会在原型链上赋值）

let obj = {a: &#39;b&#39;, c: &#39;d&#39;}

Object.prototype.test = &#39;mytest&#39;

for(let key in obj) {
    // 只遍历自身属性 可以加一层判断
    if(obj.hasOwnProperty(key)) {
          console.log(`key ${key} -&gt; ${obj[key]}`)
    }
}
</code></pre><pre><code>// 看一个使用场景
function validUser(obj) {
    // 同时具有name, age属性的为合法用户
    return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp; obj.hasOwnProperty(&#39;age&#39;)
}

console.log(validUser({name: &#39;mike&#39;})); // false;
console.log(validUser({age: 15})); // false
console.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // true
</code></pre><p>要注意不能用 <code>(!!obj.name &amp;&amp; !!obj.age)</code> 这种方法，要考虑到 <code>{age: 0}</code> 的可能性或者其他 如：<code>!!0 -&gt; false</code> <code>!!{} -&gt; true</code> <code>!![] -&gt; true</code> <code>!!&#39;&#39; -&gt; false</code></p>
<pre><code>// 多个属性
function validUser(obj) {
    // 同时具有 name, age, sex 属性的为合法用户
    // 若是上面那种做法，会导致多属性很麻烦
    // return obj.hasOwnProperty(&#39;name&#39;) &amp;&amp; 
    //          obj.hasOwnProperty(&#39;age&#39;) &amp;&amp;
    //          obj.hasOwnProperty(&#39;sex&#39;)
    // 以下为解决方法
    return requiredFields.every((it) =&gt; {
          return obj.hasOwnProperty(it)
    })
}

// 可以先配置成一个数组, 改变量就好
let requiredFields = [&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;]

console.log(validUser({name: &#39;mike&#39;})); // false;
console.log(validUser({age: 15})); // false
console.log(validUser({name: &#39;xiaohong&#39;, age: 18})); // true
console.log(validUser({name: &#39;xiaohong&#39;, age: 18, sex: &#39;ddd&#39;})); // true
</code></pre><h2 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h2><pre><code>// 另外一种遍历方法 Object.keys(obj)
let obj = {a: &#39;b&#39;, c: &#39;d&#39;}

Object.prototype.test = &#39;myTest&#39;

Object.keys(obj).forEach((key) =&gt; {
      console.log(`key ${key} -&gt; ${obj[key]}`)
})

// 这个方法只能遍历到自身可枚举属性，那有没有办法可以遍历到不可枚举属性呢？

// 打印所有自身属性，包含不可枚举

console.log(Object.getOwnPropertyNames(obj)) // [&quot;a&quot;, &quot;c&quot;, &quot;nonEnumerable&quot;]

Object.getOwnPropertyNames(obj).forEach((key) =&gt; {
      console.log(`key ${key} -&gt; ${obj[key]}`)
})

// key a -&gt; b
// key c -&gt; d
// key nonEnumerable -&gt; static

// 设置不可枚举的方法
Object.defineProperty(obj, &#39;nonEnumerable&#39;, {
    enumerable: false,
    configurable: false,
    writable: false,
    value: &#39;static&#39;
});

console.log(obj.nonEnumerable) // &#39;static&#39;
console.log(obj.hasOwnProperty(&#39;nonEnumerable&#39;)) // ture
// 说明 obj 自身有 nonEnumerable ，设置为 static
</code></pre><h2 id="get-set"><a href="#get-set" class="headerlink" title="get - set"></a>get - set</h2><p>数据双向绑定</p>
<pre><code>let obj = {a: &#39;b&#39;}

// 可以这样
Object.defineProperty(obj, &#39;c&#39;, {
    get() {
        // business logic 业务逻辑
        // if(...) {
        //      throw Error()
        // } 
        // return 3 
          return 2
    },
    set() {
           // 绑定逻辑 vue 的原理
          console.log(&#39;setting value&#39;)
    }
});

console.log(obj.c) // 在什么情况下会打印出 2 ？
obj.c = 10         // 相当于运行了 set() 这个函数 打印出 setting value
console.log(obj.c) // 仍然是 2

// 也就是说可以变成一个私有变量
</code></pre><pre><code>// 如果要设置深层次的赋值
obj = {
    a: {
        b: {
            c: {
                d: 3
            }
        }
    }
}
console.log(obj.a.b.c.d); // 3

// 用 defineProperty
Object.defineProperty(obj, &#39;_deep&#39;, {
    get: function(){
        return obj.a.b.c.d;
    }
});

console.log(obj._deep); //3
</code></pre><h2 id="怎么大小通吃"><a href="#怎么大小通吃" class="headerlink" title="怎么大小通吃"></a>怎么大小通吃</h2><pre><code>// 对象和数组一起遍历
function _each(objOrArray, callback) {
    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){
        objOrArray.forEach(callback); 
    }
    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){
        for(let key in objOrArray){
            if(objOrArray.hasOwnProperty(key)){
                callback(key,objOrArray[key]);
            }
        }
    }      
}

_each([1,2,3], function(it, index) {
    console.log(it + index);  
}); 
// 1
// 3
// 5

_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {
    console.log(key + value);
});
// ab
// cd
</code></pre><pre><code>// 设置一个上下文
function _each(objOrArray, callback, ctx){
    if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object array]&#39;){
        objOrArray.forEach(callback, ctx || this); 
    }
    else if (Object.prototype.toString.call(objOrArray).toLowerCase() === &#39;[object object]&#39;){
        for(let key in objOrArray){
            if(objOrArray.hasOwnProperty(key)){
                callback.call(ctx || this, key,objOrArray[key]);
            }
        }
    }
}

_each([1,2,3], function(it, index) {
    console.log(it + index + this.a);  
}, {a: 3}); 
// 4
// 6
// 8

_each({a: &#39;b&#39;, c: &#39;d&#39;}, function(key, value) {
    console.log(key + value + this.a);
}, {a: &#39;e&#39;});
// abe
// cde
</code></pre><p>三板斧 <code>typeof</code> <code>Array.isArray([1,2])</code> <code>(Object.prototype.toString.call([1,2])</code></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[补基础：this]]></title>
      <url>/2017/10/19/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9Athis/</url>
      <content type="html"><![CDATA[<h1 id="补基础：this"><a href="#补基础：this" class="headerlink" title="补基础：this"></a>补基础：this</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/23804247?refer=study-fe" target="_blank" rel="external">this 的值到底是什么？一次说清楚</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25991271" target="_blank" rel="external">你怎么还没搞懂 this？</a></p>
<p>this的值是在函数调用的时候决定，而不是定义的时候决定</p>
</blockquote>
<h2 id="this-的四种绑定规则"><a href="#this-的四种绑定规则" class="headerlink" title="this 的四种绑定规则"></a>this 的四种绑定规则</h2><pre><code>// 默认绑定
window.a = 3;
function f() {
    let a = 4;
    console.log(this.a);
}

f(); // 3
// 通过上面的文章我们得出其实是 f().call(undefined) 默认为 global
</code></pre><pre><code>// 隐式绑定
window.a = 3;
let obj = {
    a: 4,
    f: function() {
        console.log(this.a);
    }
};

let obj1 = {
    a: 4,
    obj: {
        a: 5,
        f: function() {
            console.log(this.a);
        }
    }
};

obj.f() // obj.f.call(obj) 所以是 4
obj1.obj.f(); // obj1.obj.f.call(obj1.obj) 是 5

let f = obj1.obj.f;
f(); // f.call(undefined) 是 3
</code></pre><pre><code>// 显式绑定
window.a = 3;
let obj = {
    a: 4,
    f: function() {
        console.log(this.a);
    }
};

obj.f.call({a: 6}); // 6
let f = obj.f;
f.call({a: 5}); // 5
</code></pre><pre><code>// new绑定
function Person(age) {
    this.age = age;
}

let mike = Person(12); // Person.call(12) 如果在全局作用域写一个 12 那就会有 12 ,但是 mike.age 还是 undefined
console.log(mike.age); // undefined

// 所以应该这样写
// let mike = new Person(12)
// 关于 new 这个方法，我在原型链实现过，内部应该会有一个 call() 的用法来调用 this
</code></pre><h2 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach 方法"></a>forEach 方法</h2><pre><code>Array.prototype._forEach = function(fn) {
    // 实现一个 forEach 方法
    for(let i = 0; i &lt; this.length; i++) {
        let it = this[i];
        fn(it, i, this); // 看这里，调用的时候是这样的 fn.call(it,i,this) fn 没有绑定任何的上下文，所以是全局变量
    }
};

function Person(age) {
    this.age = age;
    [3,5,10]._forEach(function(it){
        // console.log(this) 这里其实会打印出 global 属性, 原因看上面
        console.log(`${it} year later I&#39;m ${this.age + it} year old`);
    });
}

let mike = new Person(12);
// 3 year later I&#39;m 15 year old
// 5 year later I&#39;m 17 year old
// 10 year later I&#39;m 22 year old
</code></pre><p>所以真正实现方法是：</p>
<pre><code>// 实际上原生的 forEach 可以传两个参数，一个是 callback ，还有一个其实是 this，所以其实 forEach 他本来就考虑到这种情况，所以可以直接传一个 this 进去
Array.prototype._forEach = function(fn, ctx) {
    // 实现一个 forEach 方法
    for(let i = 0; i &lt; this.length; i++) {
        let it = this[i];
        fn.call(ctx || this, it, i, this); // 所以可以这样实现
    }
};

/*
Array.prototype._forEach = function(fn) {
    for(let i = 0; i &lt; this.length; i++) {
        let it = this[i];
        fn(it, i, this);
    }
};
*/

function Person(age) {
    this.age = age;
    [3,5,10]._forEach(function(it){
        console.log(`${it} year later I&#39;m ${this.age + it} year old`);
    }, this);
}

/*
function Person(age) {
    this.age = age;
    [3,5,10]._forEach(function(it){
        console.log(`${it} year later I&#39;m ${this.age + it} year old`);
    }.bind(this)); // bind(this) 会绑定成上下文的 this
}
*/

/*
function Person(age) {
    this.age = age;
    let that = this
    [3,5,10]._forEach(function(it){
        console.log(`${it} year later I&#39;m ${that.age + it} year old`);
    });  // 使 this 变成一个普通的变量，其实和 bind(this) 是一样的套路
}
*/

/*
function Person(age) {
    this.age = age;
    [3,5,10]._forEach((it) =&gt; {
        console.log(`${it} year later I&#39;m ${this.age + it} year old`);
    }); // 
}
*/

let mike = new Person(12);
// 3 year later I&#39;m 15 year old
// 5 year later I&#39;m 17 year old
// 10 year later I&#39;m 22 year old
</code></pre><pre><code>// 这里说一下箭头函数的 this
Array.prototype._forEach = function(fn) {
    for(let i = 0; i &lt; this.length; i++) {
        let it = this[i];
        fn(it, i, this);
    }
};

function Person(age) {
    [3,5,10]._forEach((it) =&gt; {
        console.log(this);
    });
}

Person.call({a: &#39;a&#39;}); // 绑定了 call 值 输出 =&gt; {a: &#39;a&#39;}
Person(); // Person 的 this 输出 =&gt; global
let obj = {
  b: 1,
  f: Person
}

obj.f(); // 绑定了 obj 所以是 { b: 1, [Function: Person] }
</code></pre><p>这里说一个很可能会出现的 bug ，在 <code>this.age = age</code> 这里如果不加分号会出现 bug ，变成了 <code>this.age = age[3,4,5]._forEach()</code> <code>age[3,4,5]</code> 返回是一个 <code>undefined</code></p>
<h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><pre><code>// 先看 _bind 的 this 值是什么
/*
Function.prototype._bind = function(ctx) {
    console.log(this)
};

function Person(age) {
    this.age = age;
    (function(){})._bind(this)
    console.log(this)
}

let mike = new Person(12);
// Function 因为上下文的关系
// Person { age: 12 } 
*/

Function.prototype._bind = function(ctx) {
    // 实现一个 bind 方法
    // return fn
    // 注意不能用箭头函数，因为箭头函数没有 arguments
    let that = this
    let args = Array.prototype.slice.call(arguments, 1) // [1,3]
    return function() {
        let args2 = Array.prototype.slice.call(arguments) // [4,5]
          let all = args.concat(args2); 
        return that.apply(ctx, all);
    }
};

/*
Function.prototype._bind = function(ctx) {
    // 如果要用箭头函数，用 ... 取剩余的值
    let args = Array.prototype.slice.call(arguments, 1)
    return (...args2) {
        console.log(args2)
          let all = args.concat(args2); 
          cosole.log(all)
        return that.apply(ctx, all);
    }
};
*/

function Person(age) {
    this.age = age;
    [3,5,10].forEach(function(it){
        console.log(`${it} yeas later I&#39;m ${this.age + it} yeas old`);
    }._bind(this, 1, 2));
    // let fn = function(it) {
    // }._bind(this, 1, 3);
    // fn(4,5)
    // 所以用了 _bind() 方法后就是等于 fn(this, 1, 3, 4, 5)
    // let fn = function(it) {
    // }
    // let fn2 = fn._bind(this, 1, 2)
    // fn2(4, 5, 6, 7, 8)
    // 相当于 fn(1, 2, 4, 5, 6, 7, 8)
}

let mike = new Person(12);
</code></pre><p>如何摊平数组?</p>
<pre><code>// 正常来说 数组 push 一个数组那就是数组内嵌数组
let arr = [1,2]
arr.push([3,4])
arr // [1, 2, [3, 4]]
arr.concat([3, 4]) // [1, 2, [3, 4], 3, 4]
arr.push.apply(arr, [5, 6]) // [1, 2, [3, 4], 3, 4, 5, 6]
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[补基础：原型链和 prototype]]></title>
      <url>/2017/10/17/%E8%A1%A5%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%20prototype/</url>
      <content type="html"><![CDATA[<h1 id="补基础：原型链和-prototype"><a href="#补基础：原型链和-prototype" class="headerlink" title="补基础：原型链和 prototype"></a>补基础：原型链和 prototype</h1><p>先搞清楚两个东西</p>
<ul>
<li><code>__proto__</code></li>
<li><code>prototype</code></li>
</ul>
<blockquote>
<p>实例化对象的原型(<code>__proto__</code>)指向了构造函数的prototype属性</p>
</blockquote>
<p>例如</p>
<pre><code>let arr = [1,2]
let arr2 = new Array(3,4)

arr.__proto__ === Array.prototype
</code></pre><p>再举个例子</p>
<pre><code>// Array 实际是一个构造函数
Array.__proto__ === Function.prototype

// 我们经常用到的 Array.forEach Array.push 实际上是 Function 的方法
Array.prototype.forEach
Array.prototype.push

// 举个例子
let arr = [1,2]
arr.push(3)
console.log(arr) // [1,2,3]
// 利用 hasOwnProperty 的方法看看
console.log(arr.hasOwnProperty(&#39;push&#39;)) // false
console.log(Array.prototype.hasOwnProperty(&#39;push&#39;))
</code></pre><p>所以说，本身 <code>arr</code> 是没有 <code>push</code> 这个方法的 ，于是就会从他的原型上找。先会找它的原型 (<code>arr.__proto__</code> 等价与在 <code>Array.prototype</code> 里面找) 。</p>
<p> 那 <code>arr.hasOwnProperty</code> 又是怎么来的呢？</p>
<pre><code>console.log(Object.prototype.hasOwnProperty.call(arr, &#39;hasOwnProperty&#39;)) //false
console.log(Object.prototype.hasOwnProperty.call(arr.__proto__, &#39;hasOwnProperty&#39;)) //false
console.log(Object.prototype.hasOwnProperty.call(Array.prototype, &#39;hasOwnProperty&#39;)) //false
// 既然找不到，那我们可以往上一级找
// arr.__proto__.__proto___ === Array.prototype.__proto__ === Object.prototype
/*
为什么 Array 是一个对象呢？
因为是对象格式
Array.prototype = {
  push: function() {

  }
}
*/

console.log(Object.prototype.hasOwnProperty.call(Object.prototype, &#39;hasOwnProperty&#39;)) // true


/*
实际上是有尽头的
一直往原型上找的话
最后是一个 null
*/
</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>function Person(name) {
    this.name = name;
}

Person.prototype.sayHi = function() {
    console.log(`hello I&#39;m ${this.name}`);
};

let mike = new Person(&#39;mike&#39;);
console.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // false
</code></pre><pre><code>function Person(name) {
    this.name = name;
    this.sayHi = function() {
        console.log(`hello I&#39;m ${this.name}`);
    };
}

let mike = new Person(&#39;mike&#39;);
console.log(mike.hasOwnProperty(&#39;sayHi&#39;)) // true
</code></pre><p>所以说，<code>prototype</code> 会给每个实例对象赋予一个新的 <code>sayHi()</code> </p>
<pre><code>function Person(name) {
    this.name = name;
    this.sayHi = function() {
        console.log(`hello I&#39;m ${this.name}`);
    };
}


let mike = new Person(&#39;mike&#39;);
let mike2 = new Person(&#39;mike2&#39;);
mike.sayHi();
mike2.sayHi();

console.log(mike.sayHi === mike2.sayHi) // false
</code></pre><pre><code>function Person(name) {
    this.name = name;
}

Person.prototype.sayHi = function() {
    console.log(`hello I&#39;m ${this.name}`);
};

let mike = new Person(&#39;mike&#39;);
let mike2 = new Person(&#39;mike2&#39;);
mike.sayHi();
mike2.sayHi();

console.log(mike.sayHi === mike2.sayHi) // true
</code></pre><pre><code>function Person(name) {
    this.name = name;
}

Person.prototype.sayHi = function() {
    console.log(`hello I&#39;m ${this.name}`);
};

let mike = new Person(&#39;mike&#39;);
let mike2 = new Person(&#39;mike2&#39;);
mike.sayHi();
mike2.sayHi();

Person.prototype.sayHi = function() {
    console.log(`hi I&#39;m ${this.name}`);
};

mike.sayHi();
mike2.sayHi();

// hello I&#39;m mike
// hello I&#39;m mike2
// hi I&#39;m mike
// hi I&#39;m mike2
</code></pre><pre><code>function Person(name) {
    this.name = name;
}

Person.prototype.sayHi = function() {
    console.log(`hello I&#39;m ${this.name}`);
};

let mike = new Person(&#39;mike&#39;);
let mike2 = new Person(&#39;mike2&#39;);
mike.sayHi();
mike2.sayHi();

mike.sayHi = function() {
    console.log(`hi I&#39;m ${this.name}`);
};

mike.sayHi();
mike2.sayHi();

// hello I&#39;m mike
// hello I&#39;m mike2
// hi I&#39;m mike
// hello I&#39;m mike2
</code></pre><p>所以，如果要找 a 里面有没有 b 这个玩意，就一直 <code>a.__proto__.__proto__</code> … 这个子子孙孙无穷尽也 </p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote>
<p>判断自定义对象的类型</p>
</blockquote>
<pre><code>let arr = [1,2]
console.log(arr instanceof Array)
// 实际上就是 arr.__proto__ === Array.prototype
</code></pre><pre><code>let arr = [1,2]

// 实现一个 instanceof, in 是实例 fn 是构造函数
function io(ins, fn) {
    if(ins.__proto__){
        if(ins.__proto__ === fn.prototype){
            return true;
        } else {
            return io(ins.__proto__, fn);
        }
    }else {
        return false;
    }
}

/*
function io(ins, fn) {
    while(ins.__proto__ !== null){
      if(ins.__proto__ === fn.prototype){
        return true
      }
      ins = ins.__proto__
    }
    return false
}
*/

/*
function io(ins, fn) {
    if(ins.__proto__ === fn.prototype) return true
    else if(ins.__proto__ === null){
          return false
    }
    else return io(ins.__proto__, fn)
}
*/

console.log(io(arr, Array)); //true
console.log(io(arr, Object)); //true
console.log(io(arr, Number)); //false
</code></pre><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote>
<p>创建一个实例化对象，继承构造函数的一些实例和方法</p>
<ul>
<li>新生成一个对象</li>
<li>将构造函数的 this 指向这个新生成的对象</li>
<li>设置新生成对象的原型</li>
<li>执行构造函数</li>
<li>返回这个对象</li>
</ul>
</blockquote>
<pre><code>function Person(name,age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayHi = function() {
    console.log(`hello I&#39;m ${this.name}`);
};

let mike = new Person(&#39;mike&#39;);
mike.sayHi()

// 实现一个 new 方法
function myNewObject(f, ...arg) {
    var obj, ret, proto;
    proto = f.prototype;
    obj = Object.create(proto);
    ret = f.apply(obj, arg);
    return obj;
}

// function myNewObject(fn, ...arg) {
//     let obj = {}
//     obj.__proto__ = fn.prototype
//     fn.call(obj,arg)
//     return obj
// }

let mike2 = myNewObject(Person, &#39;mike2&#39;, 12);
console.log(mike2.name) // mike2
mike2.sayHi(); // hello I&#39;m mike2
console.log(mike2 instanceof Person); // true
</code></pre><pre><code>function Person(name) {
    // 看这里，因为 this 不是那个实例化对象了
    if(!(this instanceof Person)) {
        return new Person(name);
    }
    this.name = name;
}

Person.prototype.sayHi = function() {
    console.log(`hello I&#39;m ${this.name}`);
};

let mike3 = Person(&#39;mike3&#39;);
console.log(mike3) //undefined

// 怎么让 mike3 也成为一个正常的实例化对象呢？
// 看上面

console.log(mike3.name); //mike3
mike3.sayHi(); //hello I&#39;m mike3
console.log(mike3 instanceof Person); //true
</code></pre><h2 id="inheritance"><a href="#inheritance" class="headerlink" title="inheritance"></a>inheritance</h2><p>继承方法</p>
<pre><code>function Person(name) {
    this.name = name;
}

Person.prototype.sayHi = function() {
    console.log(`hello I&#39;m ${this.name}`);
};

function Student(name, grade) {
    // to-do
    Person.call(this,name);
    this.grade = grade;
}

Student.prototype = Object.create(Person.prototype); //to-do
// Student.prototype.__proto__ = Person.prototype
// Student.prototype.constructor = Student;

// 注意如果用以下这种方法
// Student.prototype = new Person()
// xiaohong.__proto__ === Student.prototype
// xiaohong.__proto__.name === undefined // 多余的东西 
// 需要的条件是
// xiaohong.__proto__ // Student.prototype
// xiaohong.__proto__.__proto__ // Person.protoype

Student.prototype.study = function(){
    console.log(&quot;I&#39;m studying&quot;);
};

let xiaohong = new Student(&#39;xiaohong&#39;, 6);
xiaohong.sayHi(); //hello I&#39;m xiaohong
xiaohong.study(); //I&#39;m studying
console.log(xiaohong.grade); //6
console.log(xiaohong.name); //xiaohong
console.log(xiaohong instanceof Person); //true
console.log(xiaohong instanceof Student); //true
console.log(xiaohong.constructor === Person); //true
</code></pre><pre><code>// 彩蛋 做一个 Object.create()
if(typeof Object.create !== &#39;function&#39;){
      Object.create = function(obj){
      function F(){}
      F.prototype = obj
      return new F()
      }
}
</code></pre><p>注意 <code>__proto__</code> 不是规范里面的，是浏览器的规范 <code>Object.getPrototype(Array) === Array.__proto__</code></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[做一个音乐 Webapp 的流程]]></title>
      <url>/2017/10/15/%E5%81%9A%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%20Webapp/</url>
      <content type="html"><![CDATA[<h1 id="做一个音乐-Webapp"><a href="#做一个音乐-Webapp" class="headerlink" title="做一个音乐 Webapp"></a>做一个音乐 Webapp</h1><p>超低仿 Vanilla JS 写的 QQ 音乐</p>
<p><a href="https://frankietang.github.io/qq-music/index.html" target="_blank" rel="external">预览</a> | <a href="https://github.com/FRANKIETANG/qq-music" target="_blank" rel="external">源码</a></p>
<p>那么乱的笔记估计就只有我才能看懂</p>
<ul>
<li>按需求制定一下接口</li>
<li>功能拆分成一个一个模块（首页 + 推荐 / 排行榜 / 搜索 / 播放器界面）</li>
<li>技术选型（CSS 预处理器 / JS 库）</li>
</ul>
<h2 id="怎么在网页抄数据"><a href="#怎么在网页抄数据" class="headerlink" title="怎么在网页抄数据"></a>怎么在网页抄数据</h2><p><img src="https://i.loli.net/2017/09/22/59c4990ac3f33.png" alt=""></p>
<h2 id="伪造请求"><a href="#伪造请求" class="headerlink" title="伪造请求"></a>伪造请求</h2><p><img src="https://i.loli.net/2017/09/23/59c5f31f6601d.png" alt=""></p>
<pre><code>curl &#39;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=1507564199109&#39; -H &#39;pragma: no-cache&#39; -H &#39;origin: https://m.y.qq.com&#39; -H &#39;accept-encoding: gzip, deflate, br&#39; -H &#39;accept-language: zh-CN,zh;q=0.8&#39; -H &#39;user-agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39; -H &#39;accept: application/json&#39; -H &#39;cache-control: no-cache&#39; -H &#39;authority: c.y.qq.com&#39; -H &#39;cookie: pgv_pvi=1576136704; pgv_si=s2924205056; RK=QfWPx2jbHN; tvfe_boss_uuid=bdd869ba21d19595; o_cookie=350558468; ts_refer=ADTAGmyqq; ptui_loginuin=350558468; ptisp=ctc; ptcz=bde020f9828475fc3e22f0fc78ba0024b7a615fad803b91694a069a02cefdb0b; pt2gguin=o0350558468; LW_sid=11S540S7L3v4m1k4L632K6r1m3; LW_uid=g1l53027M384N1y4K6Z2v6d1L4; eas_sid=H1Y5t0B7H3o461B4f692f682Y2; ts_uid=2559117424; qqmusic_fromtag=10; checkmask=3; yqq_stat=0; ts_refer=www.google.ca/; ts_uid=2559117424; pgv_info=ssid=s8871552255; pgv_pvid=2779555285&#39; -H &#39;referer: https://m.y.qq.com/&#39; --compressed
</code></pre><p><code>npm install express --save</code> </p>
<p><code>npm install request --save</code> <code>npm install request-promise --save</code>（发请求的库）</p>
<p><a href="https://github.com/request/request-promise" target="_blank" rel="external">request-promise</a></p>
<p><img src="https://i.loli.net/2017/09/23/59c60819cabdf.png" alt=""></p>
<p><code>npm install -g nodemon</code></p>
<p><a href="https://nodemon.io/" target="_blank" rel="external">nodemon</a></p>
<p>我去…用 nodemon 不能用 <code>import XXX from &#39;XXX&#39;</code> 要用 <code>var XXX = require(&#39;XXX&#39;)</code></p>
<p><img src="https://i.loli.net/2017/09/23/59c60b0dcf706.png" alt=""></p>
<p>我去…原来还有 n 模块这玩意…</p>
<p><a href="https://www.npmjs.com/package/n" target="_blank" rel="external">n</a> 接受了这个设定还是挺不错的…</p>
<pre><code>//qq-server 代码
const express = require(&#39;express&#39;)
const request = require(&#39;request-promise&#39;)

const app = express()

app.get(&#39;/&#39;, async (req, res) =&gt; {
    const url = `https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=${+ new Date()}`
    try {
        res.json(
            await request({
                uri: url,
                json: true,
                headers: {
                    &#39;accept&#39;: &#39;application/json&#39;,
                    &#39;authority&#39;: &#39;c.y.qq.com&#39;,
                    &#39;origin&#39;: &#39;https://m.y.qq.com&#39;,
                    &#39;referer&#39;: &#39;https://m.y.qq.com/&#39;,
                    &#39;user-agent&#39;: &#39;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39;
                }
            })
        )
    } catch (e) {
        res.json({ error: e.message })
    }
})

app.listen(4000)
</code></pre><p>运行 <code>nodemon qq-server.js</code> 打开 localhost:4000</p>
<p><img src="https://i.loli.net/2017/09/23/59c6163e42f5b.png" alt=""></p>
<p>开心 终于不用跨域请求了 也不用自己去抄数据了hhhh 新技能 get</p>
<p>再分析一个 API 接口</p>
<pre><code>https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=%E6%9D%8E%E8%8D%A3%E6%B5%A9&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=1&amp;remoteplace=txt.mqq.all&amp;_=1506154238572
</code></pre><p><code>w=%E6%9D%8E%E8%8D%A3%E6%B5%A9</code> 这个是李荣浩</p>
<p><img src="https://i.loli.net/2017/09/23/59c618bbb79d2.png" alt=""></p>
<pre><code>//search部分的核心代码
app.get(&#39;/search&#39;, async(req,res)=&gt;{
    const { keyword, page = 1 } = req.query
    const url=`https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?g_tk=5381&amp;uin=0&amp;format=json&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;w=${encodeURIComponent(keyword)}&amp;zhidaqu=1&amp;catZhida=1&amp;t=0&amp;flag=1&amp;ie=utf-8&amp;sem=1&amp;aggr=0&amp;perpage=20&amp;n=20&amp;p=${page}&amp;remoteplace=txt.mqq.all&amp;_=${+ new Date()}`
    try {
        res.json(
            await request({
                uri: url,
                json: true,
                headers: HEADERS
            })
        )
    } catch (e) {
        res.json({ error: e.message })
    }    
})
</code></pre><p><img src="https://i.loli.net/2017/09/23/59c6200b767cb.png" alt=""></p>
<p>所有参数都放在 ? 后面 用 &amp; 链接</p>
<p>你看真的成了</p>
<p>那就是说…我自己做了一个 API …</p>
<p>让这个 API 跨域 <code>npm install cors --save</code></p>
<p><a href="https://zeit.co/now" target="_blank" rel="external">https://zeit.co/now</a> 把做出来的 server.js 上传就可以用了</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>import export</p>
<h2 id="音乐歌词-API"><a href="#音乐歌词-API" class="headerlink" title="音乐歌词 API"></a>音乐歌词 API</h2><p><img src="https://i.loli.net/2017/09/25/59c8db302e050.png" alt=""></p>
<p>点击 network 看 JS</p>
<p>把这个地址复制，在 console 用 <code>fetch()</code> 跑一遍</p>
<p><img src="https://i.loli.net/2017/09/25/59c8dbc2a1f79.png" alt=""></p>
<p>再回到 network 看 XHR</p>
<p><img src="https://i.loli.net/2017/09/25/59c8dc2dd23db.png" alt=""></p>
<p>写一个正则，把 callback 去掉，括号去掉。</p>
<p><code>MusicJsonCallback({...}).replace(/MusicJsonCallback\((.*)\)/, &#39;$1&#39;)</code></p>
<p><code>let json = {...}</code></p>
<p><code>JSON.parse(json)</code></p>
<p><code>json.lyric</code></p>
<p><code>let div = document.createElement(&#39;div&#39;)</code></p>
<p><code>div.innerHTML = json.lyric</code></p>
<p><code>div.firstChild.nodeValue</code></p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>单页面保存数据的方式</p>
<p>就是当你打开这个页面就可以直接转跳到那首歌的入口</p>
<p><code>href=&quot;#player?artist=${artist}&amp;songid=${song.songid}&amp;songname=${song.songname}&amp;albummid=${song.albummid}&amp;duration=${song.interval}&quot;</code></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>fetch / await async</p>
<p><code>[].slice.call()</code></p>
<p>IntersectionObserver</p>
<p><code>map</code> 和 <code>forEach</code> 的区别</p>
<p>懒加载 / 曝光加载</p>
<p>正则</p>
<pre><code>&#39;View frankietang on GitHub&#39;.match(/View (\w+) on GitHub/)[1]
&#39;frankietang&#39;
</code></pre><p>css 里面的 <code>filter:blur(15px)</code> 毛玻璃效果</p>
<p>进度条可以先移到最边边，然后慢慢的往右移。</p>
<p><code>max-height: calc(100% - 205px);</code></p>
<p><code>location.hash</code> 点击时 url 的变化</p>
<p><img src="https://ooo.0o0.ooo/2017/09/28/59ccf1d9533c4.png" alt=""></p>
<p>MVC – Model View Controller</p>
<p>autoprefixer-cli</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/NonDocumentTypeChildNode/previousElementSibling" target="_blank" rel="external">NonDocumentTypeChildNode.previousElementSibling</a></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 Vue.js 的门把手（3）]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20Vue.js%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="摸到-Vue-js-的门把手（3）"><a href="#摸到-Vue-js-的门把手（3）" class="headerlink" title="摸到 Vue.js 的门把手（3）"></a>摸到 Vue.js 的门把手（3）</h1><p>回炉重造</p>
<h2 id="重看-vue-init-webpack-的选项"><a href="#重看-vue-init-webpack-的选项" class="headerlink" title="重看 vue init webpack 的选项"></a>重看 <code>vue init webpack</code> 的选项</h2><pre><code>? Generate project in current directory? Yes
? Project name vue-resume
? Project description A Vue.js project
? Author FRANKIETANG &lt;350558468@qq.com&gt;
? Vue build standalone
//可以以后再装
? Install vue-router? No
//这东西很烦，不要
? Use ESLint to lint your code? No
//不需要单元测试
? Setup unit tests with Karma + Mocha? No
//不用管
? Setup e2e tests with Nightwatch? No
</code></pre><h2 id="升级了-NPM-之后居然装不了-SCSS-？"><a href="#升级了-NPM-之后居然装不了-SCSS-？" class="headerlink" title="升级了 NPM 之后居然装不了 SCSS ？"></a>升级了 NPM 之后居然装不了 SCSS ？</h2><p>会有一个奇怪的 <code>user &quot;root&quot; does not have permission to access the dev dir &quot;/home/tangkalun/Desktop/vue-resume/node_modules/node-sass/.node-gyp/6.3.1&quot;</code></p>
<p>那就用 <code>sudo SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install --save --unsafe-perm</code></p>
<p>不行就用 <code>export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;</code></p>
<p><code>npm install --save  sass-loader node-sass</code></p>
<p>又不行？</p>
<p><code>sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p><code>sudo cnpm install --save  sass-loader node-sass --unsafe-perm</code></p>
<p>不要加 <code>--unsafe-perm</code></p>
<p>在 linux 下有可能循环安装…</p>
<p>用这句 <code>rm -rf node_modules/ &amp;&amp; npm install &amp;&amp; npm rebuild</code></p>
<p>不用想那么多。人生苦短，能用就行。</p>
<h2 id="程序构想"><a href="#程序构想" class="headerlink" title="程序构想"></a>程序构想</h2><p>和之前一样分为导航栏，侧栏编写区，预览区</p>
<h2 id="iconfont-的善用"><a href="#iconfont-的善用" class="headerlink" title="iconfont 的善用"></a>iconfont 的善用</h2><p>生成 <code>&lt;script&gt;</code> 标签直接用…不用像之前写个脚本来搞一大堆</p>
<h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h2><p><code>npm i element-ui -S</code></p>
<p><a href="http://element.eleme.io/#/zh-CN/component/installation" target="_blank" rel="external">文档</a></p>
<h2 id="数据绑定语法为-value-sync"><a href="#数据绑定语法为-value-sync" class="headerlink" title="数据绑定语法为:value.sync"></a>数据绑定语法为<code>:value.sync</code></h2><p><a href="https://vuxjs.gitbooks.io/vux/content/form/x-input.html" target="_blank" rel="external">点击这里</a></p>
<h2 id="slot-分發內容"><a href="#slot-分發內容" class="headerlink" title="slot 分發內容"></a>slot 分發內容</h2><p><a href="http://jsnwork.kiiuo.com/archives/2645/vue-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E3%80%8C%E4%BD%BF%E7%94%A8-slot-%E5%88%86%E7%99%BC%E5%85%A7%E5%AE%B9%E3%80%8D" target="_blank" rel="external">Vue – 如何理解「使用 slot 分發內容」</a></p>
<h2 id="完。"><a href="#完。" class="headerlink" title="完。"></a>完。</h2><p><a href="https://frankietang.github.io/vue-resume/dist/index.html" target="_blank" rel="external">预览</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 Vue.js 的门把手（2）]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20Vue.js%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="摸到-Vue-js-的门把手（2）"><a href="#摸到-Vue-js-的门把手（2）" class="headerlink" title="摸到 Vue.js 的门把手（2）"></a>摸到 Vue.js 的门把手（2）</h1><p>用 vue-cli 快速搭建</p>
<pre><code>npm init -y
npm install -g vue-cli
vue init webpack .
//全部回车
npm i
npm run dev
</code></pre><h2 id="项目分三组件"><a href="#项目分三组件" class="headerlink" title="项目分三组件"></a>项目分三组件</h2><p><code>&lt;Topbar/&gt;</code> / <code>&lt;ResumeEditor/&gt;</code> / <code>&lt;ResumePreview/&gt;</code></p>
<h2 id="禁用-ESLint"><a href="#禁用-ESLint" class="headerlink" title="禁用 ESLint"></a>禁用 ESLint</h2><pre><code>//build/webpack.base.conf.js
  module: {
    rules: [
      //{
        //test: /\.(js|vue)$/,
        //loader: &#39;eslint-loader&#39;,
        //enforce: &quot;pre&quot;,
        //include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],
        //options: {
          //formatter: eslintFriendlyFormatter
        //}
      //},
</code></pre><h2 id="GitHub-预览"><a href="#GitHub-预览" class="headerlink" title="GitHub 预览"></a>GitHub 预览</h2><pre><code>//config/index.js
assetsPublicPath: &#39;/vue-resume/dist&#39;,
</code></pre><p><code>npm run build</code></p>
<p><code>https://frankietang.github.io/vue-resume/dist/#/</code></p>
<h2 id="使用-SCSS"><a href="#使用-SCSS" class="headerlink" title="使用 SCSS"></a>使用 SCSS</h2><p><code>npm install --save  sass-loader node-sass</code></p>
<h2 id="SVG-合并和使用方法"><a href="#SVG-合并和使用方法" class="headerlink" title="SVG 合并和使用方法"></a>SVG 合并和使用方法</h2><ul>
<li><a href="https://github.com/FRANKIETANG/vue-resume/commit/a112088f1c0bc772813f855139fcdd4cdeeea380" target="_blank" rel="external">使用脚本将所有 svg 拼成一个 svg，原来的多个 svg 变成了多个 symbol</a></li>
<li><a href="https://github.com/FRANKIETANG/vue-resume/commit/78556c0f7cb18d20e078f3abbbb85fd9b4c8ed43" target="_blank" rel="external">运行 node build/svg-symbol.js</a></li>
<li><a href="https://github.com/FRANKIETANG/vue-resume/commit/476cec015bbea1e7fc55bbfb33ba627c68353084" target="_blank" rel="external">将 SVG 插入 body 中</a></li>
</ul>
<pre><code>//任意地方
&lt;svg&gt;
  &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;
&lt;/svg&gt;
</code></pre><p><strong>值得注意的是，之前的 ResumeEditor 中的 data 是对象，对象是无序的，应该用数组让项目有一个完整的顺序</strong></p>
<h2 id="填写区核心代码"><a href="#填写区核心代码" class="headerlink" title="填写区核心代码"></a>填写区核心代码</h2><pre><code>        &lt;ol class=&quot;panels&quot;&gt;
            &lt;li v-for=&quot;item in resume.config&quot; 
            v-show=&quot;item.field === selected&quot;&gt;
                &lt;div v-if=&quot;resume[item.field] instanceof Array&quot;&gt;
                    &lt;div class=&quot;subitem&quot; v-for=&quot;subitem in resume[item.field]&quot;&gt;
                        &lt;div class=&quot;resumeField&quot; v-for=&quot;(value,key) in subitem&quot;&gt;
                            &lt;label&gt;{{key}}&lt;/label&gt;
                            &lt;input type=&quot;text&quot; :value=&quot;value&quot;&gt;                            
                        &lt;/div&gt;
                        &lt;hr&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div v-else class=&quot;resumeField&quot; 
                v-for=&quot;(value,key) in resume[item.field]&quot;&gt;
                    &lt;label&gt;{{key}}&lt;/label&gt;
                    &lt;input type=&quot;text&quot; 
                    v-model=&quot;resume[item.field][key]&quot;&gt;
                &lt;/div&gt;
            &lt;/li&gt;
        &lt;/ol&gt;
</code></pre><h2 id="如何把填进去的数据放到预览页面呢？"><a href="#如何把填进去的数据放到预览页面呢？" class="headerlink" title="如何把填进去的数据放到预览页面呢？"></a>如何把填进去的数据放到预览页面呢？</h2><p>可以做一个公共数据储存区域</p>
<p>填写区填进去的数据先放到公共数据再传到预览区</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p><a href="https://jsfiddle.net/n9jmu5v7/1269/" target="_blank" rel="external">最基本的 Vuex 记数应用</a></p>
<h2 id="getter-与-setter"><a href="#getter-与-setter" class="headerlink" title="getter 与 setter"></a>getter 与 setter</h2><pre><code>computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + &#39; &#39; + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
</code></pre><h2 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h2><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>
<pre><code>// ...
mutations: {
  increment (state, n) {
    state.count += n
  }
}

store.commit(&#39;increment&#39;, 10)
</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>
<pre><code>// ...
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}

store.commit(&#39;increment&#39;, {
  amount: 10
})
</code></pre><h2 id="store"><a href="#store" class="headerlink" title="$store"></a>$store</h2><p>这个 <code>$</code> 在 Vue 里是代表全局的意思</p>
<h2 id="多次-import-同一个文件"><a href="#多次-import-同一个文件" class="headerlink" title="多次 import 同一个文件"></a>多次 import 同一个文件</h2><p>Node对引入的模块都会进行缓存（缓存的是编译和执行后的对象），减少二次引入开销；<br>在Node的加载机制中，缓存的优先级是最高的；<br>这一点同时适用于不同的模块加载机制，无论ES2015的import还是CommonJS的require；</p>
<h2 id="CSS-white-space-pre-line"><a href="#CSS-white-space-pre-line" class="headerlink" title="CSS white-space: pre-line"></a>CSS white-space: pre-line</h2><p>去除一行文本中的空格，但是保留一行的换行符，作用是防止用户在输入框输入空格而产生对用户不友好显示效果</p>
<h2 id="Object-Path"><a href="#Object-Path" class="headerlink" title="Object-Path"></a>Object-Path</h2><p><a href="https://github.com/mariocasciaro/object-path" target="_blank" rel="external">object-path</a></p>
<p><a href="https://satanwoo.github.io/2015/11/05/Object-Path-Source-Code/" target="_blank" rel="external">Object-Path 源码解读</a></p>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p><code>Object.assign()</code> 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">Object.assign()</a></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><pre><code>//旧版本
components: {
  &#39;MyDialog&#39;: MyDialog
}
//ES6
components: {
  MyDialog
}
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 Vue.js 的门把手]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20Vue.js%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="摸到-Vue-js-的门把手"><a href="#摸到-Vue-js-的门把手" class="headerlink" title="摸到 Vue.js 的门把手"></a>摸到 Vue.js 的门把手</h1><p>文档那么多中文多和谐啊是不是？<a href="https://cn.vuejs.org/" target="_blank" rel="external">Vue.js</a></p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>先把 webpack 给配好。</p>
<p>接下来我们输入 Vue.js 测试代码给我们的代码</p>
<pre><code>//index.html
      &lt;div id=&quot;app&quot;&gt;
          {{ message }}
      &lt;/div&gt; 
//index.js
import Vue from &#39;vue&#39;

var app = new Vue({
    el: &#39;#app&#39;,
    data: {
      message: &#39;Hello Vue!&#39;
    }
  })
</code></pre><p>真的是非常的和谐，很像 React </p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-19472a5df4b492fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><pre><code>//index.html
&lt;div class=&quot;newTask&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;
&lt;/div&gt;
//index.js
var app = new Vue({
    el: &#39;#app&#39;,
    data: {
        newTodo: &#39;&#39;,
        todoList: []
    },
    created: function(){
        let i = 0
        setInterval(()=&gt;{
            this.newTodo = i
            i += 1
        },1000)
    }
})
</code></pre><p>只要 data.newTodo 被 JS 改了，input.value 就会变成一样的值。</p>
<pre><code>//index.html
&lt;div class=&quot;newTask&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot;&gt;
&lt;/div&gt;
//index.js
var app = new Vue({
    el: &#39;#app&#39;,
    data: {
        newTodo: &#39;&#39;,
        todoList: []
    },
    created: function(){
        let i = 0
        setInterval(()=&gt;{
            console.log(this.newTodo)
            i += 1
        },1000)
    }
})
</code></pre><p>只要 input.value 被用户改了，data.newTodo 就会变成一样的值；</p>
<h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><pre><code>//index.html
&lt;input type=&quot;text&quot; v-model=&quot;newTodo&quot; @keypress.enter=&quot;addTodo&quot;&gt;
//index.js
methods: {
    addTodo: function(){
        this.todoList.push({
            title: this.newTodo,
            createdAt: new Date()
        })
        console.log(this.todoList)
    }
}
</code></pre><h2 id="输入东西在页面展示"><a href="#输入东西在页面展示" class="headerlink" title="输入东西在页面展示"></a>输入东西在页面展示</h2><pre><code>&lt;li v-for=&quot;todo in todoList&quot;&gt;
  {{ todo.title }}
&lt;/li&gt;
</code></pre><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><pre><code>//index.html
&lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;{{ todo.title }}
&lt;span v-if=&quot;todo.done&quot;&gt;已完成&lt;/span&gt;
&lt;span v-else&gt;未完成&lt;/span&gt;
//index.js
addTodo: function(){
    this.todoList.push({
        title: this.newTodo,
        createdAt: new Date(),
        done: false
    })
    this.newTodo = &quot;&quot; //input 框变成空的
}
</code></pre><h2 id="localStorage-保存数据"><a href="#localStorage-保存数据" class="headerlink" title="localStorage 保存数据"></a>localStorage 保存数据</h2><pre><code>created: function() {
  window.onbeforeunload = () =&gt;{
    let dataString = JSON.stringify(this.todoList)
    window.localStorage.setItem(&#39;myTodos&#39;, dataString)
  }
  let oldDataString = window.localStorage.getItem(&#39;myTodos&#39;)
  let oldData = JSON.parse(oldDataString)
  this.todoList = oldData || []
},
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload" target="_blank" rel="external">onbeforeunload - MDN</a> 当窗口即将被<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onunload" target="_blank" rel="external"><code>卸载</code></a>时,会触发该事件.此时页面文档依然可见,且该事件的默认动作可以被<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault" target="_blank" rel="external"><code>取消</code></a>.</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="external">JSON - MDN</a> 简单深拷贝</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="external">localStorage - MDN</a> <code>localStorage</code> 属性允许你访问一个 local <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="external"><code>Storage</code></a> 对象。存储在 localStorage 里面的数据没有过期时间（expiration time）。</p>
<h2 id="数据存储选-leancloud"><a href="#数据存储选-leancloud" class="headerlink" title="数据存储选 leancloud"></a>数据存储选 leancloud</h2><p><a href="https://leancloud.cn/docs/start.html" target="_blank" rel="external">JavaScript SDK 安装指南</a></p>
<p><a href="https://leancloud.cn/docs/leanstorage_guide-js.html#数据存储开发指南___JavaScript" target="_blank" rel="external">数据存储开发指南 · JavaScript</a></p>
<p>之前有一个没有注意到的东西，就是利用这一段代码的时候打印出来的东西</p>
<pre><code>    signUp: function () {
      let user = new AV.User();
      user.setUsername(this.formData.username);
      user.setPassword(this.formData.password);
      user.signUp().then(function (loginedUser) {
        console.log(loginedUser);
      }, function (error) {
      });
    }
</code></pre><blockquote>
<p>注意打印出来的三个属性：attributes, createdAt, id。</p>
<p>其中 attributes 就是我们传给数据库的 username（我们不是还传了一个 password 吗？服务器是不会把 password 传给前端的）</p>
<p>createdAt 是这个数据创建的时间，id 是用户的 id，也是我们区别用户的唯一凭据。</p>
</blockquote>
<h2 id="Vue-的切换-Tab"><a href="#Vue-的切换-Tab" class="headerlink" title="Vue 的切换 Tab"></a>Vue 的切换 Tab</h2><p>在 React 中是这样切换的</p>
<pre><code>{ this.state.selectedTab === &#39;signInOrSignUp&#39; ? &lt;SignIn /&gt;  : &lt;SignUp /&gt; }
</code></pre><p>而 Vue 是这样</p>
<pre><code>&lt;div class=&quot;signUp&quot; v-if=&quot;actionType === &#39;signUp&#39;&quot;&gt;
&lt;div class=&quot;logIn&quot; v-if=&quot;actionType === &#39;logIn&#39;&quot;&gt;
</code></pre><h2 id="可注册-可登入-可登出-功能"><a href="#可注册-可登入-可登出-功能" class="headerlink" title="可注册 / 可登入 / 可登出 功能"></a>可注册 / 可登入 / 可登出 功能</h2><p>这个和我之前 React 没什么区别了</p>
<p>就是看 leancloud 的文档抄抄</p>
<p>注意 <code>v-if</code> 的使用技巧</p>
<h2 id="保存数据功能"><a href="#保存数据功能" class="headerlink" title="保存数据功能"></a>保存数据功能</h2><p><a href="https://leancloud.cn/docs/leanstorage_guide-js.html#保存对象" target="_blank" rel="external">保存数据</a></p>
<pre><code>  // 声明类型
  var TodoFolder = AV.Object.extend(&#39;TodoFolder&#39;);
  // 新建对象
  var todoFolder = new TodoFolder();
  // 设置名称
  todoFolder.set(&#39;name&#39;,&#39;工作&#39;);
  // 设置优先级
  todoFolder.set(&#39;priority&#39;,1);
  todoFolder.save().then(function (todo) {
    console.log(&#39;objectId is &#39; + todo.id);
  }, function (error) {
    console.error(error);
  });
</code></pre><p>照着抄</p>
<p>注意不可以把代码放在 <code>window.onbeforeunload</code> 里，请求发出页面就刷新了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-509e312e01c9434c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>从结果可以看到，AllTodos 保存请求失败了，被 <code>canceled</code> 了。</p>
<p>如果一个页面就要死了（刷新就表示不要当前页面了，当前页面可以死了），那么这个页面发出的请求其实就没有任何意义了。既然没有意义，浏览器为什么浪费时间去发这个页面里的请求呢？所以浏览器直接取消了这个请求。</p>
<p>简单来说，那就是：beforeunload 事件里面的所有请求都发不出去，会被取消！<br>我还从来没有在哪一本书里看到过这个知识点。所以说「实践」是非常重要的。</p>
</blockquote>
<p>这样就应该把上面那一段代码封装成一个函数调用。</p>
<h2 id="角色权限管理"><a href="#角色权限管理" class="headerlink" title="角色权限管理"></a>角色权限管理</h2><p><a href="https://leancloud.cn/docs/acl-guide.html#角色的创建" target="_blank" rel="external">角色的创建</a></p>
<pre><code>  // 创建一个针对 User 的查询
  var query = new AV.Query(AV.User);
  query.get(&#39;55f1572460b2ce30e8b7afde&#39;).then(function(otherUser) {
    var post = new AV.Object(&#39;Post&#39;);
    post.set(&#39;title&#39;, &#39;这是我的第二条发言，谢谢大家！&#39;);
    post.set(&#39;content&#39;,&#39;我最近喜欢看足球和篮球了。&#39;);

    // 新建一个 ACL 实例
    var acl = new AV.ACL();
    acl.setPublicReadAccess(true);
    acl.setWriteAccess(AV.User.current(), true);
    acl.setWriteAccess(otherUser, true);

    // 将 ACL 实例赋予 Post 对象
    post.setACL(acl);

    // 保存到云端
    return post.save();
  }).then(function() {
    // 保存成功
  }).catch(function(error) {
    // 错误信息
    console.log(error);
  });
</code></pre><h2 id="居然有-React-一样的-BUG"><a href="#居然有-React-一样的-BUG" class="headerlink" title="居然有 React 一样的 BUG"></a>居然有 React 一样的 BUG</h2><p>就是 logout 之后 再 login 别的账号会没有数据</p>
<p>和 React 的解决方法一样封装成一个函数放在 <code>methods</code> 里。</p>
<h2 id="遇到奇怪的-BUG"><a href="#遇到奇怪的-BUG" class="headerlink" title="遇到奇怪的 BUG"></a>遇到奇怪的 BUG</h2><pre><code>rm -rf node_modules/
npm install
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 React 的门把手 (完)]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(%E5%AE%8C)/</url>
      <content type="html"><![CDATA[<h1 id="摸到-React-的门把手-完"><a href="#摸到-React-的门把手-完" class="headerlink" title="摸到 React 的门把手 (完)"></a>摸到 React 的门把手 (完)</h1><p>写啊写啊终于把大概功能给写完了 <a href="https://frankietang.github.io/banana-todolist/build/index.html#" target="_blank" rel="external">效果</a> ，CSS 真难写啊… 我的同学说，审美这些东西要慢慢培养。</p>
<p>接下来我们来说说这个项目用到了什么知识点。</p>
<h2 id="1-JSX-React-webpack-LeanCloud-等知识。"><a href="#1-JSX-React-webpack-LeanCloud-等知识。" class="headerlink" title="1. JSX / React / webpack / LeanCloud 等知识。"></a>1. JSX / React / webpack / LeanCloud 等知识。</h2><p>在我博客都有很详细的介绍，这里就不多说了。<a href="https://frankietang.github.io/" target="_blank" rel="external">我的博客</a></p>
<h2 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2. HTML"></a>2. HTML</h2><h3 id="2-1-form-表单"><a href="#2-1-form-表单" class="headerlink" title="2.1 form 表单"></a>2.1 form 表单</h3><p><code>&lt;input id=&quot;xxx&quot;&gt;</code> 和 <code>&lt;label for=&quot;xxx&quot;&gt;</code> 可以对应关联</p>
<h3 id="2-2-HTML5-LocalStorage-本地存储"><a href="#2-2-HTML5-LocalStorage-本地存储" class="headerlink" title="2.2 HTML5 LocalStorage 本地存储"></a>2.2 HTML5 LocalStorage 本地存储</h3><p>在这个项目里 LocalStorage 的用法是这样的</p>
<ul>
<li>用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage</li>
<li>重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList</li>
</ul>
<pre><code>export function save(key,value){
    return window.localStorage.setItem(key,
        JSON.stringify(value))
}

export function load(key){
    return JSON.parse(window.localStorage.getItem(key))
}
</code></pre><h2 id="3-CSS"><a href="#3-CSS" class="headerlink" title="3. CSS"></a>3. CSS</h2><h3 id="3-1-flex-布局"><a href="#3-1-flex-布局" class="headerlink" title="3.1 flex 布局"></a>3.1 flex 布局</h3><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>
<h3 id="3-2-CSS-选择器"><a href="#3-2-CSS-选择器" class="headerlink" title="3.2 CSS 选择器"></a>3.2 CSS 选择器</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started/Selectors" target="_blank" rel="external">CSS 选择器 - MDN</a></p>
<h2 id="4-JavaScript"><a href="#4-JavaScript" class="headerlink" title="4. JavaScript"></a>4. JavaScript</h2><h3 id="4-1-import…from…"><a href="#4-1-import…from…" class="headerlink" title="4.1 import…from…"></a>4.1 import…from…</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="external">import - MDN</a></p>
<p><strong>import 语句 </strong>用于从一个已经导出的外部模块或另一个脚本中导入函数，对象或原始类型。</p>
<h3 id="4-2-ES6-Class"><a href="#4-2-ES6-Class" class="headerlink" title="4.2 ES6 - Class"></a>4.2 ES6 - Class</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">Class - MDN</a> <a href="http://es6.ruanyifeng.com/#docs/class#Class-的-Generator-方法" target="_blank" rel="external">Class 的基本语法</a></p>
<p>而我的项目最多是用到 <code>constructor()</code> / <code>extends</code> / <code>super()</code> ，这里举一个例子</p>
<pre><code>class TestSuper {
  constructor() {
    this.a = &#39;a&#39;
  }
}
class Test extends TestSuper {
  constructor() {
    super()
    this.b = &#39;b&#39;
  }
}
let inst = new Test()
console.log(inst.a)   //a
console.log(inst)     //Test{a:&#39;a&#39;,b:&#39;b&#39;}
</code></pre><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<p><code>extends</code> 关键词被用在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="external">类声明</a>或者<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class" target="_blank" rel="external">类表达式</a>上，以创建一个类是另一个类的子类。</p>
<p><code>super</code> 关键字用于调用一个对象的父对象上的函数。</p>
<h3 id="4-3-ES6-箭头函数"><a href="#4-3-ES6-箭头函数" class="headerlink" title="4.3 ES6 - 箭头函数"></a>4.3 ES6 - 箭头函数</h3><pre><code>var f = v =&gt; v;
var f1 = v =&gt; {
  return v
}
//相当于
var f = function f(v) {
    return v;
};
var f1 = function f1(v) {
    return v;
};
</code></pre><h3 id="4-4-拓展运算符"><a href="#4-4-拓展运算符" class="headerlink" title="4.4 拓展运算符"></a>4.4 拓展运算符</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="external">扩展语句 - MDN</a></p>
<pre><code>const pa = (...args) =&gt; {
    console.log(args);
    return args.reduce((pre,cur) =&gt; {
        return pre+cur;
    }, 0);
};
pa.apply(this, [1,2,45]);
//[1,2,45]
//48
</code></pre><h3 id="4-5-逻辑运算符-用来定义默认参数"><a href="#4-5-逻辑运算符-用来定义默认参数" class="headerlink" title="4.5 逻辑运算符 || 用来定义默认参数"></a>4.5 逻辑运算符 || 用来定义默认参数</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="external">逻辑运算符</a></p>
<pre><code>var link = function (height,color,url) {
  var height = height || 50
  var color = color || &#39;red&#39;
  var url = url || &#39;https://frankie.github.io&#39;
}
</code></pre><h3 id="4-6-深拷贝"><a href="#4-6-深拷贝" class="headerlink" title="4.6 深拷贝"></a>4.6 深拷贝</h3><pre><code>//deep Clone
let obj1 = {a: 0, b: {c: 0}};
let obj3 = JSON.parse(JSON.stringify(obj1));
obj1.a = 4;
obj1.b.c = 4;
console.log(JSON.stringify(obj3)); // {a: 0, b: {c: 0}}
</code></pre><h3 id="4-7-条件（三元）运算符"><a href="#4-7-条件（三元）运算符" class="headerlink" title="4.7 条件（三元）运算符"></a>4.7 条件（三元）运算符</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="external">条件运算符</a></p>
<pre><code>condition ? expr1 : expr2
</code></pre><h3 id="4-8-apply-call-bind"><a href="#4-8-apply-call-bind" class="headerlink" title="4.8 apply() / call() / bind()"></a>4.8 apply() / call() / bind()</h3><pre><code>var xw = {
  name : &quot;小王&quot;,
  gender : &quot;男&quot;,
  age : 24,
  say : function() {
      alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age);        
    }
}
var xh = {
  name : &quot;小红&quot;,
  gender : &quot;女&quot;,
  age : 18
}
xw.say();
xw.say.call(xh);
xw.say.apply(xh);
xw.say.bind(xh)();
</code></pre><p>call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。</p>
<pre><code>var xw = {
  name : &quot;小王&quot;,
  gender : &quot;男&quot;,
  age : 24,
  say : function(school,grade) {
    alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age + &quot; ,在&quot; + school + &quot;上&quot; + grade);  
  }
}
var xh = {
  name : &quot;小红&quot;,
  gender : &quot;女&quot;,
  age : 18
}
xw.say.call(xh,&quot;实验小学&quot;,&quot;六年级&quot;);
xw.say.apply(xh,[&quot;实验小学&quot;,&quot;六年级&quot;]);
xw.say.bind(xh,&quot;实验小学&quot;,&quot;六年级&quot;)();
xw.say.bind(xh)(&quot;实验小学&quot;,&quot;六年级&quot;);
</code></pre><p>call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。<br>那么bind怎么传参呢？它可以像call那样传参。</p>
<h3 id="4-9-event-preventDefault"><a href="#4-9-event-preventDefault" class="headerlink" title="4.9 event.preventDefault"></a>4.9 event.preventDefault</h3><p>如果事件可取消，则取消该事件，而不停止事件的进一步传播。</p>
<p>例子：切换复选框是单击复选框的默认操作。此示例演示如何防止这种情况发生</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;event.preventDefault()&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;请点击复选框控件&lt;/p&gt;
    &lt;form&gt;
        &lt;label for=&quot;id-checkbox&quot;&gt;Checkbox&lt;/label&gt;
        &lt;input type=&quot;checkbox&quot; id=&quot;id-checkbox&quot; name=&quot;checkbox&quot; /&gt;
    &lt;/form&gt;
    &lt;script&gt;
        document.querySelector(&quot;#id-checkbox&quot;).addEventListener(&quot;click&quot;, function(event){
            alert(&quot;preventDefault会阻止该复选框被勾选.&quot;)
            event.preventDefault();
            //阻止该复选框被勾选
        }, false);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="4-10-this"><a href="#4-10-this" class="headerlink" title="4.10 this"></a>4.10 this</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">this</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">Javascript的this用法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/23804247?refer=study-fe" target="_blank" rel="external">this 的值到底是什么？一次说清楚</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25991271" target="_blank" rel="external">你怎么还没搞懂this</a></p>
<h3 id="4-11-JavaScript-的-new"><a href="#4-11-JavaScript-的-new" class="headerlink" title="4.11 JavaScript 的 new"></a>4.11 JavaScript 的 new</h3><p><a href="https://zhuanlan.zhihu.com/p/23987456?refer=study-fe" target="_blank" rel="external">JS 的 new 到底是干什么的？</a></p>
<h2 id="5-最后的一点建议"><a href="#5-最后的一点建议" class="headerlink" title="5. 最后的一点建议"></a>5. 最后的一点建议</h2><p>还是好好的刷一遍《JavaScript 高级程序设计》和《ES6 标准入门》吧，要不然基础差的你很难上手 React 。</p>
<h2 id="6-相关链接"><a href="#6-相关链接" class="headerlink" title="6. 相关链接"></a>6. 相关链接</h2><p><a href="https://frankietang.github.io/2017/08/17/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 ES6 的门把手</a></p>
<p><a href="https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 webpack 的门把手</a></p>
<p><a href="https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/" target="_blank" rel="external">摸到 webpack 的门把手 (2)</a></p>
<p><a href="https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 React 的门把手</a></p>
<p><a href="https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/" target="_blank" rel="external">摸到 React 的门把手 (2)</a></p>
<p><a href="https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/" target="_blank" rel="external">摸到 React 的门把手 (3)</a></p>
<p><a href="https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%284%29/" target="_blank" rel="external">摸到 React 的门把手 (4)</a></p>
<p><a href="https://frankietang.github.io/2017/08/24/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%285%29/" target="_blank" rel="external">摸到 React 的门把手 (5)</a></p>
<p><a href="https://frankietang.github.io/2017/08/25/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%286%29/" target="_blank" rel="external">摸到 React 的门把手 (6)</a></p>
<p>这个项目的 2.0 版将会无限期跳票…</p>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 React 的门把手 (6)]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(6)/</url>
      <content type="html"><![CDATA[<h1 id="摸到-React-的门把手-6"><a href="#摸到-React-的门把手-6" class="headerlink" title="摸到 React 的门把手 (6)"></a>摸到 React 的门把手 (6)</h1><p>慢慢的撸出一个应用，就像看着自己的孩子长大一样。</p>
<h2 id="继续撸代码"><a href="#继续撸代码" class="headerlink" title="继续撸代码"></a>继续撸代码</h2><p>增加邮箱注册并找回密码的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-adc098e0863d2a19.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>请求 LeanCloud 的 API</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-d526e3072a087e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>返回登录框</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-cb586c8af567044d.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h2 id="分成一个一个小模块"><a href="#分成一个一个小模块" class="headerlink" title="分成一个一个小模块"></a>分成一个一个小模块</h2><p>就是把每个功能分成一个一个的小模块，但是在这一步要注意，会有大量的<code>props</code>和<code>state</code>。只要不弄混，你就能体会到模块化的好处。</p>
<p><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="external">React Developer Tools</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-85d314006e43f8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们用 props 在组件直接传递数据（从父组件到子组件），用 state 保存组件自身的数据，这就是 props 和 state 的区别。</p>
<p>注意每个模块的<code>state</code> </p>
<p>App 的 <code>state</code></p>
<pre><code>this.state = {
  user: getCurrentUser() || {},
  newTodo: &#39;&#39;,
  todoList: []
}
</code></pre><p>UserDialog 的 <code>state</code></p>
<pre><code>this.state = {
  selectedTeb: &#39;signInOrSignUp&#39;, //forgotPassword
  formData: {
    email: &#39;&#39;,
    username: &#39;&#39;,
    password: &#39;&#39;,
  }
}
</code></pre><p>SignInOrSignUp 的 <code>state</code></p>
<pre><code>this.state = {
  selected: &#39;signUp&#39;
}
</code></pre><p>所以说<code>state</code>的分布策略是每个组件只保存与自己有关系的数据到state里。而<code>props</code>的用法就是，负责传递数据或函数到子组件中。</p>
<p>如果一个组件没有<code>state</code>只有<code>props</code>，说明这个组件没有特殊逻辑，是一个纯（pure）的组件，而且还有一个特点是不能对（props）做任何修改。</p>
<p><a href="https://facebook.github.io/react/docs/components-and-props.html#props-are-read-only" target="_blank" rel="external">Props are Read-Only</a></p>
<p>我们可以把组件只有 <code>props</code> 没有 <code>state</code> 写成一个函数。</p>
<p>在封装的时候要注意<code>this</code>，因为之前还是一个组件，所以是可以利用<code>this</code>来接住父组件的数据的，而变成了一个函数之后，<code>this</code>传入就是这个函数的东西了。所以 <code>{this.props.xxx}</code>就变成了<code>{props.props.xxx}</code>。</p>
<p>另外如果组件只有一个方法，也可以改写一个函数</p>
<p>注意</p>
<pre><code>export default function (props) {
    return &lt;input type=&quot;text&quot; value={props.content} 
    className=&quot;TodoInput&quot; 
    onKeyPress={submit.bind(null,props)} 
    onChange={changeTitle.bind(null,props)}/&gt;
}
//相当于
let temp = function(e){
    changeTitle.call(null, props, e)
}
onChange={temp}
</code></pre><p>可以说这几行代码是很看基础的。</p>
<p>为什么在那几个函数明明没有用到 React ，但是要用 import React 。这是因为这个函数里面有 JSX ，而引用了这句话后<code>import React from &#39;react</code>浏览器就能读懂。<a href="http://web.jobbole.com/91637/" target="_blank" rel="external">我想这将是最有价值的 react 入门与进阶教程</a></p>
<p>重构到此为止</p>
<h2 id="把-TodoItem-的数据上传到云端"><a href="#把-TodoItem-的数据上传到云端" class="headerlink" title="把 TodoItem 的数据上传到云端"></a>把 TodoItem 的数据上传到云端</h2><p>我们再回过去看看 LeanCloud 的文档</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-087167c7a4e954a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>把这段代码复制来用一下，却得到了这样的反馈。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-4c6b054d27c27e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>控制中心也收到数据了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-1cb2b198f0b21514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>所以我们就思考一下 TodoItem 的流程</p>
<ul>
<li>创建一个 Todo，就在中心留下一条记录</li>
<li>用户修改一个 Todo，就发请求修改对应的 Todo</li>
<li>用户删除 Todo，我们就删除一个</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-213d7d92c6c93bf2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>这里要用到文档里的代码 <a href="https://leancloud.cn/docs/leanstorage_guide-js.html#批量操作" target="_blank" rel="external">批量操作</a> <a href="https://leancloud.cn/docs/acl-guide.html#单用户权限设置" target="_blank" rel="external">单用户权限设置</a> <a href="https://leancloud.cn/docs/leanstorage_guide-js.html#删除对象" target="_blank" rel="external">删除对象</a> <a href="https://leancloud.cn/docs/leanstorage_guide-js.html#更新对象" target="_blank" rel="external">更新对象</a></p>
<p>注意在更新对象的函数</p>
<pre><code>  update({id,title,status,deleted},successFn,errorFn){
    let todo = AV.Object.createWithoutData(&#39;Todo&#39;,id)
    title !== undefined &amp;&amp; todo.set(&#39;title&#39;,title)
    status !== undefined &amp;&amp; todo.set(&#39;status&#39;,status)
    deleted !== undefined &amp;&amp; todo.set(&#39;deleted&#39;,deleted)
//这里为什么要那么麻烦？
//为什么我要像上面那样写代码？
//考虑如下场景
//update({id:1, title:&#39;hi&#39;})
//调用 update 时，很有可能没有传 status 和 deleted
//也就是说，用户只想「局部更新」
//所以我们只 set 该 set 的
//那么为什么不写成 title &amp;&amp; todo.set(&#39;title&#39;, title) 呢，为什么要多此一举跟 undefined 做对比呢？
//考虑如下场景
//update({id:1, title: &#39;&#39;, status: null}}
//用户想将 title 和 status 置空，我们要满足
    todo.save().then((response) =&gt; {
      successFn &amp;&amp; successFn.call(null)
    },(error) =&gt; {
      errorFn &amp;&amp; errorFn.call(null,error)
    })
  }
</code></pre><p>啊真的累，React 真的难啊，几个小模块就那么多接口…</p>
<p><a href="https://github.com/FRANKIETANG/banana-todolist/commits/master" target="_blank" rel="external">所有代码</a></p>
<p><a href="https://frankietang.github.io/banana-todolist/build/index.html" target="_blank" rel="external">预览</a></p>
<p>我会另开几篇文章来详解这里免得知识点的，因为涉及的知识点有点多。</p>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 React 的门把手 (5)]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(5)/</url>
      <content type="html"><![CDATA[<h1 id="摸到-React-的门把手-5"><a href="#摸到-React-的门把手-5" class="headerlink" title="摸到 React 的门把手 (5)"></a>摸到 React 的门把手 (5)</h1><p>这次我们就来天我们上一次挖的深坑 <a href="https://frankietang.github.io/2017/08/22/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(4" target="_blank" rel="external">摸到 React 的门把手 (4)</a>/) ，慢慢填，不用急。干那么快干嘛，要好好享受过程。体验学到知识的快感。</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>看名字就感觉应该是一个保存本地数据的玩意对吧（我猜的）<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="external">loocalStorage</a></p>
<p>我们用这个方法就可以保存数据而不会一刷新就会初始化了</p>
<ul>
<li>用户提交数据的时候，将所有的 todo 字符串的形式保存在 localStorage</li>
<li>重新打开页面的时候，将 localStorage 里面的字符串变为对象赋值给 todoList</li>
</ul>
<p>封装 localStorage 封装成两个函数</p>
<pre><code>export function save(key,value){
    return window.localStorage.setItem(key,
        JSON.stringify(value))
}

export function load(key){
    return JSON.parse(window.localStorage.getItem(key))
}
</code></pre><p>load 和 save 的调用</p>
<pre><code>// load
localStore.load(&#39;todoList&#39;) || []
// save
localStore.save(&#39;todoList&#39;,this.state.todoList)
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3191557-7c1b95c23aa12525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><code>||</code> 居然还有这种操作？可以用来定义默认参数？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-0dcd24f922e4a0aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>不过 ES6 有了新的默认参数用法</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-48b523717d27a58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>好了这里就不展开了。</p>
<h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><p>之前在每个 setState 之后会运行一次 save，但是我们知道 componentDidUpdate 会在组件更新之后调用，相当于 “组件更新” 等价于 “数据更新”</p>
<p>利用 componentDidUpdate 封装代码。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>其实我们不需要服务器，用 LeanCloud 就可以了。</p>
<p>点击创建应用</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-f47971710bf3edd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><a href="https://leancloud.cn/docs/leanstorage_guide-js.html" target="_blank" rel="external">看文档</a></p>
<p><a href="https://leancloud.cn/docs/sdk_setup-js.html" target="_blank" rel="external">JavaScript SDK 安装指南</a></p>
<p>安装</p>
<pre><code>$ sudo npm install leancloud-storage --save
</code></pre><p>复制这一段代码到我们的App.js</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-49cd74d87191419f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<pre><code>ping api.leancloud.cn
</code></pre><p>验证结果如下则正常</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-e10c06115a5054f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>然后我们测试下面这一段代码。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-d0ceaa7fa89d6cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>OK 了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-4797976d0ab6e532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>然后我们就继续把 LeanCloud 的对象和用户的开发文档看一遍，就可以继续写代码了。</p>
<h2 id="继续撸代码"><a href="#继续撸代码" class="headerlink" title="继续撸代码"></a>继续撸代码</h2><p>先把我们上面的 localStore 给删掉</p>
<p>然后做出一个登录框</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-c5799a036bc6459c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>还要让它变成一个选项卡来回切换</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-caefa908df34d17f.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>把 form 表单的 input 和 formData 绑定用下面这种方法是不行的</p>
<pre><code>    changeUsername(e){
        this.state.formData.username = e.target.value
        this.setState(this.state)
    }
</code></pre><p>其实是不行的，原因看 <a href="https://stackoverflow.com/questions/37755997/why-cant-i-directly-modify-a-components-state-really" target="_blank" rel="external">Why can’t I directly modify a component’s state, really?</a> 里面 <a href="https://stackoverflow.com/users/4945468/pranesh-ravi" target="_blank" rel="external">Pranesh Ravi</a> 的答案。</p>
<blockquote>
<p>Just a reminder: most basic methods for cloning in JS (<code>slice</code>, ES6 destructuring, etc.) are shallow. If you have a nested array or nested objects you’ll need to look at other methods of deep copying, e.g. <code>JSON.parse(JSON.stringify(obj))</code> (though this particular method won’t work if your object has circular references). </p>
</blockquote>
<p>因为对象是嵌套的，所以要用深拷贝的方法。</p>
<p>点击注册后使用 LeanCloud API 来注册</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-0359d75695fc17ef.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>这样数据就能来到了</p>
<p>来到后还要把它记住并显示出来</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-a186a02fe0ba8bc2.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>实现注册成功关闭窗口</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-d801a196febd2d97.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>用户进入页面时读取上次登录的 user</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-bbc5b207c51506ce.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>做出可以登出的功能</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-963e5edeb970c9f1.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>完成登录功能</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-10f8da0986e07f6b.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>代码：</p>
<ul>
<li><a href="https://github.com/FRANKIETANG/banana-todolist/commits/master" target="_blank" rel="external">LeanCloud</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commits/master" target="_blank" rel="external">localStore</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 React 的门把手 (4)]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(4)/</url>
      <content type="html"><![CDATA[<h1 id="摸到-React-的门把手-4"><a href="#摸到-React-的门把手-4" class="headerlink" title="摸到 React 的门把手 (4)"></a>摸到 React 的门把手 (4)</h1><p>经过一段时间的踩坑 <a href="https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 React 的门把手</a> <a href="https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%282%29/" target="_blank" rel="external">摸到 React 的门把手 (2)</a> <a href="https://frankietang.github.io/2017/08/21/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20%283%29/" target="_blank" rel="external">摸到 React 的门把手 (3)</a> ，是不是可以做一个项目了？</p>
<h2 id="Todo-List"><a href="#Todo-List" class="headerlink" title="Todo List"></a>Todo List</h2><p>不管学什么框架，好像大家都喜欢做 Todo List 啊… AngularJS Vue.js React 都有Todo List … 那我也做一个呗。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-46b343dbe1c59d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="有什么功能"><a href="#有什么功能" class="headerlink" title="有什么功能"></a>有什么功能</h2><ul>
<li>输入框输入要做的事</li>
<li>按回车添加要做的事</li>
<li>添加要做的事后输入框清空</li>
<li>每一个要做的事可以标记成已完成</li>
<li>要做的事能删除</li>
</ul>
<h2 id="Todo-List长什么样"><a href="#Todo-List长什么样" class="headerlink" title="Todo List长什么样"></a>Todo List长什么样</h2><ul>
<li><p>有一个大盒子</p>
</li>
<li><p>里面有一个标题</p>
</li>
<li><p>有一个类似 <code>&lt;input&gt;</code> 的玩意</p>
</li>
<li><p>一个列表，重点</p>
<ul>
<li>todoList<ul>
<li>一个数组 id 用来区分要做的事</li>
<li>title 是这个要做的事是什么</li>
<li>status 要有一个 completed 值表示完成，空表示未完成</li>
<li>deleted 是一个 boolean ，表示是否要删除</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>newTodo 用来容纳用户在 input 输入的值，为什么不用 input 的 value 属性？因为 value= 后面加引号会错。在 React 中是无法直接更改 from 表单元素的值的，必须通过 setState() 去响应用户的输入。</li>
</ul>
<h2 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h2><p>注意 JavaScript 会自动给行末添加分号。如果 return 后面换行不加括号就会变成 <code>return;</code>，所以为了提高可读性还是加括号会比较好。</p>
<p>添加 CSS <code>npm i -S normalize.css</code></p>
<p>然后在 <code>import</code> 加上 CSS 和 JS ，另外一定要注意顺序。normalize.css 要放在最前面。</p>
<h2 id="怎么交互"><a href="#怎么交互" class="headerlink" title="怎么交互"></a>怎么交互</h2><p>试了一下 newTodo 的值改成 <code>&#39;&#39;</code> ，在 input 里什么都输入不了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-2fe83ce52dc119fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>浏览器告诉了我们两种方法</p>
<ul>
<li>If the field should be mutable use <code>defaultValue</code>.</li>
<li>set either <code>onChange</code> or <code>readOnly</code>.</li>
</ul>
<p>那我们用一下 <code>defaultValue</code> ，ok 了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-0a3d90f9199c3e88.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>监听用户的回车事件 我们可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onkeypress" target="_blank" rel="external">GlobalEventHandlers.onkeypress</a> 这个属性</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-383c1bddda0d2c8c.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>我们用 props 的话我们要注意绑定按回车那个 this ，就是我系列文章上一篇的 bind(this) </p>
<p>这样，我们就能够往里面加东西了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-1b876867916258d3.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>但是我们又发现了一个问题，input 的 value 没有重置。那是因为 defaultValue，只会影响 input 的第一次值，后面的 newTodo 怎么变，都不会影响 input</p>
<p>那我们试试 onChange 这种方法，成了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-2fc657e33903e0cb.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>紧接着是标记为已完成的事件和未完成的事件</p>
<p>我们让 checked 的值先等于 null，点击后就变成了 completed</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-44d0d5f42f5c0a9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="http://upload-images.jianshu.io/upload_images/3191557-5d8f997dcfc09154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>点击 checkbox 后增加了 <code>status: &#39;completed&#39;</code></p>
<p>接下来新增一个删除 todo</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-a6bbcdeda9ada74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="http://upload-images.jianshu.io/upload_images/3191557-3279099d4a906453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们还要让 deleted 变成真 deleted</p>
<p>那我们就用 <code>filter</code> 这个 API ，<code>.filter((item)=&gt; !item.deleted)</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-76ff1267a6ea4bd5.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>基本功能已经做出来了</p>
<p>##代码</p>
<ul>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/2431a2a81415c3fd674f14a894a2bd3f7777f805" target="_blank" rel="external">基本骨架完成</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/37a39392ac65e03d4a4551ca6f2aa33400fcd5ec" target="_blank" rel="external">将输入框变成 TodoInput 组件</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/db78ca8d08545394b5ecd93e344fc955508ce393" target="_blank" rel="external">将每个待办封装成 TodoItem 组件</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/ad05ce18fe7083a2e76573c3032b28cc6c715103" target="_blank" rel="external">添加 normalize.css</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/9b62a921aa2adbfec99c17c04cc4438e7ae17b69" target="_blank" rel="external">添加 reset.css</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/556f760571f1b60c7b7c25f46e6698bacb168d67" target="_blank" rel="external">fix value</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/5eeef99c4ae2678e60c28a691b0b5d935c1b2591" target="_blank" rel="external">监听回车事件</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/c8727d8482b81f84e1441166f3be016b8affea9a" target="_blank" rel="external">App 传一个函数给 TodoInput</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/b9de4886314df06317d176b00b769196fcbd642d" target="_blank" rel="external">bind(this)</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/b765bebe0097d7283d34209f84404e9433e667c4" target="_blank" rel="external">可以添加 todo 了</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/20701a8e764cfe158b3b387c6686fada36f54c52" target="_blank" rel="external">fix value again</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/730db326d22892d3ef4e32e6e705c061d24a1142" target="_blank" rel="external">fix value again and again</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/a78fea70fd172c1aa35b77d85e1f9720f738ea1c" target="_blank" rel="external">标记为已完成或者未完成</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/9bc07f8a2c564c95bacc7e8ba1728e4b69b20784" target="_blank" rel="external">删除 todo</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/f0ea5a391f90588fd093eb859c273bbd96a05930" target="_blank" rel="external">真正删除 todo</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/85b7255e4daa64699badfa2b35f8eab4268516f5" target="_blank" rel="external">TodoItem 样式</a></li>
<li><a href="https://github.com/FRANKIETANG/react-todo-list/commit/d1df4c1ecadaf9aa5af0a55e30d295e2b8b943c5" target="_blank" rel="external">TodoInput 样式</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 React 的门把手 (3)]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(3)/</url>
      <content type="html"><![CDATA[<h1 id="摸到-React-的门把手-3"><a href="#摸到-React-的门把手-3" class="headerlink" title="摸到 React 的门把手 (3)"></a>摸到 React 的门把手 (3)</h1><p>经过了上几篇文章 <a href="https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 React 的门把手</a> <a href="https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(2" target="_blank" rel="external">摸到 React 的门把手 (2)</a>/) 的踩坑，我们估计很快就可以摸到门把手了。</p>
<h2 id="关于-JSX"><a href="#关于-JSX" class="headerlink" title="关于 JSX"></a>关于 JSX</h2><p>实际上 JSX 并不是 JavaScript 和 HTML 的结合，而是和 XML 的结合，就像这样。<a href="https://babeljs.io/repl/" target="_blank" rel="external">https://babeljs.io/repl/</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-264608323011334e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><a href="https://facebook.github.io/react/docs/introducing-jsx.html" target="_blank" rel="external">Introducing - JSX</a></p>
<h2 id="关于-React-的虚拟-DOM"><a href="#关于-React-的虚拟-DOM" class="headerlink" title="关于 React 的虚拟 DOM"></a>关于 React 的虚拟 DOM</h2><blockquote>
<p>你用这些 XML 写出来的标签，都不会出现在页面里，只会出现在内存里。React 会使用虚拟 DOM 计算出真正的页面结构，然后再更新到页面中（真正的 DOM 操作）。</p>
<p>让 JS 操作内存肯定比操作 DOM 要快很多。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-04a725ede551ad1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="."></p>
<p>看看这一段代码：</p>
<ul>
<li>用 XML 语法声明一个 h1</li>
<li>babel 将 h1 转为 React Element（虚拟元素）</li>
<li>React 将虚拟元素转化为真正的 DOM，插入到 #root 里。</li>
</ul>
<h2 id="按需更新"><a href="#按需更新" class="headerlink" title="按需更新"></a>按需更新</h2><blockquote>
<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>
</blockquote>
<p>所以说更新一个元素的唯一方法就是新的元素</p>
<p>我们改一下 index.js</p>
<pre><code>function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(
    element,
    document.getElementById(&#39;root&#39;)
  );
}

setInterval(tick, 1000);
</code></pre><p>这个示例通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="external"><code>setInterval()</code></a> 方法，每秒钟调用一次 <code>ReactDOM.render()</code>.</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><pre><code>class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;Component&lt;/h1&gt;
    }
}

ReactDOM.render(
    &lt;Welcome/&gt;,
    document.getElementById(&#39;root&#39;)
)
</code></pre><p>这样我们就造了一个 <code>&lt;Welcome/&gt;</code> 的组件</p>
<p><code>extends React.Component</code> 不能删掉。</p>
<h2 id="组件成为一个单独代码"><a href="#组件成为一个单独代码" class="headerlink" title="组件成为一个单独代码"></a>组件成为一个单独代码</h2><pre><code>//src/Welcome.js
import React from &#39;react&#39;

class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;Component&lt;/h1&gt;
    }
}

export default Welcome
</code></pre><p><code>import React from &#39;react&#39;</code> 这个是引用 React ，不写这一句就在这个组件代码里就用不了 <code>React.Component</code></p>
<p><code>export</code> 和 <code>export default</code> 作用是导出常量/函数/文件/模块 这些</p>
<p><code>export</code> 和 <code>import</code> 可以有多个，<code>export default</code> 只能有一个</p>
<p><code>export</code> 导出导入的时候要加 {}，<code>export default</code> 则不需要</p>
<p><a href="http://www.jianshu.com/p/edaf43e9384f" target="_blank" rel="external">ES6：export default 和 export 区别</a></p>
<pre><code>//src/index.js
import Welcome from &#39;./Welcome&#39;

ReactDOM.render(
  &lt;Welcome/&gt;,
  document.getElementById(&#39;root&#39;)
)
</code></pre><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><pre><code>//src/Welcome.js
class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;I am {this.props.name}&lt;/h1&gt;
    }
}
//其中 class Welcome 变成 funciton Welcome
</code></pre><pre><code>ReactDOM.render(
    &lt;Welcome name=&quot;tangkalun&quot;/&gt;,
    document.getElementById(&#39;root&#39;)
)
</code></pre><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><blockquote>
<p>组件不能改变得到的 props，那么组件中可以变的东西放在哪呢？答案是 state（函数形式的组件不支持 state）。</p>
</blockquote>
<pre><code>//src/Welcome.js
class Welcome extends React.Component {
    constructor(props){
        super(props)
        this.state = {
            date: new Date()
        }
    }
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;I am {this.props.name}&lt;/h1&gt;
                &lt;h2&gt;{this.state.date.toString()}.&lt;/h2&gt;                
            &lt;/div&gt;
        )
    }
}
</code></pre><h2 id="改变-state"><a href="#改变-state" class="headerlink" title="改变 state"></a>改变 state</h2><p>这里我们可以用 <code>setState()</code> 来改变 state。</p>
<pre><code>//在 constructor 里加
setInterval(function(){
  this.state = {
    date: new Date()
  }
})
</code></pre><p>这上面的代码是有问题的，实际上还要 <code>.bind(this)</code></p>
<pre><code>setInterval(function(){
  this.setState({
    date: new Date()
  })
}.bind(this))
</code></pre><blockquote>
<p>The callback is made in a different context. You need to <code>bind</code> to <code>this</code> in order to have access inside the callback</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/31045716/react-this-setstate-is-not-a-function" target="_blank" rel="external">React this.setState is not a function</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25954470" target="_blank" rel="external">setState：这个API设计到底怎么样</a></p>
<p>我讨厌 setState 这个 API</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><a href="https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle" target="_blank" rel="external">The Component Lifecycle</a></p>
<p>React 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）</p>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><blockquote>
<p>mount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。</p>
<p>这个过程会暴露几个钩子（hook）方便你往里面加代码：</p>
<ul>
<li><code>constructor()</code> 初始化 props 和 state</li>
<li><code>componentWillMount()</code> 我要插入了</li>
<li><code>render()</code> 将 render 里的 return 的内容插入到页面中</li>
<li><code>componentDidMount()</code> 插进去后该做点什么吗？</li>
</ul>
</blockquote>
<p>commit: <a href="https://github.com/FRANKIETANG/react-demo/commit/cad040489620cf5b4f7e02a571cb2e3c06803932" target="_blank" rel="external">钩子</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-c31f16851c918ba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><blockquote>
<p>mount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子：</p>
<ul>
<li><code>componentWillReceiveProps(nextProps)</code> - 我要读取 props 啦！</li>
<li><code>shouldComponentUpdate(nextProps, nextState)</code> - 请问要不要更新组件？true / false</li>
<li><code>componentWillUpdate()</code> - 我要更新组件啦！</li>
<li><code>render()</code> - 更新！</li>
<li><code>componentDidUpdate()</code> - 更新完毕啦！</li>
</ul>
</blockquote>
<h3 id="unmount"><a href="#unmount" class="headerlink" title="unmount"></a>unmount</h3><blockquote>
<p>当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子：</p>
<ul>
<li>componentWillUnmount() - 我要死啦！</li>
</ul>
</blockquote>
<h2 id="setState-应该放在哪？"><a href="#setState-应该放在哪？" class="headerlink" title="setState 应该放在哪？"></a>setState 应该放在哪？</h2><p>commit: <a href="https://github.com/FRANKIETANG/react-demo/commit/3b2061343d754f2975356ef4502d445e943eef5a" target="_blank" rel="external">哪些钩子里面可以加 setState</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-6dc701032129deb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这里面有三个错误</p>
<p>第一个错误说明不能在 constructor 里面 setState</p>
<p>第二个错误说明不能在 render 里面 setState</p>
<p>第三个错误说明 Welcome.shouldComponentUpdate 必须返回 boolean value，那我们改改</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-ace3aae6e3f84a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>好吧错误都是 render 的，那就都删掉吧。</p>
<p>还是会有 bug 原因是在 componentWillUpdate 和 componentDidUpdate 里 setState 了，因为每次 setState 都会触发这两个钩子，而这两个钩子却又触发了 setState。</p>
<p>所以只能在这几个钩子里 setState：</p>
<ul>
<li><code>componentWillMount</code></li>
<li><code>componentDidMount</code></li>
<li><code>componentWillReceiveProps</code></li>
<li><code>componentDidUpdate</code></li>
</ul>
<h2 id="看看成果"><a href="#看看成果" class="headerlink" title="看看成果"></a><a href="https://github.com/FRANKIETANG/react-demo" target="_blank" rel="external">看看成果</a></h2>]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 React 的门把手 (2)]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(2)/</url>
      <content type="html"><![CDATA[<h1 id="摸到-React-的门把手-2"><a href="#摸到-React-的门把手-2" class="headerlink" title="摸到 React 的门把手 (2)"></a>摸到 React 的门把手 (2)</h1><p>经过了上一篇 <a href="https://frankietang.github.io/2017/08/18/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 React 的门把手</a> 的踩坑，我们现在可以更加深入的看看 React 其中的奥妙了。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击 Get Started 第一个就是 ReactDOM 的 Hello World，我们先别看这些，先看看怎么安装，点击 Installation</p>
<p>那我们就试试 Create a New App </p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-5c60dc8c2e8b2bfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>搞完 <code>create-react-app my-app</code> 后会有提示，看看就好，记住这四句命令</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-b2844d1fd40c9dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>弹出如下页面就成功了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-237bac3ead01e3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="create-react-app-里面有什么"><a href="#create-react-app-里面有什么" class="headerlink" title="create-react-app 里面有什么"></a>create-react-app 里面有什么</h2><p>我们来看一下文件目录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-52e47859bb2f5dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>src 目录，用于存放所有源代码，最重要的就是 index.js 了。和 webpack 那个 index.js 差不多</li>
<li>public 目录，用于存放不需要 build 的资源，如 publib/index.html</li>
</ul>
<p>当我们运行了 <code>npm run build</code> 这句话，我们会发现多了一个 build 文件夹，里面的文件全部都压缩过了，感觉有点像 webpack 啊。。</p>
<h2 id="试着写写-React"><a href="#试着写写-React" class="headerlink" title="试着写写 React"></a>试着写写 React</h2><p>我们把全部文件删掉，然后运行</p>
<pre><code>create-react-app .
npm start
</code></pre><p>改 src/inden.js </p>
<pre><code>ReactDOM.render(
    &lt;h1&gt;Hello, world!&lt;/h1&gt;,
    document.getElementById(&#39;root&#39;)
)
</code></pre><p>展现出一个大大的 hello world </p>
<p>我们做点小修改</p>
<ul>
<li><p>我们把 Hello World 改成 Hi World，只用直接在 <code>&lt;h1&gt;text&lt;/h1&gt;</code> 这里改就好了。</p>
</li>
<li><p>把 document.getElementById(‘root’) 改为 document.getElementById(‘root2’)，哟吼？网页直接显示了报错信息</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-c625b5538e2c6912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>把 publib/index.html 里的 19 行改为 <code>&lt;div id=&quot;root2&quot;&gt;&lt;/div&gt;</code>，我们会发现页面有变回去了，说明这些都是相关联的。</p>
</li>
<li><p><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 里添加了在 index.js 写好了的 HTML 代码。</p>
</li>
</ul>
<h2 id="将这个应用部署到-GitHub"><a href="#将这个应用部署到-GitHub" class="headerlink" title="将这个应用部署到 GitHub"></a>将这个应用部署到 GitHub</h2><pre><code>git add .
git commit -m &#39;update&#39;
npm run build
</code></pre><p>我们会发现看上去好像已经上传了，但实际上并没有，上网查了查原来是 .gitignore 被 create-react-app 改掉了，你需要删除 .gitignore 里面的 /build 这一行。</p>
<p>然后我们就可以愉快的 push 上去了</p>
<p>嗯？怎么没有效果啊？还记得前面曾经有提示<img src="http://upload-images.jianshu.io/upload_images/3191557-ece626b7c04a108c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>好，我们设置好路径</p>
<pre><code>&quot;homepage&quot;: &quot;https://frankietang.github.io/react-demo/build&quot;
</code></pre><p>搞定。</p>
<h2 id="看看成果"><a href="#看看成果" class="headerlink" title="看看成果"></a><a href="https://github.com/FRANKIETANG/react-demo" target="_blank" rel="external">看看成果</a></h2>]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 React 的门把手]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20React%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="摸到-React-的门把手"><a href="#摸到-React-的门把手" class="headerlink" title="摸到 React 的门把手"></a>摸到 React 的门把手</h1><p><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">React 入门实例教程 - 阮一峰</a></p>
<p>阮一峰真的很适合当老师，这里我们就慢慢的跟上阮一峰老师步伐，摸上 React 的门把手。</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><pre><code>npm init
npm install --save react react-dom
</code></pre><p>而阮一峰的 demo 包自带了 React ，那我们就直接用吧。</p>
<pre><code>$ git clone git@github.com:ruanyf/react-demos.git
</code></pre><h2 id="第一个-demo"><a href="#第一个-demo" class="headerlink" title="第一个 demo"></a>第一个 demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      ReactDOM.render(
        &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li><p>并非一定要引用 browser.js ，引入它的作用是使浏览器支持<code>babel</code>，你可以使用<code>ES2015</code>（具体可以看<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰的ECMAScript 6 入门</a>）进行编码。如果你用ES5，可以不引入。而在这里的作用是将 JSX 语法转为 JavaScript 语法。</p>
<pre><code>// The ES5 way
var Photo = React.createClass({
  handleDoubleTap: function(e) { … },
  render: function() { … },
});
</code></pre><pre><code>// The ES6+ way
class Photo extends React.Component {
  handleDoubleTap(e) { … }
  render() { … }
}
</code></pre></li>
</ol>
<ol>
<li>注意 React 是用了 JSX 的语法，跟 JavaScript 不兼容。使用了 JSX 的地方都要加上 <code>type=&#39;text/babel&#39;</code></li>
<li><code>ReactDOM.render</code> 是一个 API ，将模板转成 HTML 语言，并插入制定的 DOM 节点。</li>
</ol>
<h2 id="第二个-demo"><a href="#第二个-demo" class="headerlink" title="第二个 demo"></a>第二个 demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      var names = [&#39;Alice&#39;, &#39;Emily&#39;, &#39;Kate&#39;];

      ReactDOM.render(
        &lt;div&gt;
        {
          names.map(function (name, index) {
            return &lt;div key={index}&gt;Hello, {name}!&lt;/div&gt;
          })
        }
        &lt;/div&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>在这个例子中我觉得 JSX 语法原来可以这样用，其实就是等于 HTML 和 JavaScript 的混写。</li>
<li>遇到 HTML 标签（以 <code>&lt;</code> 开头），就用 HTML 规则解析；遇到代码块（以 <code>{</code> 开头），就用 JavaScript 规则解析。</li>
</ol>
<h2 id="第三个demo"><a href="#第三个demo" class="headerlink" title="第三个demo"></a>第三个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      var arr = [
        &lt;h1 key=&quot;1&quot;&gt;Hello world!&lt;/h1&gt;,
        &lt;h2 key=&quot;2&quot;&gt;React is awesome&lt;/h2&gt;,
      ];
      ReactDOM.render(
        &lt;div&gt;{arr}&lt;/div&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>这里有一个亮点，就是用了这行代码 <code>&lt;div&gt;{arr}&lt;/div&gt;</code> 把数组成员全部展现到模板上，如果让我想我只会想到用 for 循环再一个一个加到 HTML 那里。。。</li>
</ol>
<h2 id="第四个demo"><a href="#第四个demo" class="headerlink" title="第四个demo"></a>第四个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      var HelloMessage = React.createClass({
        render: function() {
          return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
        }
      });

      ReactDOM.render(
        &lt;HelloMessage name=&quot;John&quot; /&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li><p>也就是说，用 <code>React.createClass</code> 可以把一个段代码封装成组件，然后像普通的 HTML 标签一样在网页插入这个组件。</p>
</li>
<li><p>要保证自己的组件拥有 <code>ReactDOM.render</code> 这个 API 来输出组件。</p>
</li>
<li><p>组件类的第一个字母必须大写，否则会报错。如 <code>HelloMessage</code> 不能写成 <code>helloMessage</code>。</p>
</li>
<li><p>还有组件类只能包含一个顶层标签，否则会出错 </p>
<pre><code>var HelloMessage = React.createClass({
  render: function() {
    return &lt;h1&gt;
      Hello {this.props.name}
    &lt;/h1&gt;&lt;p&gt;
      some text
    &lt;/p&gt;;
  }
});
</code></pre></li>
<li><p>组件的用法和 HTML 的用法是一样的，可以加入任何的属性，比如 <code>&lt;HelloMessage name=&quot;John&quot;&gt;</code> 就是 <code>HelloMessage</code> 中加入一个 <code>name</code> 属性。组件的属性可以在组件类的 <code>this.props</code> 对象上获取，比如 <code>name</code> 属性就可以通过 <code>this.props.name</code> 读取。</p>
</li>
<li><p>添加组件属性，有一个地方需要注意，就是 <code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code> ，这是因为 <code>class</code> 和 <code>for</code> 是 JavaScript 的保留字。</p>
</li>
</ol>
<h2 id="第五个demo"><a href="#第五个demo" class="headerlink" title="第五个demo"></a>第五个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      var NotesList = React.createClass({
        render: function() {
          return (
            &lt;ol&gt;
              {
                React.Children.map(this.props.children, function (child) {
                  return &lt;li&gt;{child}&lt;/li&gt;;
                })
              }
            &lt;/ol&gt;
          );
        }
      });

      ReactDOM.render(
        &lt;NotesList&gt;
          &lt;span&gt;hello&lt;/span&gt;
          &lt;span&gt;world&lt;/span&gt;
        &lt;/NotesList&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>这一个例子主要是讲解了 <code>this.props.children</code> 属性。它表示组件的所有子节点。</li>
<li><code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。</li>
<li>React 提供一个工具方法 <a href="https://facebook.github.io/react/docs/top-level-api.html#react.children" target="_blank" rel="external"><code>React.Children</code></a> 来处理 <code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。</li>
</ol>
<h2 id="第六的demo"><a href="#第六的demo" class="headerlink" title="第六的demo"></a>第六的demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;

      var data = 123;

      var MyTitle = React.createClass({
        propTypes: {
          title: React.PropTypes.string.isRequired,
        },

        render: function() {
          return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
        }
      });

      ReactDOM.render(
        &lt;MyTitle title={data} /&gt;,
        document.getElementById(&#39;example&#39;)
      );

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li><p><code>PropTypes</code>属性，就是用来验证组件实例的属性是否符合要求。</p>
</li>
<li><p><code>Mytitle</code>组件有一个<code>title</code>属性。<code>PropTypes</code> 告诉 React，这个 <code>title</code> 属性是必须的，而且它的值必须是字符串。<code>title</code> 没有通过验证。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-a577caebac60a9c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>另外，阮一峰老师还介绍了<code>getDefaultProps</code> 方法可以用来设置组件属性的默认值。</p>
<pre><code>var MyTitle = React.createClass({
  getDefaultProps : function () {
    return {
      title : &#39;Hello World&#39;
    };
  },

  render: function() {
     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
   }
});

ReactDOM.render(
  &lt;MyTitle /&gt;,
  document.body
);
//上面代码会输出&quot;Hello World&quot;。
</code></pre></li>
</ol>
<h2 id="第七个demo"><a href="#第七个demo" class="headerlink" title="第七个demo"></a>第七个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      var MyComponent = React.createClass({
        handleClick: function() {
          this.refs.myTextInput.focus();
        },
        render: function() {
          return (
            &lt;div&gt;
              &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;
              &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt;
            &lt;/div&gt;
          );
        }
      });

      ReactDOM.render(
        &lt;MyComponent /&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
//这样就能通过点击 button 来获取 input 的 focus
</code></pre><ol>
<li><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <a href="http://calendar.perfplanet.com/2013/diff/" target="_blank" rel="external">DOM diff</a> ，它可以极大提高网页的性能表现。</p>
<p>但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。</p>
</li>
<li><p>上面代码中，组件 <code>MyComponent</code> 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 <code>ref</code> 属性，然后 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。</p>
</li>
<li><p>需要注意的是，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 <code>Click</code> 事件的回调函数，确保了只有等到真实 DOM 发生 <code>Click</code> 事件之后，才会读取 <code>this.refs.[refName]</code> 属性。</p>
</li>
<li><p>除了 <code>Click</code> 事件以外，还有 <code>KeyDown</code> 、<code>Copy</code>、<code>Scroll</code> 等</p>
</li>
</ol>
<h2 id="第八个demo"><a href="#第八个demo" class="headerlink" title="第八个demo"></a>第八个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
var LikeButton = React.createClass({
  getInitialState: function() {
    return {liked: false};
  },
  handleClick: function(event) {
    this.setState({liked: !this.state.liked});
  },
  render: function() {
    var text = this.state.liked ? &#39;like&#39; : &#39;haven\&#39;t liked&#39;;
    return (
      &lt;p onClick={this.handleClick}&gt;
        You {text} this. Click to toggle.
      &lt;/p&gt;
    );
  }
});

ReactDOM.render(
  &lt;LikeButton /&gt;,
  document.getElementById(&#39;example&#39;)
);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>组件的状态，用来和用户互动，组件一开始有一个状态，然后用户操作导致状态改变，从而改变状态，根据状态重新渲染页面。</li>
<li><code>return {liked: false}</code> 初始化组件的状态</li>
<li><code>this.setState({liked: !this.state.liked})</code> 将组件状态设置为当前状态相反状态</li>
</ol>
<h2 id="第九个demo"><a href="#第九个demo" class="headerlink" title="第九个demo"></a>第九个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      var Input = React.createClass({
        getInitialState: function() {
          return {value: &#39;Hello!&#39;};
        },
        handleChange: function(event) {
          this.setState({value: event.target.value});
        },
        render: function () {
          var value = this.state.value;
          return (
            &lt;div&gt;
              &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;
              &lt;p&gt;{value}&lt;/p&gt;
            &lt;/div&gt;
          );
        }
      });

      ReactDOM.render(&lt;Input/&gt;, document.getElementById(&#39;example&#39;));
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>第一次看这个，呦吼？这难道是传说中的双向绑定？<a href="http://www.cnblogs.com/kuailingmin/p/4609721.html" target="_blank" rel="external">React的双向绑定</a></li>
<li>上面代码中，文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。</li>
</ol>
<h2 id="第十个demo"><a href="#第十个demo" class="headerlink" title="第十个demo"></a>第十个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      var Hello = React.createClass({
        getInitialState: function () {
          return {
            opacity: 1.0
          };
        },

        componentDidMount: function () {
          this.timer = setInterval(function () {
            var opacity = this.state.opacity;
            opacity -= .05;
            if (opacity &lt; 0.1) {
              opacity = 1.0;
            }
            this.setState({
              opacity: opacity
            });
          }.bind(this), 100);
        },

        render: function () {
          return (
            &lt;div style={{opacity: this.state.opacity}}&gt;
              Hello {this.props.name}
            &lt;/div&gt;
          );
        }
      });

      ReactDOM.render(
        &lt;Hello name=&quot;world&quot;/&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li><p>这里主要是介绍了关于组件的生命周期</p>
</li>
<li><p>React 为每个状态都提供了两种处理函数，<code>will</code> 是我要插入了！<code>did</code> 是我插进去之后，要不要搞点东西？</p>
</li>
<li><p>阮一峰老师的这个 demo 是在<code>hello</code>组件加载以后，通过 <code>componentDidMount</code> 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。</p>
</li>
<li><p>注意组件 <code>style</code> 属性的设置方式</p>
<pre><code>//这样是错的
style=&quot;opacity:{this.state.opacity};&quot;
//而要写成
style={{opacity: this.state.opacity}}
</code></pre><p>这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>
</li>
</ol>
<h2 id="第十一个demo"><a href="#第十一个demo" class="headerlink" title="第十一个demo"></a>第十一个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/jquery.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
var UserGist = React.createClass({
  getInitialState: function() {
    return {
      username: &#39;&#39;,
      lastGistUrl: &#39;&#39;
    };
  },

  componentDidMount: function() {
    $.get(this.props.source, function(result) {
      var lastGist = result[0];
      if (this.isMounted()) {
        this.setState({
          username: lastGist.owner.login,
          lastGistUrl: lastGist.html_url
        });
      }
    }.bind(this));
  },

  render: function() {
    return (
      &lt;div&gt;
        {this.state.username}&#39;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(
  &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,
  document.getElementById(&#39;example&#39;)
);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>把数据通过 AJAX 请求的方法从服务器获取，阮一峰老师这里是用了 <code>componentDidMount</code> 方法设置 AJAX 请求，再用 <code>this.setState</code> 方法重新渲染 UI，<code>InitialState</code> 初始数据为空</li>
</ol>
<h2 id="第十二个demo"><a href="#第十二个demo" class="headerlink" title="第十二个demo"></a>第十二个demo</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/jquery.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
var RepoList = React.createClass({
  getInitialState: function() {
    return {
      loading: true,
      error: null,
      data: null
    };
  },

  componentDidMount() {
    this.props.promise.then(
      value =&gt; this.setState({loading: false, data: value}),
      error =&gt; this.setState({loading: false, error: error}));
  },

  render: function() {
    if (this.state.loading) {
      return &lt;span&gt;Loading...&lt;/span&gt;;
    }
    else if (this.state.error !== null) {
      return &lt;span&gt;Error: {this.state.error.message}&lt;/span&gt;;
    }
    else {
      var repos = this.state.data.items;
      var repoList = repos.map(function (repo, index) {
        return (
          &lt;li key={index}&gt;&lt;a href={repo.html_url}&gt;{repo.name}&lt;/a&gt; ({repo.stargazers_count} stars) &lt;br/&gt; {repo.description}&lt;/li&gt;
        );
      });
      return (
        &lt;main&gt;
          &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt;
          &lt;ol&gt;{repoList}&lt;/ol&gt;
        &lt;/main&gt;
      );
    }
  }
});

ReactDOM.render(
  &lt;RepoList promise={$.getJSON(&#39;https://api.github.com/search/repositories?q=javascript&amp;sort=stars&#39;)} /&gt;,
  document.getElementById(&#39;example&#39;)
);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li><p>数据传来后赋值</p>
<pre><code>componentDidMount() {
  this.props.promise.then(
    value =&gt; this.setState({loading: false, data: value}),
    error =&gt; this.setState({loading: false, error: error}));
},
</code></pre><p>如果Promise对象报错（rejected状态），组件显示报错信息；如果Promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。</p>
<pre><code>getInitialState: function() {
  return {
    loading: true,
    error: null,
    data: null
  };
},
</code></pre><p>Promise对象正在抓取数据（pending状态），组件显示”正在加载”</p>
</li>
</ol>
<h2 id="第十三个demo"><a href="#第十三个demo" class="headerlink" title="第十三个demo"></a>第十三个demo</h2><ul>
<li><p>这里不贴代码</p>
</li>
<li><p>这是一个 React 的服务器渲染</p>
</li>
<li><p>根据 readme.md 的提示，我们搞好依赖，<code>node server.js</code> 来监听 <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> <img src="http://upload-images.jianshu.io/upload_images/3191557-888bf6bd6f540557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>这看着是非常像手写服务器的方法，如果有 JavaScript权威指南 这本书，我建议你看看 P302 如何手写服务器。<img src="http://upload-images.jianshu.io/upload_images/3191557-bc51896f11363644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>这里推荐一篇文章 <a href="http://www.alloyteam.com/2017/01/react-from-scratch-server-render/" target="_blank" rel="external">从零开始 React 服务器渲染</a></p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 TypeScript 的门把手]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20TypeScript%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="摸到-TypeScript-的门把手"><a href="#摸到-TypeScript-的门把手" class="headerlink" title="摸到 TypeScript 的门把手"></a>摸到 TypeScript 的门把手</h1><p><a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">TypeScript</a></p>
<h2 id="Basic-Types（原始数据类型）"><a href="#Basic-Types（原始数据类型）" class="headerlink" title="Basic Types（原始数据类型）"></a>Basic Types（原始数据类型）</h2><pre><code>let a: boolean = false;
a = &#39;hello&#39;
//这样是错的
//因为类型不兼容 要 a = true
let b: number = 1;
let c: string = &#39;1&#39;;
let e: number[] = [1,2,3];
//number[] 等于 Array&lt;number&gt;

//这里有一个新类型 Tuple
//有限长度的有限列表
let f: [string, number] = [&#39;1&#39;,2];

//Enum 一个数字的集合
enum g {
  hello = 0,
  world = 1,
}
enum g1 {
  hello,
  world,
}
//是默认012345这样赋值
//转成 JS
(function (g) {
    g[g[&quot;hello&quot;] = 0] = &quot;hello&quot;;
    g[g[&quot;world&quot;] = 1] = &quot;world&quot;;
})(g || (g = {}));
var g1;
(function (g1) {
    g1[g1[&quot;hello&quot;] = 0] = &quot;hello&quot;;
    g1[g1[&quot;world&quot;] = 1] = &quot;world&quot;;
})(g1 || (g1 = {}));
//TS2.4后可以赋值 string
enum g {
  hello = &#39;0&#39;,
  world = &#39;1&#39;,
}

//Any
//let the values pass through compile-time checks
let notSure:any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false;

//Void
function a(): void {
  alert(&#39;hello world&#39;)
}

//Never
function never1(): never {
  throw Error(&#39;Something failed&#39;)
}

//assert 断言
//Type assertion
let someValue1: any = &quot;this is a string&quot;;
let strLength1: number = (&lt;string&gt;someValue).length;
//让 String 具有 Number 的办法
</code></pre><h2 id="Variable-Declarations"><a href="#Variable-Declarations" class="headerlink" title="Variable Declarations"></a>Variable Declarations</h2><pre><code>var s = 1;
let s1 = 2;
const s2 = 3;
function s3 () {
  return 4;
} 
const s4 = () =&gt; {
  return 5；
}
</code></pre><h2 id="Interfaces（接口）"><a href="#Interfaces（接口）" class="headerlink" title="Interfaces（接口）"></a>Interfaces（接口）</h2><pre><code>interface IMap {
  a: string;
}
//type contract
let obj1: IMap = {
  a: &#39;1&#39;,
  b: 2,   //error 一定要 string
}
function sss (a: IMap): IMap{
  return a;
}

//Optional Properties
interface IOptional1 {
  a: number;
  b?: string;
}
// arg.b 有可能 undefined
function sss1(arg: IOptional1): string{
  return arg.b + &#39;&#39;
}

//Readonly properties
interface Point {
    readonly x: number;
    readonly y: number;
}
let point: IPoint = {
  x: 1, 
  y: 2,
}
//point.x = 23;
//只读属性没法定义

//Function Types
interface ISearchFunc {
    (source: string, subString: string): boolean;
}
//function(source, subString) 没有必要再定义
let mySearch: ISearchFunc = function(source: string, subString: string) {
    let result = source.search(subString);
    return result &gt; -1;
}
//Indexable Types
interface IndexType {
  [key:string]:number
}
let inst1: IndexType {
  a: &#39;1&#39;,     //error
}

//type
type aType = IndexType;
//比如说是let啊，就是类型声明对吧 type 就类似

type aaaaa = string;
let ssss: aaaaa = &#39;1&#39;

interface IPeople {
  eyes: number;
}
enum LapTopEnum {
  haiwei,
  lenovo,
  apple,
  IBM,
}
interface ImonkeyProgramer extends IPeople {
  laptop: LapTopEnum
}
let tangkalun: ImonkeyProgramer = {
  laptop: LapTopEnum.apple,
  eyes: 2,
}
</code></pre><blockquote>
<p>In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</p>
</blockquote>
<h2 id="Classes（类）"><a href="#Classes（类）" class="headerlink" title="Classes（类）"></a>Classes（类）</h2><pre><code>class A {
    a:string
    constructor() {
        this.a = &#39;1&#39;
    }
    hello(): string {
        return &#39;1&#39;;
    }
}
let instA = new A();
instA.a
//转换成 JS
var A = (function () {
    function A() {
        this.a = &#39;1&#39;;
    }
    A.prototype.hello = function () {
        return &#39;1&#39;;
    };
    return A;
}());
var instA = new A();
instA.a;
//注意 private public protect

//Inheritance
class People {
    name: string
    constructor(name: string) {
        this.name = name;
    }
}
class A extends People {
    a: string;
    constructor() {
        super(&#39;tangkalun&#39;);
        this.a = &#39;1&#39;;
    }
    hello(): string {
        return this.a;
    }
}
// class 不仅可以描述数据结构,同时他还有方法、属性等等的封装
let instA = new A();
instA.a;
instA.name;
//关于super()这个问题，是调用父类的构造函数
</code></pre><h2 id="Generics（泛型）"><a href="#Generics（泛型）" class="headerlink" title="Generics（泛型）"></a>Generics（泛型）</h2><pre><code>interface SillyBoy&lt;T&gt; {
  skills: T
}
const tangkalun: SillyBoy&lt;[&#39;string&#39;,&#39;string&#39;,&#39;string&#39;]&gt; = {
  skills: [&#39;eat&#39;,&#39;fuck&#39;,&#39;sleep&#39;]
}
const frankie: SillyBoy&lt;[string]&gt; = {
  skills: [&#39;fuck&#39;],
}
const tang: SillyBoy&lt;[undefined]&gt; = {
  skills: undefined,
}
const kalun: SillyBoy&lt;string&gt; = {
    skills: &#39;sleep&#39;,
}
</code></pre><p>先到这里吧，我太菜了。</p>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 webpack 的门把手 (2)]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B%20(2)/</url>
      <content type="html"><![CDATA[<h1 id="摸到-webpack-的门把手-2"><a href="#摸到-webpack-的门把手-2" class="headerlink" title="摸到 webpack 的门把手 (2)"></a>摸到 webpack 的门把手 (2)</h1><p>经过了上一篇 <a href="https://frankietang.github.io/2017/08/20/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/" target="_blank" rel="external">摸到 webpack 的门把手</a> 的踩坑，我们大概知道了 webpack 是用 loader 加载不同的资源，把大东西压成小东西。大不一定能满足，小也有小的优点嘛。对吧，有的时候大家就喜欢小。</p>
<h2 id="webpack-到底干了什么"><a href="#webpack-到底干了什么" class="headerlink" title="webpack 到底干了什么"></a>webpack 到底干了什么</h2><p>bundle.js 把每一个每一个模块都 call 一下，然后把模块存到 installedModules 里，方便其他模块使用。有空填坑分析代码。</p>
<h2 id="压缩代码的一些问题"><a href="#压缩代码的一些问题" class="headerlink" title="压缩代码的一些问题"></a>压缩代码的一些问题</h2><p>我们会发现 jQuery 的代码并没有压缩，其实我们可以使用 <code>webpack -p</code>，webpack 给出的解释是<br><code>shortcut for --optimize-minimize --define process.env.NODE_ENV=&quot;production&quot;</code></p>
<p>运行 <code>-p</code> ，实际执行</p>
<ul>
<li>使用UglifyJsPlugin进行 JS文件压缩,webpack 自带的压缩插件</li>
<li>运行<a href="https://webpack.js.org/plugins/loader-options-plugin/#components/sidebar/sidebar.jsx" target="_blank" rel="external">LoaderOptionsPlugin</a></li>
<li>设置Node环境变量</li>
</ul>
<pre><code>//运行 webpack -p 会通过如下方式调用 DefinePlugin
var webpack=require(&#39;webpack&#39;);

module.exports={
  plugins:[
    new webpack DefinePlugin({
      &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)
    })
  ]
}
</code></pre><p><code>DefinePlugin</code> 在原始的源码中执行查找和替换操作. 在导入的代码中,任何出现 <code>process.env.NODE_ENV</code>的地方都会被替换为<code>”production”</code>. 因此, 形如<code>if (process.env.NODE_ENV !== ‘production’) console.log(‘…’)</code> 的代码就会等价于 <code>if (false) console.log(‘…’)</code> 并且最终通过<code>UglifyJS</code>等价替换掉.</p>
<p><a href="https://webpack.js.org/guides/public-path/" target="_blank" rel="external">webpack - public-path</a></p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>每次写完代码都要 npm run webpack ，很麻烦，那我们需要 <code>webpack --progress --watch</code> 监听文件变动，只要我们保存了文件就会自动编译代码。</p>
<p>在 npm script 加一句 <code>&quot;watch&quot;: &quot;webpack --progress --watch&quot;</code>，然后 npm run watch 试试</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-f654ac96a8135f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>不但能刷新代码，还能刷新浏览器</p>
<p>看到 Using webpack-dev-server 那里，它叫我们在根目录跑这句话</p>
<pre><code>npm install --save-dev webpack-dev-server
</code></pre><p>在 webpack.config.js 加点东西</p>
<pre><code>devServer: {
    contentBase: &#39;./dist&#39;
},
</code></pre><p>在 package.json 的 npm script 加点东西</p>
<pre><code>&quot;start&quot;: &quot;webpack-dev-server --open&quot;
</code></pre><p>成了，看下图。<br><img src="http://upload-images.jianshu.io/upload_images/3191557-494866b6ba1c3ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果我们改一下 src/bundle.js 就会发现</p>
<ul>
<li>bundle.js 自动打包</li>
<li><a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> 自动刷新</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3191557-c12e95d7cc12d8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>注意，我们就不能再直接打开 index.html 了，因为它引用的是 /bundle.js，用 file:// 协议打开 index.html 的话，会请求 file:///bundle.js，显然这个文件不存在。</p>
<p><a href="https://webpack.js.org/guides/development/" target="_blank" rel="external">webpack - development</a></p>
<h2 id="查看成果"><a href="#查看成果" class="headerlink" title="查看成果"></a><a href="https://github.com/FRANKIETANG/webpack-demo" target="_blank" rel="external">查看成果</a></h2>]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 webpack 的门把手]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20webpack%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="摸到-webpack-的门把手"><a href="#摸到-webpack-的门把手" class="headerlink" title="摸到 webpack 的门把手"></a>摸到 webpack 的门把手</h1><p>之前接触过一阵子 webpack ，想了一下还是写篇博客吧。要不然又忘掉怎么配置了。</p>
<h2 id="怎么安装？"><a href="#怎么安装？" class="headerlink" title="怎么安装？"></a>怎么安装？</h2><p><a href="https://webpack.js.org/" target="_blank" rel="external">来，我们先看 webpack 的官网</a></p>
<p>点击到 guides ，我们直接抄，抄完我们就知道 webpack 的流程了</p>
<p>不过有几点我们是要注意的</p>
<ul>
<li>注意 index.js 中的 <code>_.join</code>，这个 _ 实际上是 lodash 暴露的全局变量。</li>
<li>为了使用 lodash，HTML 使用 script 引入了 lodash v4.16.6。可以用 npm 装回来 <code>npm install --save lodash</code></li>
<li>尽量运行 <code>./node_modules/.bin/webpack</code> </li>
</ul>
<h2 id="看看文件结构"><a href="#看看文件结构" class="headerlink" title="看看文件结构"></a>看看文件结构</h2><ul>
<li><code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code> 将 src/index.js 变成 dist/bundle.js</li>
<li>index.html 引用的是 dist/bundle.js</li>
<li>lodash 被安装在 node_modules 里</li>
<li>webpack 也被安装在 node_modules里，<code>./node_modules/.bin/webpack</code> 就是一个可执行文件</li>
<li>webpack、lodash 的版本号都被写在 package.json 里了</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="external">读懂diff - 阮一峰</a></p>
<h2 id="引用-jQuery"><a href="#引用-jQuery" class="headerlink" title="引用 jQuery"></a>引用 jQuery</h2><ul>
<li><p><code>npm i -S jquery</code></p>
<pre><code> import _ from &#39;lodash&#39;
+import j from &#39;jquery&#39;

 function component () {
-  var element = document.createElement(&#39;div&#39;);
+  var element = j(&#39;&lt;div&gt;&lt;/div&gt;&#39;);

   /* lodash is required for the next line to work */
-  element.innerHTML = _.join([&#39;Hello&#39;,&#39;webpack&#39;], &#39; &#39;);
+  element.html(_.join([&#39;Hello&#39;,&#39;webpack&#39;], &#39; &#39;))

-  return element;
+  return element.get(0);
 }

 document.body.appendChild(component());
</code></pre></li>
<li><p><code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code> 跑这句话</p>
</li>
<li><p>点击 commits 看看有什么变化</p>
</li>
<li><p>建议 index.js 改成 <code>console.log(1)</code> 然后运行 <code>./node_modules/.bin/webpack src/index.js dist/bundle.js</code>，看看 bundle.js 和 index.js 的区别</p>
</li>
</ul>
<h2 id="做一点改良"><a href="#做一点改良" class="headerlink" title="做一点改良"></a>做一点改良</h2><ul>
<li><p>我们可以在根目录搞一个 <code>webpack.config.js</code>，在里面写上一点代码。</p>
<pre><code>var path = require(&#39;path&#39;)

module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        filename: &#39;bundle.js&#39;,
        path: path.resolve(__dirname, &#39;dist&#39;)
    }
}
</code></pre><p>重点是这三个玩意 src/index.js 、dist 和 bundle.js 在哪就行，方便我们后面改。</p>
</li>
<li><p>然后我们就可以用上这句 <code>./node_modules/.bin/webpack --config webpack.config.js</code></p>
</li>
<li><p>或者我们可以进行下面的改良</p>
<pre><code>  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;webpack&quot;: &quot;webpack&quot;
  },
  &quot;keywords&quot;: [],
</code></pre><p>然后运行 npm run webpack</p>
</li>
</ul>
<h2 id="尝试-import-一个自己的文件"><a href="#尝试-import-一个自己的文件" class="headerlink" title="尝试 import 一个自己的文件"></a>尝试 import 一个自己的文件</h2><ul>
<li><p>创建一个 <code>foo.js</code></p>
<pre><code>export default function(){
    return &#39;tangkalun&#39;
}
</code></pre></li>
<li><p>然后在 <code>index.js</code> 加上 <code>import foo from &#39;./foo&#39;</code>，顺便 <code>console.log</code> 一下</p>
</li>
<li><p><code>npm run webpack</code></p>
</li>
</ul>
<h2 id="利用-webpack-压缩-JS-文件"><a href="#利用-webpack-压缩-JS-文件" class="headerlink" title="利用 webpack 压缩 JS 文件"></a>利用 webpack 压缩 JS 文件</h2><ul>
<li><p><a href="https://webpack.js.org/guides/production/" target="_blank" rel="external">webpack 自带的</a> 支持所有 <a href="https://github.com/mishoo/UglifyJS2#usage" target="_blank" rel="external">UglifyJS 选项</a></p>
</li>
<li><p>在 <code>webpack.config.js</code> 加上这样一句话，UglifyJS 的选项可以一个都不加</p>
<pre><code>var webpack = require(&#39;webpack&#39;);

module.exports = {
  /*...*/
  plugins:[
    new webpack.optimize.UglifyJsPlugin()
  ]
};
</code></pre></li>
<li><p><code>npm run webpack</code></p>
</li>
<li><p>压完了</p>
</li>
</ul>
<h2 id="看看成果"><a href="#看看成果" class="headerlink" title="看看成果"></a>看看成果</h2><p><a href="https://github.com/FRANKIETANG/webpack-demo" target="_blank" rel="external">点击这里</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Black History </tag>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 Promise 的门把手]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20Promise%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>这其实是异步的一种方法。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><pre><code>//假定有两个函数f1和f2，后者等待前者的执行结果。
f1()
f2()
//如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。
function f1(callback){
  setTimeout(function(){
    //f1 的任务代码
    callback()
  },1000)
}
//是不是有点像 AJAX
//执行代码就变成下面这样：
f1(f2)
//例子
function f2(){
  let b = 2
  console.log(b)
}

function f1(callback){
  setTimeout(function(){    
    let a = 1
    console.log(a)
    callback()
  },3000)
}

f1(f2)
</code></pre><h3 id="Promises对象"><a href="#Promises对象" class="headerlink" title="Promises对象"></a>Promises对象</h3><blockquote>
<p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="external">统一接口</a>。</p>
<p>简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。</p>
</blockquote>
<p>注意这个 <code>then</code> </p>
<pre><code>//f1 的回调函数 f2
f1().then(f2)
//看下面这个例子
f1().then(f2).then(f3)
//比如说
//先执行 f1() 函数
//执行完后获取一个对象，叫 promise 对象
//这个 promise 对象呢，它上面有个方法叫做 then
//所以就调用了 then(f2)
//如果数据到来之后就会执行 then(f2)
//这个数据的参数传给 f2
//then(f2) 执行完后再执行 then(f3)
f1().then(f2).fail(f3)
//如果执行失败就执行 fail(f3)
</code></pre><h3 id="为什么要用-Promise"><a href="#为什么要用-Promise" class="headerlink" title="为什么要用 Promise"></a>为什么要用 Promise</h3><pre><code>$.get(url, function(data){
  console.log(data)
  $.get(url2, function(data){
    console.log(data)
    $.get(url3, function(date){
      ........
    })
  })
})
//Promise
$.get(url)
 .then()
 .then()
 .then()
</code></pre><h3 id="如何实现一个-Promise"><a href="#如何实现一个-Promise" class="headerlink" title="如何实现一个 Promise"></a>如何实现一个 Promise</h3><pre><code>class Promise{
  constructor(){
    this.callbacks = []    //这个数组存储的是对象
  }

  then(onsuccess,onfail){
    this.callbacks.push({
      resolve: onsuccess,
      reject: onfail
    })
    return this
  }

  resolve(result){
    this.complete(&#39;resolve&#39;,result)
  }

  reject(result){
    this.complete(&#39;reject&#39;,result)
  }

  complete(type,result){
    var callbackObj = this.callbacks.shift()
    callbackObj[type](result)     //callbackObj[resolve] 等于 fn1 所以就是 fn1(result)
  }

}

// function Promise(){

// }

// Promise.prototype.then = function(){

// }

var p = new Promise()

function fn() {
  console.log(&#39;fn1&#39;)
  setTimeout(function(){
    p.resolve(&#39;data1&#39;)
  },1000)
  return p
}

function fn1(result) {
  console.log(&#39;fn1&#39;,result)
  setTimeout(function(){
    p.resolve(&#39;data2&#39;)
//     p.reject()
    fn2()
  },2000)
}

function fn2(result) {
  console.log(&#39;fn2&#39;,result)
}

fn().then(fn1).then(fn2)
//[{resolve:fn1,reject:undefined},{resolve:fn2,reject:undefined}]
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> Black History </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[摸到 ES6 的门把手]]></title>
      <url>/2017/10/14/%E6%91%B8%E5%88%B0%20ES6%20%E7%9A%84%E9%97%A8%E6%8A%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="ES-6标准入门（个人笔记）"><a href="#ES-6标准入门（个人笔记）" class="headerlink" title="ES 6标准入门（个人笔记）"></a>ES 6标准入门（个人笔记）</h1><h2 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1.let 和 const"></a>1.<code>let</code> 和 <code>const</code></h2><p>主要是解决作用域问题。</p>
<h3 id="1-1let"><a href="#1-1let" class="headerlink" title="1.1let"></a>1.1<code>let</code></h3><h4 id="1-1-1for-循环"><a href="#1-1-1for-循环" class="headerlink" title="1.1.1for 循环"></a>1.1.1for 循环</h4><pre><code>//在 var 里
var a = 0
for (var i = 0;i &lt; 10;i++) {
  console.log(i)//10
}
console.log(i)//10
</code></pre><pre><code>//而在 let 则不一样
let a = 0
for (let i = 0;i &lt; 10;i++) {
  console.log(i)//10
}
console.log(i)//undefined
//等于
var a = 0
for (var _i = 0;_i &lt; 10;_i++) {
  console.log(_i)
}
console.log(i)
</code></pre><h4 id="1-1-2块级作用域"><a href="#1-1-2块级作用域" class="headerlink" title="1.1.2块级作用域"></a>1.1.2块级作用域</h4><pre><code>function f1() {
  var n = 5
  if (true) {
    var n = 10
  }
  console.log(n)//10
}
f1()
</code></pre><pre><code>//而在 let 里面，会偷梁换柱
function f1() {
  let n = 5
  if (true) {
    let n = 10
  }
  console.log(n)//5
}
//相当于
function f1() {
  var n = 5
  if (true) {
    var _n = 10
  }
  console.log(n)//5
}
//换掉了变量名
</code></pre><h3 id="1-2const"><a href="#1-2const" class="headerlink" title="1.2const"></a>1.2<code>const</code></h3><pre><code>//这样写会报错
const b = 0
b = 1
//这样写反而不会报错
const c = {
  a:1
}
c.a = 2
//为什么呢？
//因为 b 指向了另外一个地方
//用 const 赋值的时候，b 是 only 的。
//而 c.a 并没有改变 c 的指向
//如果是
/*
c = {a:2}
*/
//这样就会报错，指向另外一个地方了
</code></pre><p>const 能在块级作用域里吗？</p>
<pre><code>    const C = &#39;c&#39;;
    const s = () =&gt; {
        const C = &#39;s&#39;;
        return {
            a: &#39;hello world&#39;
        }
    }
    //相当于
    var C = &#39;c&#39;;
    var s = function s() {
        var C = &#39;s&#39;;
        return {
            a: &#39;hello world&#39;
        };
    };
</code></pre><p>是可以的。</p>
<h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h2><h3 id="2-1基本用法"><a href="#2-1基本用法" class="headerlink" title="2.1基本用法"></a>2.1基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>
<p>解构赋值是讲究叶子节点的。</p>
<pre><code>//一个简单的例子
let [a,b,c] = [1,2,3]
//相当于
var a = 1,
    b = 2,
    c = 3
</code></pre><pre><code>//我们再来看一个例子
let { d,e }={ d:1, e:2 }
//相当于
var _d$e = { d:1,e:2 },
    d = _d$e.d
    e = _d$e.e
</code></pre><h3 id="2-2深度解构"><a href="#2-2深度解构" class="headerlink" title="2.2深度解构"></a>2.2深度解构</h3><pre><code>//例子
let obj = {
  p: [
    &#39;Hello&#39;,
    {y:&#39;World&#39;}
  ]
}

let { p:[x,{ y }] } = obj
//相当于
var obj = {
  p: [&#39;Hello&#39;,{ y:&#39;World&#39; }]
}

var _obj$p = _slicedToArray(obj.p,2),
    x = _obj$p[0],
    y = _obj$p[1].y

//_slicedToArray 只是一个方法，了解就好
//先把 obj 给克隆下来，层级展开，其实就是递归
</code></pre><pre><code>//_slicedToArray
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[&quot;return&quot;]) _i[&quot;return&quot;](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(&quot;Invalid attempt to destructure non-iterable instance&quot;); } }; }()
</code></pre><h3 id="2-3应用"><a href="#2-3应用" class="headerlink" title="2.3应用"></a>2.3应用</h3><h4 id="2-3-1function-add-a-b-return-a-b"><a href="#2-3-1function-add-a-b-return-a-b" class="headerlink" title="2.3.1function add(a,b){return a+b}"></a>2.3.1<code>function add(a,b){return a+b}</code></h4><pre><code>//传入数组相加
function add([x,y]){
  return x+y
}
add([1,2])//3
//相当于
function add(_ref){
  var _ref2 = _slicedToArray(_ref,2),
        x = _ref2[0],
        y = _ref2[1]

  return x + y
}

add([1,2])//3
</code></pre><h4 id="2-3-2字符串解构"><a href="#2-3-2字符串解构" class="headerlink" title="2.3.2字符串解构"></a>2.3.2字符串解构</h4><pre><code>const [a1,b1,c1,d1,e1] = &#39;hello&#39;
//相当于
var _hello = &#39;hello&#39;,
    _hello2 = _slicedToArray(_hello,5),
    a1 = _hello2[0],
    b1 = _hello2[1],
    c1 = _hello2[2],
    d1 = _hello2[3],
    e1 = _hello2[4]
</code></pre><h4 id="2-3-3-rest-解构"><a href="#2-3-3-rest-解构" class="headerlink" title="2.3.3 rest 解构"></a>2.3.3 rest 解构</h4><pre><code>const { p,...rest } = {p:1,a:2,c:2}
console.log(rest) // {a:2,c:2}
//相当于
var _p$a$c = {p:1,a:2,c:2},
    p = _p$a$c.p,
    rest = _objectWithoutProperties(_p$a$c,[&#39;p&#39;])
console.log(rest)//{a:2, c:2}
//_objectWithoutProperties 也是一个方法，知道就好
</code></pre><pre><code>//_objectWithoutProperties
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) &gt;= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
</code></pre><pre><code>//最后一个例子
function add({
  name,
  list:[x,y]
}){
  return name+y
}
add({name:&#39;tangkalun&#39;,list:[&#39;21&#39;,&#39;male&#39;]})
</code></pre><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="3-1函数参数默认值"><a href="#3-1函数参数默认值" class="headerlink" title="3.1函数参数默认值"></a>3.1函数参数默认值</h3><pre><code>function log(x, y = &#39;World&#39;) {
  console.log(x, y);
}
log(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World
//相当于
function log(x) {
    var y = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &#39;World&#39;;
    console.log(x, y);
}
log(&#39;hello&#39;); // log(&#39;Hello&#39;) // Hello World
</code></pre><h3 id="3-2-rest-参数"><a href="#3-2-rest-参数" class="headerlink" title="3.2 rest 参数"></a>3.2 rest 参数</h3><pre><code>function add(a, b, ...values) {
  console.log(values)
}
add(2, 5, 3) // 3
//相当于
function add(a, b) {
    for (var _len = arguments.length, values = Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {
        values[_key - 2] = arguments[_key];
    }

    console.log(values);
}
add(2, 5, 3); // 3
</code></pre><h3 id="3-3扩展运算符"><a href="#3-3扩展运算符" class="headerlink" title="3.3扩展运算符"></a>3.3扩展运算符</h3><pre><code>console.log(5,...[1, 2, 3])
//相当于
(_console = console).log.apply(_console, [5].concat([1, 2, 3]));
//注意如果 console.log(...5,[1,2,3]) 会出错
//...要放在最后一项
</code></pre><h3 id="3-4箭头函数"><a href="#3-4箭头函数" class="headerlink" title="3.4箭头函数"></a>3.4箭头函数</h3><pre><code>var f = v =&gt; v;
var f1 = v =&gt; {
  return v
}
//相当于
var f = function f(v) {
    return v;
};
var f1 = function f1(v) {
    return v;
};
</code></pre><pre><code>const pa = () =&gt; [1,2,3]
pa()
//[1,2,3]
</code></pre><pre><code>    const pa = (...args) =&gt; {
        console.log(args);
        return args.reduce((pre,cur) =&gt; {
            return pre+cur;
        }, 0);
    };
    pa.apply(this, [1,2,45]);
    //[1,2,45]
    //48
</code></pre><h4 id="3-4-1箭头函数的-this"><a href="#3-4-1箭头函数的-this" class="headerlink" title="3.4.1箭头函数的 this"></a>3.4.1箭头函数的 this</h4><pre><code>var f1 = v=&gt;{
    console.log(this)
}
var f3 = function(v){
    //this
    return v=&gt;{
        console.log(this);
    }
}
//相当于
var f1 = function f1(v) {
    console.log(undefined);
};
var f3 = function f3(v) {
    var _this = this;
    //this
    return function (v) {
        console.log(_this);
    };
};
//由于函数作用域的关系，this 的指向会指向上级作用域
//作用域没有就 undefined
//这样搞都是假 this
</code></pre><pre><code>const s = () =&gt; {
  console.log(this)
}
s()
//window
//注意 babel 环境下输出的 this 是 undefined
</code></pre><blockquote>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<h2 id="4-Promise"><a href="#4-Promise" class="headerlink" title="4. Promise"></a>4. Promise</h2></blockquote>
<pre><code>let p = new Promise((resolve,reject)=&gt;{
    setTimeout(resolve,3000,1)
})
let q = new Promise((resolve, reject) =&gt; {
    reject(&#39;not good time&#39;)
})
let pending = new Promise((resolve,reject)=&gt;{

})

// p ==&gt; fulfilled 1
// Promise的状态 fulfilled pending rejected
// Promise的值  

// 3s 后
let p1 = p.then(val=&gt;{
    val += 2;
    //return 2
    return new Promise((res, rej) =&gt; {
        res(2)
    })
}).then((val) =&gt; {
    console.log(val);
});

//只要 return 的话这个 return 的值就是 p1 的当前的状态
</code></pre><p><a href="https://www.zhihu.com/question/36972010" target="_blank" rel="external">为什么要加 setTimeout</a> 神坑，这里我也不是很懂。</p>
<p>其实我们只用知道这只是一个异步过程</p>
<pre><code>let p = new Promise((resolve,reject)=&gt;{
    setTimeout(resolve,3000,1)
})
p
//Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}
//3s 后
//Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1}
</code></pre><h2 id="5-Iterator"><a href="#5-Iterator" class="headerlink" title="5. Iterator"></a>5. Iterator</h2><pre><code>let t = [1,2,3];

for(let val of t){
    console.log(val)
};
//1 2 3
</code></pre><pre><code>const s= function(){
    for(let val of arguments){
        console.log(val)
    };
}
s(1,2,34);
//for...of 可以同时处理数组和类数组对象
//就是说，可以循环一个数据结构
</code></pre><h2 id="6-Class"><a href="#6-Class" class="headerlink" title="6. Class"></a>6. Class</h2><pre><code>//例子
class Test{
  constructor(){
    this.a = &#39;a&#39;
    this.b = &#39;b&#39;    
  }
}
//等于
let Test = function(argument){
  this.a = &#39;a&#39;
  this.b = &#39;b&#39;
}

let inst = new Test()
console.log(inst.a)
//这个例子是用 class 来实现语法转换的一个例子
</code></pre><pre><code>//实现面向对象
let Test = function(argument){
  this.a = &#39;a&#39;
  this.b = &#39;b&#39;
}
Test.prototype.c =()=&gt; {console.log(&#39;c&#39;)}

let inst = new Test()
console.log(inst.c)
//用 class 来实现
class Test{
  constructor(){
    this.a = &#39;a&#39;
    this.b = &#39;b&#39;    
  }
  c(){console.log(&#39;c&#39;)}
}
let inst = new Test()
console.log(inst.c())
//这里会有个 undefined ，因为 console.log(&#39;c&#39;) 并没有返回值
</code></pre><pre><code>//以前我们写构造函数会这样写
let Test = function(argument){
  this.a = a
  this.b = b
}
Test.prototype.c = function(){
  return &#39;ddddd&#39;
}
//用 class
class Test{
  constructor(){
    this.a = &#39;a&#39;
    this.b = &#39;b&#39;
  }
  c(){
    return &#39;ddddd&#39;
  }
}
</code></pre><p>关于 <code>super()</code> 的问题</p>
<pre><code>class TestSuper {
  constructor() {
    this.a = &#39;a&#39;
  }
}
class Test extends TestSuper {
  constructor() {
    super()
    this.b = &#39;b&#39;
  }
}
let inst = new Test()
console.log(inst.a)   //a
console.log(inst)     //Test{a:&#39;a&#39;,b:&#39;b&#39;}
</code></pre><h2 id="7-Module"><a href="#7-Module" class="headerlink" title="7. Module"></a>7. Module</h2><pre><code>//a.js
function f1(){
  let a = 1
}
export {f1}
</code></pre><pre><code>//module.js
import {f1} from &#39;./let_const.js&#39;
//相当于
var _let_const = require(&#39;./a.js&#39;)
//只有 nodejs 有 require 函数
//先把 import...form 转换成 require 的形式
//用 webpack 来处理 require 函数
</code></pre><pre><code>a.js ==&gt;  require(&#39;./b.js&#39;).kkkkk
b.js ==&gt;  require(&#39;./c.js&#39;).kkkkk
c.js ==&gt;  require(&#39;./a.js&#39;).kkkkk

AMD  define + require

webpack ==&gt; node.js的fs io体系来把所有的require依赖放在一个文件里面
bundle.js

(function(moduleArr) {
    // XXX
}[
    a.js ,
    c.js,
    d.js
])()
</code></pre><p>webpack3 会自己封装一层 require</p>
<h2 id="8-Generator"><a href="#8-Generator" class="headerlink" title="8. Generator"></a>8. Generator</h2><p>是一种异步编程解决方案</p>
<p><code>yield</code> 产出</p>
<pre><code>function* helloWorldGenerator() {
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
};
//最好仅在 nodejs 上使用 generator
//yield 执行完之后是停止的
//需要手动执行 .next()
var hw = helloWorldGenerator();
let a = hw.next();
let b = hw.next();
let c = hw.next();
console.log(a,b,c)
/*
{ value: &#39;hello&#39;, done: false } { value: &#39;world&#39;, done: false } { value: &#39;ending&#39;, done: true }
*/
</code></pre><h2 id="ES6-语法测试"><a href="#ES6-语法测试" class="headerlink" title="ES6 语法测试"></a>ES6 语法测试</h2><ul>
<li>安装babel命令行</li>
</ul>
<pre><code class="bash">$ cnpm install babel-cli
</code></pre>
<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">参考文档</a></p>
<p>第一次接触 <code>&#39;use strict&#39;</code> </p>
<p>看来踩的坑还有点少。</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="external">Javascript 严格模式详解 - 阮一峰</a></p>
<p>这只是笔记，多看看阮一峰的 ES6 文档吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> Black History </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
